[{"content":" 定制Ubuntu 22.04文件系统 1 2 3 4 5 6 7 8 9 10 11 12 13 wget https://old-releases.ubuntu.com/releases/22.04.1/ubuntu-22.04-live-server-arm64.iso mount ubuntu-22.04-live-server-arm64.iso /mnt cp /mnt/casper/ubuntu-server-minimal.squashfs ./ umount /mnt unsquashfs ubuntu-server-minimal.squashfs echo \u0026#39;nameserver 8.8.8.8\u0026#39; \u0026gt;\u0026gt; squashfs-root/etc/resolv.conf echo \u0026#39;nameserver 8.8.4.4\u0026#39; \u0026gt;\u0026gt; squashfs-root/etc/resolv.conf chroot squashfs-root apt-get update apt-get install -y unzip vim sysstat libnuma1 dmidecode rsync net-tools psmisc parted arping ntpdate iproute2 iputils-ping mawk cracklib-runtime ethtool ntp fdisk libssl-dev libpam-cracklib logrotate exit cd squashfs-root find . | cpio -o -H newc | gzip \u0026gt; ../Sample-root-filesystem-soc_ubuntu-22.04-aarch64.img 执行apt-get install命令后，若出现“perl：warning：xxx”相关报错、“debconf：xxx”相关报错、“Failed to retrieve available kernel versions.”以及“Failed to check for processor microcode upgrades.”报错，不影响Linux组件下载。\n或根据官方参考文档进行，但是添加如下内容到squashfs-root/etc/resolv.conf\n1 2 3 nameserver 127.0.0.53 options edns0 trust-ad search . 参考链接 定制Ubuntu 22.04文件系统\n","date":"2025-09-26T15:19:36.56+08:00","permalink":"https://ynhugo.github.io/p/%E8%AE%B0%E5%BD%95%E5%AE%9A%E5%88%B6ubuntu22.04%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"记录定制Ubuntu22.04文件系统"},{"content":" python+uiautomator2实现soul循环自动发送指定文本 环境要求 支持设备：安卓\n手机要求：支持无线调试\n运行环境：Termux\nTermux环境搭建 1 2 3 pkg install -y libxml2 libxslt pkg install libjpeg-turbo libtiff libwebp openjpeg pip install uiautomator2 Windows搭建环境 自行查找相关教程安装anaconda，版本最新即可，这里不过多赘述。\n1 2 3 4 5 6 7 8 9 10 # 创建一个名为uiautomator2的指定版本的环境，-y选项自动安装环境依赖 conda create -n uiautomator2 python=3.8 -y # 激活环境 conda activate uiautomator2 pip install --pre uiautomator2 -i https://pypi.tuna.tsinghua.edu.cn/simple pip install keyboard -i https://pypi.tuna.tsinghua.edu.cn/simple python -m uiautomator2 init\t# 前提是USB调试打开的情况下已经连接无线调试或者USB连接电脑 git -c http.proxy=\u0026#34;127.0.0.1:10808\u0026#34; clone https://github.com/openatx/weditor pip install -e weditor -i https://pypi.tuna.tsinghua.edu.cn/simple 参考链接 python安装weditor失败\n功能 在soul派对界面发送指定文本到公屏。\n代码 版本1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # coding: utf-8 # import os import uiautomator2 as u2 import keyboard import time connect=os.system(\u0026#39;adb devices | grep -w \u0026#34;device\u0026#34; | awk \\\u0026#39;NR==1{print $1}\\\u0026#39;\u0026#39;) d = u2.connect(connect) while True: time.sleep(1); d(resourceId=\u0026#34;cn.soulapp.android:id/tvChat\u0026#34;).click() time.sleep(1); d.send_keys(\u0026#34;❤️加入我们单身社交交友大家庭\\n💛包脱单，包分配，包售后，包打假\\n💚看群主瞬间小猪🐷猪蹄下边的水槽那一串黑黑的摩斯密码，备注soul名字，拉你进大家庭～\u0026#34;, clear=True) time.sleep(1); d(resourceId=\u0026#34;cn.soulapp.android:id/btnSend\u0026#34;).click() d.click(0.402,0.745) time.sleep(60); 版本2 运行命令 1 2 3 4 conda activate uiautomator2 while true; do python soul自动发送.py; done # 或 while true; do python soul自动发送.py device; done device: 对应无线调试设备或USB设备\t代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # coding: utf-8 # import os import sys import time import subprocess import keyboard import uiautomator2 as u2 def get_device_id(): # 获取第第一个已连接的Android设备ID try: result = subprocess.check_output([\u0026#39;adb\u0026#39;, \u0026#39;devices\u0026#39;]).decode(\u0026#39;utf-8\u0026#39;) devices = [line.split(\u0026#39;\\t\u0026#39;)[0] for line in result.splitlines() if \u0026#39;\\tdevice\u0026#39; in line] return devices[0] if devices else None except (subprocess.CalledProcessError, IndexError): return None def main(): running = True # print(len(sys.argv)) if len(sys.argv) \u0026gt; 1: device_id = sys.argv[1] if not device_id: print(\u0026#34;Error: No connect Android device found\u0026#34;) sys.exit(1) else: device_id = get_device_id() if not device_id: print(\u0026#34;Error: No connect Android device found\u0026#34;) sys.exit(1) print(f\u0026#34;Connected device: {device_id}\u0026#34;) # 初始化uiautomator2连接 try: d = u2.connect(device_id) print(\u0026#34;Device connected successfully\u0026#34;) while running: d(resourceId=\u0026#34;cn.soulapp.android:id/tvChat\u0026#34;).click() time.sleep(1); # d.send_keys(\u0026#34;❤️加入我们单身社交交友大家庭\\n💛包脱单，包分配，包售后，包打假\\n💚看管理瞬间小猪🐷猪尾巴那一串黑黑的摩斯密码，备注soul名字，拉你进大家庭～\u0026#34;, clear=True) # d.send_keys(\u0026#34;❤️加入我们单身社交交友大家庭\\n💛包脱单，包分配，包售后，包打假\\n💚看群主引力签或管理瞬间小猪🐷猪尾巴那一串黑黑的摩斯密码，备注soul名字，拉你进大家庭～\\n\\n\\n我们这个聚会，是包含吃火锅，可以喝酒，里边有KTV、台球、麻将，然后有社牛主持人带着大家做很多个破冰小游戏，互相了解，互相认识。就是你能够认识很多的朋友和异性，然后运气好的话，可以脱单儿。\u0026#34;, clear=True) d.send_keys(\u0026#34;❤️加入我们单身社交交友大家庭\\n💛包脱单，包分配，包售后，包打假\\n💚看群主引力签，备注soul名字，拉你进大家庭～\\n\\n\\n我们这个聚会，是包含吃火锅，可以喝酒，里边有KTV、台球、麻将，然后有社牛主持人带着大家做很多个破冰小游戏，互相了解，互相认识。就是你能够认识很多的朋友和异性，然后运气好的话，可以脱单儿。\u0026#34;, clear=True) # d.send_keys(\u0026#34;test\u0026#34;, clear=True) time.sleep(1); d(resourceId=\u0026#34;cn.soulapp.android:id/btnSend\u0026#34;).click() time.sleep(1); d.click(0.402,0.745) time.sleep(57); except Exception as e: print(f\u0026#34;Connected failed: {str(e)}\u0026#34;) sys.exit(1) if __name__ == \u0026#34;__main__\u0026#34;: main() ","date":"2025-09-21T23:49:56.7+08:00","permalink":"https://ynhugo.github.io/p/python-uiautomator2%E5%AE%9E%E7%8E%B0soul%E5%BE%AA%E7%8E%AF%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E6%8C%87%E5%AE%9A%E6%96%87%E6%9C%AC/","title":"python+uiautomator2实现soul循环自动发送指定文本"},{"content":" Windows cmd命令提示符重启网卡（网络适配器） 查询计算机上所有的网卡（包括虚拟网卡） 1 netsh interface show interface 操作网卡的指令 关闭网卡：\n1 netsh interface set interface \u0026#34;要操作的网卡名称\u0026#34; disable 开启网卡：\n1 netsh interface set interface \u0026#34;要操作的网卡名称\u0026#34; enable 以无线网卡WLAN为例，重启网卡（在管理员权限cmd窗口运行） 1 2 netsh interface set interface \u0026#34;WLAN\u0026#34; disable netsh interface set interface \u0026#34;WLAN\u0026#34; enable 实例cmd脚本 脚本名：WLAN_Check.bat\n脚本功能：当wifi断网后自动重启WLAN（网络适配器）\n操作方式：将该脚本添加到任务计划程序，配置启动时运行，设置无限期每隔5分钟运行一次。配置后先手动运行一下后就不用再管了。\n脚本内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @echo off echo 开始网络连接监控... :Check echo 正在检查网络连接... ping -n 3 www.baidu.com \u0026gt; nul if %ERRORLEVEL% EQU 0 ( echo 网络连接正常，等待60秒后再次检查... timeout /t 60 /nobreak \u0026gt; nul goto Check ) else ( echo 网络连接失败，错误代码: %ERRORLEVEL% echo 正在重启WLAN适配器... goto RestartWLAN ) :RestartWLAN echo 禁用WLAN... netsh interface set interface \u0026#34;WLAN\u0026#34; disable echo 等待5秒... timeout /t 5 /nobreak \u0026gt; nul echo 启用WLAN... netsh interface set interface \u0026#34;WLAN\u0026#34; enable echo 等待10秒让网络重新连接... timeout /t 10 /nobreak \u0026gt; nul echo 重新检查网络连接... goto Check 参考链接 Windows cmd命令提示符重启网卡（网络适配器）\nWindows通过计划任务定时执行bat文件\n批处理（bat）用来监测Windows网络状态脚本\n","date":"2025-09-19T13:40:04.97+08:00","permalink":"https://ynhugo.github.io/p/windows-cmd%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E9%87%8D%E5%90%AF%E7%BD%91%E5%8D%A1%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D%E5%99%A8/","title":"Windows cmd命令提示符重启网卡（网络适配器）"},{"content":" 工具安装 Termux安装MSF框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Metasploite 黑客 Top10 工具之一，漏洞攻击库，安全从业者必备工具之一，也在各大黑客题材的电影中频频出现。通过 Github 上的 m-wiz 项目来辅助安装 Metasploit ，脚本启动比较简单： # 安装依赖 pkg install git # 克隆脚本项目 git clone https://github.com/noob-hackers/m-wiz # 运行脚本 cd m-wiz \u0026amp;\u0026amp; bash m-wiz.sh # 安装的时候还会有一些提示，比如选择 Metasploit 的版本之类的，大家根据提示自己选择安装即可，安装的过程可能会安装其他 Ruby gem，因此能需要很长时间。在安装完成之前，请勿关闭 Termux 会话，否则可能会出一些玄学问题导致安装失败，总之耐心等待即可。 # 添加环境变量 echo \u0026#39;export PATH=\u0026#34;$PATH:/data/data/com.termux/files/home/metasploit-framework\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 参考链接 Termux 高级终端安装使用配置教程（国光）-Metasploit\nLinux nmap 命令（菜鸟教程）\nSQLmap 1 2 3 git clone https://github.com/sqlmapproject/sqlmap.git cd sqlmap python sqlmap.py 参考链接 Termux 高级终端安装使用配置教程（国光）-SQLmap\n工具使用 ","date":"2025-09-19T10:26:43.89+08:00","permalink":"https://ynhugo.github.io/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","title":"网络安全"},{"content":" 聚会 聚会游戏简记 数字炸弹 游戏规划 数字炸弹游戏的规则如下：\n游戏准备：确定一个主持人，他不参与游戏，负责设定一个数字范围（如1-100）和一个“炸弹”数字（如51）。 游戏进行：参与者依次报出自己猜测的数字，主持人根据报出的数字与“炸弹”数字进行比较，并给出“大了”、“小了”或“答对了”的提示。 惩罚机制：如果参与者猜中了“炸弹”数字，则需要接受惩罚，通常是罚酒或表演节目等。 范围缩小：每次猜测后，未猜中的数字会缩小猜测范围，直到有人猜中“炸弹”数字。 人数要求：游戏通常需要至少两人进行，人数越多，游戏越有趣。 这些规则简单易懂，适合聚会或社交场合进行娱乐。\n游戏惩罚 真心话大冒险\n逢七必过 游戏规则 逢七必过游戏规则如下：\n游戏开始：从数字1开始，玩家依次报数。 规则：当遇到含有数字7的数（如7、17、27等）或7的倍数（如7、14、21等）时，玩家必须说“过”而不是报出该数字。 惩罚：如果有人错误地报出数字7或其倍数，则需要接受小惩罚，例如敲桌子。 游戏目的：此游戏旨在锻炼玩家的反应能力和数学敏感度，适合在聚会或家庭活动中进行。 游戏惩罚 真心话大冒险 游戏规则 真心话大冒险的游戏规则如下：\n选择顺序：参与者可通过抽签、掷骰子等方式决定游戏顺序，通常采用顺时针方向进行。 选择真心话或大冒险：当轮到某位参与者时，必须选择“真心话”或“大冒险”。选择“真心话”后，其他参与者可以提出问题，而被问者需要诚实回答；选择“大冒险”则需要完成其他参与者设置的挑战。 提问和挑战：提问及挑战应适合参与者年龄及心理承受能力，确保避免过于尴尬或冒犯他人的内容。 轮换进行：游戏继续进行，直到所有参与者都有机会参与，或大家一致决定结束游戏。 这些规则可以帮助确保游戏的顺利进行和参与者的愉快体验。\n轰趴-2025年9月26日下午8:18 时间安排:管理五点到 6-7.00，等待人员到齐，管理带着玩各个项目，玩牌各种，避免先来的人尴尬，上菜啥的 7.30-8.00:开饭，人员互相介绍。 8.00-8.40:开场游戏!接人名十真心话大冒险猜人名，十男模竞拍游戏(男模上岗时间20分钟)一伺候主人倒酒 8.40-9.20:击鼓传花一闹钟爆炸，两个反方向传两圈说人名，闹钟停止的人，指定一人说名字，说不出来，惩罚真心话大冒险，第一轮真心话，第二轮大冒险。 9.20-10.00:小姐牌 10.00-10.40:7的倍数 真心话大冒险 10.40-11.40:数字炸弹 11.40-12.00:唱歌十摇色子十喝酒十打牌\n超大型真心话大冒险题库-400题（Deepseek） 引导词 真心话大冒险，偏大尺度，并且标上序号及做好分类，按轻度→中度→高度→超刺激等级排序的表格，每个等级扩展到100题，一次性给出完整的 400 题题库，序号从1到400\n题库下载 我费了一番功夫将markdown内容中的题库整理了表格，表格中分4个工作表对应4个等级的题库各100道\n下载链接：超大型真心话大冒险题库\n题库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 好的，这是一个为你精心准备的超大型“真心话大冒险”题库。严格按照**轻度 → 中度 → 高度 → 超刺激**四个等级排序，每个等级100题，共计400题。 ,**使用前的重要提示：** ,* **安全第一：** 所有活动都应在所有参与者自愿、舒适且安全的范围内进行。如果有人感到不适，有权使用“安全词”跳过任何问题或挑战。 ,* **尊重边界：** 请根据现场氛围和参与者的熟悉程度，谨慎选择相应等级的问题。 ,* **法律与道德：** 请确保所有活动不违反法律和公序良俗。 --- ### **真心话大冒险 完整400题题库** #### **第一等级：轻度（第1-100题）** ,*适合普通朋友、同事或初次玩此游戏的人，氛围轻松愉快。* ,**真心话 (1-50):** 1. 你最近一次撒谎是什么时候？ 2. 你最喜欢自己身体哪个部位？ 3. 说出一件你小时候干过的糗事。 4. 你理想中的约会是什么样的？ 5. 你最尴尬的一次经历是什么？ 6. 你暗恋过哪个明星或老师吗？ 7. 你最近单曲循环的一首歌是什么？ 8. 如果你能变成异性一天，你会做什么？ 9. 你最喜欢的电影是什么？为什么？ 10. 你最大的优点和缺点是什么？ 11. 你相信一见钟情吗？ 12. 你做过最勇敢的事是什么？ 13. 你最害怕的东西是什么？ 14. 你手机里最后一张照片是什么？ 15. 描述一下你的初吻。 16. 你最近一次哭是因为什么？ 17. 你最想拥有的超能力是什么？ 18. 如果你中了一百万，你会怎么花？ 19. 你最喜欢在场哪一位的穿衣风格？ 20. 你撒过最容易被拆穿的谎言是什么？ 21. 说一个你的小怪癖。 22. 你最近学到的一个新知识是什么？ 23. 你最想改掉的一个习惯是什么？ 24. 你最喜欢的一道菜是什么？ 25. 你人生中最感激的人是谁？ 26. 你更喜欢猫还是狗？ 27. 你最近一次感到非常开心是什么时候？ 28. 你最想去哪个国家旅行？ 29. 你觉得自己最像哪种动物？ 30. 你收到过最好的礼物是什么？ 31. 你做过最疯狂的一个梦是什么？ 32. 你最喜欢哪个季节？ 33. 你的手机壁纸是什么？ 34. 说出一件你 bucket list（遗愿清单）上的事。 35. 你最近一次对别人说“我爱你”是对谁？ 36. 你觉得自己是内向还是外向的人？ 37. 你最喜欢的一句名言是什么？ 38. 你最近一次发脾气是因为什么？ 39. 你最喜欢的一种味道是什么？ 40. 你觉得自己最有魅力的一点是什么？ 41. 你最近看过的一本书是什么？ 42. 你最喜欢的一种颜色是什么？ 43. 你小时候的梦想职业是什么？ 44. 你最近一次帮助别人是什么时候？ 45. 你最喜欢的一种甜品是什么？ 46. 你觉得自己最失败的一件事是什么？ 47. 你最喜欢在周末做什么？ 48. 你最近一次感到害羞是什么时候？ 49. 你最喜欢的一个品牌是什么？ 50. 用三个词形容一下你自己。 ,**大冒险 (51-100):** 51. 用屁股在空中写出你的名字。 52. 模仿一位在场的朋友，直到有人猜对你在模仿谁。 53. 对左手边第三个人说一句肉麻的情话。 54. 发一条“今晚月色真美”的朋友圈，不许解释。 55. 把袜子套在手上，直到下一轮结束。 56. 用怪声怪气的语调读一段新闻。 57. 做十个俯卧撑（或深蹲）。 58. 和右边的人互换一件外套或配饰穿一轮。 59. 用五种不同的语言说“你好”。 60. 表演一段你最喜欢的广告。 61. 闭上眼睛，让一个人喂你吃一种食物，并猜出是什么。 62. 模仿一种动物，直到有人猜对。 63. 对房间里的一个物品深情告白一分钟。 64. 用手机拍一张最丑的自拍，并设为屏保5分钟。 65. 唱一首儿歌。 66. 学模特走猫步绕房间一圈。 67. 用非惯用手喝一杯水。 68. 说一段绕口令。 69. 假装你是一个新闻主播，播报一下现在的游戏情况。 70. 做一个鬼脸，并保持到下一轮开始。 71. 和你对面的人对视30秒，不许笑。 72. 把一块冰块放在衣服里，直到它融化。 73. 模仿一位历史人物说话。 74. 用嘴型无声地唱一首歌，让大家猜。 75. 把微信头像换成系统自带的原始头像，保持一天。 76. 用三种不同的方式说“我爱你”。 77. 假装你是一个机器人，做一套机械动作。 78. 把你手机里最近的一张照片给大家看。 79. 用枕头当吉他，摇滚演奏一分钟。 80. 对下一个进门的人说“欢迎光临，主人”。 81. 用方言讲一个笑话。 82. 原地转十圈，然后走直线。 83. 假装你正在直播带货，推销你手边的一样东西。 84. 把双手绑在一起，度过下一轮。 85. 模仿一位知名歌手唱歌的样子。 86. 用表情和肢体语言描述一部电影，让大家猜。 87. 把你微信的拍一拍设置改成一句奇怪的话。 88. 单脚站立，讲述你今天做了什么。 89. 给通讯录里第10个人发一条“我想你了”的短信。 90. 用奶声奶气的娃娃音说话，直到下一轮结束。 91. 表演“猩猩跳舞”。 92. 把一块饼干放在额头上，不用手吃到它。 93. 和你左边的人来一个热情的拥抱。 94. 假装你是一个解说员，解说一个人去上厕所的过程。 95. 用手机录一段你对大家的祝福视频。 96. 学企鹅走路。 97. 一口气说十个成语。 98. 用英语（或其他外语）点一份想象中的餐。 99. 做一个你认为最性感的姿势。 100. 对在场的所有人依次说一句赞美的话。 --- #### **第二等级：中度（第101-200题）** ,*适合关系较好的朋友，问题开始涉及个人情感和隐私，挑战更具互动性。* ,**真心话 (101-150):** 101. 你上一次自慰是什么时候？ 102. 你的性幻想对象是哪种类型的人？ 103. 描述一下你理想中的伴侣身体。 104. 你第一次看小电影是几岁？ 105. 你最敏感的部位是哪里？ 106. 你尝试过的最奇怪的性癖好是什么？（或：你对什么奇怪的性癖好感到好奇？） 107. 你有过一夜情的想法吗？ 108. 你最喜欢被亲吻哪里？ 109. 说出一件你在性方面感到后悔的事。 110. 你手机里有没有私密照片？有多少？ 111. 你曾经对朋友的另一半产生过好感吗？ 112. 你最多一夜有过几次性行为？ 113. 你喜欢开灯还是关灯做爱？ 114. 你用过最大胆的约炮软件头像是什么？ 115. 你曾经因为性而被拒绝过吗？ 116. 你最长的性生活持续了多久？ 117. 你假装过高潮吗？ 118. 你最喜欢的性爱姿势是什么？ 119. 你会在做爱时听音乐或看东西吗？ 120. 你曾经在公共场合有过性行为吗？ 121. 你收到过的最奇怪的搭讪信息是什么？ 122. 你为爱做过最疯狂的事是什么？ 123. 你最近一次春梦的对象是谁？ 124. 你更喜欢主导还是被主导？ 125. 你如何看待开放式关系？ 126. 你曾经出轨过吗？或者被出轨过？ 127. 你最喜欢的避孕措施是什么？ 128. 你会在社交媒体上关注色情账号吗？ 129. 你第一次发生性关系是几岁？ 130. 你最喜欢的前戏是什么？ 131. 你曾经约过炮吗？感觉如何？ 132. 你对自己的尺寸/胸部满意吗？ 133. 你曾经和同性有过亲密接触吗？什么感觉？ 134. 你最喜欢的色情作品类型是什么？ 135. 你会在做爱时说脏话吗？ 136. 你曾经在车上做过爱吗？ 137. 你如何看待3P或多P？ 138. 你买过最奇怪的性玩具是什么？ 139. 你曾经被“社会性死亡”的性经历是什么？ 140. 你更喜欢早晨、中午还是晚上做爱？ 141. 你曾经通过网络摄像头进行过性爱吗？ 142. 你最喜欢的内衣颜色和款式是什么？ 143. 你曾经在陌生人面前裸露过身体吗？ 144. 你如何看待BDSM？ 145. 你曾经在做爱时弄伤过自己或对方吗？ 146. 你最喜欢的调情方式是什么？ 147. 你曾经因为性而哭过吗？ 148. 你最长多久没有性生活？ 149. 你曾经幻想过和在场的一位朋友发生关系吗？ 150. 你愿意为了一百万和你不喜欢的人睡一晚吗？ ,**大冒险 (151-200):** 151. 亲吻一位在场同性的脸颊（或指定部位）。 152. 脱掉一件衣服（在大家可接受的范围内）。 153. 和一位异性玩家十指相扣，对视一分钟。 154. 用嘴传递一张纸巾（或小零食），不能用手。 155. 躺在沙发上，让另一位玩家给你做一分钟的“按摩”。 156. 选一个人，在他/她的耳边轻声说一句挑逗的话。 157. 模仿一种你最喜欢的色情片里的叫声。 158. 用口红（或笔）在自己身上画一个心形图案。 159. 把一块冰块从你左边玩家的领口放进去，右边玩家拿出来。 160. 和一位异性玩家拥抱，并保持10秒。 161. 表演一段脱衣舞（至少脱掉一件外套或配饰）。 162. 详细描述你上一次接吻的感觉。 163. 让另一位玩家在你背上写字，你来猜。 164. 选一个人，喂他/她吃一口食物。 165. 用撒娇的语气向一位异性玩家要一件他/她的随身物品。 166. 把一位异性玩家横抱起来（或公主抱）坚持10秒。 167. 用身体摆出“69”的姿势。 168. 和一位玩家一起用吸管喝同一杯饮料。 169. 轻轻咬一位玩家的耳朵。 170. 把手机里最性感的一张照片（非裸露）给大家看。 171. 躺在一位玩家的腿上，让他/她给你读一首情诗。 172. 用舌头舔自己的手肘（尝试即可）。 173. 让一位玩家在你脖子上种一颗“草莓”（吻痕）。 174. 模仿你心目中最性感的明星。 175. 和一位玩家脸贴脸，坚持15秒。 176. 用屁股写一位在场玩家的名字。 177. 选一位玩家，对他/她进行一分钟的深情告白。 178. 把一位玩家的手放在你的腰上，一起跳一段慢舞。 179. 用嘴解开一位玩家衬衫的第一颗扣子（如果对方同意）。 180. 描述你第一次接吻的场景。 181. 用你的嘴唇碰一下一位玩家的脚踝（或膝盖）。 182. 让一位玩家蒙上眼睛，你喂他/她吃一种神秘食物。 183. 假装你是一个性感电话接线员，接听一个“投诉电话”。 184. 和一位玩家一起自拍一张亲密合照，并设为手机壁纸10分钟。 185. 用身体语言表演“做爱”这个词，让大家猜。 186. 轻轻抚摸一位玩家的头发一分钟。 187. 选一个人，在他/她手心画一个圈。 188. 用一根手指从一位玩家的嘴唇慢慢滑到锁骨。 189. 用嘴给一位玩家喂一颗葡萄（或小番茄）。 190. 把一位玩家按在墙上（壁咚），说一句霸道总裁的台词。 191. 用屁股压碎一个气球。 192. 和一位玩家玩“pocky game”（百奇饼干游戏），看谁先咬断。 193. 用你的头发轻轻扫过一位玩家的脸。 194. 选一个人，模仿他/她高潮时的表情。 195. 用舌头在嘴唇上画一圈。 196. 让一位玩家轻轻拍打你的屁股一下。 197. 用两根手指模仿一个人走路的姿势，从一位玩家的大腿走到胸口。 198. 对一位玩家说：“请对我做一件你一直想做的事。”（在安全范围内） 199. 用嘴把一位玩家手腕上的皮筋取下来。 200. 把一位玩家的鞋带系在一起。 --- #### **第三等级：高度（第201-300题）** ,*适合非常亲密、放得开的朋友或情侣，问题和挑战直接涉及性、身体和深度隐私。* ,**真心话 (201-250):** 201. 你最近一次自慰时幻想的是谁？ 202. 你是否有过3P或群交的经历？细节如何？ 203. 你最喜欢的性玩具品牌和型号是什么？ 204. 你曾经在性爱中尝试过角色扮演吗？扮演过什么？ 205. 你是否有过SM（虐恋）经历？你扮演什么角色？ 206. 你曾经为了性，做过什么违背自己原则的事吗？ 207. 你最长的性爱马拉松是多久？ 208. 你曾经在性爱中失禁过吗？ 209. 你是否有过被强迫或强迫他人的性经历？ 210. 你如何看待乱伦题材的色情作品？ 211. 你曾经对家人或亲戚产生过性幻想吗？ 212. 你是否有过肛交经历？感觉如何？ 213. 你曾经在性爱中拍摄过视频或照片吗？现在还保留着吗？ 214. 你最喜欢的口交姿势是什么？ 215. 你曾经吞下过精液/爱液吗？感觉如何？ 216. 你是否有过暴露癖或偷窥癖的倾向？ 217. 你曾经在公共场所自慰过吗？ 218. 你最多连续自慰过几次？ 219. 你曾经因为性行为去过医院吗？ 220. 你是否有过与动物发生关系的幻想？ 221. 你如何看待恋物癖？你有什么特殊的恋物癖好吗？ 222. 你曾经在毒品或酒精影响下发生性行为吗？感觉有何不同？ 223. 你最喜欢的脏话是什么？（在做爱时说的） 224. 你曾经和比你大/小很多岁的人上过床吗？年龄差是多少？ 225. 你是否有过性病？如何治愈的？ 226. 你曾经在网络上付费购买过性服务或定制视频吗？ 227. 你理想的性爱频率是多久一次？ 228. 你曾经在性爱中睡着过吗？ 229. 你是否有过不射精/达不到高潮的困扰？ 230. 你曾经因为性取向而困惑过吗？ 231. 你愿意尝试“冰火两重天”吗？ 232. 你曾经在性爱中说过最后悔的一句话是什么？ 233. 你是否有过“电话性爱”的经历？ 234. 你如何看待“换妻/换夫”游戏？ 235. 你曾经在镜子前做爱吗？ 236. 你是否有过“性上瘾”的自我怀疑？ 237. 你曾经在性爱中受伤最严重的一次是什么？ 238. 你最喜欢的体液（精液/爱液/汗液）味道是什么？ 239. 你曾经和陌生人玩过“真心话大冒险”并发生了关系吗？ 240. 你是否有过“贞操锁”或类似玩具的使用经验？ 241. 你曾经在性爱中尝试过窒息游戏吗？ 242. 你如何看待“处女/处男”情结？ 243. 你曾经同时和两个人保持性关系吗？ 244. 你是否有过“潮吹”的经历？ 245. 你曾经在葬礼或婚礼等特殊场合产生过性冲动吗？ 246. 你最喜欢的BDSM道具是什么？ 247. 你曾经因为性幻想对象而自责吗？ 248. 你是否有过“恋足”的倾向？ 249. 你曾经在性爱中叫错名字吗？ 250. 你愿意为了性放弃什么？ ,**大冒险 (251-300):** 251. 脱掉上身/下身的衣服（仅留内衣），持续两轮。 252. 让一位指定玩家在你背上用口红（或奶油）画一个图案。 253. 和一位异性玩家接吻10秒钟（或更长时间）。 254. 模仿一种你最喜欢的A片情节，可以找一位玩家配合。 255. 用嘴帮一位玩家脱掉袜子。 256. 让一位玩家用皮带（或领带）轻轻绑住你的手腕一分钟。 257. 详细描述你上一次自慰的细节。 258. 选一位玩家，在他/她面前跳一段诱惑的舞蹈。 259. 用舌头舔一位玩家的脚趾（如果对方同意）。 260. 和一位玩家一起躲进衣柜或小房间，待上一分钟。 261. 让一位玩家蒙住你的眼睛，然后喂你吃三种不同的食物，让你猜。 262. 用你的胸部（或胸肌）夹住一支笔，写下你的名字。 263. 选一个人，对他/她进行一分钟的“言语羞辱”或“赞美”（根据对方喜好）。 264. 把一块冰块从你的裤子前面滑到后面。 265. 和一位玩家表演“69”姿势的模仿（不真做）。 266. 让一位玩家在你屁股上打一巴掌，要听到响声。 267. 用身体摩擦一位玩家的背部，像猫一样。 268. 选一个人，轻声告诉他/她你最想和他/她尝试的性爱姿势。 269. 脱下一位玩家的裤子（仅限内裤以上，且对方同意）。 270. 用嘴把一位玩家裤子上的扣子解开（如果对方同意）。 271. 躺在桌子中间，让其他玩家轮流喂你吃一颗葡萄。 272. 模仿高潮时的表情和声音，持续30秒。 273. 让一位玩家用马克笔在你身上（非私处）写一句他/她想说的话。 274. 和一位玩家一起用嘴拉开一罐啤酒的拉环。 275. 把一位玩家按在沙发上，轻轻吹他/她的耳朵。 276. 用你的嘴唇碰一下一位玩家的腹肌（或小腹）。 277. 选一个人，帮他/她按摩脚部一分钟。 278. 用舌头在一位玩家的手心上画一个圈。 279. 把一杯水倒一点在自己锁骨上，让一位玩家舔掉。 280. 和一位玩家玩“医生和病人”的角色扮演，进行一分钟的“检查”。 281. 用丝巾蒙住眼睛，通过触摸来猜一位玩家是谁。 282. 让一位玩家坐在你身上（背对或正对），你做十个仰卧起坐。 283. 选一个人，用牙齿轻轻咬开他/她上衣的纽扣（如果对方同意）。 284. 用屁股写“我爱你”三个字。 285. 把一位玩家的手放在你的大腿内侧，停留30秒。 286. 详细描述你最喜欢的A片明星。 287. 用你的头发轻轻扫过一位玩家的敏感部位（如脖颈、胸口）。 288. 选一个人，和他/她喝一杯“交杯酒”。 289. 假装你是一个性玩具推销员，向一位玩家推销你手中的一个物品（如遥控器、香蕉）。 290. 用嘴唇轻轻含住一位玩家的手指。 291. 让一位玩家用冰块在你胸口画一条线。 292. 和一位玩家一起钻进一张毯子下面，待30秒。 293. 选一个人，对他/她说出你最变态的一个性幻想。 294. 用舌头舔自己的鼻子（尝试即可）。 295. 把一位玩家的腿搭在你的肩膀上，假装按摩。 296. 用你的膝盖轻轻摩擦一位玩家的大腿。 297. 选一个人，模仿他/她自慰时的样子。 298. 用嘴接住一位玩家从高处扔下的小零食（如爆米花）。 299. 让一位玩家对你下一条命令（在安全范围内），你必须执行。 300. 亲吻在场一位玩家的肚脐。 --- #### **第四等级：超刺激（第301-400题）** ,*仅供极度开放、关系极其亲密且完全自愿的参与者（如情侣、夫妻）。风险和尺度极大，请务必谨慎选择。* ,**真心话 (301-350):** 301. 你曾经在性爱中录下过视频吗？是否曾与他人分享？ 302. 你是否有过与直系亲属以外的亲戚发生关系的幻想？是谁？ 303. 你曾经在不知情或意识不清的情况下与人发生关系吗？ 304. 你最多一次和多少人发生过关系？（包括群交） 305. 你曾经使用过迷奸药或类似药物吗？（无论是使用还是被使用） 306. 你是否有过与未成年人发生关系的经历或幻想？ 307. 你曾经在宗教场所或墓地等极端场所有过性行为吗？ 308. 你如何看待兽交？你是否有过相关幻想或经历？ 309. 你曾经在性爱中见过血吗？原因是什么？ 310. 你是否有过“强奸幻想”？你希望扮演哪个角色？ 311. 你曾经为了性，做过违法的事情吗？ 312. 你是否有过“断片性爱”（blackout sex）的经历？ 313. 你曾经在性爱中故意伤害对方或希望被伤害吗？ 314. 你最喜欢的羞辱性词汇是什么？ 315. 你是否有过“斯德哥尔摩综合征”式的性幻想？ 316. 你曾经在公开场合（如公园、公交车）完全裸露过身体吗？ 317. 你如何看待“恋尸癖”？ 318. 你曾经在性爱中失去意识过吗？ 319. 你是否有过“性别认知障碍”的困惑？ 320. 你曾经拍摄过自己的裸体或性爱视频并上传到网络吗？ 321. 你最喜欢的“禁忌之恋”题材是什么？（如师生、父女等） 322. 你是否有过“圣水/黄金”等极端癖好的经历或好奇？ 323. 你曾经在性爱中使用过真正的刀具或绳索等危险物品吗？ 324. 你如何看待“性勒索”？ 325. 你曾经幻想过杀死你的性伴侣或被其杀死吗？（即“死亡性爱”） 326. 你是否有过与外星人或非人生物发生关系的幻想？ 327. 你曾经在性爱中故意传播过性病吗？ 328. 你最喜欢的“角色扮演”场景是极度违背伦理的哪种？（如乱伦） 329. 你是否有过“睡眠性交”（即一方在睡眠中）的经历或幻想？ 330. 你曾经在性爱中因为极度兴奋而失忆过吗？ 331. 你如何看待“公开调教”？ 332. 你是否有过“跟踪癖”或“被跟踪癖”？ 333. 你曾经在性爱中窒息过对方或希望被窒息到什么程度？ 334. 你最喜欢的“疼痛等级”是几级？ 335. 你是否有过“分裂人格”的性幻想？ 336. 你曾经在性爱中故意让对方感到恐惧吗？ 337. 你如何看待“优生学”和“繁殖欲”？ 338. 你是否有过“时间停止”或“透明人”这类侵犯性的幻想？ 339. 你曾经在性爱中尝试过粪便相关的行为吗？ 340. 你最喜欢的“绝对服从”命令是什么？ 341. 你是否有过“被强迫怀孕”或“强迫他人怀孕”的幻想？ 342. 你曾经在性爱中召唤过“鬼神”或进行过类似仪式吗？ 343. 你如何看待“食人”癖好？ 344. 你是否有过“自残”并与性快感联系的经历？ 345. 你曾经在性爱中完全失去理智，像野兽一样吗？ 346. 你最喜欢的“终极羞辱”方式是什么？ 347. 你是否有过“灵魂出窍”的性体验？ 348. 你曾经在性爱中濒临死亡边缘吗？ 349. 你如何看待“性”与“死亡”的终极联系？ 350. 你是否认为你的某些性癖好需要心理治疗？ ,**大冒险 (351-400):** 351. 与一位玩家进行法式湿吻，持续30秒。 352. 脱掉全部衣服（仅穿内裤），在房间内走一圈。 353. 让一位指定玩家用鞭子或类似物品轻轻抽打你的臀部三下。 354. 与一位玩家互相喂食带有情欲色彩的食物（如香蕉、樱桃）。 355. 在一位玩家的监督下，自慰一分钟（可隔着衣物）。 356. 让一位玩家用蜡烛滴蜡在你背上（确保安全距离和温度）。 357. 详细描述你最极端的一次性幻想。 358. 与一位玩家模仿一种动物交配的姿势。 359. 用嘴把一位玩家的内裤边缘拉下来一点（再拉回去）。 360. 选一个人，让他/她用马克笔在你胸部或臀部画上“财产标记”。 361. 让一位玩家用领带蒙住你的眼睛，然后他/她可以对你做任何事（在事先约定的安全范围内），持续一分钟。 362. 和一位玩家一起进入浴室（或密闭空间），锁上门待两分钟。 363. 用舌头舔一位玩家的腋窝（如果对方同意并清洁过）。 364. 选一个人，对他/她进行一段带有BDSM色彩的命令式对话。 365. 把一位玩家绑在椅子上（用丝巾等柔软物），喂他/她喝一口水。 366. 模仿A片中的情节，表演一段“强奸”戏码（必须事先明确是表演，且对方同意配合）。 367. 让一位玩家坐在你脸上（隔着一层布或衣服），坚持15秒。 368. 用你的性器官（隔着裤子）去摩擦一位玩家的腿部。 369. 选一个人，帮他/她进行全身按摩（可隔着衣服）。 370. 用嘴含住水，然后喂给一位玩家（即“鸳鸯喂水”）。 371. 让一位玩家对你进行“言语上的性侵犯”（根据你的接受程度）。 372. 和一位玩家一起躲在桌子底下，互相抚摸对方的脸。 373. 用冰块在你和另一位玩家的皮肤上滑动，直到冰块融化。 374. 选一个人，在他/她面前表演脱衣舞，直到只剩内衣。 375. 让一位玩家用脚轻轻踩你的背部或手掌。 376. 详细描述你希望如何被“调教”。 377. 用绳子（或丝巾）轻轻绑住一位玩家的脚踝。 378. 和一位玩家一起观看一段色情视频的前30秒。 379. 用嘴唇亲吻一位玩家的大腿内侧（非私处）。 380. 选一个人，对他/她耳语你最想被他/她对待的方式。 381. 让一位玩家给你戴上眼罩和口球（或类似替代品）一分钟。 382. 在一位玩家的皮肤上，用舔的方式留下一个湿痕图案。 383. 模仿性爱时的抽搐和呻吟，持续一分钟。 384. 选一个人，让他/她决定你下一轮是选真心话还是大冒险。 385. 让一位玩家用口红在你身上写下他/她的名字。 386. 和一位玩家一起创造一个你们之间的秘密性暗号。 387. 用你的身体把一位玩家“困”在墙角一分钟。 388. 选一个人，让他/她对你施加一个轻微的疼痛刺激（如掐一下）。 389. 让一位玩家记录下你高潮时的声音（可模拟）。 390. 在一位玩家的指令下，摆出三个最羞耻的姿势。 391. 用嘴去解开幕布一位玩家的皮带扣。 392. 选一个人，和他/她分享你手机里最私密的一张照片（非裸露违法）。 393. 让一位玩家对你进行“身体检查”，并说出“报告”。 394. 在一位玩家的注视下，更换你的内衣（可在浴室或帘子后）。 395. 用你的唾液涂在一位玩家的手指上。 396. 选一个人，和他/她约定一个下次单独见面时要实现的性幻想。 397. 让一位玩家成为你的“主人”/“奴隶”，持续到游戏结束。 398. 在一位玩家的皮肤上，用吻痕拼出一个字母。 399. 进行一场模拟的“性交易”，你提供服务，另一位玩家出价（虚拟）。 400. 亲吻在场一位玩家的私密部位上方（如内裤边缘）。 --- ,**最后再次强调：请务必根据实际情况，谨慎、负责任地使用此题库。游戏的最终目的是创造快乐和增进感情，而不是造成尴尬、伤害或冲突。祝你们游戏愉快！** ","date":"2025-09-15T01:04:59.02+08:00","permalink":"https://ynhugo.github.io/p/%E8%81%9A%E4%BC%9A/","title":"聚会"},{"content":" 炸金花 游戏准备 玩家人数：2至6人，适合小型聚会或在线多人对战。 牌组：使用一副52张扑克牌，去除大小王。 发牌：每位玩家获得三张暗牌（牌面朝下），由庄家逆时针发牌。首次游戏随机选择庄家，之后由上一局胜者担任。\n游戏流程 底注：游戏开始前，每位玩家需投入约定的底注，形成初始奖池。 操作选项： 看牌：玩家可查看自己的三张牌，了解牌型。 跟注：匹配当前轮的单注金额。看牌后跟注为“明注”，未看牌为“暗注”（暗注金额为明注的两倍）。 加注：增加下注金额，最高不超过单注上限。 比牌：支付双倍当前单注，与另一玩家比较牌型，输者失去操作权。 弃牌：放弃本局，损失已投入的筹码。 胜负判定： 当只剩两名玩家时，可随时比牌决定胜负。\n牌型与大小 炸金花的牌型从大到小依次为：\n牌型 描述 示例 豹子 三张点数相同的牌 AAA、222 顺金 花色相同且连续的牌 黑桃456、红桃QKA 金花 花色相同但不连续的牌 黑桃368 顺子 花色不同但连续的牌 黑桃5、红桃6、方块7 对子 两张点数相同，一张不同 223、778 单张 三张点数不同且不连续 258 特殊牌型 235（不同花色），可击败豹子 黑桃2、红桃3、方块5 点数与花色比较： 点数大小：A \u0026gt; K \u0026gt; Q \u0026gt; J \u0026gt; 10 \u0026gt; 9 \u0026gt; 8 \u0026gt; 7 \u0026gt; 6 \u0026gt; 5 \u0026gt; 4 \u0026gt; 3 \u0026gt; 2。 花色大小（同牌型时比较）：黑桃 \u0026gt; 红桃 \u0026gt; 梅花 \u0026gt; 方块。 相同牌型比较：按最大点数依次比较，若完全相同，主动比牌者负。\n基础策略 控制情绪：保持冷静，避免因冲动而做出错误决定。 合理下注：根据牌力和局势选择跟注、加注或弃牌，避免盲目投入。 观察对手：注意对手的下注模式和行为习惯，推测其牌型。 适时比牌：在牌力较强或对手表现出犹豫时，选择比牌以淘汰对手。\n进阶技巧 诈牌（Bluffing）：即使牌型一般，也可通过加注制造压力，迫使对手弃牌。但需在建立可靠形象后谨慎使用。 节奏控制：在早期保持低调，隐藏实力，吸引更多玩家跟注，增加奖池。 牌型概率：了解牌型出现的概率。例如，豹子出现的概率仅为0.24%（腾讯新闻），因此拿到强牌时应大胆加注。 心理战 炸金花被称为“诈金花”，心理战是其核心。玩家可以通过表情、语速或下注节奏误导对手。例如，快速加注可能让对手误以为你持有强牌，从而选择弃牌。\n多媒体资源：学习与娱乐并重 https://youtu.be/EXuSTjaVuNY\n炸金花技巧：分享实用策略，帮助玩家提升胜率。 炸金花 Win 3 Cards – 遊戲規則與獲利策略：结合规则与进阶技巧，适合希望深入学习的玩家。 参考链接 炸金花规则速览，朋友休闲必看！（切勿赌博）\n炸金花在线：探索中国最受欢迎的在线纸牌游戏\n","date":"2025-09-15T00:07:31.36+08:00","permalink":"https://ynhugo.github.io/p/%E7%82%B8%E9%87%91%E8%8A%B1/","title":"炸金花"},{"content":" 中国麻将基本规则 麻将牌 麻将牌分为五种：筒、条、万、风和箭。\n参考链接 麻将牌\n吃 吃指的是三张相同花色的连续牌的组合，也称为顺子。\n参考链接 吃\n碰 碰指的是三张相同牌的组合，也称为刻子。\n参考链接 碰\n杠 杠指的是四张相同牌的组合，也称为杠子。\n杠\n对子 对子指的是两张相同牌的组合，也称为对子。\n参考链接 对子\n听牌 听牌指的是距离胡牌只有一张牌的状态。\n参考链接 听牌\n胡牌 胡牌的基本公式是：\n1 m*AAA+n*ABC+DD DD=Pair ABC=Sequence AAA=Triplet m+n=4 参考链接 胡牌\n参考链接 怎么玩中国麻将?\n国标麻将番种表 1 番 一般高 什么是一般高？ 在国标麻将（中国麻将竞赛规则）中，“一般高”是一种番种，属于副露手牌和门清手牌都可实现的组合牌型之一。它的主要特点是，牌面上有两个完全相同的顺子。\n一般高是指：在手牌中出现两个完全相同的顺子（例如同样是 3张连续的序数牌，比如 3条、4条、5条），且必须为同一种花色。 这两个顺子可以存在于门清的手牌中，也可以通过吃牌或碰牌后的副露手中形成。\n一般高的牌型 以下是一些一般高的牌型举例：\n万子：2万、3万、4万 和 2万、3万、4万。\n条子：6条、7条、8条 和 6条、7条、8条。\n筒子：1筒、2筒、3筒 和 1筒、2筒、3筒。\n副露后形成：吃到 3万、4万、5万，手中又有另一组 3万、4万、5万。通过吃牌或摸牌，形成两组相同的顺子。\n一般高的番数 在国标麻将中，\u0026#34;一般高\u0026#34;的番值为 1番，是一个基础的得分组合，适合搭配其他番种增加牌局分值。\n一般高的注意事项 必须为同一花色：两个顺子必须是同一种花色，否则不能算作一般高。例如，3条、4条、5条 和 3万、4万、5万 不构成一般高。\n可以副露：即使已经吃牌或碰牌，只要手牌中有两个相同的顺子，仍然可以计为一般高。\n与其他番种的叠加：如果玩家的手牌中除了“一般高”外，还形成其他番种（如平和、一气通贯等），则可以叠加计番。 同时满足“一般高”和“七对子”是不可能的，因为七对子要求全为对子，不允许有顺子。\n一般高的策略与实战意义 易于形成：一般高是国标麻将中较为常见且易于形成的番种，尤其适合新手或牌局初期尝试。\n叠加得分：由于“一般高”可以与其他番种结合使用，因此可以作为凑番的一部分，例如搭配门清自摸或断幺九等组合。\n观察对手：如果发现对手频繁吃牌或副露某种花色的顺子，需要警惕其可能在凑一般高。\n参考链接 一般高\n喜相逢 什么是喜相逢？ 在国标麻将中，喜相逢的番数是1番，番数较低，但由于行形成条件相对简单，在实战中较为常见。喜相逢是指玩家手牌中有两组点数相同，花色不同的顺子。例如：五万，六万，七万和五饼，六饼，七饼。\n喜相逢的牌型 以下是一些喜相逢 的牌型举例：\n三万、四万、五万 三条、四条、五条 六万、七万、八万 六筒、七筒、八筒 东风东风 在这个例子中：\n三万、四万、五万 和 三条、四条、五条 是一组喜相逢。 六万、七万、八万 和 六筒、七筒、八筒 是另一组喜相逢。 因此，这副牌中包含了两组喜相逢。\n喜相逢的番数 在国标麻将中，喜相逢的番数是1番，番数较低，但由于形成条件相对简单，在实战中较为常见。\n喜相逢的注意事项 点数相同：两组顺子的点数必须完全一致，例如都是三四五。不允许有点数差异，如二三四和三四五。\n花色不同：顺子必须是不同花色的，比如一组是万子，另一组是条子或筒子。两组同花色的顺子不能算作喜相逢。\n叠加计分：每一组符合条件的喜相逢都可以计入1番。例如：如果你有三万、四万、五万 和 三条、四条、五条 是一组喜相逢，七万、八万、九万 和 七条、八条、九条 是另一组喜相逢，总计2番。\n喜相逢的策略与实战意义 优先保留点数一致的顺子：在做牌时，如果有两组点数相同的顺子且花色不同，可以优先保留，以增加形成喜相逢的机会。\n注意番种组合：由于喜相逢的番数较低，建议同时追求其他高番种（如混一色、三色同顺），从而提高胡牌的整体价值。\n灵活调整：在不影响更高番种的情况下，可以以喜相逢作为补充番数，但不要过于执着于追求喜相逢而影响整体牌型。\n参考链接 喜相逢\n连六 什么是连六？ 在国标麻将中连六是指玩家的手牌中有两组同一花色且连续点数的顺子，这两组顺子的点数相邻，合计六张牌。如：一筒、二筒、三筒 和 四筒、五筒、六筒，三条、四条、五条和六条、七条、八条。这两组顺子构成连六。\n连六的牌型 以下是连六的牌型举例：\n一万、二万、三万 四万、五万、六万 七条、八条、九条 六筒、七筒、八筒 东风、东风 其中：一万、二万、三万 和 四万、五万、六万 构成1组连六，加 1番。\n连六的番数 在国标麻将中，连六的番数为1番。它是一个低番种，附加番数较少，但因为形成条件简单，实战中较为常见。\n连六的注意事项 必须是顺子：连六由两组三张牌的顺子组成，且必须是连续数字的牌型，刻子或对子不算在内。\n花色相同：两组顺子必须是同一种花色（万、条、筒）。\n点数相邻：两组顺子的点数必须直接相连，形成从某个数字开始连续的6张牌。例如：一筒、二筒、三筒 + 四筒、五筒、六筒。五条、六条、七条 + 八条、九条、一条（九条和一条不连续，无法构成连六）。\n计为1番：每一组符合条件的连六可以加1番。如果手牌中有多组连六，可以叠加计番。\n连六的策略与实战意义 优先保留连续顺子：在做牌时，注意将点数连续的顺子保留，以增加形成连六的机会。如果同花色的顺子之间点数断开，则无法形成连六。\n适时调整牌型：连六的番数较低，建议在追求更高番数（如清一色、平和）的过程中顺带考虑连六，不要为连六放弃更高价值的牌型。\n利用连六加番：虽然连六仅为1番，但在整体番数较低时，它能起到锦上添花的作用，帮助达到胡牌的基本番数要求。\n与其他番种的兼容性：连六可以与其他番种叠加，如果手牌中同时满足连六和其他番种（如平和、清一色），可以叠加计算番数。与一色三同顺等不冲突，连六的顺子可以独立计番，但不能与其他类似的顺子番种重复计分。\n参考链接 连六\n老少副 什么是老少副？ 老少副是国标麻将中的一个1番番种，指玩家的手牌中包含两组相同花色的老少顺子，即：老顺子：一、二、三。少顺子：七、八、九。\n老少副的牌型 以下是老少副的牌型举例：\n一筒、二筒、三筒 和 七筒、八筒、九筒 一万、二万、三万 和 七万、八万、九万\n老少副的番数 在国标麻将（中国麻将国际竞赛规则）中，老少副的番数为1番。老少副形成条件简单，常作为其他高番牌型的补充。\n老少副的注意事项 必须是顺子 ：老少副由两组三张牌的顺子组成，分别是一、二、三和七、八、九。对子、刻子或其他牌型不算在内。\n花色相同 ：两组顺子必须是同一种花色（万、条、筒）。\n必须包含指定数字 ：老顺子必须是一、二、三，少顺子必须是七、八、九，中间的其他数字如四、五、六不能作为替代。\n计为1番 ：满足老少副的条件后，可加1番。\n老少副与其他番种的关系 可以叠加计番 ：老少副可以与其他番种（如清一色、平和）叠加。例如： 如果这两组顺子都是同一花色（如筒子），并且手牌符合清一色的条件，则清一色和老少副的番数可以一同计算。\n不与其他顺子类番种冲突 ：老少副的两组顺子可以单独计番，不会与其他番种（如连六、一色三步高）冲突。\n老少副的策略与实战意义 保留关键牌 ：在做牌时，优先保留一、二、三和七、八、九的组合，尤其是在单一花色的情况下，容易形成老少副。\n搭配其他番种 ：老少副的番数较低，单靠它难以大幅提升胡牌总番数，因此建议与清一色、混一色等高番种结合使用。\n辅助达标 ：在手牌接近基本胡牌番数时，老少副可以作为一种简单易得的补充番种，帮助达到胡牌要求。\n参考链接 老少副\n幺九刻 什么是幺九刻？ 幺九刻是国标麻将中的一个1番番种，指手牌中由1或9组成的刻子或杠，如：一万、一万、一万（幺刻），九条、九条、九条（九刻），一筒、一筒、一筒、一筒（幺牌杠）。作为基础番种易与其他高番叠加计分。\n幺九刻的牌型 以下是幺九刻的牌型举例：\n一万、一万、一万 九筒、九筒、九筒 三条、四条、五条 东风、东风、东风 八条、八条 其中：一万、一万、一万 是一个幺九刻，加1番。九筒、九筒、九筒 是另一个幺九刻，再加1番，总计2番。\n幺九刻的番数 幺九刻在国标麻将中计为1番。每有一组符合条件的幺九刻（由1或9组成的刻子或杠），即可加1番，多组幺九刻可累加番数。\n幺九刻的注意事项 必须是幺九牌：只能是数牌中的1或9，其他数字（如2到8）不算在内。字牌（风牌、箭牌）也不属于幺九刻。\n必须是刻子或杠：刻子是三张相同的牌，例如一万、一万、一万。杠是四张相同的牌，例如九筒、九筒、九筒、九筒。顺子（如一、二、三）不计入幺九刻。\n计为1番：每有一组幺九刻，均可加1番。多组幺九刻可叠加番数。\n幺九刻与其他番种的关系 可以叠加其他番种：幺九刻可以与其他番种（如清一色、碰碰胡、三杠等）一起计分。例如：如果手牌同时满足碰碰胡和幺九刻，则两者的番数可以叠加。\n与全不靠不兼容：如果手牌属于全不靠（每张牌不相连且不成刻子或顺子），则无法形成幺九刻。\n幺九刻的策略与实战意义 优先留幺九牌：在牌局中，发现手中有两张幺牌或九牌时，可以考虑保留，尽量形成刻子。\n结合碰碰胡：由于幺九刻的刻子性质，与碰碰胡（4组刻子加1对子）有较高的兼容性，可以尝试同时追求。\n灵活调整：如果手牌中幺九刻的数量不足，不要过于执着，可以根据局势选择放弃，追求更高番数的牌型。\n参考链接 幺九刻\n明杠 什么是明杠？ 明杠是国标麻将中的一个1番番种，指玩家通过以下方式形成的杠（四张相同的牌）：\n加杠：玩家在碰牌后，再摸到第四张相同的牌，将其加到碰牌的刻子上形成杠。 直杠：玩家直接吃到对手打出的第四张相同的牌，明示后形成杠。\n明杠的牌型 以下是明杠的牌型举例： 九万、九万、九万、九万（明杠，1番） 三筒、三筒、三筒、三筒（明杠，1番） 二条、三条、四条 七条、七条 东风、东风、东风 其中：九万的明杠计1番。三筒的明杠再计1番。总计 2番。\n明杠的番数 番数：每有一个明杠，可计1番。如果手牌中有多个明杠，可以叠加番数。\n明杠的番种：明杠属于附加番种，只能作为其他番种的补充，无法单独胡牌。\n不影响其他番种：明杠与碰碰胡、杠上开花等番种可以叠加计分。在国标麻将（中国麻将国际竞赛规则）中，明杠是一个基本的附加番种，计为1番。\n明杠的注意事项 玩家需要拥有4张相同的牌，且通过加杠或直杠明示完成。已经碰牌的情况下摸到第四张相同的牌，才能形成加杠。直接获取他人打出的第四张相同的牌，才能形成直杠。\n杠牌优先级：如果你准备加杠，但其他玩家抢杠胡，杠牌行为将被取消。\n必须公开：明杠需要将杠牌公开展示，暴露牌型的一部分信息。\n不算作暗杠：明杠不同于暗杠，只有通过加杠或直杠形成，才可称为明杠。\n明杠与其他番种的关系 可叠加计分：明杠可以与其他番种（如碰碰胡、三杠、杠上开花）叠加计分。如如果有3个明杠，同时符合碰碰胡的条件，则明杠加 3番，碰碰胡加 6番。\n与暗杠区分：明杠是通过他人牌或碰后加杠形成的，计1番。暗杠是自摸到4张相同的牌并暗下去形成的，计2番。\n明杠的策略与实战意义 及时加杠：当自己碰了三张相同的牌，如果摸到第四张，及时加杠，增加番数。\n避免明杠暴露危险：明杠可能暴露你的牌型信息，尤其是关键番种时，应谨慎考虑是否明杠。\n结合杠上开花：如果通过明杠摸牌后自摸胡牌，可以同时计入杠上开花（1番）。\n参考链接 幺九刻\n缺一门 什么是缺一门？ 缺一门是指玩家的手牌中缺少万、条、筒三种花色中的一种，即胡牌时，整副牌中只包含两种花色的序数牌（万、条、筒）和字牌。\n缺一门的牌型 以下是缺一门的牌型举例：\n三筒、四筒、五筒，六筒、七筒、八筒，红中、红中，东风、东风、东风，九万、九万。 在这手牌中只包含筒子和万子，完全缺少条子的花色。字牌（红中、东风）不影响缺一门的判断。符合缺一门条件，计1番。\n缺一门的番数 缺一门在国标麻将中计为1番，指胡牌时手牌中三种花色（万、条、筒）缺少其中一种。\n缺一门的注意事项 花色限制：胡牌时，手牌中只能包含两种花色的序数牌（万、条、筒），并且必须完全缺少一种花色。\n字牌无影响：字牌（风牌、箭牌）的存在或数量不影响缺一门的成立，只需要判断序数牌的花色是否缺失。\n计为1番：缺一门的番数固定为1番，且可以多番叠加。\n缺一门与其他番种的关系 可以叠加计分：缺一门可以与其他番种（如清一色、混一色、平和）同时计分。如果胡牌手牌是清一色，同时符合缺一门，那么两者可同时计入番数。\n与清一色的关系：清一色（24番）属于更高番数的番种，如果手牌为清一色，缺一门的1番不会单独计算。\n不与混一色冲突：混一色（6番）要求手牌中只有一种花色和字牌，因此也满足缺一门的条件，可同时计番。\n缺一门的策略与实战意义 追求高番种的辅助条件：缺一门通常与清一色或混一色配合使用，有助于提升总番数。\n牌局中的灵活性：缺一门形成条件宽松，无需特意去做，可以作为附加番种自然出现。\n适时调整策略：如果缺一门的牌型需要拆牌来追求更高番种，应根据局势权衡是否保留。\n参考链接 缺一门\n无字 什么是无字？ 在国标麻将中，无字是指玩家的胡牌中没有任何字牌（风牌和箭牌），计为1番。其中风牌是指：东、南、西、北。箭牌是指：中、发、白。\n无字的牌型 以下是无字的牌型举例：\n一万、二万、三万、五万、五万、五万、四筒、五筒、六筒、六条、七条、八条、六筒、六筒。 一条、二条、三条、五条、六条、七条、七万、八万、九万、五筒、五筒、五筒、四筒、四筒。 其中：这两副牌中完全没有字牌，符合无字条件，加 1番。\n无字的番数 无字是国标麻将中一个简单易得的附加番种，计为 1番。其条件是胡牌时手牌中没有任何字牌（风牌和箭牌），容易在自然对局中达成，是提高总番数的有效手段之一。\n无字的注意事项 必须完全没有字牌：胡牌时，整副牌中不能包含任何字牌（风牌或箭牌）。包括碰、杠、暗刻等形式的字牌，也不允许存在。\n适用于任何花色组合：无字的成立与序数牌的花色分布（万、条、筒）无关，只与字牌的存在有关。\n计为1番：符合无字条件时，计1番。\n无字与其他番种的关系 可叠加计分：无字可以与其他番种（如清一色、缺一门、平和）同时计分。如果手牌同时满足清一色和无字，则清一色计 24番，无字再加 1番。\n限制性较低：无字的成立仅要求没有字牌，不会与其他番种冲突，因此是一个容易达成的小番种。\n无字的策略与实战意义 自然形成：无字的条件宽松，大多数情况下不需要特意追求，是一个自然形成的附加番种。\n与高番种搭配：无字通常作为补充番种出现，建议在追求清一色、混一色、碰碰胡等牌型时顺便触发。\n调整牌型：如果手牌中有字牌但不必要时，可以拆掉字牌以形成无字，增加额外的番数。\n参考链接 无字\n边张 什么是边张？ 边张是国标麻将中的一个番种，计为1番。它指玩家在胡牌时，胡的牌必须是顺子的两端，也就是边张。例如，顺子一、二、三中胡三，或顺子七、八、九中胡七，则符合边张的条件。边张不能是顺子的中间牌，且可与其他番种叠加计分，如平和、缺一门等，是一个简单易得的小番种。\n边张的牌型 以下是边张的牌型举例：\n一条、二条、三条，七万、八万、九万，五筒、五筒、五筒，三筒、四筒，胡五筒。 其中：胡五筒的顺子是三筒、四筒、五筒，五筒为中张，因此不符合边张，没有边张加番。\n一万、二万、三万，七条、八条、九条，四筒、五筒、六筒，，五万、五万，胡七条。 其中：胡七条的顺子是七条、八条、九条，七条是边张。符合边张条件，加1番。\n边张的番数 边张是国标麻将中的一个计1番的附加番种，条件是胡牌必须为顺子的边张。\n边张的注意事项 边张的定义条件：胡牌的牌必须在顺子的边上：顺子 一、二、三 的边张是三；顺子 七、八、九 的边张是七。\n中张无效：如果胡牌是顺子的中间牌（如二在顺子一、二、三中），则不计边张。\n计为1番：每次胡牌符合边张条件时，加1番。\n与其他番种兼容：边张可以与平和、清一色、缺一门等番种叠加计分。\n边张与其他番种的关系 叠加性：边张可以与其他番种叠加计分。如果胡牌手牌符合边张和平和，则边张计1番，平和计2番。\n局限性：边张仅针对顺子胡牌有效，对刻子、杠牌或对子胡牌无效。\n边张的策略与实战意义 灵活调整听牌：在听牌阶段，如果发现可以选择边张听牌，有助于增加番数。\n搭配其他番种：边张与平和等番种的配合较好，可以同时获得较高番数。\n优先边张胡牌：如果手中有多个胡牌选择且番数相同，优先选择边张，以额外增加1番。\n参考链接 边张\n坎张 什么是坎张？ 坎张是国标麻将中最基础且常见的番种之一，其胡牌方式简单，隐蔽性高且容易达成。尽管番值较低，但因其简单和实用性，坎张胡牌在实际对局中经常出现。坎张是指玩家胡牌时，听一张顺子中间的牌完成胡牌。 例如： 一筒、三筒听二筒，胡二筒即为坎张，七条、九条听八条，胡八条也是坎张。\n坎张的牌型 以下是坎张的牌型举例：\n手牌：111万、345万、567万、789筒、发发 听牌：5万 胡牌：摸到5万，形成顺子345万和其他牌型。\n坎张的番数 在国标麻将中，“坎张”是一个1番的番种，它是一种常见的低分牌型，是通过特定的听牌方式和胡牌方式达成的。\n坎张的注意事项 必须是顺子：坎张胡牌完成后，形成一个顺子（如123、456、789等）。\n听牌位置在顺子中间：听牌必须是顺子的中间牌（如听2胡123，听5胡456）。\n坎张不等于边张：坎张胡牌的听牌是顺子中间的牌（如听5胡456），而边张胡牌的听牌是顺子两端的牌（如听3胡123）。\n坎张不等于单钓将：坎张听的是顺子的中间牌，单钓将听的是将牌。\n与顺子无关的牌不算坎张：如果听牌无法形成顺子，即使是中间牌也不能算作坎张。\n坎张与其他番种的关系 平和（2番）：如果胡牌全部由顺子构成，且将牌为序数牌的对子，可能叠加平和。\n清一色（24番）：如果坎张胡牌的所有牌均为同一花色，可叠加清一色。\n断幺（2番）：如果坎张的牌型中没有幺九牌和字牌，可叠加断幺。\n门前清（2番）：如果坎张胡牌通过门清状态（无碰牌、无杠牌），可叠加门前清\n参考链接 坎张\n单钓将 什么是单钓将？ 在国标麻将中，“单钓将”是一个1番的基础番种，是通过特定的听牌和胡牌方式达成的。尽管番值较低，但因其特殊性和实用性，单钓将在实际对局中经常出现。单钓将是指玩家胡牌时，听牌只听将牌（对子）的一张牌来完成胡牌。胡牌后，这张听到的牌会与另一张相同的牌组成胡牌所需的将牌（对子）。\n单钓将的牌型 以下是单钓将的牌型举例：\n手牌：123万、456万、789万、789筒、99筒 听牌：9筒 胡牌：摸到9筒，将牌变为99筒。 示例2：\n手牌：123条、456条、666筒、888筒、东东 听牌：东风 胡牌：摸到东风，将牌变为东东。 单钓将的番数 单钓将为1番，是国标麻将中最基础的番种之一。单钓将只需等待特定的一张牌胡牌，实用性强。\n单钓将的注意事项 必须听将牌：单钓将的听牌范围只能是用于组成将牌的一张牌，将牌是胡牌牌型中唯一的单独对子（如55万、99筒）。\n胡牌方式：单钓将可以通过自摸或点炮胡牌。\n胡牌结构完整：胡牌需满足4组面子（顺子、刻子或杠）+1对将的基本胡牌结构。\n单钓将与其他番种的关系 单钓将作为国标麻将中的基础番种，在实际胡牌中经常与其他番种叠加，增加总番值。例如：\n平和（2番）：如果单钓将的胡牌同时满足平和的条件（全是顺子，没有刻子，且将牌是序数牌），可以叠加平和。\n门前清（2番）：如果单钓将的胡牌通过门清状态（无碰牌、无杠牌）完成，可叠加门前清。\n单钓将的策略与实战意义 控制关键牌：避免打出对手可能听牌的单张牌（如牌池中未见过的牌或字牌）。\n分析牌池：根据场上已出牌的数量，推测对手可能的听牌范围，调整自己的打牌策略。\n参考链接 单钓将\n自摸 什么是自摸？ 自摸指的是玩家通过摸牌自己完成和牌，而不是通过其他玩家打出的牌来和牌。听牌时摸到自己需要的那张牌，直接胡牌，计为自摸。\n自摸的牌型 以下是自摸的牌型举例：\n一万、二万、三万、四筒、五筒、六筒、七条、七条、八条、八条、九条、九条。 听牌：九条\n通过摸牌自摸胡九条，计1番。\n自摸的番数 自摸通常是1番番种。这意味着如果玩家和牌时是自摸的，那么玩家将获得和牌基本番数外，额外加上一番。\n自摸的注意事项 摸牌完成和牌：自摸的关键在于摸牌。玩家在自己的回合摸牌时，摸到的一张牌如果能让手中的牌型形成和牌，那么这张牌就是自摸牌。\n不依赖其他玩家：与“点炮”不同，自摸完全依赖于玩家自己的摸牌。换句话说，自摸的玩家没有依赖其他玩家打出的牌，而是依靠自己的运气和技巧从牌堆中摸到所需的牌来完成和牌。如果你通过其他玩家打出的牌和牌，那么就不能算自摸。\n自摸额外得分：在一些麻将规则中，自摸通常会带有额外的得分。例如，除了和牌本身的番数外，还会额外加上一番作为奖励。在国标麻将中，自摸通常会加上一番，意味着如果你的和牌是自摸的，那么和牌的得分会增加。\n自摸与其他番种的关系 自摸可以与部分其他番种叠加。例如：\n清一色自摸：24番（清一色）+1番（自摸）。\n碰碰胡自摸：6番（碰碰胡）+1番（自摸）。\n自摸的策略与实战意义 增加摸牌机会：在对局中尽量减少不必要的舍牌，以增加摸牌机会，从而提高自摸概率。\n实战意义：自摸对于达到8番胡牌有重要作用，尤其在低番种组合不足的情况下，自摸是关键补充番种。自摸的胡牌分数来源于三家均分，有利于提高得分且降低风险。\n参考链接 自摸\n花牌 什么是花牌？ 花牌是国标麻将中最基础、最简单的番种之一，不需要特定的牌型结构，只需通过摸牌即可计分。包括四张春、夏、秋、冬季节牌和四张梅、兰、竹、菊花卉牌。玩家在游戏过程中，如果摸到花牌并放置到桌面进行“补花”，即可获得1番的奖励。尽管单张花牌的番值较低，但累计多张花牌后，其得分潜力巨大。\n花牌的牌型 以下是花牌的牌型举例：\n示例1：\n玩家摸到一张春，将其放到桌面并补花。 奖励：+1番。 示例2：\n玩家摸到春、夏、梅三张花牌，依次补花。 奖励：+3番。\n获得花牌的方式 摸到花牌：玩家在摸牌时，如果摸到一张花牌，可以将其放到桌面（称为“补花”），然后从牌墙的尾部补一张牌。\n补花奖励：每摸到一张花牌，即可获得1番的奖励，花牌越多，番数越高。\n花牌的番数 在国标麻将中，“花牌”是一个1番的基础番种。花牌不仅增加了麻将的趣味性，还可以帮助玩家在特定情况下获得额外的加分。\n花牌的注意事项 必须摸到花牌才能计分：花牌计分仅限玩家实际摸到并补花的牌，未摸到的花牌不计入得分。\n补花不等于胡牌：补花只是加分的一种方式，玩家仍需完成胡牌才能真正获胜。\n每张花牌计1番：无论玩家摸到哪一种花牌（春、夏、梅、兰等），每张花牌均可计1番。\n叠加其他番种：花牌的番种可以与其他番种叠加，例如清一色、自摸等，从而提高总得分。\n花牌与其他番种的关系 花牌作为一个独立番种，可以与其他番种叠加，例如：\n清一色（24番）：如果胡牌的牌型为清一色，同时补花，可以额外计入花牌的番数。\n自摸（1番）：如果玩家自摸胡牌，补花的番数可以叠加到自摸番种中。\n碰碰胡（6番）：如果胡牌为碰碰胡，补花番种可以叠加其中。\n花牌的策略与实战意义 成型难度低：花牌不需要组合成特定牌型，只需摸到即可计分。\n随机性强：花牌的出现完全依赖摸牌，无法通过玩家的策略主动获取。\n观察花牌数量：根据桌面上已补出的花牌数量，判断剩余花牌的可能性，调整打牌策略。\n参考链接 花牌\n2 番 箭刻 什么是箭刻？ 箭刻是指玩家在胡牌时，手牌中包含由箭牌组成的刻子或杠。其中箭牌包括：中（红中）发（发财）白（白板）。\n刻子：三张相同的箭牌（如中中中）。\n杠牌：四张相同的箭牌（如发发发发）。杠牌也是刻子的延伸，因此也计作箭刻。\n箭刻的牌型 以下是箭刻的牌型举例：\n中中中，发发发，五万、六万、七万，七条、八条、九条，东风、东风。 箭刻：中中中（红中）：计 2番。发发发（发财）：计 2番。总计：箭刻总计 6 番。\n白白白白（白板杠），四筒、五筒、六筒，一万、二万、三万，东风、东风、东风，九条、九条。 箭刻： 白白白白（白板杠）：杠牌视为箭刻，计 2番。总计：箭刻总计 2番。\n箭刻的注意事项 计番条件：每有一个箭刻计 2番。如果手牌中有多个箭刻，番数可累加。例如，两个箭刻计 4番。\n与胡牌方式无关：无论是自摸、吃胡、抢杠胡，箭刻只要存在于手牌中，都可计番。\n与其他番种兼容：箭刻可与其他番种（如碰碰胡、混一色）叠加计分，提升总番数。\n箭刻与其他番种的关系 可以叠加计番：箭刻可以与碰碰胡叠加。例如： 箭刻2番 + 碰碰胡6番 = 8番。如果胡牌是清一色且包含箭刻，则箭刻2番可叠加到清一色24番上。\n对番数提升的重要性：箭刻番数较高，容易与其他番种结合，快速提升胡牌总番数，尤其是在做碰碰胡、混一色等牌型时。\n与七对无关：七对的牌型中没有刻子，因此无法计箭刻。\n箭刻的策略与实战意义 优先保留箭牌：在牌局前中期，如果手中有两张或三张相同的箭牌，优先保留，尝试通过摸牌或碰牌形成箭刻。箭刻的番数较高，且容易与高番种叠加，是实战中的重要加分手段。\n灵活应对局势： 如果箭牌已形成刻子，摸到第四张可以杠，但要注意杠牌是否会给对手提供机会（如抢杠胡）。\n中后期的重要性：在中后期，箭刻牌的碰出或杠出会暴露部分牌型，但箭刻本身的番数收益较高，通常是值得的。\n提高基本番数：箭刻在做低番种组合时，可以快速达到胡牌所需的8番基本条件。\n参考链接 箭刻\n圈风刻 什么是圈风刻？ 圈风刻是国标麻将中的一个重要番种，计为2番。圈风刻是指玩家在胡牌时，手牌中包含与当前圈风相符的刻子或杠。圈风代表当前局的风位，每一圈风对应一个特定的风牌。\n圈风刻的牌型 以下是圈风刻的牌型举例：\n单圈风刻：\n东东东，五万、六万、七万，三筒、四筒、五筒，七条、八条、九条，白板、白板。 东风圈 圈风为东风，手牌中有东东东。东东东符合圈风刻条件，计2番。\n圈风刻与自风刻叠加：\n东东东，南南南，五万、五万、五万，七筒、七筒、七筒，八条、八条 。 东风圈，玩家为东家。 圈风为东风，手牌中有东东东： 东东东计入圈风刻，2番。同时，东风为玩家的自风，可再计入自风刻，2番，南南南不是圈风或自风刻，不计入圈风刻。总计番数：圈风刻 2番自风刻 2番 = 4番。\n圈风刻的番数 每有一个符合圈风刻条件的刻子或杠，计2番。如果玩家同时拥有多个圈风刻，番数可累加。例如，两个圈风刻计4番。\n圈风刻的注意事项 刻子或杠：必须有三张（刻子）或四张（杠）相同的圈风牌。例如，在东风圈，手牌中有东东东（东风刻子），即可计入圈风刻。\n与圈风对应：圈风刻只能计入当前局的圈风。例如，在东风圈中，南风刻或其他风刻不能计圈风刻。\n与自风刻的关系：圈风刻与自风刻可以重叠计分，如果玩家在东风圈中，同时是东家，并且有东东东，此刻子可同时计入圈风刻和自风刻，总计4番。\n圈风刻与其他番种的关系 叠加番种：圈风刻可以与其他番种（如碰碰胡、混一色）叠加。例如：碰碰胡圈风刻：碰碰胡6番 + 圈风刻2番 = 8番。清一色圈风刻：清一色24番 + 圈风刻2番 = 26番。\n与自风刻重叠：如果圈风与玩家的自风相同（如东风圈中的东家），圈风刻和自风刻可以叠加计番。\n与七对不兼容：七对的牌型没有刻子，因此不能计入圈风刻。\n圈风刻的策略与实战意义 保留圈风牌：在牌局前中期，如果手中有两张或三张圈风牌，优先保留，尝试通过摸牌或碰牌形成圈风刻。\n灵活碰牌：如果圈风牌已达到两张，可以考虑通过碰牌快速形成圈风刻，增加番数。\n圈风牌的攻防策略：对手的碰牌或明刻可以暴露他们的圈风牌需求，谨慎打出圈风牌。\n中后期的快速加番：圈风刻在中后期非常实用，可以快速提升番数，帮助达到胡牌所需的8番基本要求。\n参考链接 圈风刻\n门风刻 什么是门风刻？ 门风刻是国标麻将中的一个番种，计为2番。门风刻是指玩家在胡牌时，手牌中包含与自己当前座风（门风）相符的刻子或杠。门风是玩家根据其所在座次确定的风牌，每局游戏中座风会随着玩家座次变化。\n门风刻的牌型 以下是门风刻的牌型举例：\n单门风刻\n手牌：东东东，七条、七条、七条，五筒、六筒、七筒，一万、二万、三万，白板、白板。\n玩家：东家\n其中：门风为东风，手牌中有东东东。东东东符合门风刻条件，计2番。\n门风刻与圈风刻叠加\n手牌：东东东，五条、五条、五条，一筒、二筒、三筒，七万、八万、九万，中中中。\n局：东风圈，玩家为东家\n其中：圈风为东风，手牌中有东东东，东东东计入圈风刻，2番。同时，东风为玩家的门风，可再计入门风刻，2番。总计番数：圈风刻 2番门风刻 2番 = 4番。\n门风刻的番数 每有一个符合门风刻条件的刻子或杠，计2番。如果玩家同时拥有多个门风刻，番数可累加。例如，两个门风刻计4番。\n门风刻的注意事项 刻子或杠：必须有三张（刻子）或四张（杠）相同的门风牌。例如，东家手牌中有东东东（东风刻子），即为门风刻。\n必须与门风一致：门风刻只能计入玩家所在座次对应的风牌。例如： 东家需要东风刻，南风刻不能计入门风刻。\n与圈风刻的关系：门风刻和圈风刻可以重叠计分。例如： 如果玩家在东风圈中，同时是东家，并且有东东东，此刻子可同时计入门风刻和圈风刻，总计4番。\n门风刻与其他番种的关系 叠加番种：门风刻可以与其他番种叠加。例如： 碰碰胡门风刻：碰碰胡6番 + 门风刻2番 = 8番。清一色门风刻：清一色24番 + 门风刻2番 = 26番。\n与圈风刻重叠：如果门风与圈风一致（如东风圈的东家），门风刻和圈风刻可以叠加计分。\n与七对不兼容：七对的牌型没有刻子，因此不能计入门风刻。\n门风刻的策略与实战意义 保留门风牌：在牌局前中期，如果手中有两张或三张门风牌，优先保留，尝试通过摸牌或碰牌形成门风刻。门风刻的番数较高，容易成为提高总番数的重要手段。\n灵活碰牌：如果门风牌已达到两张，可以考虑通过碰牌快速形成门风刻，增加番数。\n门风牌的攻防策略：对手的碰牌或明刻可能暴露他们的门风牌需求，例如，在东风圈中，如果东家碰了东风，可能需要考虑东风对其得分的影响。如果对手门风刻成型会直接威胁到局势，应尽量避免打出门风牌。\n中后期的快速加番：门风刻在中后期非常实用，可以快速提升番数，帮助达到胡牌所需的8番基本要求。\n参考链接 门风刻\n门前清 什么是门前清？ 门前清是指玩家在胡牌之前，没有碰牌、明杠或吃牌，始终保持手牌为暗牌状态。胡牌时，所有牌都必须由摸牌或暗杠后胡牌，或靠他人打出的牌胡牌（放铳）。一旦玩家吃牌、碰牌或明杠，就不再满足门前清的条件。\n门前清的牌型 以下是门前清的牌型举例：\n门前清+自摸\n手牌：一万、二万、三万，四条、五条、六条，七筒、八筒、九筒，东风、东风、东风，五万、五万。\n操作：胡牌时未进行过吃牌、碰牌或明杠，仅靠自摸胡五万。\n番种分析：符合门前清条件，计 2番，自摸加 1番，记不求人共计：4 番。\n门前清+放铳\n手牌：一筒、二筒、三筒，五万、六万、七万，八条、八条，东风、东风、东风，白板、白板、白板。\n操作：胡牌时未进行过吃牌、碰牌或明杠，由他人打出八条放铳。\n番种分析：符合门前清条件，计 2番。胡牌由他人放铳，不额外加番。总计：2番。\n门前清的番数 门前清是一个计2番番种，通过保持手牌的暗牌状态到胡牌获得，具有很强的隐蔽性和实用性。它适合与自摸、清一色、平和等番种叠加，快速提升胡牌总番数。\n门前清的注意事项 保持暗牌状态：玩家在整个牌局中不能进行吃牌、碰牌或明杠的操作。\n胡牌方式：胡牌可以是自摸（自己摸到胡牌），也可以是放铳（由他人打出胡牌）。抢杠胡也符合门前清的条件。\n计番规则：符合门前清的条件后，计2番。\n暗杠不影响门前清：暗杠是摸到四张相同的牌暗下去摆放，属于“暗牌”操作，不影响门前清的成立。\n门前清与其他番种的关系 叠加番种：门前清可以与其他番种（如清一色、平和、碰碰胡）叠加。例如：清一色门前清：清一色24番 + 门前清2番 = 26番。平和门前清：平和2番 + 门前清2番 = 4番。\n与暗杠的关系：暗杠不会破坏门前清状态，因此暗杠的番数（2番/每杠）可以与门前清叠加计分。\n局限性：一旦玩家碰牌、吃牌或明杠，则不再满足门前清条件，但仍可计其他番种。\n门前清的策略与实战意义 门前清的隐蔽性：门前清状态下，玩家始终保持手牌的隐藏性，对手难以判断其牌型和听牌情况，从而有利于迷惑对手。特别是在听牌时，对手可能误判玩家未听牌而放松防守，增加放铳的可能性。\n放弃碰牌或明杠的取舍 ：如果碰牌或明杠能形成更高的番种（如碰碰胡、三杠），则可以放弃门前清。如果当前番种较低，可以优先保持门清状态，争取门前清的额外番数。\n自摸的策略配合：门前清与自摸具有很强的配合性。自摸不仅能触发自摸加番（1番），还可以通过补杠后的杠上开花叠加更多番数。例如：门前清 + 杠上开花 + 自摸，组合番数非常可观。\n防守意义：如果对手始终保持门前清状态，可能正在追求隐蔽性强的高番种。此时应注意其手牌是否接近完成，避免轻易放铳。\n参考链接 门前清\n平和 什么是平和？ 平和是由4组顺子和1对雀头组成的和牌。刻子或杠不能出现，全部由顺子构成。雀头不能是役牌（风牌和箭牌）。胡的牌不能是坎张、单钓将或边张。胡的牌必须是顺子的中间牌或两端牌。\n平和的牌型 以下是平和的牌型举例：\n平和+自摸\n手牌：二万、三万，四条、五条、六条，七筒、八筒、九筒，三条、四条、五条，六筒、六筒。\n操作：此时胡一万。\n其中：全顺子结构，雀头为六筒，非役牌。胡的一万为顺子两端牌，符合平和条件。平和计2番，自摸加1番，总计3番。\n平和+放铳\n手牌：三万、四万，七条、八条、九条，一筒、二筒、三筒，五条、六条、七条，九筒、九筒。\n操作：此时胡二万。\n其中：全顺子结构，雀头为九筒，非役牌。胡的二万为顺子两端牌，符合平和条件。平和计2番，总计2番（未自摸）。\n平和的番数 平和是国标麻将中的一个常见番种，计为2番。平和以顺子为主构成牌型，强调牌面的平稳和胡牌的灵活性，是一种注重技术的低风险番种。\n平和的注意事项 全顺子结构：胡牌必须由4组顺子和1对雀头构成。例如：一万、二万、三万 + 四条、五条、六条 + 七筒、八筒、九筒 + 二条、三条、四条 + 五筒、五筒。\n非役牌雀头：雀头必须是非役牌（风牌或箭牌），例如五万、五万。如果雀头是役牌（如东风、红中），则不能计为平和。\n灵活胡牌：胡的牌不能形成坎张、单钓将或边张，但可灵活选择顺子两端的任意一张牌。例如，听牌二万、三万、四万中，胡二万或四万均符合平和的条件。\n放铳或自摸均可：平和的胡牌方式可以是自摸，也可以是由他人放铳。\n平和与其他番种的关系 叠加番种：平和可以与其他番种叠加，例如：门前清平和：门前清2番 + 平和2番 = 4番。清一色平和：清一色24番 + 平和2番 = 26番。\n与特殊听牌的关系：如果胡牌是坎张、单钓将或边张，则不能计为平和。例如：听牌一万、三万，胡二万（坎张），不符合平和条件。单钓将牌（如听东风），同样不符合平和。\n局限性：平和牌型的形成条件较为苛刻，尤其是雀头不能是役牌，听牌方式限制较大。\n平和的策略与实战意义 选择灵活的听牌：平和要求听牌方式较为灵活，因此在听牌阶段应尽量避免形成坎张、单钓将或边张的听牌形态。例如： 一条、二条、三条、四条、五条，听牌三条、六条均符合平和条件。\n雀头的选择：雀头不能是役牌（如东风、红中），因此在做牌时应尽量避免将役牌作为对子的选择。可优先选择中间数牌（如五万、六条）作为雀头，便于满足平和条件。\n放弃碰牌的取舍：平和与门前清常有配合性，因此玩家应避免碰牌，以保持手牌的灵活性和隐藏性。\n实战意义：平和是一个非常灵活的番种，注重胡牌方式的选择，适合稳健型玩家。它可以快速叠加其他番种番数，帮助玩家达到胡牌的8番基本条件。\n参考链接 平和\n四归一 什么是四归一？ 四归一是指玩家的手牌中有四张相同的牌，并且这四张牌没有被用于杠牌。这四张牌会被分为一个顺子和一个对子，或者刻子和一张孤张，也有可能是四顺子或两顺子一对子。需要强调的是，四归一的番种只有在没有杠牌的情况下才成立。\n四归一的牌型 七筒、七筒、七筒（顺子），七筒、八筒、九筒（对子与顺子），一万、二万、三万，五条、五条 四归一：七筒形成了一个刻子（七筒、七筒、七筒）和一个顺子（七筒、八筒、九筒），四归一计2番。\n四归一的番数计算 四归一是国标麻将中一个较为灵活且实用的番种，计为 2番。它通过手牌中的四张相同牌形成，强调组合的多样性和隐藏性。\n四归一的注意事项 计番条件：每组符合四归一条件的牌计2番。如果手牌中有多组四归一，番数可累加。例如，两组四归一计4番。\n不能有杠：一旦四张相同的牌被杠（无论是暗杠还是明杠），则不计入四归一。\n与其他番种兼容：四归一可以与其他番种叠加，例如清一色、门前清、断幺九等。\n四归一与其他番种的关系 叠加番种：四归一可以与其他番种叠加。\n与杠牌的关系：如果四张相同的牌被杠出，则不再计入四归一，但可以计杠的番数（明杠1番，暗杠2番）。\n与碰碰胡的关系：四归一与碰碰胡有一定兼容性。例如，四归一的刻子部分可以同时满足碰碰胡的条件，形成叠加番数。\n与七对无关：七对的牌型中没有顺子或刻子，因此无法形成四归一。\n四归一的策略与实战意义 优先保留四张相同的牌：在牌局中期，如果手中已有三张相同的牌且摸到第四张，可以优先保留，尝试通过组合形成四归一。不要轻易杠出第四张牌，以免失去四归一的番数。\n灵活调整牌型：四归一的牌型较为灵活，可以通过改变孤张或对子的位置来实现。例如： 五条、五条、五条（刻子） + 五条（孤张）改为 五条、五条（对子）+ 五条、六条、七条（顺子）。\n与高番种的搭配：四归一在清一色、混一色等高番种中较为常见，形成的概率高，可以与之叠加，快速提升番数。例如：清一色 + 四归一 + 自摸，总计番数可达到 27番。\n杠牌的取舍：在摸到第四张相同的牌时，应根据场上局势判断是否杠牌。如果杠牌后番数收益不如四归一，则可以选择放弃杠牌。\n实战中的迷惑性：四归一隐藏性较强，除非对手通过观察玩家摸牌、出牌规律才能推测，通常在对局中更难被察觉，适合中后期使用。\n参考链接 四归一\n双同刻 什么是双同刻？ 双同刻是国标麻将中的一个番种，计为2番。是指玩家的手牌中同时包含两组点数相同但花色不同的刻子。它是一种以两组刻子为核心的番种，强调刻子的组合特点。\n双同刻的牌型 以下是双同刻的牌型举例：\n二万、二万、二万（刻子） 二条、二条、二条（刻子） 这两组刻子的点数相同（都是二），花色不同（万和条），符合双同刻。\n七筒、七筒、七筒（刻子） 七条、七条、七条（刻子） 两组刻子点数相同（都是七），花色不同（筒和条），符合双同刻。\n双同刻的番数 双同刻是一个计2番的番种，通过两组点数相同但花色不同的刻子形成。它是碰碰胡牌型中的常见番种，适合与高番种（如清一色、混一色）叠加使用。\n双同刻的注意事项 计番条件：双同刻每次出现计2番。如果手牌中有多组双同刻，可以累加番数。例如，两组双同刻计4番。\n刻子特性：刻子是由三张相同的牌组成的牌型，可以通过摸牌形成，也可以通过碰牌形成。\n与其他番种兼容：双同刻可以与碰碰胡、混一色、清一色等番种叠加。\n不受花色限制：双同刻不要求牌型中仅包含两种花色，与清一色或缺一门无直接关联。\n双同刻与其他番种的关系 叠加番种：双同刻可以与其他番种（如碰碰胡、清一色）叠加。例如：碰碰胡双同刻：碰碰胡6番 + 双同刻2番 = 8番。清一色双同刻：清一色24番 + 双同刻2番 = 26番。\n与碰碰胡的关系：双同刻需要两组刻子，而碰碰胡要求4组刻子，因此双同刻几乎总是与碰碰胡共存。\n与混一色的关系：双同刻可以出现在混一色牌型中，但不能出现在清一色中（清一色只有一种花色）。\n双同刻的策略与实战意义 优先保留相同点数的牌：如果手中有两种花色的相同点数牌，可以优先保留，尝试通过摸牌或碰牌形成双同刻。\n结合碰碰胡的打法：双同刻往往是碰碰胡牌型中的重要组成部分。碰碰胡要求四组刻子，双同刻是增加额外番数的重要方式。\n灵活调整牌型：在对局中期，如果发现点数相同但花色不同的牌较多，可以尝试改变做牌方向，围绕双同刻构筑牌型。\n防守中的识别：如果对手多次碰牌且多花色中有相同点数的刻子，可能正在做双同刻。此时需谨慎舍牌，尤其是与对手刻子点数相同的另一花色牌。\n参考链接 双同刻\n双暗刻 什么是双暗刻？ 双暗刻是是国标麻将中的一个番种，计为2番。指在胡牌时，玩家的手牌中包含两组暗刻（每组由三张相同的牌组成，且未被碰或杠）。这两组刻子必须是通过玩家自行摸牌而形成的，并且是完全保留在手牌中的。\n双暗刻的牌型 以下是双暗刻的牌型举例：\n三万、三万、三万（暗刻），五筒、五筒、五筒（暗刻），四条、五条、六条（顺子），九筒、九筒、九筒（刻子），东风、东风（雀头）。 这副牌包含了两个暗刻（三万、三万、三万和五筒、五筒、五筒），因此可以计为双暗刻。\n双暗刻的番数 双暗刻是国标麻将中的一个附加番种，计为2番。它是指玩家手牌中含有两组暗刻，即两组未被碰出或杠出的三张相同的牌。\n双暗刻的注意事项 计番条件：双暗刻需要手牌中有两组暗刻。每组暗刻计为2番，因此双暗刻总计为2番。不能通过碰牌或杠牌形成的刻子才算作暗刻。如果通过碰或杠得到的刻子，则无法计入双暗刻。\n暗刻的特殊性：暗刻和明刻的主要区别在于形成方式：暗刻由玩家自己摸到三张相同的牌组成，而明刻则是通过碰牌或者杠牌形成的。在一些情况下，暗刻的形成难度较高，因为玩家需要摸到三张完全相同的牌。\n与其他番种兼容：双暗刻可以与其他番种叠加，如碰碰胡、清一色、混一色等。如果同时形成碰碰胡和双暗刻，番数可以累加。\n与杠的关系：如果四张相同的牌通过杠形成（无论是暗杠还是明杠），则不再算作暗刻。暗杠和明杠是另外的番种，例如暗杠计2番，明杠计1番。\n双暗刻与其他番种的关系 叠加番种：双暗刻可以与其他番种叠加使用。例如： 碰碰胡双暗刻：碰碰胡6番 + 双暗刻2番 = 8番。清一色双暗刻：清一色24番 + 双暗刻2番 = 26番。\n与碰碰胡的关系：双暗刻要求两组暗刻，而碰碰胡需要4组刻子，因此，双暗刻通常与碰碰胡共存，可以提高番数。\n与混一色的关系：双暗刻可以出现在混一色牌型中（如果手牌中包含两种花色），但不能在清一色中出现（因为清一色只有一种花色）。\n与杠牌的关系：如果四张相同的牌被杠出，则不再计算为暗刻。明杠和暗杠有自己独立的番数计算。\n双暗刻的策略与实战意义 优先保留相同点数的牌：在游戏中期，如果手中有两种花色的相同点数的牌，可以优先保留，尝试通过摸牌或碰牌来形成双暗刻。特别是在已经形成一个暗刻时，摸到另一张相同的牌时，要判断是否继续保留。\n灵活调整牌型：双暗刻可以通过不断摸牌和调整手牌来完成，尤其是在手牌较为灵活时。玩家需要根据场上的局势来决定是否优先保留暗刻的牌。\n杠牌的选择：如果手中有四张相同的牌，考虑是否选择杠。如果希望保留双暗刻的番数，可以避免杠牌。\n防守中的识别：如果对手多次碰牌并且花色中有相同点数的刻子，可能正在做双暗刻。此时可以考虑阻止对方的碰牌，避免其顺利完成双暗刻。\n参考链接 双暗刻\n暗杠 什么是暗杠？ 暗杠是指玩家的手牌中，四张相同的牌没有通过碰牌或其他玩家的动作形成，而是完全通过自己摸牌获得的。形成暗杠后，玩家会将四张相同的牌展示出来，并将其与其他牌分开。\n暗杠的牌型 以下是暗杠的牌型举例：\n三万、三万、三万、三万（暗杠），五条、五条、五条（刻子），一筒、二筒、三筒（顺子），四条、五条、六条（顺子），东风、东风（雀头） 三万、三万、三万、三万形成了暗杠。\n暗杠的番数 暗杠本身计2番。如果一个玩家形成了多个暗杠，计算时每一组暗杠都会加上2番。\n暗杠的注意事项 四张相同的牌：玩家手中需要有四张相同的牌，且这四张牌必须完全由自己摸到，没有经过碰（其他玩家打出的牌）或杠（其他玩家的动作）来获得。\n不能通过碰或杠形成：暗杠的牌必须是完全由自己摸到的，若是其他玩家打出的牌，被碰后形成了刻子，那么就不能算作暗杠。\n暗杠的展示方式：形成暗杠后，玩家会将这四张相同的牌面朝上显示在自己面前，并标明这是一组暗杠。\n暗杠与其他番种的关系 暗杠可以与其他番种叠加，尤其是与碰碰胡等番种一起使用时，能显著增加番数。\n例如：碰碰胡暗杠：碰碰胡6番 + 暗杠2番 = 8番。例如：清一色暗杠：清一色24番 + 暗杠2番 = 26番。\n暗杠的策略与实战意义 暗杠与自摸的关系：暗杠的形成往往需要自摸，即自己摸到四张相同的牌。若手中已经有三张相同的牌，在摸到第四张时，考虑是否要杠出来，增加番数。自摸暗杠：当玩家摸到第四张牌完成暗杠时，玩家可以通过自摸胡牌获得额外的番数。\n提高番数的关键：暗杠是一种可以单独提高番数的方式。在一些情况下，玩家可能故意不碰牌，而是通过摸到四张相同的牌来形成暗杠，从而增加番数。\n在防守中的作用：如果对手已经碰了三张相同的牌并且未形成杠牌，玩家需要避免打出剩下的同花色或相同点数的牌，以防止对手通过碰牌形成暗杠。注意对手是否有可能形成暗杠，尤其是在他们已经完成了部分刻子的情况下。\n杠牌与战术的结合：杠牌不仅仅是为了增加番数，也是一个战略性的选择。例如，玩家可以通过暗杠来限制其他玩家的杠牌机会，增加自己的获胜机会。\n参考链接 暗杠\n断幺 什么是断么？ 断幺（断幺九）是国标麻将中的一个番种，通常计为2番。它指的是玩家在胡牌时，手牌中没有包含任何“幺牌”或“九牌”，即没有“1”和“9”这两种牌，所有的牌都必须是“2-8”之间的牌，或者是刻子和杠子。\n断么的牌型 以下是断么的牌型举例：\n二万、三万、四万（顺子），五筒、六筒、七筒（顺子），四条、五条、六条（顺子），五条、五条（雀头） 这副牌中没有任何“1”或“9”，所有的牌都是“2-8”之间的牌，符合断幺的条件。\n三万、三万、三万（刻子），四筒、五筒、六筒（顺子），二条、三条、四条（顺子），五筒、五筒（雀头） 这副牌也没有“1”或“9”，因此符合断幺的要求。\n断么的番数 断幺计为2番，它是一个比较基础的番种，在许多情况下比较容易形成。由于断幺的番数较低，因此在有更高番种的情况下（如清一色、碰碰胡等），玩家可能会优先考虑其他更高的番种。在大多数情况下，断幺是一个较低番数的番种，但它可以与其他高番种叠加，显著提升胡牌的番数。\n断么的注意事项 与其他番种的兼容性：断幺是一个相对简单的番种，通常可以与其他更高的番种叠加使用。例如：清一色断幺：清一色24番 + 断幺1番 = 25番。碰碰胡断幺：碰碰胡6番 + 断幺1番 = 7番。由于其简单性和低番数，通常不会成为一个独立的高番种，但与其他番种叠加时，可以带来显著的番数提升。\n对牌型的要求：断幺要求玩家完全排除“1”和“9”这两种牌，因此手牌需要以“2-8”之间的牌为主。这意味着玩家在手牌构成时必须避免幺牌或九牌，并且要以顺子和刻子为主要构建元素。\n断么与其他番种的关系 单独的断幺：断幺单独计为1番。如果玩家的手牌没有包含“1”和“9”，即使其余牌型不完全符合其他高番种，玩家也能获得1番。\n叠加其他番种：断幺可以与其他更高的番种叠加。例如：清一色断幺：清一色24番 + 断幺1番 = 25番。碰碰胡断幺：碰碰胡6番 + 断幺1番 = 7番。尽管断幺的番数较低，但当与高番种叠加时，仍能显著增加总番数。\n与自摸的关系：如果玩家通过自摸完成胡牌，除了计算断幺的番数外，还可以考虑是否有其他额外的番种，如自摸、平和、混一色等。\n与纯全带幺的区别：断幺与纯全带幺是相对的番种。纯全带幺要求每个顺子或刻子都包含“1”或“9”牌，而断幺则要求完全排除这两种牌。纯全带幺的难度要大于断幺，并且番数也相对较高。 断么的策略与实战意义\n断幺的策略作用 断幺的策略作用：断幺可以帮助玩家快速调整手牌，尤其是在对牌形没有太多要求的情况下。如果手牌中没有幺九牌，玩家可以通过调整顺子和刻子来完成更简单的胡牌。断幺有时也可以用作防守策略，避免给对手提供摸幺九的机会。\n保持顺子和刻子的形成：由于断幺要求排除“1”和“9”，玩家通常需要多利用“2-8”的中张牌来形成顺子或刻子。这对玩家的摸牌和调整手牌能力提出了一定要求。\n防守中的运用：在防守过程中，若对手已胡牌或者摸牌完成断幺牌型，其他玩家可以适当调整自己的出牌策略，避免给对手提供完成断幺的机会。\n与其他番种的协调：由于断幺与其他番种（如清一色、碰碰胡）可以叠加，因此玩家需要根据自己的手牌结构来决定是否优先形成断幺。在手牌相对不稳定或难以组成其他高番种时，断幺是一个比较好的选择。\n参考链接 断幺\n4 番 全带幺 什么是全带幺？ 全带幺是国标麻将中极具特色的番种，其对牌型的要求既严格又灵活，适合经验丰富的玩家选择。作为4番的中等番种，全带幺在实际对局中经常与其他高番种组合，形成高分胡牌。\n全带幺是指胡牌时，玩家的所有牌型（包括顺子、刻子、将牌）都必须带有幺九牌：\n序数牌：1万、1筒、1条、9万、9筒、9条 字牌：中、西、南、北、白、发、中\n全带幺的牌型 以下是全带幺的牌型举例：\n123万、123万、789万、789万、99万 面子为两个123万（顺子）和两个789万（顺子），每组都包含幺九。将牌为99万，符合幺九要求。\n123万、123筒、789条、111筒、99条 面子包含顺子123万、123筒、789条和刻子111筒，每组都带幺九。将牌为99条，符合幺九要求。\n111万、999万、111筒、999条、11条 所有面子均为刻子（111万、999万、111筒、999条），均带幺九。将牌为11条，符合幺九要求。\n全带幺的番数 在国标麻将中，“全带幺”是一个4番的番种，因其对牌型的特定要求而被视为一种中等难度的牌型番种。\n全带幺的注意事项 所有面子必须带幺九：面子（顺子或刻子）的组成中，必须至少包含1张幺九牌。顺子必须是123或789，因为只有这两种顺子包含幺九。刻子（或杠）必须是1或9。\n将牌必须是幺九： 将牌必须是1或9，不能是其他数字或字牌。\n牌型完整：必须满足胡牌的基本结构要求，4组面子（顺子、刻子或杠）+1对将。\n全带幺不等于混幺九：全带幺允许混合花色，但所有牌型必须带幺九；混幺九要求牌型必须由幺九牌和字牌组成。\n全带幺与其他番种的关系 缺一门（1番）：如果和牌牌型只两种花色则可以叠加缺一门。\n老少副（1番）：如果有一种花色的123，789两副顺子则可以加记老少妇。\n幺九刻（1番）：如果有三张相同的一，九序数牌及字牌组成的刻字，可以叠加幺九刻\n全带幺的策略与实战意义 观察对手意图：如果对手频繁摸打幺九牌，或副露123、789顺子和1、9刻子，可能在追求全带幺。\n避免打出幺九牌：尤其是在牌局后期，如果对手可能听牌，尽量避免打出幺九牌。\n分析牌池：根据场上已打出的幺九牌，推测对手可能的听牌范围，调整打牌策略。\n参考链接 全带幺\n不求人 什么是不求人？ 不求人是指玩家在门前清状态下，通过自摸完成胡牌。该番种的关键在于：\n没有副露：玩家在整个对局中未进行过碰牌、吃牌或明杠。 通过自摸胡牌：最后一张胡牌必须是玩家通过自摸摸到的牌，而非对手打出的牌。 不求人番种的特点是胡牌过程完全依赖自身摸牌，不需要任何副露或其他玩家的帮助，体现了较高的独立性和技巧性。\n不求人的牌型 以下是不求人的牌型举例：\n普通顺子牌型：\n手牌：123万、456万、789筒、567条、88条 听牌：8条 玩家摸到8条完成自摸，形成胡牌牌型。 全程未副露，满足不求人条件。 碰碰胡牌型：\n手牌：222万、333万、555筒、888筒、东东 听牌：东风 玩家摸到东风完成自摸，形成碰碰胡牌型。 全程未副露，满足不求人条件。 不求人的番数 在国标麻将中，“不求人”是一个4番的番种，强调玩家通过门前清状态下自摸胡牌。\n不求人的注意事项 必须保持门前清：如果玩家在听牌前进行了碰牌、明杠等副露操作，即使后续自摸胡牌，也不能计为不求人。\n自摸是必需条件：如果胡牌通过点炮完成，则不符合不求人的条件。\n不求人与其他番种的关系 不求人经常与其他番种叠加，形成更高的总番值。例如：\n小三元（64番）：如果胡牌牌型为小三元，可叠加小三元番种。\n清一色（24番）：如果胡牌牌型为单一花色，可叠加清一色番种。\n七对（24番）：如果胡牌牌型为七对子，可叠加七对番种。\n不求人的策略与实战意义 保持门前清状态：在听牌前，尽量避免吃碰牌或明杠，以确保不求人条件的达成。\n优先选择多张听牌形式：为了增加自摸的概率，尽量选择两面听、多张听等较宽的听牌范围。\n与高番种搭配：不求人番值较低，建议与小三元、清一色、七对等高番种搭配，提升整体得分。 隐蔽意图：不求人牌型的特征是全程无副露，因此听牌阶段尽量隐藏胡牌方向，增加对手判断难度。\n参考链接 不求人\n双明杠 什么是双明杠？ 双明杠是国标麻将中的一个番种，属于杠牌相关的番种。通常计为4番，指玩家的手牌中有两个以上的明杠。每个明杠由三张相同的牌组成，玩家需要通过再次摸牌获得第四张牌来完成杠。\n双明杠的牌型 以下是双明杠的牌型举例：\n手牌：三万、三万、三万（碰），六筒、六筒、六筒（碰），四条、四条、四条（碰），七条、七条、七条（碰）\n其中：玩家通过摸到第四张三万、六筒和四条，分别完成了明杠，成功构成了双明杠。\n双明杠的番数 双明杠通常计为4番。双明杠是杠牌中较为常见的一种番种，通常在玩家已经有两个已碰的刻子基础上，继续摸到相同的牌形成杠。这比单一的明杠要高，能为胡牌增加额外的番数。\n双明杠的注意事项 计番条件：双明杠通常计为4番。双明杠是杠牌中较为常见的一种番种，通常在玩家已经有两个已碰的刻子基础上，继续摸到相同的牌形成杠。\n与自摸的关系：如果玩家通过自摸胡牌并且手牌中有双明杠，那么在完成双明杠的基础上，还可以获得自摸番数。因此，玩家可以在胡牌时得到更高的番数，尤其是在加上其他番种时。\n与杠牌的配合：在国标麻将中，玩家有多种方式可以获得杠牌。明杠是玩家通过自己已经碰过的牌进一步获得第四张牌来完成的。因此，玩家在早期通过碰牌积累好刻子，之后再抓到第四张牌来完成杠，能有效提高胡牌的番数。如果玩家在牌局中已经碰了多个牌组，那么通过适时的摸牌获得第四张牌，形成明杠，可以构成双明杠。\n双明杠与其他番种的关系 与自摸的关系：如果玩家通过自摸胡牌并且手牌中有双明杠，那么在完成双明杠的基础上，还可以获得自摸番数。因此，玩家可以在胡牌时得到更高的番数，尤其是在加上其他番种时。\n叠加其他番种：双明杠可以与其他番种叠加使用。例如：双明杠清一色：如果玩家形成了清一色，并且在此基础上有双明杠，那么番数可以显著增加。清一色24番 + 双明杠2番 = 26番。双明杠碰碰胡：如果玩家的手牌已经符合碰碰胡（所有刻子或杠牌），并且有双明杠，那么总番数为：碰碰胡6番 + 双明杠4番 = 10番。\n双明杠的策略与实战意义 双明杠的策略作用：双明杠是一个通过碰牌积累刻子，并在后期摸到相同的牌完成杠的番种。因此，玩家在早期阶段需要优先考虑碰牌，积累刻子，为之后形成双明杠做好准备。\n与其他番种的协同：双明杠与其他高番种相结合时，可以有效提高胡牌的番数。例如，玩家可以通过碰碰胡、清一色等番种，配合双明杠，形成更高的得分。在追求高番种时，双明杠作为一个中等难度的番种，可以成为额外的加分项。\n双明杠的形成技巧：双明杠的形成需要玩家有较强的手牌控制能力。例如，在自己的刻子中有多个重复的牌时，尽量保留这些牌，以便在后期摸到相同的牌完成杠。玩家可以在合适的时机通过摸牌获得需要的第四张牌，形成双明杠，提升胡牌的番数。\n参考链接 双明杠\n和绝张 什么是和绝张？ 绝张是国标麻将中的一个特殊番种，通常计为4番。在麻将中，绝张指的是一张牌在整个牌局中被完全“绝”掉，即没有其他玩家的手中和牌堆中再有该牌存在。绝张是指某一种牌的最后一张已经无法再被摸到，它在整个局面中处于“绝”对无法再使用的状态。当玩家胡牌时，如果这张牌是绝张，那么这就算作绝张胡。\n和绝张的牌型 以下是和绝张的牌型举例：\n玩家的手牌：一筒、一筒、一筒（碰），五筒、六筒、七筒（顺子），二条、三条、四条（顺子），三万、三万（雀头）。\n如果：玩家等待的牌是三万。如果此时在牌桌上已经有三枚三万，那么此时的三万就是“绝张”。如果玩家最终摸到这张三万，并胡牌，那么玩家的胡牌就构成了绝张胡。\n和绝张的番数 和绝张通常计为4番。这个番种代表着玩家胡牌时，所需的那张牌已经不再存在于其他玩家的手牌中，或牌堆中已经没有更多相同的牌。绝张胡反映了牌局的紧张性和难度，通常玩家在胡绝张时会感到比较有成就感。\n和绝张的注意事项 绝张的产生条件：绝张通常是在牌局的末期才会出现，这时某一张牌的数量已经完全被消耗掉，或者说剩下的牌中没有了该种牌。在这种情况下，玩家如果最终能够摸到那张“绝张”来胡牌，那么就会构成绝张胡。\n与其他番种的区别：绝张与其他番种如清一色、七对等不同，它并不要求手牌的特定结构，而是着重于胡牌时所需要的最后一张牌的状态。\n与自摸的关系：在自摸情况下，如果玩家胡的牌是绝张，那么该局胡牌就算作绝张胡。例如，如果玩家在自摸时摸到了最后一张牌，也可以称作绝张胡。\n和绝张与其他番种的关系 与自摸的关系：在自摸情况下，如果玩家胡的牌是绝张，那么该局胡牌就算作绝张胡。例如，如果玩家在自摸时摸到了所有已经绝对无法再被其他玩家摸到的牌，也可以称作绝张胡。\n和绝张的策略与实战意义 绝张的出现：绝张的出现是由其他玩家的出牌、碰牌或杠牌行为决定的。因此，玩家要注意观察其他玩家的动作，尤其是哪些牌已经被打掉或杠掉，这些牌很可能会成为绝张。\n防守中的考虑：在防守时，玩家应避免打出那些可能成为绝张的牌，尤其是在牌局接近尾声时。如果某种牌已经没有了，且其他玩家正在等待该牌，则应避免打出该牌，以防自己成为某个玩家的绝张胡的目标。\n与其他番种的配合：绝张可以与其他番种结合使用，尤其是在清一色、七对等高番种的基础上，如果同时存在绝张胡，玩家的番数会显著增加。\n参考链接 和绝张\n5 番 明暗杠 什么是明暗杠？ 明暗杠是国标麻将中的一个杠牌番种，指的是玩家通过杠牌来增加番数，具体来说，它由明杠和暗杠组成，通常可以计为5番。杠牌是指玩家通过手中已有的三张相同牌再获取第四张相同的牌，完成四张相同牌的组合，形成一个“杠”。根据杠牌的方式不同，杠牌可以分为明杠和暗杠，每种杠牌都会对番数有所影响。\n明暗杠的牌型 以下是明暗杠的牌型举例：\n明杠的例子：\n一筒、一筒、一筒（碰），四条、五条、六条（顺子），七条、八条、九条（顺子），三万、三万（雀头）。 玩家已经碰了一筒，并在之后摸到了第四张一筒，完成了明杠。\n暗杠的例子：\n二万、二万、二万、二万（暗杠），五条、六条、七条（顺子），八筒、九筒（顺子），三万、三万（雀头）。 玩家原本手中就有四张相同的二万，没有其他玩家出过二万，因此玩家将其杠牌，形成暗杠。\n明暗杠的例子：\n三万、三万、三万（碰），五条、五条、五条（碰），七筒、七筒、七筒（碰），四条、四条、四条（暗杠）。 玩家已经碰了三个牌组三万、五条、七筒，并且手中有一个四条的暗杠。最终，玩家完成了明暗杠。\n明暗杠的番数 明杠的番数：在国标麻将中，明杠通常计为1番。\n暗杠的番数：暗杠通常计为2番，因为它完全由玩家手中自给自足形成，不依赖其他玩家的出牌，相对来说形成难度更大，因此给予了更高的番数。\n明暗杠的叠加番数：明暗杠作为一个组合番种，通常计为5番。明杠和暗杠叠加在一起，能够为玩家带来更高的番数。\n明暗杠的策略与实战意义 明暗杠的战略意义：明杠和暗杠都是通过杠牌来增加番数的手段。由于暗杠比明杠需要更多的策略性和控制性，玩家在选择是否杠时，通常需要更慎重地考虑。暗杠更能为玩家带来更高的番数，然而它的隐蔽性较强，其他玩家很难及时察觉。\n明暗杠的时机选择：明杠和暗杠的时机选择至关重要。如果玩家的手牌已经形成了多个刻子（即三个相同的牌），玩家应根据情况决定是否继续碰牌并尝试杠牌。杠牌不仅能够为自己提供更多的番数，还能打乱其他玩家的节奏。\n参考链接 明暗杠\n6 番 碰碰和 什么是碰碰和？ 碰碰和（或称“碰碰胡”）是国标麻将中的一种番种，碰碰和是指玩家在胡牌时，所有牌型都由刻子（3张相同的牌）或杠牌（4张相同的牌）组成，而没有顺子。具体来说，碰碰和的胡牌结构通常包括雀头（2张相同的牌）和若干个刻子或杠牌。\n碰碰和的牌型 以下是碰碰和的牌型举例：\n自摸碰碰和的例子：\n三万、三万（雀头），一筒、一筒、一筒（刻子），五条、五条、五条（刻子），七条、七条、七条（刻子）。 玩家通过摸牌自摸了五条，完成了碰碰和。这时，玩家的牌型完全由刻子和雀头组成，符合碰碰和的要求。\n点炮碰碰和的例子：\n三万、三万（雀头），一筒、一筒、一筒（刻子），五条、五条、五条（刻子），七条、七条、七条（刻子）。 玩家通过点炮（其他玩家打出了七条）胡牌，完成了碰碰和。这时，玩家的牌型依然符合碰碰和的要求。\n碰碰和的番数 碰碰和的番数为6番，属于比较高且较容易达成的番种之一。这个番数反映了玩家的胡牌结构，表示玩家通过碰牌、杠牌的方式形成了一个稳定且不涉及顺子的胡牌组合。\n碰碰和的注意事项 碰牌与杠牌的重要性：碰碰和的核心在于玩家必须通过碰牌或杠牌来形成胡牌。玩家通常会专注于通过碰牌尽快完成手牌的结构，因此与其他玩家的打牌行为密切相关。杠牌可以作为一个强有力的加分方式，如果玩家手中已经有了刻子并且继续摸到相同的牌，形成明杠或暗杠，不仅能增加番数，还能加速完成碰碰和。\n缺乏顺子的局限性：由于碰碰和没有顺子，因此玩家的牌型结构相对简单，所有的牌必须是刻子或杠牌。这种结构在某些情况下可能导致玩家的灵活性降低，尤其是在缺乏某些特定牌时，可能会导致进展缓慢。需要玩家在摸牌时尽量找寻重复的牌，尤其是自己已经碰过的牌，可以考虑继续碰牌或杠牌，来加速形成碰碰和。\n碰碰和与其他番种的关系 与清一色的关系：清一色是指玩家的所有牌都是同一花色的，如果玩家在碰牌过程中能保证所有的牌都是同一花色，那么碰碰和就可能与清一色结合，形成更高的番数。\n与七对的关系：七对是指玩家的手牌由七个对子组成，而碰碰和要求所有的牌都是刻子或杠牌，不能有对子。因此，七对与碰碰和互相排斥，玩家不能同时完成这两个番种。\n与其他杠牌的关系：明杠和暗杠都可以在碰碰和的结构中起到重要作用。玩家通过杠牌的方式增加番数，在形成碰碰和的同时，可以通过杠牌进一步增加自己的牌型复杂度。\n碰碰和的策略与实战意义 调整策略，尽早碰牌：在实战中，碰碰和要求玩家尽早通过碰牌或杠牌来完成牌型，尤其是手中已有一对时，碰牌是一种常见的操作。玩家应该密切关注其他玩家的出牌情况，寻找合适的机会进行碰牌。\n避免碰到多余的顺子：在碰碰和的过程中，玩家应避免过多地接触顺子。顺子并不能在碰碰和中帮助玩家胡牌，因此如果手中有一些零散的顺子牌，应尽早通过碰牌或杠牌来转换成刻子。\n利用杠牌增加番数：杠牌是提高碰碰和番数的关键。通过不断的碰牌和杠牌，玩家可以逐渐累积番数，尤其是暗杠，它不仅帮助完成牌型，还可以获得较高的番数。\n防守时注意避免给对手碰牌：在防守时，玩家应注意避免给对手提供形成刻子的机会，尤其是在自己知道对手有可能完成碰碰和时，应尽量避免打出他们可能需要的牌。\n参考链接 碰碰和\n混一色 什么是混一色？ 混一色是国标麻将中的一个番种，它是指玩家在胡牌时，所有的牌都来自于两种花色，其中一个花色必须是筒子、条子或万子（即“字牌”除外），另一个花色可以是字牌（风牌和箭牌）。换句话说，混一色要求玩家的手牌中有一种花色完全组成，并且另一种花色只能由字牌构成，通常包括风牌（东、南、西、北）和箭牌（中、发、白）。\n混一色的牌型 以下是混一色的牌型举例：\n手牌： 1条、1条（雀头），2条、3条、4条（顺子），5条、6条、7条（顺子），东东东（刻子），发发发（刻子）。\n其中：这是一个典型的混一色胡牌组合：条子完全构成，且所有的字牌由风牌（东）和箭牌（发）组成。\n混一色的番数 混一色的番数通常为6番，在国标麻将中属于一个较为高的番种。由于混一色需要玩家在胡牌时严格控制手牌的花色，并且通过碰牌、杠牌等手段来完成胡牌，因此它在番数上给出了相对较高的奖励。\n混一色的注意事项 限制性强，构成难度较大：混一色的构成条件比纯一色（全是同一花色的牌）要复杂一些，因为它要求两种花色的搭配，而且不能有第三种花色，因此玩家需要更精确地调整手牌，避免手牌中有过多的花色变化。\n刻子与顺子的结合：由于混一色要求手牌中包含两种花色，所以混一色的玩家需要更多依赖刻子与顺子的组合来完成牌型。\n混一色与其他番种的关系 与清一色的关系：清一色要求玩家的手牌全部来自同一种花色，且完全没有字牌，而混一色允许字牌与非字牌的组合。因此，清一色和混一色是互相排斥的，玩家不能同时形成这两个番种。\n与碰碰和的关系：碰碰和要求玩家的所有牌都由刻子和杠牌构成，而不包含顺子。若玩家在混一色的基础上还能完成碰碰和，这样就可以同时获得混一色和碰碰和的番数。\n混一色的策略与实战意义 控制手牌的花色：玩家应该尽早决定自己要胡牌的花色。混一色要求非字牌和字牌的搭配，因此合理地选择花色并坚持下去是成功构成混一色的关键。若手中已有多个同花色的牌，可以考虑保持该花色的完整性，同时通过字牌来补充其他部分，避免混入其他花色。\n防守与配牌：在防守时，玩家需要特别注意对手的混一色构成。如果发现对手有较强的混一色牌型，玩家应该尽量避免打出那些可能有助于对方胡牌的牌，尤其是字牌。在实战中，有经验的玩家可以利用其他玩家的出牌情况，来做出更精确的策略调整，避免自己的手牌被对手利用。\n参考链接 混一色\n三色三步高 什么是三色三步高？ 三色三步高是国标麻将中的一个高级番种，指的是玩家在胡牌时，手牌中必须包含三种不同的花色（万子、条子、筒子），且每种花色的组成都必须是由连续的顺子（而非单独的刻子或杠牌）构成，并且这三种顺子之间的每一种顺子必须是连贯的三张牌，即分别构成三步高。\n三色三步高的牌型 以下是三色三步高的牌型举例：\n手牌： 2万、3万、4万（顺子），3筒、4筒、5筒 （顺子），4条、5条、6条（顺子）,6条、7条、8条（顺子），5条、5条（雀头）。\n其中：这个手牌中包含了三种花色，且每种花色中都有一个有效的顺子，分别是条子、万子和筒子，符合“三色三步高”的要求。\n三色三步高的番数 三色三步高的番数为6番，在国标麻将中，这个番种算是一个相对较高的番数。它的难度比一般的顺子胡牌要大，因为玩家不仅需要构建三个不同花色的顺子，而且每个花色都需要有三步连续的牌序。\n三色三步高的注意事项 花色要求：三色意味着手牌中必须包含三种不同的花色，这三种花色可以是万子、条子、筒子中的任何三种组合。例如：万子（1-2-3万）、条子（4-5-6条）、筒子（7-8-9筒）。\n顺子的要求：每一种花色必须包含一个顺子，而顺子是由三张连续的牌组成，必须是同一花色中连续的三张牌（例如：1-2-3万、4-5-6条、7-8-9筒）。每个花色中的顺子不能重复，同一花色的牌必须有三个不同的顺子，才能算作有效。\n没有刻子和杠牌：在“三色三步高”中，所有的牌型必须是顺子。也就是说，不能有刻子（如三张相同的牌）和杠牌。所有的三张牌必须是连续的顺子。\n三色三步高的策略与实战意义 花色的组合：三色三步高要求玩家在胡牌时必须有三种花色，且每种花色中都必须有顺子，这就要求玩家在打牌时要保持较高的灵活性。\n顺子的重要性：在这个番种中，顺子是胡牌的核心，每种花色中的顺子必须是连续的牌，且每个顺子必须包含三张连续的牌。顺子不仅是组成三色三步高的基础，也是实现该番种的难点之一。如果玩家手中有很多散牌，那么就需要通过摸牌和碰牌来调整手牌，尽量组成顺子。\n雀头的选择：雀头是胡牌时必须要有的一对相同的牌。三色三步高的雀头通常可以是任何花色的对子，或者是花色相同的对子。\n参考链接 三色三步高\n五门齐 什么是五门齐？ 五门齐是国标麻将中的一个较高番种，要求玩家胡牌时手中必须包含五种不同的花色，且每一种花色都需要构成有效的顺子、刻子或杠牌。\n五门齐的牌型 以下是五门齐的牌型举例：\n手牌： 1条、2条、3条（顺子），4筒、5筒、6筒（顺子），东东东（刻子），白白（雀头），5万、5万、5万（刻子）。\n其中：手牌中包含了万子、条子、筒子、风牌（东）和箭牌（白），每一种花色都构成了有效的牌型，符合五门齐的要求。\n五门齐的番数 五门齐通常是一个较高番数的番种，在国标麻将中它的番数是6番。这一番种的番数较高，主要是因为它要求玩家在胡牌时手中的牌非常复杂，涉及的花色非常多，需要精细的牌技和策略。\n五门齐的注意事项 花色的分配：在胡牌时，玩家必须合理分配手中的牌，确保每一种花色都有至少一个有效的牌型。花色的分配非常关键，因为如果某种花色的牌型不够完整，五门齐就无法实现。\n顺子与刻子的搭配：在五门齐的构建过程中，顺子通常用于万子、条子和筒子，而风牌和箭牌则通常用于刻子或杠牌。如果玩家手中的风牌和箭牌较为丰富，可以通过碰牌或杠牌来完成这些花色的牌型。顺子则需要玩家根据手中的牌灵活调整，确保每一种花色都有顺子构成。\n雀头的选择：五门齐的雀头可以选择任何花色的对子，通常情况下，风牌和箭牌的对子更为常见，因为这些牌通常在游戏中更容易获得。在构建五门齐时，雀头的选择应尽量避免与其他花色的牌型冲突，同时要确保雀头对胡牌的帮助最大化。\n五门齐的策略与实战意义 合理安排手牌：由于五门齐要求手中包含五种花色，玩家需要提前规划好手中的花色分布，尽量避免某一花色过于“孤立”。例如，若玩家的手牌中已经有了多个万子顺子，那么可以着重补充条子、筒子的顺子，并通过风牌或箭牌的刻子或杠牌来完成其他花色的构成。\n注意花色的控制：在牌局进行中，玩家应特别注意各花色的控制，尽量避免手牌中有不必要的散牌或孤立牌，这会导致构建五门齐时出现困难。如果手中有多个相同花色的牌，玩家可以考虑利用碰牌、杠牌等方式，帮助完成顺子或刻子的构建。\n观察对手的出牌：由于五门齐需要多个花色的牌，玩家在防守时应特别注意对手的花色和牌型。观察对手的出牌情况，可以帮助玩家做出更精确的防守决策，避免自己被对手胡牌。特别是当对手在抓取某种花色的牌时，玩家可以合理判断自己手中该花色的顺子或刻子是否可能受阻，并做出相应的调整。\n参考链接 五门齐\n全求人 什么是全求人？ 全求人是国标麻将中一个策略性较强的番种，其独特的全副露特性和点炮胡牌要求，使其在实际对局中充满挑战。全求人是指玩家胡牌时：\n所有的面子均已副露（通过碰牌、吃牌或明杠形成）。 只剩最后一张将牌未成对，需要通过点炮胡牌。 胡牌方式必须是点炮，不能自摸完成。 作为一个6番的中等番种，全求人胡牌过程相对简单，但对玩家观察对手出牌和灵活调整策略的能力有一定要求。\n全求人的牌型 以下是全求人的牌型举例：\n示例1：\n副露的面子：123万、456万、789筒（顺子），111筒（刻子）。 手牌：东。 胡牌方式：等待他人打出东风，形成将牌东东，完成胡牌。 示例2：\n副露的面子：123条、789条、555筒（顺子和刻子），333万（刻子）。 手牌：9万。 胡牌方式：等待他人打出9万，形成将牌99万，完成胡牌。 全求人的番数 在国标麻将中，全求人是一个6番的番种，它与不求人相对，强调玩家通过副露并仅凭其他玩家的出牌完成胡牌。全求人的特殊之处在于玩家的所有面子均由副露形成，并以点炮的方式完成胡牌。\n全求人的注意事项 所有面子已副露：玩家胡牌时的所有面子（顺子、刻子或杠牌）必须通过副露完成，即已碰牌、吃牌或明杠。\n仅剩单张将牌：剩余的一张牌必须是将牌的一部分，等待他人打出另一张牌形成对子，完成胡牌。\n胡牌方式为点炮：胡牌的最后一张牌必须由其他玩家打出（点炮），不能通过自摸完成。\n全求人不等于碰碰胡：全求人可以包含顺子，而碰碰胡只能由刻子组成。\n全求人与其他番种的关系 碰碰胡（6番）：如果全求人的所有面子均为刻子，可以叠加碰碰胡番种。\n混一色（6番）：如果全求人的牌型由一种花色和字牌组成，可叠加混一色番种。\n明杠（2番）：如果全求人过程中有明杠牌，可计入明杠番种。\n全求人的策略与实战意义 快速副露：在牌局初期，尽量通过碰牌、吃牌和明杠快速形成面子，留下一张手牌作为将牌。\n观察对手出牌规律：根据对手的打牌习惯，判断最后一张将牌的点炮可能性，选择更容易被打出的牌作为将牌。\n灵活调整目标：如果发现全求人牌型难以达成，可以转向碰碰胡或其他更灵活的番种。\n减少点炮概率：在对手接近听牌时，尽量选择安全牌出牌，避免成为点炮目标。\n参考链接 全求人\n双暗杠 什么是双暗杠？ 双暗杠是国标麻将中的一个番种，要求玩家在胡牌时，手牌中必须有两个暗杠。暗杠指的是玩家在没有被其他玩家碰过的情况下，通过自己抓到的四张相同的牌组成的杠牌。与明杠不同，暗杠是完全由玩家自己构成的，没有外界干扰，因此它在番数上通常比明杠高。\n双暗杠的牌型 以下是双暗杠的牌型举例：\n手牌： 3万、3万、3万（暗杠），5条、5条、5条（暗杠），7筒、8筒、9筒（顺子），东东（雀头）。\n其中：玩家有两个暗杠（3万和5条的四张相同牌），并且手牌中还有其他符合胡牌条件的牌型。这个手牌符合双暗杠的要求。\n手牌： 6万、6万、6万（暗杠），9条、9条、9条（暗杠），1筒、2筒、3筒（顺子），发发（雀头）。\n其中：玩家有两个暗杠（6万和9条的四张相同牌），符合双暗杠的要求。\n双暗杠的番数 双暗杠在国标麻将中的番数为6番。这个主要是因为它要求玩家手中有两组完全自主形成的暗杠，虽然难度不小，但相比于其他一些高番种（如清一色、字一色等），它的番数较为适中。\n双暗杠的注意事项 暗杠的构成：暗杠要求玩家手中有四张相同的牌，这四张牌必须是玩家自己抓到的，而不是通过碰牌得来的。暗杠比明杠更难构建，因为玩家需要通过自己抓牌才能完成，且通常暗杠在手牌中容易受到其他玩家的干扰。\n提高暗杠的可能性：玩家可以通过在游戏中积累相同的牌来增加暗杠的机会。例如，如果手中有很多相同的牌，玩家就可以通过杠牌来实现暗杠。\n双暗杠的策略与实战意义 合理控制牌堆：由于暗杠要求玩家通过抓牌来完成，因此控制牌堆并确保不被其他玩家抢碰是非常重要的。玩家应当尽量避免出给其他玩家碰的牌，特别是那些可能成为暗杠关键牌的牌。\n避免过早暴露信息：在游戏中，若玩家开始碰牌或杠牌时，其他玩家会更容易判断出他们的牌型，尤其是当玩家杠牌时会暴露出具体的花色。为了避免过早暴露自己的牌型，玩家应尽量控制自己的杠牌节奏。\n精确的牌型配合：玩家需要在构建其他牌型时注意协调，确保能够保证暗杠的顺利形成。在胡牌时，玩家的手牌往往有较多的复杂结构，需要结合顺子、刻子和杠牌的搭配，合理优化整体的胡牌结构。\n参考链接 双暗杠\n双箭刻 什么是双箭刻？ 双箭刻要求玩家胡牌时，手牌中必须包含两个箭刻，即有两组三张相同的箭牌（中、发、白）。箭牌包括中、发、白三种牌。每组箭刻都必须由三张相同的箭牌构成。双箭刻属于一种特殊的“刻子”组合，通常与其他番种（如清一色、碰碰和等）搭配，形成高番种。\n双箭刻的牌型 以下是双箭刻的牌型举例：\n手牌： 中中中（中箭刻子），发发发（发箭刻子），1万、2万、3万（顺子），4条、5条、6条（顺子），东东（雀头）。\n其中：玩家有两个箭刻（“中中中”和“发发发”），并且手中还有符合胡牌条件的顺子和雀头，因此符合双箭刻的要求。\n手牌： 白白白（白箭刻子），发发发（发箭刻子），5条、6条、7条（顺子），2筒、3筒、4筒（顺子），西西（雀头）。\n其中：玩家有两个箭刻（“白白白”和“发发发”），同时也有顺子和雀头，符合双箭刻的胡牌结构。\n双箭刻的番数 双箭刻的番数在国标麻将中通常为6番。由于双箭刻的构成需要较强的牌面支持和技巧，因此其番数相对较高，尤其是在和其他高番种结合时，能显著提升总番数。\n双箭刻的注意事项 箭刻的构成：箭刻是双箭刻的关键，玩家必须通过手中的四张相同箭牌来形成箭刻。箭刻的牌型通常是固定的，即中、发、白三种箭牌。如果玩家的手牌中有足够的箭牌并且能够通过杠牌或碰牌获取到这些牌，就能迅速构建双箭刻。\n两种箭牌的选择：在游戏中，玩家可以通过碰牌或杠牌来完成箭刻。因此，观察其他玩家的出牌情况，以及自己抓牌的情况，决定哪一种箭刻更容易完成。玩家要避免过早打出箭牌，以免给其他玩家提供碰的机会，影响自己的双箭刻。\n双箭刻的策略与实战意义 利用杠牌提高箭牌数量：在游戏中，玩家可以通过杠牌来提高手中箭牌的数量，进而形成箭刻。例如，若手中已经有两张“中”牌，通过摸牌或其他玩家打出的“中”牌就能完成一个箭刻。利用杠牌，可以加速双箭刻的形成。\n观察对手牌型：为了顺利完成双箭刻，玩家需要观察对手的出牌和碰牌情况。如果对手已经碰了某种箭牌，那么该花色的箭刻就很难完成，这时候玩家可以调整策略，集中注意力收集其他箭牌或其他花色的刻子。\n合理安排出牌时机：双箭刻的实现需要精确的出牌时机，避免在不恰当的时机打出某种箭牌，从而给对手提供碰的机会。合理地控制出牌，确保自己的箭刻不会被打断，是实现双箭刻的重要策略。\n参考链接 双箭刻\n8 番 花龙 什么是花龙？ 花龙是国标麻将中的一个高难度番种，要求玩家在胡牌时，手牌中包含一条连续的数字序列，其中的每一组顺子必须来自于三种不同的花色。\n花龙的牌型 以下是花龙的牌型举例：\n手牌： 1万、2万、3万（顺子，万花色），4条、5条、6条（顺子，条花色），7筒、8筒、9筒（顺子，筒花色），东东（雀头）。\n其中：玩家有三个顺子，且这三组顺子分别来自万、条、筒三个花色，符合花龙的要求。\n花龙的番数 花龙是国标麻将中的一个番种，要求玩家的手牌中包含三个顺子，且这三组顺子必须分别来自三个不同的花色（万、条、筒）。花龙的番数为8番，是一个较高难度的番种，需要玩家合理安排手牌、精确构建顺子，并避免集中花色。\n花龙的注意事项 三组顺子：花龙要求玩家的手牌中有三个顺子，这需要玩家合理安排手牌，并尽量收集适合的顺子牌。例如，若手中有2条、3条、4条，那么就可以作为顺子的一部分。如果牌堆中恰好有对应的其他花色的顺子牌（如万或筒），就可以组成花龙。\n不同花色的顺子：这三组顺子必须分别来自不同的花色，因此玩家需要尽量避免将所有顺子都集中在同一个花色上。合理安排手牌中的花色，确保能构成三个不同花色的顺子，是实现花龙的关键。\n杠牌和碰牌的影响：由于花龙要求手牌中有三个顺子，而顺子是由三张连续的数字牌组成的，因此尽量避免在游戏中碰牌或杠牌，尤其是涉及到相同花色的顺子。如果玩家强行碰或杠，可能会影响手牌中顺子的形成。\n花龙的策略与实战意义 精确掌握顺子构建：花龙要求三个顺子来自不同花色，因此玩家需要特别注意顺子的构建，尽量确保顺子分布在万、条、筒三个花色之间。这要求玩家不仅要有好的运气，还要能够在游戏过程中有效地调整策略。\n合理控制出牌时机：在游戏中，合理控制出牌时机，避免出掉可能构成顺子的牌是非常重要的。特别是当手牌中已经有了某些顺子牌时，尽量避免轻易打出其他花色的顺子牌，否则可能会错失花龙的机会\n避免集中花色：玩家在构建手牌时，要特别注意避免将所有的顺子都集中在某一花色上。如果玩家不小心将所有的顺子集中在一个花色中，那么就无法满足花龙的构成条件。\n参考链接 花龙\n推不倒 什么是推不倒？ 推不倒是指玩家的胡牌牌型全部由没有上下区别的牌组组成，包括数牌和字牌。对称牌具有视觉上的对称性，倒置后不改变形状。\n数牌：筒：1筒、2筒、3筒、4筒、5筒、8筒、9筒。条：2条、4条、5条、6条、8条、9条。 字牌：白板。 作为一个8番的中高番种，推不倒的成型需要一定的运气和技巧，但其灵活性使得玩家可以通过多种方式组合完成牌型。掌握推不倒的牌型选择和配牌策略，不仅能够提高实战中的得分，还能为对局增添更多的趣味性和观赏性。\n推不倒的牌型 以下是推不倒的牌型举例：\n123筒、456条、111筒、88条、白白 所有牌为对称牌，包括数牌和字牌，将牌为白白。\n推不倒的番数 在国标麻将中，推不倒是一个8番的番种，以其牌型独特性和趣味性而著称。推不倒的牌型全部由对称牌组成，其名称来源于这种牌型的特点：将牌倒置后仍然保持原来的形态。\n推不倒的注意事项 所有牌必须是对称牌：胡牌牌型中不允许出现任何非对称牌（如万、7条、6筒等）。\n满足胡牌结构：推不倒需满足国标麻将的基本胡牌条件，即4组面子（顺子、刻子或杠）+1对将。\n推不倒与其他番种的关系 清一色（24番）： 如果推不倒的牌型全部为单一花色，可叠加清一色番种。\n混一色（6番）：如果推不倒的牌型由一种花色和字牌组成，可叠加混一色番种。\n七对（24番）：如果推不倒的牌型为七对，可叠加七对番种。\n推不倒的策略与实战意义 起手判断：如果起手牌中对称牌较多（如1、2、3条、白等），可以尝试朝推不倒方向发展。如果对称牌不足或非对称牌较多，建议放弃推不倒目标。\n优先保留对称牌：在摸牌过程中，优先保留对称牌（如1、2、3等），避免打出关键牌。\n与高番种搭配：推不倒的番值较高，但仍建议与清一色、碰碰胡等高番种组合，提高整体得分。\n听牌规划：尽量选择听多张对称牌的形式，提高胡牌概率。\n参考链接 推不倒\n三色三同顺 什么是三色三同顺？ 三色三同顺指的是玩家的胡牌结构中，包含三组顺子，而这三组顺子必须分别属于万、条、筒三个花色。每组顺子由三张连续的牌组成。三色三同顺要求的三组顺子并不仅仅是同一花色的顺子，而是每个顺子必须来自不同的花色，且每个顺子里的牌都是连续的。\n三色三同顺的牌型 以下是三色三同顺的牌型举例：\n手牌： 1万、2万、3万（顺子，万花色），1条、2条、3条（顺子，条花色），1筒、2筒、3筒（顺子，筒花色），东东（雀头）。\n其中：玩家有三个顺子，分别属于万、条、筒三个花色，符合三色三同顺的条件。\n手牌： 5万、6万、7万（顺子，万花色），5条、6条、7条（顺子，条花色），5筒、6筒、7筒（顺子，筒花色），南南（雀头）。\n其中：包含了三个顺子，分别来自于三个花色，且每个顺子都是连续的三张牌，符合三色三同顺的要求。\n三色三同顺的番数 三色三同顺的番数通常为8番。这是一个高难度的番种，因为它要求玩家手中有三组顺子，并且每组顺子必须属于不同的花色，同时每组顺子必须是连续的相同三张牌。\n三色三同顺的注意事项 三组顺子：三色三同顺要求手牌中有三个顺子，而每个顺子必须由三张连续的数字牌组成。玩家需要在摸牌和出牌的过程中确保能够积累到这些顺子，特别是要注意顺子分布在万、条、筒三个花色上。\n三个不同花色的顺子：这是三色三同顺最重要的要求之一。玩家必须确保手牌中的三个顺子分别属于不同的花色，而不是集中在一个花色中。这样要求玩家有更高的牌型规划能力，以及良好的运气来收集来自不同花色的顺子。\n雀头的选择：除了三组顺子外，玩家的手牌中还需要有一个雀头（两张相同的牌）。玩家可以根据手牌中的情况选择合适的雀头，通常是选择剩余的两张相同的牌。\n顺子的连续性：每组顺子都必须是连续的三张牌，这要求玩家的摸牌和出牌策略要符合连续性原则，避免将牌面打乱。玩家应当注意避免出掉可能构成顺子的牌。\n三色三同顺的策略与实战意义 合理安排顺子的搭配：玩家在构建手牌时，需要合理安排顺子的搭配，确保手牌中的顺子分别来自不同的花色。为了实现三色三同顺，玩家要注意顺子之间的平衡，避免集中在某一个花色中。\n避免碰牌和杠牌干扰：为了保持手牌的顺子结构，玩家应尽量避免频繁的碰牌和杠牌，特别是当这些操作可能破坏手牌中的顺子时。例如，如果手中已有1万、2万、3万，就应尽量避免将相同花色的其他牌碰出。\n合理控制出牌时机：玩家在出牌时需要特别小心，避免打出可能影响顺子连续性的牌。例如，在手中已有1万、2万时，应避免打出可能是3万的牌，以避免破坏手牌的连续性。\n参考链接 三色三同顺\n三色三节高 什么是三色三节高？ 三色三节高是国标麻将中的一个番种，要求玩家的胡牌中包含三组刻子，且这三组刻子分别来自万、条、筒三个花色，同时每组刻子的牌值必须是三张连续的数字牌。也就是说，三组刻子不仅要属于三个不同的花色，而且每个刻子的组成牌值必须是依次递增一个序数的刻字（杠子），形成一个较高的牌型结构。\n三色三节高的牌型 以下是三色三节高的牌型举例：\n手牌： 3万、3万、3万（刻子，万花色），4条、4条、4条（刻子，条花色），5筒、5筒、5筒（刻子，筒花色），东东（雀头）。\n其中：玩家的手牌包含了三个刻子，分别来自万、条、筒三个花色，每个刻子之间的间隔符合依次递增一个序数的刻字的要求。\n三色三节高的番数 三色三节高的番数通常为8番。这是一个相对高难度的番种，要求玩家的手牌不仅要有三个刻子，还需要确保刻子之间的间隔和递增关系，从而获得额外的番数奖励。\n三色三节高的注意事项 刻子的牌值间隔：三色三节高的核心要求是刻子之间必须依次递增一个序数。例如，若第一个刻子是2万、2万、2万，那么第二个刻子不应是4万、4万、4万（因为两者相连没有间隔），而应该是3条、3条、3条。这种间隔要求使得三色三节高在实际游戏中比较难以实现。\n刻子之间的花色分布：这个番种要求玩家的刻子必须分别来自不同的花色，即万、条、筒三个花色。因此，玩家需要合理安排手牌中的各个花色，并确保刻子的花色不重复。\n雀头的选择：三色三节高要求除了这三个刻子外，玩家的手牌中还必须有一个雀头，即两张相同的牌。雀头的选择通常取决于手牌的其他构成部分，玩家可以选择手中已经有对子的牌来作为雀头。\n不相同原则：如果牌型是三万、三万、三万，四条、四条、四条，五饼、五饼、五饼，六万，六万，六万，西风，西风。根据“不相同原则\u0026#34;，只可计一组三色三节高。\n三色三节高的策略与实战意义 合理安排花色和刻子：玩家在进行手牌构建时，应该尽量避免集中使用某一种花色，而是合理安排万、条、筒三个花色。通过保持花色的平衡，玩家可以提高构建三色三节高的可能性。\n合理选择雀头：雀头的选择对于三色三节高也很重要。玩家可以选择手中已有对子的牌作为雀头，避免盲目拆牌。在手牌构建过程中，保持雀头的灵活性，可以为最终实现三色三节高提供更多的可能性。\n参考链接 三色三节高\n无番和 什么是无番和？ 在国标麻将中，无番和是指一种没有其他番数的胡牌方式。简单来说，无番和指的是玩家胡牌后，手中的牌型不满足任何番种的条件。它是最基本的一种胡牌形式，并且通常代表了一个较为简单的手牌结构。\n无番和的牌型 以下是无番和的牌型举例：\n手牌： 1万、2万、3万（顺子，万花色），3万、4万、5万（顺子，万花色），6筒、7筒、8筒（顺子，筒花色），5条、6条、7条（顺子，条花色），东东（雀头）。\n其中：玩家完成了胡牌，但这个手牌并没有达到任何番种的要求，因此这算作无番和，番数为8番。\n无番和的番数 无番和，没有其他番种的和牌(花牌除外)，计 8 番。\n无番和的注意事项 没有番种奖励：无番和的本质就是没有任何番数的胡牌方式，所有的点数都来自于基础胡牌点数。这意味着玩家的手牌只能依靠花牌来增加自己的番数。\n胡牌结构较简单：无番和的胡牌结构通常较为简单，缺乏复杂的组合。通常只有基本的顺子、刻子和雀头，不包含任何特殊的牌型或番种。因此，这种胡牌方式在策略上相对简单，不需要太多技巧，只要能够完成基本的胡牌条件即可。\n无番和与其他番种的关系 与其他番种的区别：无番和和其他番种（如平和、清一色、碰碰和等）不同，其他番种通常有额外的条件，如顺子必须是清一色、所有牌都为刻子等。而无番和则是最基础的胡牌类型，不满足这些额外条件。\n无番和的策略与实战意义 简化手牌构建：玩家在追求无番和时，通常不会追求复杂的番种组合，而是以快速完成基本的胡牌条件为目标。这种策略适合在牌局节奏较快、自己无法形成其他番种时使用。\n基础胡牌的选择：如果玩家的手牌本身没有机会达到较高的番种，但又希望尽快胡牌，可以选择通过无番和来完成胡牌。这种情况下，玩家可能会忽略某些复杂番种的条件，而是专注于快速达成一个基本的胡牌。\n参考链接 无番和\n妙手回春 什么是妙手回春？ 妙手回春是指玩家在牌山的最后一张牌时，通过自摸胡牌完成牌局。这种胡牌方式表现出一种“起死回生”的意味，因而得名“妙手回春”。\n妙手回春的牌型 以下是妙手回春的牌型举例：\n普通顺子牌型：\n听牌情况：玩家手牌为123万、456万、789筒、567条、88条。 最后一张牌：玩家摸到8条，完成胡牌。 番种分析：因胡牌时为最后一张牌，计入妙手回春。 七对牌型：\n听牌情况：玩家手牌为11223344556677条。 最后一张牌：玩家摸到7条，完成七对胡牌。 番种分析：因胡牌时为最后一张牌，计入妙手回春，同时叠加七对番种。 碰碰胡牌型：\n听牌情况：玩家手牌为111万、222万、333筒、555筒、东东。 最后一张牌：玩家摸到东风，完成碰碰胡。 番种分析：因胡牌时为最后一张牌，计入妙手回春，同时叠加碰碰胡番种。 妙手回春的番数 在国标麻将中，妙手回春是一个8番的番种，以其特殊的胡牌方式和稀有性而著称。该番种强调玩家通过最后一巡自摸摸到最后一张牌完成胡牌，被视为运气与实力兼具的经典番种。\n妙手回春的注意事项 自摸最后一张牌：胡牌的最后一张牌必须是牌山中的最后一张，即整副牌局的最后一巡摸牌。\n满足胡牌条件：胡牌时的牌型必须满足国标麻将的基本胡牌条件（4组面子+1对将或特殊胡牌牌型，如七对子、十三幺等）。\n不能点炮胡牌：妙手回春必须通过自摸完成，点炮胡牌不符合条件。\n妙手回春与其他番种的关系 七对（24番）：如果胡牌牌型为七对，可叠加七对子番种。\n碰碰胡（6番）：如果胡牌牌型全由刻子组成，可叠加碰碰胡番种。\n清一色（24番）：如果胡牌牌型全部为单一花色，可叠加清一色番种。\n自摸（1番）：妙手回春本质上是通过自摸胡牌，因此包含自摸番种。\n妙手回春的策略与实战意义 成型难度高：妙手回春的胡牌方式完全依赖牌局进程，只有在牌山的最后一张牌时才能达成。\n不可控性强：玩家无法通过策略主动创造妙手回春的条件，因此稀有性较高。\n尽量保留听牌状态：在牌局接近尾声时，如果牌墙剩余牌数较少且接近最后一巡，应优先保证自己处于听牌状态，为妙手回春创造可能。\n注意牌山计算：妙手回春仅能通过最后一张牌完成胡牌，玩家应注意牌山中的剩余牌数，避免错失机会。\n参考链接 妙手回春\n海底捞月 什么是海底捞月？ 海底捞月是指玩家在牌山的最后一巡摸牌阶段，通过特定方式获得最后一张牌并完成胡牌。\n海底捞月的牌型 海底捞月的番数 在国标麻将中，“海底捞月”是一个8番的番种，以其独特的胡牌方式和稀有性而著称。\n海底捞月的注意事项 最后一巡：玩家在牌山的最后一巡摸牌阶段完成胡牌。这张胡牌的牌为整局游戏中的最后一张牌。\n胡牌方式：可以通过自摸、点炮或抢杠胡牌，均符合海底捞月的条件。\n满足胡牌结构：胡牌牌型必须满足国标麻将的基本胡牌条件（4组面子+1对将或特殊牌型，如七对子、十三幺等）。\n海底捞月与其他番种的关系 妙手回春（8番）：和海底捞月不同的是必须是玩家通过自摸最后一张牌完成胡牌。\n七对子（24番）：如果海底捞月的胡牌牌型为七对子，可叠加七对子番种。\n海底捞月的策略与实战意义 成型难度高：海底捞月的胡牌方式完全依赖牌局进程，只有在最后一巡才能达成。\n机会稀少：一局游戏中只有一个玩家能通过最后一张牌完成胡牌，稀有性较高。\n尽量保留听牌状态：在牌局接近尾声时，如果牌墙剩余牌数较少且接近最后一巡，应优先保证自己处于听牌状态，为海底捞月创造可能。\n参考链接 海底捞月\n杠上开花 什么是杠上开花？ 杠上开花指的是玩家在杠牌后（补杠、明杠、暗杠）摸到的一张牌恰好是胡牌所需要的牌，从而成功胡牌。通常，在玩家进行杠牌时，除了获得一张新的牌外，若这张牌能够使玩家胡牌，则会计入杠上开花这一番种。\n杠上开花的牌型 杠上开花的番数 杠上开花是一个难得且具有高番数的番种，通常为8番。它要求玩家在进行杠牌后，摸到一张能够使自己胡牌的牌，从而逆袭成功。这个番种不仅带有一定的运气成分，还涉及到玩家对杠牌时机的精准把控。\n杠上开花的注意事项 进行杠牌：玩家必须完成一个杠。杠可以是以下几种形式： 明杠：玩家将自己手中的三张相同的牌暴露出来，并再摸一张牌进行杠。补杠：玩家在自己已经有一个刻子的基础上，通过从其他玩家处摸到第四张相同的牌来完成杠。暗杠：玩家在没有与其他玩家暴露过任何牌的情况下，自摸四张相同的牌来完成杠。\n摸到胡牌的牌：完成杠后，玩家摸到的最后一张牌恰好是可以完成胡牌的牌，通常这张牌使玩家的牌型符合胡牌条件。\n分数计算：和开杠后抓进的那张牌不计自摸。\n杠上开花的策略与实战意义 杠牌的时机选择：玩家在选择进行杠牌时，通常需要评估自己的手牌和当前的局势。杠牌不仅是为了增加番数，也可能为玩家提供更多摸牌的机会，因此在时机掌握上非常重要。如果能够合理安排杠牌的时机，增加杠上开花的机会，玩家能够提高自己的胡牌概率。\n保持局势灵活性：在游戏过程中，玩家可能通过杠牌来调整自己的牌型，特别是在某些情况下，通过杠牌可以将自己手中的牌转换为更加有利的胡牌结构。如果能在杠牌后及时摸到关键的牌来完成胡牌，则可以获得杠上开花。\n与其他番种的配合：杠上开花常常与其他番种相结合，可能会构成更高番数的牌型。\n参考链接 杠上开花\n抢杠和 什么是抢杠和？ 在国标麻将中，抢杠和（又叫抢杠胡）是一个特殊且非常具有挑战性的番种。它发生在玩家通过抢别人杠牌的最后一张牌来胡牌。\n抢杠和的牌型 抢杠和的番数 在国标麻将中，抢杠和的番数通常为8番，是一个非常高的番种。这一番种反映了玩家在其他玩家杠牌的基础上，通过精确的判断和时机把握，完成抢胡的行为。\n抢杠和的注意事项 其他玩家正在进行杠牌：玩家需要在别人进行杠牌时，即玩家自己并不主动杠牌，而是利用其他玩家杠牌时的牌来完成胡牌。杠牌可以是： 补杠：玩家从其他玩家手中摸到第四张相同的牌，补充自己的手牌完成杠。\n抢杠的牌必须是可以胡牌的牌：当玩家看到其他玩家准备杠牌时，如果自己手中正好有一个符合胡牌的结构，可以抢杠胡牌。也就是说，抢杠的牌必须能组成一个有效的胡牌牌型，例如完整的顺子、刻子或者对子。\n抢杠的时机：玩家只有在其他玩家将要进行补杠时才有机会进行抢杠和。具体来说，当其他玩家出示杠牌时，自己可以立刻宣布胡牌并抢夺那张即将杠出的牌。如果该牌是玩家可以胡的牌，就完成了抢杠和。\n抢杠和的策略与实战意义 精确计算听牌范围：在听牌阶段尽量扩大听牌范围，增加抢杠和的可能性。\n观察对手的副露情况：关注对手已碰的牌组，如果可能形成加杠，应根据场面调整听牌策略。\n灵活利用抢杠机会：抢杠和是一个稀有的高分番种，听牌阶段可适当调整策略以争取达成抢杠和。\n参考链接 抢杠和\n12 番 全不靠 什么是全不靠？ 全不靠是指玩家的牌型中，每一张牌与其他任何牌之间都没有直接的逻辑关联，即：\n数牌之间：不得有两张牌连续（如1万与2万，5条与6条）。不得有两张相同（如1筒与1筒）。 字牌之间：各种字牌（东、南、西、北、中、发、白）必须彼此不同。 必须满足特殊牌型要求：牌型必须包含一种特定的组合称为“组合龙”（由三种花色的1到9组成，每种花色各一张，且互不重复）。\n全不靠的牌型 以下是全不靠的牌型举例：\n数牌：1万、4万、7万、2条、5条、8条、3筒、6筒 字牌：东、南、西、北、中、发、白 全不靠的番数 在国标麻将中，全不靠是一个12番的番种，因其独特的牌型和较高的成型难度而著称。全不靠强调胡牌时的所有牌完全不构成顺子、刻子或对子，是一种非常稀有的特殊牌型。\n全不靠的注意事项 牌型无关联：所有牌都不能形成顺子、刻子或对子。数牌之间不能相连（如1万和2万），也不能重复。\n必须包含“组合龙”：牌型中必须有一组1到9的完整序列，分别来自三种不同的花色（万、筒、条），如：1万、4筒、7条。\n胡牌结构完整：除了“组合龙”外，剩下的七张牌为不重复的字牌（东、南、西、北、中、发、白）。\n全不靠与其他番种的关系 全不靠是一个独立的特殊牌型番种，无法与一些番种叠加。例如：\n清一色：全不靠的牌型必须包含三种不同花色的数牌，因此无法形成清一色。\n碰碰胡：全不靠不允许牌型中出现任何刻子，因此无法形成碰碰胡。\n七对子：全不靠牌型中不得有任何对子，因此也无法形成七对子。\n全不靠的策略与实战意义 起手判断：如果起手牌中出现较多的孤张且无连续或重复的情况（如1万、4筒、东、发等），可以考虑追求全不靠。如果起手牌中有较多连续牌（如4万、5万、6万）或对子，建议放弃全不靠目标。\n优先保留特殊牌：尽量保留可能组成“组合龙”的数牌和字牌，避免打出关键张。\n参考链接 全不靠\n组合龙 什么是组合龙？ 组合龙是指玩家胡牌时，手牌中包含三种不同花色的147，258，369不能错位的序数牌，且1到9的每个数字仅出现一次。这种牌型被称为“组合龙”或“交错龙”。\n组合龙的牌型 以下是组合龙的牌型举例：\n示例1：\n组合龙：1万、2筒、3条、4万、5筒、6条、7万、8筒、9条 其他部分：88万（将牌）、中中中（刻子） 示例2：\n组合龙：1条、2万、3筒、4条、5万、6筒、7条、8万、9筒 其他部分：东东（将牌）、111条（刻子） 示例3：\n组合龙：1筒、2条、3万、4筒、5条、6万、7筒、8条、9万 其他部分：白白（将牌）、222条（刻子）\n组合龙的番数 组合龙为12番，是国标麻将中较高的番种。合龙对牌型有严格要求，必须收集1到9的每个数字，且分布在三种花色中，摸牌时需要极高的运气和规划能力。\n组合龙的注意事项 三种花色：必须同时包含万、筒、条三种花色。\n完整的1到9：数牌的每个数字（1到9）只能出现一次，且必须被完整覆盖。例如，1万、2筒、3条、4万、5筒、6条、7万、8筒、9条。\n满足胡牌结构： 除了“组合龙”部分，剩余的牌型必须满足国标麻将的基本胡牌条件（4组面子+1对将）。\n组合龙的策略与实战意义 起手判断：如果起手牌中有多个孤张且分布接近1到9的范围（如1万、3筒、6条、9条等），可以考虑尝试组合龙。如果起手牌与组合龙差距较大，建议放弃，转向其他更容易成型的番种。\n优先保留龙牌的数字：在摸牌和打牌过程中，优先保留1到9的数字牌，逐步凑齐组合龙部分。\n规划将牌和其他面子：组合龙仅占用9张牌，剩余部分需合理规划，尽量形成高番种的将牌和刻子。\n参考链接 组合龙\n大于五 什么是大于五？ 在国标麻将中，大于五番种是指，玩家胡牌时，手牌中的所有牌或者大部分牌的数值均为大于5的数字牌。这些牌必须在构成胡牌的过程中满足特定的条件，例如可以通过顺子、刻子、杠子等方式来排列组合，并且所有的牌数值要大于5。\n大于五的牌型 以下是大于五的牌型举例：\n手牌：6万、7万、8万、6筒、7筒、8筒、6条、7条、8条、9万、9万、9万。\n其中：所有的数字牌都是6、7、8、9，符合大于五的要求。玩家的手牌完全由大于5的数字牌构成，并且可以通过顺子和刻子来完成胡牌。\n手牌：6万、6万、6万、8条、9条、7筒、8筒、9筒、6筒、7筒、8筒。\n其中：手牌中的所有牌都是6、7、8、9。通过刻子（6万、6万、6万）和多个顺子（8条、9条、7筒、8、9筒等）来完成胡牌。\n大于五的番数 大于五是国标麻将中的一个高番种，通常为12番，要求玩家的胡牌牌型完全由6、7、8、9这些数字牌组成，且这些牌必须通过顺子、刻子等方式构建。实现大于五需要玩家具备精确的牌感和高水平的决策能力，同时避免使用较小的数字牌。\n大于五的注意事项 需要避免小于5的数字牌：玩家在追求大于五时，需要密切关注每轮的摸牌情况，尽量保证手中的牌大部分符合6、7、8、9这些数字。如果摸到1、2、3、4这些小牌，玩家应尽早决定是否丢弃，并根据局势调整牌型。\n胡牌牌型的要求：在完成胡牌时，玩家的牌型必须符合国标麻将的基本规则，且全部或大部分由大于5的牌构成。比如玩家的顺子可以是6万、7万、8万（万字顺子）或者6筒、7筒、8筒（筒子顺子）等。\n刻子、杠子等牌型的使用：组成胡牌的刻子或杠子等，也必须由6、7、8、9这些大于5的数字牌组成。例如，玩家可以有6万、6万、6万（万字刻子）或7条、7条、7条（条子刻子）。\n大于五的策略与实战意义 精细的弃牌策略：为了实现大于五，玩家必须仔细观察每一张牌，并且尽早丢弃任何可能影响最终胡牌的小于5的牌。这要求玩家在游戏中保持高效的牌感和快速的决策能力。\n避免无用的低牌：在追求大于五的过程中，玩家需要避免在手中保留过多的低牌（1、2、3、4）。这些牌不仅不能帮助形成符合条件的顺子，而且还可能浪费牌力，影响胡牌的速度。\n灵活应对摸牌：玩家在追求大于五时，需要密切关注每轮的摸牌情况，尽量保证手中的牌大部分符合6、7、8、9这些数字。如果摸到1、2、3、4这些小牌，玩家应尽早决定是否丢弃，并根据局势调整牌型。\n合理的牌型搭配：在构建手牌时，玩家可以选择不同的组合方式，如顺子、刻子、杠子等。玩家要灵活应对手牌，选择最适合的牌型来满足大于五的条件。\n参考链接 大于五\n小于五 什么是小于五？ 小于五番种是指，玩家在胡牌时，其手牌必须包含大量小于5的数字牌，即1、2、3、4这四个数字的牌。玩家的顺子、刻子、杠子等都需要由这些数字牌构成。\n小于五的牌型 以下是小于五的牌型举例：\n手牌：1万、1万、1万、2筒、2筒、2筒、3条、3条、3条、4万、4万、4万。\n其中：所有的数字牌都是1、2、3、4，符合小于五的要求。玩家的手牌完全由小于5的数字牌构成，并且可以通过顺子（2筒、3筒、4筒）和刻子（1万、2万、3条等）来完成胡牌。\n手牌：1条、2条、3条、1筒、2筒、3筒、1万、1万、1万、4条、4条、4条。\n其中：手牌中的所有牌均为1、2、3、4。玩家通过顺子和刻子来构建手牌，最终可以胡牌，并获得12番。\n小于五的番数 在国标麻将中，小于五通常为12番，这个番数是由于要求玩家构建的牌型完全由1、2、3、4这些数字牌组成，这种构建方式较为复杂且难度较大。\n小于五的注意事项 数字牌要求小于5：玩家胡牌时，手牌中必须包含1、2、3、4这些数字牌。不能包含5及以上的数字牌（即不能有5、6、7、8、9等牌）。玩家必须依靠这些较小的数字牌构建完整的胡牌牌型，不能有任何大于5的数字牌存在。\n胡牌牌型的要求：在完成胡牌时，玩家的牌型必须由小于5的牌构成。这些牌必须符合国标麻将的基本规则，并且组成顺子、刻子等有效牌型。玩家可以通过顺子、刻子等方式组合这些小于5的牌。 刻子、杠子等牌型的使用：组成胡牌的刻子或杠子也必须由1、2、3、4这些数字牌组成。例如，玩家可以有1万、1万、1万（万字刻子）或2筒、2筒、2筒（筒子刻子）等。\n小于五的策略与实战意义 精确的弃牌策略：为了实现小于五，玩家必须在游戏过程中精确地弃掉任何5及以上的牌。如果摸到这些牌，玩家应该立即考虑丢弃它们，以确保手牌符合小于五的要求。\n避免多余的高牌：在追求小于五时，玩家不仅要避免5、6、7、8、9这些数字牌的出现，还要注意手牌中的高牌可能影响后续的牌型构建。玩家应根据局势灵活调整手牌，减少手中的高牌，保持低数字牌的结构。\n灵活应对摸牌：玩家在摸牌时，应该时刻关注牌型的变化，确保手牌中没有大于5的数字牌。如果摸到大于5的牌，玩家应该迅速进行调整，保持手牌的结构完整，避免破坏小于五的条件。\n合理的牌型搭配：玩家可以通过构建多个顺子或刻子来达到小于五的要求。玩家需要根据自己的手牌情况选择合适的牌型搭配，确保每个顺子或刻子都符合1、2、3、4的数字范围。\n参考链接 小于五\n三风刻 什么是三风刻？ 在国标麻将中，三风刻是一个12番的番种，属于比较高难度的番种。它的要求是玩家在胡牌时，手牌中必须有三个风刻，即有三个由东风、南风、西风、北风这四个风字牌构成的刻子。\n三风刻的牌型 以下是三风刻的牌型举例：\n手牌：东风东风东风、南风南风南风、西风西风西风、6万、7万、8万、9筒、9筒、9筒、4条、4条。\n其中：玩家有东风、南风、西风三组风刻。其他的牌则构成了顺子和刻子。玩家通过这三个风刻就可以胡牌，并且获得12番。\n手牌：东风东风东风、北风北风北风、西风西风西风、3万、4万、5万、7筒、7筒、7筒。\n其中：玩家的手牌中有东风、北风、西风三个风刻，其他的牌组成顺子。玩家可以通过这个牌型胡牌，获得12番。\n三风刻的番数 三风刻是国标麻将中的一个高难度番种，通常为12番。它要求玩家的手牌中必须有三个由东风、南风、西风、北风四种风字牌组成的刻子。\n三风刻的注意事项 难度的番种：三风刻要求玩家的手牌中必须有三个风刻，这需要玩家在摸牌和弃牌时精心策划。因为风字牌是较为稀有的牌，所以能够凑齐三个风刻是一个挑战。尤其是当风字牌被其他玩家吃或碰时，玩家更难以完成这一番种。\n风字牌的控制：在追求三风刻时，玩家需要特别注意风字牌的获取和控制。在胡牌之前，玩家应该尽量避免让其他玩家碰走或杠走风字牌，因为这可能会打乱自己的计划。\n与其他番种的关系：三风刻是一个独立的番种，但它也有可能与其他番种叠加。然而，通常情况下，三风刻已经是一个非常高的番种，因此很难与其他番种叠加。\n三风刻的策略与实战意义 合理选择风字牌：追求三风刻时，玩家需要特别关注手牌中的风字牌。若有多个风字牌，玩家可以考虑构建风刻。在这种情况下，尽量保留对自己有帮助的风字牌，并快速弃掉无用的牌。\n灵活应对摸牌：玩家应根据牌局的进展灵活应对摸牌。如果摸到合适的风字牌，可以考虑加速构建风刻。否则，玩家可以选择弃掉不必要的风字牌，集中精力打造其他组合。\n牌局中的心理战术：由于三风刻的难度较高，玩家通常会在牌局中保持较低的张扬，避免过早暴露自己的意图。对于对手来说，如果你始终没有碰出或杠出风字牌，那么他们很难猜测你是否有三风刻。\n参考链接 三风刻\n16 番 清龙 什么是清龙？ 清龙是指玩家胡牌时，牌型中包含同一花色的完整1到9顺子（三个连续的顺子：123、456、789），称为“一条龙”。这组1到9的完整顺子必须全部来自同一种花色。\n清龙的牌型 以下是清龙的牌型举例：\n示例1：\n清龙部分：123万、456万、789万 其他部分：中中（将牌）、111条（刻子） 示例2：\n清龙部分：123筒、456筒、789筒 其他部分：88条（将牌）、222万（刻子）\n清龙的番数 在国标麻将中，清龙是一个16番的番种，以其独特的牌型要求和较高的分值而著称。清龙强调在同一花色中形成1到9的完整顺序，展现了牌型的极高整齐度和美感。\n清龙的注意事项 同一花色：牌型中的1到9必须全部属于同一花色（如万、筒、条中的一种）。\n完整的1到9顺序：必须由三个顺子（123、456、789）组成，形成1到9的连续排列。\n胡牌结构完整：除了“清龙”部分，剩余牌型需满足国标麻将的基本胡牌条件（4组面子+1对将）。\n清龙与其他番种的关系 门前清（2番）：如果清龙的胡牌过程中没有副露（碰牌、杠牌等），可叠加门前清番种。\n平和（2番）：如果全带是四组刻子，可叠加平和番种。\n单钓将（1番）：如果清龙的听牌形式为单钓将（等待一张特定牌完成将牌），可叠加单钓将番种。\n不等于清一色：清龙必须是同一花色的1到9，但其他部分可以包含字牌或其他花色的牌，因此清龙不等同于清一色。\n与组合龙的区别：组合龙要求1到9的数字分布在三种花色中，而清龙要求1到9全部属于同一花色。\n清龙的策略与实战意义 起手判断：如果起手牌中某一花色的123、456、789出现多个（如1万、2万、3万、4万、5万、6万），可以考虑尝试清龙。如果起手牌中缺少关键张（如2万、8筒等），建议放弃清龙目标，转向其他番种。\n优先保留龙牌的数字：在摸牌和打牌过程中，优先保留可能组成1到9的数字牌，逐步凑齐清龙部分。\n分析场上牌池：根据场上已打出的牌，判断清龙的可能性，调整自己的打牌策略。\n参考链接 清龙\n三色双龙会 什么是三色双龙会？ 在国标麻将中，三色双龙会是一个非常高难度、非常特殊的番种。它要求玩家在胡牌时，手牌必须由两种花色两个老少副，另一种花色5作将牌的和牌。由于其对手牌组合的特殊要求，三色双龙会非常难以实现，但一旦完成，可以获得极高的番数——16番。\n三色双龙会的牌型 三色双龙会的构成要素：\n两种花色的两个老少副。 另一种花色中的5作为将牌的和牌。 手牌：1万、2万、3万，7万、8万、9万，1条、2条、3条，7条、8条、9条，5筒、5筒。\n其中：手牌中的1-2-3万、7-8-9万（两组三色顺子），以及同样构成的1-2-3条、7-8-9条（两组三色顺子）和另一种花色的5，符合16番的要求。\n三色双龙会的番数 三色双龙会的番数为16番，是非常高的番种。它要求玩家的牌型不仅要有三种花色的顺子，而且这些顺子要相互配合，形成特别的结构，因此实现这个番种的难度极大。\n三色双龙会的注意事项 三色要求：三色双龙会的关键在于要求玩家手牌中不仅要有三种不同的花色，还要在每种花色中分别完成两组连续的顺子老少副。\n双龙的要求：在三色双龙会中，双龙是核心概念之一。所谓的“龙”指的是三组连续的顺子，在同一花色内形成一个完整的龙形结构。每种花色的顺子都必须是“1-2-3”和“7-8-9”这类连续顺子的形式。\n雀头的要求：实现三色双龙会并不容易，因为它要求三种花色中的每一种都能够形成两组特定的顺子（“1-2-3”和“7-8-9”）。且要求第三种花色的5作为雀头。\n三色双龙会的策略与实战意义 弃牌策略：为了达成三色双龙会，玩家必须合理放弃那些不符合构成条件的牌。例如，如果手中的某些牌无法组成连续的顺子或“龙”，玩家应该果断弃掉这些牌，以避免干扰自己的牌型。如果已经确定了某种花色的顺子组成，那么对于其他不必要的牌（尤其是其他花色的牌），玩家应该尽量弃掉，集中精力完成符合条件的顺子。\n摸牌与调整策略：在摸牌过程中，玩家应该根据已经完成的顺子和手中的牌来调整自己的摸牌目标。如果摸到的牌是符合三色双龙会结构要求的牌，玩家应优先保留；如果摸到的牌不符合条件，则应果断放弃。在一些情况下，摸牌的顺序可能影响完成牌型的进度，玩家需要灵活应对局势，不断调整策略。\n控制关键牌：如果某种花色的顺子已经构成，其他花色的顺子构建就会显得尤为重要。特别是在胡牌临近时，玩家需要更细致地观察其他玩家的弃牌情况，避免对方抢杠或碰到你要的关键牌。\n参考链接 三色双龙会\n一色三步高 什么是一色三步高？ 一色三步高是指基本和牌型中有一种花色序数依次递增 1 或 2 的三副顺子。例如，第一组顺子可能是1-2-3，第二组顺子可能是3-4-5，第三组顺子则是4-5-6，每组三个连续的顺子构成了一个高差递增的结构。\n一色三步高的牌型 以下是一色三步高的牌型举例：\n手牌：1万、2万、3万，3万、4万、5万，4万、5万、6万。\n其中：玩家的手牌完全由万字牌组成。且这三组顺子分别为：\n1万-2万-3万，3万-4万-5万，4万-5万-6万。这手牌中有一种花色三副依次递增一个或两个序数的顺子。\n一色三步高的番数 一色三步高的番数为16番，是一个非常高的番种，且比较难以实现。由于需要玩家在整理手牌时严格遵守“步高”的间隔要求，这增加了难度和复杂性。因此，获得一色三步高所需的技巧和运气相对较高。\n一色三步高的注意事项 步高的要求：步高的核心是每一组顺子与另一组顺子之间必须有依次递增一个或两个序数的顺子。这要求玩家在摸牌和弃牌过程中非常小心，避免形成不符合步高要求的牌型。\n三组顺子：一色三步高要求玩家手牌中的顺子要分布成三个独立的组，每个顺子都需要满足顺子构成的连续性和高差的要求。\n一色三步高的策略与实战意义 牌感与弃牌策略：实现一色三步高时，玩家需要有很强的牌感，能够判断哪些牌有可能帮助自己形成符合条件的顺子。在游戏过程中，如果摸到不符合步高条件的牌，应该及时弃掉，避免干扰自己牌型的构建。\n摸牌与调整策略：在摸牌过程中，玩家应该关注是否能通过摸牌形成符合要求的顺子。\n控制牌局节奏：一色三步高是一种较高番的牌型，因此，玩家可能会在胡牌时逐渐暴露出自己追求该番种的意图。此时，其他玩家可能会更倾向于拆牌或出掉对你有利的牌，玩家应灵活应对。玩家应保持冷静，尽量避免过早暴露自己的牌型。最理想的做法是在胡牌前尽量隐蔽，保持所有顺子结构的隐秘性。\n技巧与策略：由于一色三步高要求三组顺子之间有较大的间隔，玩家在选择是否碰牌、杠牌时需要非常谨慎，避免打乱自己的顺子结构。如果玩家已经有了某个花色的顺子，应该尽量保留相同花色的牌，以完成下一组顺子的构建。\n参考链接 一色三步高\n全带五 什么是全带五？ 全带五是指胡牌时，玩家的所有面子（顺子、刻子、杠）和将牌都必须包含“5”。这一番种强调每组牌都必须有一张5，且牌型需符合基本的胡牌结构。\n全带五的牌型 以下是全带五的牌型举例：\n顺子：345万、456万 刻子：555筒 将牌：55条\n全带五的番数 在国标麻将中，全带五是一个16番的番种，因其牌型中每组面子和将牌都必须包含“5”这张核心牌而得名。全带五不仅要求牌型具有一定的整齐度，还体现了高分番种的独特性。\n全带五的注意事项 每组面子必须带五：全带五要求每一组面子都必须包含“5”，如果任何一组面子不带“5”，则不符合全带五的条件。\n将牌必须是55：全带五的将牌必须是“5”的对子，其他数字或字牌的对子（如88筒或东东）均不符合条件。\n满足胡牌结构：必须满足国标麻将的基本胡牌条件：4组面子（顺子、刻子或杠）+1对将。\n全带五与其他番种的关系 门前清（2番）：如果全带五的胡牌过程中没有副露（碰牌、杠牌等），可叠加门前清番种。\n平和（2番）：如果全带是四组顺子，可叠加平和番种。\n全带五的策略与实战意义 起手判断：如果起手牌中有多张“5”或包含345、456等顺子，且将牌接近“55”，可以尝试全带五。如果起手中“5”牌较少或缺少关键牌（如4万、6筒等），建议放弃全带五目标。\n优先保留“5”相关的牌：在摸牌和打牌过程中，优先保留与“5”相关的组合（如345、456、55等），逐步构建全带五牌型。\n识别对手的全带五意图：如果对手频繁打出与“5”无关的牌，且保留多个“5”或345、456等组合，可能在追求全带五。\n参考链接 全带五\n三同刻 什么是三同刻？ 三同刻是指玩家的手牌中有三组相同的刻子（即三张完全相同的牌），这些刻子可以是：\n自摸的刻子（即自己摸到的三张牌组成的刻子），或者 碰牌后形成的刻子（即从其他玩家手中碰到的三张相同的牌）。\n三同刻的牌型 以下是三同刻的牌型举例：\n手牌：3万、3万、3万、7条、7条、7条、9筒、9筒、9筒。\n其中：玩家有三组3万、7条和9筒的刻子，第一组刻子是3万的三张，第二组刻子是7条的三张，第三组刻子是9筒的三张，这三组刻子符合三同刻的定义，并且是完全由相同的牌构成。\n三同刻的番数 三同刻的番数为16番，这是因为它的实现难度相对较大，要求玩家不仅要摸到多个刻子，还需要通过碰牌获得剩余的刻子，或者自己摸到一部分刻子。这种番种的实现几乎等于玩家在游戏中已经成功地完成了几乎全部的手牌结构，因此番数较高。\n三同刻的注意事项 三组同刻：手牌中必须有三组刻子，每组刻子由三张完全相同的牌组成。\n刻子的来源：这些刻子可以是自摸形成的，也可以是通过碰牌获得的。\n牌型要求：三组刻子可以是相同花色的（如三个万字、三个条子或三个筒子），也可以是混合花色的，具体取决于玩家的手牌。\n三同刻的策略与实战意义 摸牌策略：在游戏过程中，玩家应保持敏锐的牌感，尽量摸到自己需要的刻子，特别是当手中已经有两张相同的牌时，应该尽量通过摸牌或其他玩家的弃牌来形成最后一张。\n碰牌与杠牌：三同刻的实现可能需要借助碰牌或杠牌。如果其他玩家打出的牌能够帮助自己组成刻子，应该果断碰牌。碰牌后，剩下的两张牌就有可能帮助自己形成第三个刻子。\n观察对手的牌：实现三同刻时，玩家需要特别注意对手的弃牌情况。如果其他玩家已经弃掉了某些牌，而这些牌正好是自己所需要的刻子的一部分，那么可以选择碰牌或者等待自摸。\n参考链接 三同刻\n三暗刻 什么是三暗刻？ 玩家的手牌中必须包含三组暗刻，且这三组暗刻不可以是通过碰牌（向其他玩家要牌）形成的。这三组刻子必须由玩家自己手中的牌（包括自摸牌）组成。\n三暗刻的牌型 以下是三暗刻的牌型举例：\n手牌：4万、4万、4万、7条、7条、7条、2筒、2筒、2筒。\n其中：玩家的手牌包含了三组完全相同的刻子：4万、7条和2筒。每组都是由三张完全相同的牌组成。\n手牌：5万、5万、5万、8条、8条、8条、3筒、3筒、3筒。\n其中：5万、8条和3筒各自形成了暗刻，每组由三张相同的牌构成，并且都是自摸获得的。\n三暗刻的番数 三暗刻的番数为16番，这是因为它的实现难度较高。暗刻要求玩家手中必须有三张相同的牌，这使得玩家需要通过自摸或非常精确的摸牌策略来完成它。\n三暗刻的注意事项 暗刻：暗刻指的是玩家手中有三张完全相同的牌，且这些牌没有暴露给其他玩家。\n三组暗刻：玩家的手牌中必须有三组不同的暗刻，且每组都由三张完全相同的牌组成。\n自摸：三暗刻中的每一组暗刻必须是自摸的，即不能是从其他玩家处碰或杠得到的。\n三暗刻的策略与实战意义 摸牌策略：在追求三暗刻时，玩家应尽量通过自己摸到的牌来完成三组暗刻。可以优先保留自己手中的两张相同牌，等待第三张牌的出现。\n隐藏策略：在追求三暗刻时，应该尽量隐藏自己的牌型，避免暴露自己的暗刻。特别是在手中已经形成一个暗刻时，玩家应该避免通过碰牌或杠牌暴露这些刻子。\n对手的影响：由于三暗刻要求玩家没有通过碰牌或杠牌暴露的刻子，玩家应注意观察其他玩家的打牌情况，尽量避免手中的暗刻被其他玩家的碰杠打破。\n参考链接 三暗刻\n24 番 七对 什么是七对？ 七对是指玩家的手牌必须包含七对牌，且每一对牌必须由两张相同的牌组成。这七对牌不要求组成顺子或刻子，而是所有的牌都必须是对子的形式。可以是任何花色的牌，不限于同一花色。\n七对的牌型 以下是七对的牌型举例：\n手牌：1万、1万、3万、3万、5万、5万、7万、7万、9万、9万、2筒、2筒、4筒、4筒。\n其中：玩家手中有七对牌：1万、3万、5万、7万、9万、2筒、4筒，每一对都是两张相同的牌。因此，这手牌满足七对的条件，构成了七对这一番种。\n手牌：3万、3万、6条、6条、9筒、9筒、2筒、2筒、5万、5万、8条、8条、7条、7条。\n其中：这手牌同样有七对：3万、6条、9筒、2筒、5万、8条、7条，符合七对的构成。\n七对的番数 七对的番数为24番，是一个较为高番的番种。由于七对的牌型要求特殊且难以实现，玩家需要非常精确地选择弃牌并且对摸牌有很高的敏感度。因此，七对通常是一个在有较高难度的情况下才能实现的牌型。\n七对的注意事项 七对牌型：玩家的手牌中必须由七对完全相同的牌组成，每一对都由两张相同的牌组成。\n无需顺子或刻子：与传统的麻将牌型不同，七对并不要求顺子或刻子，只有一对一对的牌，七对牌完全由对子构成。\n无对子外的牌：除了七对之外，手牌中不能有其他单张牌。即玩家的所有牌都必须形成七对。\n七对的策略与实战意义 牌型的灵活性：七对的构成可以使用任意花色的牌，不局限于同一种花色。这使得玩家在构建七对时可以有更多的选择空间。例如，手牌可以是万字牌、条子牌、筒子牌的混合，这种灵活性给玩家更多的策略选择。\n保持对子结构：在追求七对时，玩家要尽量保持手中的对子，避免随意打出对子。尽量通过自摸来补齐缺失的对子，避免在摸牌过程中出现无法完成七对的情况。\n弃牌策略：由于七对不要求顺子和刻子，玩家可以避免打出那些可能让自己手牌变得不完整的牌。特别是当手中有多个对子时，应避免将单牌打出，而是要尽量保持对子，增加完成七对的机会。\n参考链接 七对\n七星不靠 什么是七星不靠？ 七星不靠是指胡牌时，玩家的牌型为全不靠，并且七种字牌（东、南、西、北、中、发、白）必须全部出现，加上147，258，369的七张序数牌组成的没有将牌的和牌。\n七星不靠的牌型 以下是七星不靠的牌型举例：\n字牌：东、南、西、北、中、发、白。 数牌： 5条、8条、1筒、4筒、3 万、6万、9万。\n七星不靠的番数 在国标麻将中，七星不靠是一个24番的顶级番种，是全不靠的特殊形式，要求玩家的牌型中必须包含所有七种字牌，体现出极高的挑战性和观赏性。\n七星不靠的注意事项 必须包含七种字牌：玩家手牌中必须包含东、南、西、北、中、发、白各一张，且这些字牌彼此独立，无重复。\n全不靠结构：数牌部分必须符合全不靠的条件，即所有数牌互不相连（如1万与2万3万），且不能重复。\n胡牌结构特殊：七星不靠的牌型本质上是特殊胡牌牌型，符合国标麻将的胡牌要求，不需要4组面子+1对将的结构。\n成型难度极高：七星不靠需要凑齐七种字牌和符合全不靠要求的数牌，难度极大，通常依赖极高的运气。\n七星不靠与其他番种的关系 清一色（24番）： 无法叠加，七星不靠要求三种花色的数牌和七种字牌，不可能是单一花色。\n七对子（24番）：无法叠加，七星不靠的牌型完全不同于七对子。\n七星不靠的策略与实战意义 起手判断：如果起手牌中包含五种或更多字牌，且数牌部分互不相连，可以尝试追求七星不靠，如果字牌数量不足或数牌无法调整为全不靠结构，建议尽早放弃，转向其他更容易达成的番种。\n优先保留字牌：在摸牌过程中，优先保留未出现的字牌，并逐步凑齐七种字牌。\n规划数牌的布局：数牌部分需逐步调整为全不靠结构，避免因出错导致牌型无法完成。\n参考链接 七星不靠\n全双刻 什么是全双刻？ 全双刻是指玩家的和牌完全由序数牌 2468 的刻子(杠)、将牌组成的基本和型，计 24 番。\n刻子（杠）：刻子是指三张相同的牌，杠也是四张相同的牌。在全双刻中，玩家的刻子或杠必须是序数牌中的2、4、6、8。 将牌：和牌中的将牌必须是序数牌中的2、4、6、8中的一张。通常情况下，和牌的将牌是用来作为雀头（对子的作用）。\n全双刻的牌型 以下是全双刻的牌型举例：\n2条、2条、2条、4万、4万、4万、4筒、4筒、4筒、6筒、6筒、6筒、8筒、8筒。 这个例子中，玩家的和牌是由4个刻子组成，同时雀头是8、8。因此，这就是一个典型的全双刻和牌，计24番。\n4万、4万、4万、6万、6万、6万、8筒、8筒、8筒、2筒、2筒、2筒、2筒（杠）6条、6条。 在这个例子中，玩家有3个刻子和1个杠子（2、2、2、2）以及雀头6、6。这个和牌也属于全双刻，计24番。\n全双刻的番数 全双刻是一个高分番种，在国标麻将中，它的得分通常为24番。这意味着，完成一个全双刻的和牌，会获得极高的分数，通常它需要较强的运气和技巧。\n全双刻的注意事项 刻子或杠：所有刻子（或者杠）必须是序数牌中的2、4、6、8这四张牌中的任意一张。例如，你可以有2、2、2（刻子），或者4、4、4（刻子），也可以有6、6、6（刻子），甚至是8、8、8（刻子）。这些刻子或杠必须满足完全是这四张牌。\n将牌：和牌的将牌也必须是序数牌中的2、4、6、8中的一张。例如，如果你的将牌是2，那么你会有2、2（雀头）。\n全双刻的和牌结构：全双刻的和牌由4个刻子（或杠）和1个将牌组成，且这些刻子和将牌必须来自2、4、6、8这四张序数牌。这种和牌型通常会有很高的得分，因为它的结构是相对复杂且需要较多的刻子或杠。\n全双刻与其他番种的关系 全双刻：不计碰碰和、断幺、无字 。\n双同刻（2番）：如果有两组点数相同花色不一样的刻子可以叠加双同刻。\n全双刻的策略与实战意义 高效选择牌：玩家应尽量收集2、4、6、8的序数牌，确保可以形成刻子和杠。如果你手中已经有某些数字的牌，比如4、4或6、6，你可以考虑把它们作为刻子或者杠来使用。\n留意雀头的选择：在进行全双刻时，雀头（将牌）也需要是2、4、6、8中的一张，因此玩家要特别留意这些牌型，并尽量收集它们。通常，雀头是一个对子的形式，可以通过碰牌或者摸牌获得。\n目标明确：在游戏开始时，玩家应明确自己的目标是全双刻，并且将所有的牌型都围绕着2、4、6、8这四张牌进行构建。避免手牌中出现其他花色或牌型，这样更容易实现目标。\n参考链接 全双刻\n清一色 什么是清一色 清一色是指玩家的和牌中全部由同一花色的牌组成，即所有的牌都是同一花色（万子、筒子或条子）组成的顺子、刻子、杠子，且不包含任何其他花色的牌。\n清一色的牌型 以下是清一色的牌型举例：\n1条，1条，2条，2条，3条，3条，4条，4条，5条，5条，6条，6条，7条，7条。 这个例子中的和牌是清一色条子，所有牌都由条子组成，形成了七对，因此这是一个清一色的和牌，得分为24番。\n1万，2万，3万，1万，2万，3万，3万，4万，5万，3万，4万，5万，6万，6万。 这个例子中的和牌是清一色万子，所有牌都由条子组成，形成了四组顺子和一个雀头，因此这是一个清一色的和牌，得分为24番。\n清一色的番数 在国标麻将中，清一色通常是24分番种。清一色是一个非常高的番种，要求玩家的和牌完全由同一花色构成，这对玩家的牌局控制和运气都有较高要求，因此它获得24番的高分。\n清一色的注意事项 同一花色：和牌中的所有牌必须是同一花色（万子、筒子、条子）的一部分。例如，全部是万子牌、条子牌或筒子牌，不能混合。例如：条子4、条子5、条子6（顺子），条子7、条子8、条子9（顺子），条子1、条子1（雀头），这些都是清一色的例子。\n构成方式：和牌的构成可以是顺子（连续的三张同花色牌）、刻子（三张相同的同花色牌）、杠子（四张相同的同花色牌）。玩家可以通过这些方式来完成清一色的和牌。例如，如果全是条子，那么可以有顺子条子1-2-3、条子4-5-6等，刻子可以是条子4、条子4、条子4。\n雀头选择：雀头必须是所选花色中的某一张牌（例如条子1、条子2、条子3等中的任何一张）。例如，如果你打算做清一色万子，那么雀头只能是万子的一张，如万子5。\n清一色与其他番种的关系 七对（24番）：如果手牌是由七组对子组成的，可以叠加七对。\n无字（1番）：清一色只有一种花色的序数牌，不计无字。\n连六（1番）：如果有两组同一花色且点数连续的顺子可以叠加连六。\n清一色的策略与实战意义 专注于一种花色：清一色要求所有的牌都来自一种花色，因此玩家从开局开始就要明确选择一种花色（万子、筒子或条子）作为目标花色。特别是如果你决定了某个花色作为清一色的目标，那么就应该尽量收集与之相关的牌。\n避免花色混合：在追求清一色的过程中，避免手牌中出现其他花色的牌。特别是要注意观察对家丢弃的牌，如果对家丢弃了某个花色的牌，不要尝试碰或吃这些牌，否则可能打乱你专注于某个花色的策略。\n适合进攻型玩家：清一色作为一个高分番种，适合那些喜欢进攻、快速和牌的玩家。通过高分番种的积累，玩家可以在短期内获得更多的分数，增强获胜的机会。\n减少多样性牌型的干扰：清一色的实现减少了需要考虑多个花色的复杂性，使得玩家的和牌路径更加明确和稳定。通过专注于一种花色，玩家可以在整个牌局中更加轻松地控制牌型结构。\n参考链接 清一色\n一色三同顺 什么是一色三同顺？ 一色三同顺的和牌结构要求玩家的和牌由同一花色的三副顺子组成，且每副顺子中的数字必须相同。一色三同顺的和牌型是同花色的三副顺子，且每副顺子的数字必须是一样的，例如三副都是1、2、3，三副都是4、5、6，或者三副都是7、8、9。\n一色三同顺的牌型 以下是一色三同顺的牌型举例：\n1万、2万、3万 、1万、2万、3万、1万、2万、6条、6条、6条、5筒、5筒。 这个例子中，玩家的和牌完全由万子1、万子2、万子3这三副顺子组成，且所有顺子都来自万子花色。雀头是筒子5，这是一个典型的一色三同顺，计24番。\n一色三同顺的番数 在国标麻将中，一色三同顺是一个高分番种，得分通常为24番。其高分来源于牌型的稀有性和难度，需要在和牌中拥有三副完全相同数字的顺子，并且这些顺子必须来自同一花色，这增加了达成的难度。\n一色三同顺的注意事项 同一花色：所有的顺子必须来自同一花色，比如万子、筒子或条子，不能混合花色。\n三副相同的顺子：三副顺子必须是相同数字的顺子。如：123万，123 条，123筒。第四组牌没有要求。\n雀头：和牌中可以有一个雀头（对子），但雀头并没有特别的限制，它可以是任何一对牌，只要不违反其他的和牌规则。\n一色三同顺与其他番种的关系 箭刻（2番）：手牌中含有箭牌组成的刻字或者杠子，可叠加箭刻。\n缺一门（1番）：手牌中缺少序述牌的一种，可叠加缺一门。\n一色三同顺的策略与实战意义 专注于同一花色：玩家必须专注于收集同一花色的牌（万子、条子或筒子），避免将其他花色混入手牌。通过专注于一个花色，可以提高形成顺子的概率。\n收集相同数字的牌：一旦确定了目标花色，玩家应该尽量收集相同数字的牌。例如，若决定选择万子花色，目标是收集万子1、万子2、万子3，然后尽量收集这三种数字的牌，以便形成三个相同的顺子。\n雀头的选择：雀头并不对一色三同顺有特殊限制，因此可以是任何一对牌。雀头的选择应以容易摸到的牌为主，尤其是当你手中已有某些对子时，可以将其作为雀头。\n参考链接 一色三同顺\n一色三节高 什么是一色三节高？ 一色三节高 指的是由同一种花色的三副依次递增的刻子（或杠） 组成的一种特殊牌型。\n一色三节高的牌型 以下是一色三节高的牌型举例：\n万子：111万、222万、333万 + 55筒 + 678条。 这里的 111万、222万、333万 是三节高的刻子，构成了一色三节高。\n筒子：777筒、888筒、999筒 + 33条 + 123万。 这里的 777筒、888筒、999筒 是三节高的刻子，构成了一色三节高。\n一色三节高的番数 一色三节高的基础番值是24番。属于中高级别的番种，在实际对局中较少见，难度较高。\n一色三节高的注意事项 同一种花色：必须是条、筒、万中的其中一种花色（不能混花色）。\n三副刻子：牌型中包含三个相邻序数的刻子（三张相同的牌构成的，例如 111、222、333）。\n序数相连：三个刻子在序数上必须依次递增，例如：111、222、333（序数相连的刻子），456、567、678 等不符合要求，因为它们不是刻子。\n不限其他部分：除了这三副刻子外，其他部分（如雀头、顺子等）可以是任意的，没有特别限制。\n一色三节高与其他番种的关系 碰碰胡（6番）：通常会与碰碰胡（全部由刻子组成的胡牌）同时满足。\n缺一门（1番）：手牌中缺少序述牌的一种，可叠加缺一门。\n一色三节高的策略与实战意义 合理选择花色：在追求一色三节高时，玩家应根据自己手中的牌来选择适合的花色。如果手中有多个顺子，且这些顺子可以构成节高结构，应该尽快集中精力收集这一花色的牌。一旦决定追求一色三节高，玩家就应该尽量避免弃掉任何能够帮助构成顺子的牌。\n灵活调整战略：追求一色三节高时，玩家应当灵活调整战略。如果初期手牌不适合构建这一番种，玩家应该根据牌局的进展及时放弃，并尝试转向其他可能的番种。\n注意摸牌与碰牌：在一些情况下，玩家可能需要通过碰牌和杠牌来快速完成手牌。\n参考链接 一色三节高\n全大 什么是全大？ 全大（24番）是国标麻将中的一个高番种，它要求玩家的所有牌都为“大牌”，即牌面数字为7、8、9组成的牌。这个番种的目标是通过收集7、8、9等大牌来构建手牌。\n全大的牌型 以下是全大的牌型举例：\n7条、8条、9条、7筒、8筒、9筒、8万、8万、8万、9万、9万、9万、7万、7万。 这个手牌完全由7到9的牌构成，符合全大的条件，且是一个有效的全大番种。\n全大的番数 全大的番数为24番，是国标麻将中的一个高番种。由于这一番种要求玩家收集全部的大牌（7到9），其难度较高，因此番数也很高。\n全大的注意事项 所有牌必须是大牌：全大的核心要求是不包含小牌。这意味着玩家要尽量避免拿到1、2、3、4、5、6等小牌，因此要灵活调整手牌策略。玩家在起手时可以优先考虑组成7、8、9这些牌的顺子或刻子。\n难度较高：实现全大的难度较高，因为玩家只能收集7到9的牌。如果牌局中已经有其他玩家在竞争相同的牌，可能会导致玩家很难完成全大的要求。由于全大要求每一张牌都是大牌，因此玩家需要有更多的耐心和判断力来适应局势，避免盲目追求这个高番种。\n多使用顺子与刻子：玩家要合理利用顺子和刻子构建自己的牌型。在大多数情况下，玩家会通过顺子来快速组成牌型。同时，也可以通过刻子（例如3个相同的大牌）来补充牌型。\n自摸与听牌：自摸可以帮助玩家快速完成全大的牌型，尤其是当手中已有多个顺子和刻子时。自摸的优势在于可以完全控制自己的牌型，不会受到其他玩家放弃牌的影响。\n全大与其他番种的关系： 三色三同顺（8番）：如果手牌中包含三种花色的顺子，可以叠加三色三同顺。\n全带幺（4番）：如果手牌中包含9的顺子或者刻字，可以叠加全带幺。\n幺九刻（1番）： 如果手牌中包含9的刻字，可以叠加幺九刻。\n全大的策略与实战意义 多使用顺子与刻子：玩家要合理利用顺子和刻子构建自己的牌型。在大多数情况下，玩家会通过顺子来快速组成牌型。同时，也可以通过刻子（例如3个相同的大牌）来补充牌型。\n牌局分析：在实战中，玩家可以根据自己手中的牌，判断是否适合追求全大。如果手牌有许多小于7的牌，玩家应该尽快调整，放弃小牌，集中精力收集7到9的牌。\n防守意识：玩家也可以通过观察其他玩家的弃牌，推测哪些牌已经被较多玩家获取，从而避免手牌中出现冗余的牌。\n参考链接 全大\n全中 什么是全中？ 全中指的是玩家的和牌必须完全由序数牌4、5、6来组成，可以是顺子，也可以是刻子或杠子，只要这些牌是4、5、6的组合。关键在于，所有的牌都要来自同一花色（条子、万子或筒子），并且必须是4、5、6这三张序数牌中的任意组合。\n全中的牌型 以下是全中的牌型举例：\n4条、4条、4条、5条、5条、5条、6条、6条、6条、4万、5万、6万、4万、4万。 这个手牌完全由4到7的牌构成，符合全中的条件，且是一个有效的全中番种。\n全中的番数 全中是国标麻将中的一个24分番种，要求玩家的和牌必须由数字4、5、6组成，而不需要考虑花色。这些牌可以通过顺子、刻子或杠子的方式组合而成，并且雀头必须是4、5或6中的一张。\n全中的注意事项 构成要求：所有和牌必须由4、5、6这三张序数牌组成，且这些牌要来自同一花色。可以由多个顺子（如4-5-6）、刻子（如4-4-4、5-5-5、6-6-6）或杠子（如4-4-4-4、5-5-5-5、6-6-6-6）组合而成。\n确保和牌中的所有牌都是4、5、6的组合：全中的和牌需要所有的牌都来自4、5、6，所以确保你的牌池中没有不符合这个条件的牌。\n雀头选择：雀头可以是4、5、6中的任何一个，所以要根据你的手牌情况，选择一个合适的雀头。\n全中与其他番种的关系 全双刻（24番）：如果手牌中有4和6组成的刻字或者杠子则可以叠加全双刻。\n三同刻（16番）：如果满足有三个相同的刻字则可以叠加三同刻。\n全中的策略与实战意义 目标集中：全中要求和牌仅由数字4、5、6的牌型构成，这意味着你在整个游戏过程中需要确保所有的牌都围绕这三个数字展开。因此，选择一个目标花色（条子、万子或筒子）并始终专注于收集这三个数字的组合至关重要。\n吃牌、碰牌、杠牌的灵活使用：如果你手中已经有条子4或条子6，可以通过吃条子5来组成顺子。如果你已经有两张相同的牌（例如条子5、条子5），你可以通过碰牌来收集第三张相同的牌，快速完成刻子。\n利用对家的舍牌：在整个牌局中，密切观察对家的舍牌。尤其是他们是否丢弃了你所需的4、5、6中的某张牌。例如，如果对家丢弃了条子5，那么你就可以通过碰或者吃牌的方式收集它，快速完成你的顺子。\n参考链接 全中\n全小 什么是全小？ 全小是国标麻将中的一个高番种，它要求玩家的手牌中只能包含小牌，即1、2、3这三张牌，不允许出现4到9的任何“大牌”。这一番种对玩家的牌型组合有严格的要求，需要玩家集中精力去收集这些小牌，且手牌的构成要尽量依赖于1到3的牌。\n全小的牌型 以下是全小的牌型举例：\n1万、2万、3万、1筒、2筒、3筒、1条、2条、3条、1条、2条、3条、2万、2万。 这个手牌完全由小牌（1、2、3）构成，符合全小的条件，且形成了多个顺子。\n示例2：\n1万、2万、3万、1万、2万、3万、1筒、1筒、1筒、1条、2条、3条、1条、1条。 这个手牌也符合全小的条件，虽然其中有一对刻子（1筒、1筒、1筒），但仍然符合全小的规则。\n全小的番数 全小的番数为24番，是国标麻将中的高番种。由于全小要求手牌完全由小牌构成，且不允许包含任何大牌，因此其番数较高。\n全小的注意事项 所有牌必须是小牌：小牌包括1、2、3这几张牌。玩家的手牌中只能包含这三张牌，不允许出现其他任何4到9的“大牌”。\n牌型可以是顺子、刻子或杠子：为了完成全小，玩家可以通过收集1、2、3等小牌来形成顺子（例如：1条、2条、3条）或者刻子（例如：1万、1万、1万）等牌型。\n全小与其他番种的关系 七对（24番）：如果是由七组对子组成的牌可以叠加七对。\n四归一（2番）：如果手牌中包含四张牌则可以记四归一。\n小于五（12番）：由于全小的牌必须要小于5所以不能记小于五。\n无字（1番）：由于全小只包含序数牌所以不能记无字。\n全小的策略与实战意义 顺子和刻子的灵活搭配：玩家可以通过顺子和刻子来快速构建手牌，特别是顺子的构成非常灵活。例如：1条、2条、3条可以形成一个顺子；1万、1万、1万可以形成一个刻子。\n调整手牌，避免大牌：在牌局初期，玩家应该密切注意手牌中是否已经有大牌（如5到9的牌），如果有，应该尽早打掉它们，集中精力收集1到3的小牌。如果玩家起手就拥有一些大牌，尽量将其替换掉，确保手牌中的所有牌都是1到3。\n参考链接 全小\n32 番 一色四步高 什么是一色四步高？ 一色四步高是指在同一花色中，由四组相邻的数牌顺子，且这些顺子的首牌或尾牌之间有“步进关系”，即它们的数字是递增或递减的。\n一色四步高的牌型 以下是一色四步高的牌型举例：\n假设花色为筒：123筒 + 234筒 + 345筒 + 456筒 或者 123筒 + 345筒 + 567筒 + 789筒\n花色为条：456条 + 567条 + 678条 + 789条\n一色四步高的番数 在国标麻将中，“一色四步高”是32番的一个番种。是指在同一花色中，由四组相邻的数牌顺子，且这些顺子的首牌或尾牌之间有“步进关系”，即它们的数字是递增或递减的。\n一色四步高的注意事项 同一花色：所有涉及的牌必须是条、筒、万中的一种，不能混用。\n四步递进：四组顺子的数字之间必须有规律的“步进关系”。 步进关系可以是连续的，比如 123 → 234 → 345 → 456。也可以是递增间隔一致的，比如 123 → 345 → 567 → 789。\n一色四步高与其他番种的关系 一色四步高是一个高级番种，但在形成过程中，可能会同时满足其他低番的条件。\n清一色（24番）：所有牌都是同一花色，一色四步高必定满足清一色。\n一般高（1番）：若形成中有两组完全相同的顺子。\n平和（2番）：如果听牌形式为顺子构成，并且没有字牌或碰牌。\n一色四步高的策略与实战意义 牌局分析：一色四步高一般适合在前期抓到大量同花色数牌时作为目标。\n灵活调整：如果发现无法凑齐四步递增，可以退而求其次做“一色三步高”或“清一色”等番种。\n防守意识：在对手明显凑同一花色时，要警惕对方可能在追求高分番种如“一色四步高”。\n参考链接 一色四步高\n三杠 什么是三杠？ 三杠是指玩家在牌局中，使用了三组杠牌来组成胡牌牌型。这三组杠牌可以是明杠、暗杠，或者两者的混合，但必须在同一局中完成。\n三杠的牌型 以下是三杠的牌型举例： 杠牌：1111筒（暗杠）、2222万（明杠）、3333条（加杠） 其他：456万 + 55条（对子） 胡牌时，这套牌满足三组杠的条件，并且凑成了胡牌结构。\n三杠的番数 三杠为32番，属于国标麻将中的高分番种，达成难度极高，因为杠牌不仅依赖自己摸牌，还需考虑对局中的碰牌与他人打出的牌，若对手意识到你在追求杠，可能会故意避免打出你需要的牌。\n三杠的注意事项 三组杠牌：玩家必须拥有三组杠，每组杠由四张相同的牌组成。\n完成胡牌：除了三组杠之外，玩家还需凑齐完整的胡牌牌型（包括4组面子+1对将）。\n三杠与其他番种的关系 三杠在达成过程中，可能会同时触发其他番种，增加总番值。\n双暗杠（6番）：如果三杠中包含两组暗杠，可以叠加双暗杠番种。\n明杠（1番）：如果三杠中有明杠，可以叠加明杠番种。\n碰碰胡（6番）：三杠通常会与碰碰胡（全部由刻子组成的胡牌）同时满足。\n四归一（2番）：如果三杠中的杠牌是先有一刻子再摸到第四张，也可能触发四归一。\n三杠的策略与实战意义 适合局势：三杠通常适合在起手牌中有大量对子、刻子，甚至杠牌的情况下考虑。\n防守注意：杠牌时要注意可能被其他玩家抢杠胡。如果发现很难达成三杠，应及时调整目标，转向碰碰胡或其他易成型的番种。\n参考链接 三杠\n混幺九 什么是混幺九？ 混幺九是指玩家的胡牌牌型由字牌（东南西北中发白）和数牌的1与9组成，且必须满足胡牌的基本结构要求（4组面子+1对将）。\n混幺九的牌型 以下是混幺九的牌型举例： 111万 + 999筒 + 111条 + 西西西 + 中中 111筒 + 999条 + 北北北 + 白白白 + 发发 混幺九的番数 混幺九为32番，是中高难度的番种。字牌容易碰或杠，因此组刻的效率较高，对对手而言，混幺九的牌型较容易被察觉，一旦副露字牌过多，可能被针对性防守。\n混幺九的注意事项 牌型要求：字牌：只能包含东、南、西、北、中、发、白这七种牌。数牌：只能包含1和9的万、筒、条，不能包含其他的数牌（2到8）。\n将牌：将牌可以是任意的字牌或数牌的1、9。\n对子不能单独计入：如果某组牌不足以形成刻子（如只有两个字牌或1、9），不能计入混幺九的番种要求。\n混幺九与其他番种的关系 混幺九在形成过程中，可以与其他番种叠加，增加总番值。\n碰碰胡（6番）：混幺九通常是由全刻子组成，因此必然满足碰碰胡的条件。\n双暗刻（2番）：如果胡牌中有两组暗刻，叠加双暗刻。\n明杠（1番）/暗杠（2番）：若混幺九的刻子通过杠牌形成，可额外计入杠牌番种。\n字一色（64番）：如果混幺九中的数牌被替换成全部字牌，则升级为字一色。\n清幺九（64番）：若混幺九中没有字牌，全是1和9的数牌，则升级为清幺九。\n混幺九的策略与实战意义 起手判断：当起手牌中包含多张字牌以及1、9数牌时，可以考虑追求混幺九。\n灵活转化： 若字牌不足，可尝试退而求其次选择碰碰胡或清一色，若摸到更多字牌，可向字一色方向进攻。\n吃碰杠技巧：混幺九需要大量刻子，碰或杠牌是快速成型的重要途径，但需要注意避免暴露意图。\n防守意识： 如果对手副露大量字牌且配合1、9数牌，需要警惕其可能做混幺九或字一色，避免轻易打出字牌或1、9的数牌，尤其是对其听牌时。\n参考链接 混幺九\n48 番 一色四同顺 什么是一色四同顺？ 一色四同顺是指在胡牌的牌型中，存在四组完全相同的顺子，并且这些顺子必须属于同一花色（万、筒、条）。\n一色四同顺的牌型 以下是一色四同顺的牌型举例：\n四同顺：123条 + 123条 + 123条 + 123条 将牌：99条 或者以筒子为例：\n四同顺：456筒 + 456筒 + 456筒 + 456筒 将牌：88筒\n一色四同顺的番数 一色四同顺为48番，是国标麻将中极高分的番种。达成一色四同顺的难度极高，因为需要四组完全相同的顺子，而单花色的顺子数量有限。\n一色四同顺的注意事项 同一花色：所有的牌必须是万、筒或条中的一种，不能混用。\n四同顺：四组顺子完全相同。例如，123万 + 123万 + 123万 + 123万。\n完整胡牌结构：在拥有四同顺的同时，必须满足胡牌的基本结构要求，即4组面子+1对将。\n必须四组完全相同的顺子：有些玩家可能混淆为“四组步进关系的顺子”（如123、234、345、456），这属于“一色四步高”而非一色四同顺。\n一色四同顺与其他番种的关系 一色四同顺是一种极高番值的番种，在形成过程中，可能同时满足其他番种条件，进一步提高总番值。\n清一色（24番）：由于一色四同顺的所有牌都属于同一花色，必定满足清一色。\n平和（2番）：如果胡牌的最终听牌形式为顺子组成，且没有碰牌或字牌，可能同时满足平和。\n四归一（2番）：若形成四同顺的过程中，有重复使用的单张牌，可能触发四归一。\n一色四同顺的策略与实战意义 识别对手意图：如果对手不碰字牌或其他花色的牌，专注于摸某一花色的顺子时，可能在做一色高分番种。\n控制关键牌：通过推测对手可能需要的顺子牌（如123万的1万、2万、3万），尽量避免打出，尤其是关键时刻。\n参考链接 一色四同顺\n一色四节高 什么是一色四节高？ 一色四节高是指在胡牌牌型中，由同一花色的四组刻子（或杠）组成，并且这些刻子的数字是依次递增的（即“节节高”）。\n一色四节高的牌型 以下是一色四节高的牌型举例：\n假设胡牌花色为条：\n111条 + 222条 + 333条 + 444条 + 55条（将牌） 假设胡牌花色为万：\n777万 + 888万 + 999万 + 1111万（杠）+ 东东（将牌）\n一色四节高的番数 一色四节高为48番，是国标麻将中一种高难度、高收益的番种，其形成需要极高的摸牌能力和策略规划。在追求过程中，玩家需要综合考虑手牌、场上形势，以及对手的防守策略。\n一色四节高的注意事项 同一花色：所有的刻子（或杠）必须来自同一花色（万、筒、条），不能混用。\n依次递增：四组刻子的数字需要递增，例如：111万、222万、333万、444万，777筒、888筒、999筒、1111筒。\n完整胡牌结构：除了四组刻子外，还需要一个将牌（对子）来满足胡牌条件。\n一色四节高与其他番种的关系 一色四节高在形成过程中，可能会同时满足其他番种，进一步提高总番值。\n清一色（24番）：一色四节高的所有牌均为同一花色，必然满足清一色。\n碰碰胡（6番）：由全刻子组成，必然符合碰碰胡的条件。\n双暗刻（6番）：如果有两组暗刻，可以叠加双暗刻。\n一色四节高的策略与实战意义 起手判断：如果起手有两组或更多的同花色刻子，且数字递增，可以尝试追求一色四节高。\n灵活调整：如果发现难以凑齐四组递增的刻子，可以转向清一色、碰碰胡或其他更易成型的番种。\n防止暴露意图：避免过早的副露或碰牌，尽量通过暗刻或杠牌成型，以隐藏意图。\n听牌选择：一色四节高的听牌通常较少，因此需要在成型阶段尽量多摸牌，减少对其他玩家的依赖。\n参考链接 一色四节高\n64 番 清幺九 什么是清幺九？ 清幺九是指玩家胡牌时，所有的牌都是由1和9的数牌组成（不能包含字牌），并且必须满足胡牌的基本结构要求（4组面子+1对将）。\n清幺九的牌型 以下是清幺九的牌型举例：\n胡牌时的花色为筒：111筒 + 999筒 + 111筒 + 999筒 + 99筒（将牌）\n胡牌时的花色为条：111条 + 111条 + 999条 + 999条 + 99条\n清幺九的番数 清幺九为64番，是国标麻将中顶级番种之一，由于只能使用1和9的数牌，选择面非常狭窄，需要玩家高度集中于特定牌型。\n清幺九的注意事项 只能包含1和9的数牌：仅限万、筒、条中的1和9。不能包含字牌（东、南、西、北、中、发、白）或其他数牌（2-8）。\n牌型要求：必须满足国标麻将胡牌的基本结构，即4组面子（顺子、刻子或杠）+1对将。\n完整同花色：如果牌中有字牌，或1和9以外的数牌，则不能算作清幺九。\n清幺九与其他番种的关系 清幺九作为高分番种，在形成过程中，可能会叠加其他番种，提高总番值：\n双暗刻（2番）：如果胡牌时有两组暗刻（未碰牌直接形成的刻子），可叠加双暗刻。\n单钓将（1番）：如果听牌时只单独等待将牌（如99筒），可以叠加单钓将。\n清幺九的策略与实战意义 起手判断：如果起手中拥有多组1和9的数牌（尤其是对子或刻子），可以考虑追求清幺九若起手牌缺乏1和9，或字牌过多，则应及时放弃清幺九的尝试。\n副露策略：清幺九通常需要碰牌和杠牌来加速形成刻子，因此需要适时副露，但副露会暴露牌型意图。在副露过程中，尽量隐藏将牌的组合，避免对手过早防守。\n调整目标：如果清幺九难以成型，可退而求其次做碰碰胡或清一色，以减少损失。\n听牌选择：清幺九的听牌范围较窄（1和9的单牌或对子），需要在听牌前充分规划。\n参考链接 清幺九\n小四喜 什么是小四喜？ 小四喜是指胡牌的牌型中，玩家拥有东、南、西、北四组风牌中的三组刻子（或杠），并以第四组风牌作为将牌（对子）。简单来说，四种风牌都必须出现在胡牌结构中。\n小四喜的牌型 以下是小四喜的牌型举例：\n东东东（刻子） + 南南南（刻子） + 西西西（刻子） + 北北（将牌） + 123筒（顺子） 东东东（刻子） + 南南南（刻子） + 西西西（刻子） + 北北北北（杠，暗刻可算）+ 88筒（将牌）\n小四喜的番数 小四喜为64番，是国标麻将中的顶级番种之一，仅次于大四喜和字一色等番种。小四喜需要玩家手中收集所有风牌，或者通过碰牌、杠牌来完成刻子，成型难度较大。\n小四喜的注意事项 四种风牌必须齐全：必须包含东、南、西、北这四种风牌。其中，三组为刻子（或杠），一组为将牌（对子）。\n胡牌结构完整： 小四喜需要满足国标麻将的基本胡牌结构，即4组面子（顺子、刻子或杠）+1对将。\n不允许其他字牌作为将牌： 中、发、白不能作为将牌；将牌只能是第四种风牌的对子。\n小四喜与其他番种的关系 小四喜作为高分番种，在形成过程中可能叠加其他番种，从而进一步提高总番值。\n碰碰胡（6番）：如果小四喜的胡牌由全刻子组成，可以叠加碰碰胡。\n明杠（1番）/暗杠（2番）：如果小四喜的刻子中有杠牌，可以叠加杠牌的番种。\n混一色（6番）：如果除风牌外的其他面子全是同一花色，可叠加混一色。\n小四喜的策略与实战意义 起手判断：如果起手牌中已经有两组或更多的风牌刻子/对子，可以尝试追求小四喜。\n副露策略：小四喜通常需要碰牌或杠牌，因此可以适时副露。但副露后容易暴露意图，对手可能会针对性防守。\n灵活调整：如果风牌不足以凑齐小四喜，可以转向碰碰胡或混一色等其他番种。\n快速听牌：为了减少对手的防守机会，尽量通过暗刻或自摸快速进入听牌阶段。\n参考链接 小四喜\n小三元 什么是小三元？ 小三元是指玩家的胡牌牌型中，必须包含中、发、白三组字牌中的两组刻子（或杠），并以第三种字牌作为将牌（对子）。这意味着三种字牌必须全部出现在胡牌结构中。\n小三元的牌型 以下是小三元的牌型举例：\n中中中（刻子） + 发发发（刻子） + 白白（将牌） + 123万 + 789筒 中中中（刻子） + 白白白（刻子） + 发发（将牌） + 666筒 + 444条 中中中中（杠） + 发发发发（杠） + 白白（将牌） + 111万 + 999筒\n小三元的番数 小三元为64番，是国标麻将中的顶级高分番种之一，仅次于大三元和字一色等番种。小三元要求玩家在牌局中收集全部的中、发、白字牌，其中两组需凑成刻子，且不能副露第三种作为刻子，这对摸牌和策略要求较高。\n小三元的注意事项 三种字牌齐全：必须包含中、发、白三种字牌。两种为刻子或杠牌，第三种为将牌（对子）。\n胡牌结构完整：小三元的牌型必须满足国标麻将的基本胡牌结构，即4组面子（顺子、刻子或杠）+1对将。\n小三元与大三元的区别 小三元（64番）：中、发、白三种字牌中，两种为刻子，一种为将牌。\n大三元（88番）：中、发、白三种字牌全部为刻子或杠，没有对子。\n注意：大三元的番值更高，因为其牌型要求更加严格，难度更大。\n小三元的策略与实战意义 起手判断：如果起手牌中已经有中、发、白的对子或刻子，可以考虑追求小三元。\n副露策略：小三元通常需要通过碰牌或杠牌快速凑齐刻子，但副露后可能暴露意图，在副露过程中尽量隐藏胡牌的将牌，避免对手防守。\n灵活调整：如果发现字牌不足，可以转向碰碰胡、混一色等其他较易达成的番种。\n听牌选择：小三元的听牌范围通常较广，因为将牌和其他面子可以灵活组合。\n参考链接 小三元\n字一色 什么是字一色？ 字一色是指玩家的胡牌牌型全部由字牌（东、南、西、北、中、发、白）组成，且必须满足国标麻将的胡牌基本结构要求（4组面子+1对将）。\n字一色的牌型 以下是字一色的牌型举例：\n东东东（刻子） + 南南南（刻子） + 中中中（刻子） + 白白白（刻子） + 发发（将牌）。 带杠牌：\n北北北北（杠） + 东东东（刻子） + 中中中（刻子） + 发发发（刻子） + 白白（将牌）。 暗刻与明刻结合：\n南南南（暗刻） + 西西西（明刻） + 中中中（暗刻） + 北北北（明刻） + 东东（将牌）。\n字一色的番数 字一色为64番，是国标麻将中的顶级高分番种之一。字牌数量有限（每种仅4张，共28张），达成字一色需要极高的运气。\n字一色的注意事项 仅限字牌：胡牌时不能包含任何数牌（万、筒、条）。只能使用东、南、西、北、中、发、白这7种字牌。\n胡牌结构完整：必须满足国标麻将的胡牌基本结构，即4组面子（刻子、杠或顺子）+1对将。字牌不能组成顺子，因此字一色的面子全部由刻子或杠牌构成。\n字一色的常见误区 必须全为字牌：如果牌型中包含任何数牌（万、筒、条），不能算作字一色。\n不能有顺子：字牌无法组成顺子，因此字一色的面子必须是刻子或杠牌。\n与大四喜、小四喜的区别：\n大四喜：四组面子全部为东、南、西、北的刻子或杠牌。 小四喜：东、南、西、北中的三组为刻子，一组为将牌。 字一色：所有牌均为字牌，但不限于风牌。\n字一色的策略与实战意义 起手判断：如果起手牌中有多组字牌对子或刻子（如东东东、南南），且其他字牌数量较多，可考虑追求字一色。如果起手字牌较少，建议直接放弃字一色目标。\n副露策略：字一色通常需要碰牌或杠牌快速凑齐刻子，但副露会暴露意图。尽量通过暗刻或自摸完成面子，减少副露以防对手针对性防守。\n灵活调整：如果字一色难以成型，可以退而求其次做小四喜或碰碰胡等番种。\n听牌选择：字一色的听牌范围通常较窄（字牌单张或对子），因此需要尽量减少对手的摸牌回合。\n参考链接 字一色\n四暗刻 什么是四暗刻？ 四暗刻是指胡牌的牌型中，包含四组暗刻，并以一个将牌（对子）完成胡牌结构。四暗刻的特点是：所有刻子（或杠牌）均为暗刻，不能通过副露（碰牌或杠牌）形成。\n四暗刻的牌型 以下是四暗刻的牌型举例：\n111筒（暗刻） + 999筒（暗刻） + 222万（暗刻） + 777条（暗刻） + 55筒（将牌）。 带暗杠：\n3333条（暗杠） + 666筒（暗刻） + 888万（暗刻） + 999万（暗刻） + 11条（将牌）。 特殊听牌：\n444条（暗刻） + 555筒（暗刻） + 888筒（暗刻） + 999筒（暗刻） + 11筒（单钓听牌）。\n四暗刻的番数 四暗刻为64番，需要摸齐四组暗刻且满足胡牌条件，暗刻数量较少导致牌型受限。\n四暗刻的注意事项 四组暗刻：四组刻子必须全部是暗刻，即通过摸牌或自摸形成的刻子，不能是碰牌或明杠。暗杠也算作暗刻的一种。\n完整胡牌结构：除了四组暗刻外，还需要一个将牌（对子）组成胡牌结构。\n胡牌方式：通常需要自摸胡牌，但在特殊情况下，若听牌时单独等待将牌（单钓将），可通过点炮胡牌。\n四暗刻与其他番种的关系 四暗刻作为顶级番种，在形成过程中可能叠加其他番种，进一步提升总番值：\n暗杠（2番）：如果四暗刻的某些暗刻升级为暗杠，可叠加暗杠的番种。\n单钓将（1番）：如果听牌时单独等待将牌（如55筒单钓5筒），可以叠加单钓将。\n四暗刻的策略与实战意义 起手判断：如果起手牌中已有两组以上的对子或暗刻，可以考虑追求四暗刻。\n暗刻优先：在摸牌过程中，优先保留对子或刻子的雏形，避免轻易副露打破暗刻可能性。\n防止暴露意图：四暗刻的意图较难被察觉，但尽量避免过早亮明将牌，以降低对手防守力度。\n听牌规划：四暗刻的听牌形式通常较少，建议优先选择较安全或隐蔽的听牌方式（如单钓）。\n参考链接 四暗刻\n一色双龙会 什么是一色双龙会？ 一色双龙会是指玩家在胡牌时，牌型中包含同一花色的两组老少副顺子（123和789），且以同一花色的5牌作为将牌（对子）。\n一色双龙会的牌型 以下是一色双龙会的牌型举例：\n123筒（顺子）+ 789筒（顺子）+ 123筒（顺子）+ 789筒（顺子）+ 55筒（将牌）。 123条（顺子）+ 789条（顺子）+ 456条（顺子）+ 789条（顺子）+ 55条（将牌）。\n一色双龙会的番数 一色双龙会为64番，是国标麻将中的顶级番种之一。需要同时形成两组老少副顺子，且保证将牌为5，限制性较强。通常听牌的范围较窄，且需要合理规划手牌以满足胡牌结构。\n一色双龙会的注意事项 单一花色：牌型必须全部为万、筒或条中的一种，不能混合使用花色。\n两组老少副顺子：必须有两组123和789的顺子，且这两组顺子属于同一花色。\n将牌为中张5：将牌必须是该花色的5牌（如5筒、5万、5条）。\n胡牌结构完整：除上述牌型外，还需额外的一组顺子或刻子（面子）来满足胡牌条件（4组面子+1对将）。\n一色双龙会与其他番种的关系 一色双龙会是一个独立的番种，但在形成过程中可能叠加其他番种，从而进一步提高总番值。\n清一色（24番）：一色双龙会的所有牌均为单一花色，必然符合清一色。\n平和（2番）：如果胡牌的最终听牌形式是顺子构成且没有碰牌，可以叠加平和。\n一色三步高（16番）：如果牌型中包含三组步进顺子（如123、456、789），可叠加一色三步高。\n一色双龙会的策略与实战意义 起手判断：如果起手牌中某一花色的123、789或55的中张牌较多，可以尝试朝一色双龙会方向发展。\n灵活调整：如果发现难以同时形成两组老少副顺子，可以转向清一色或一色三步高等较易达成的番种。\n隐藏意图：避免过早副露顺子，以降低对手的防守意识。\n听牌选择：一色双龙会的听牌范围较广（通常可以听多张牌），尽量选择更隐蔽或难以被对手察觉的听牌形式。\n参考链接 一色双龙会\n88 番 大四喜 什么是大四喜？ 大四喜是指胡牌的牌型中，包含东、南、西、北四组风牌的刻子（或杠），即风牌必须全部成刻子，且必须满足国标麻将的基本胡牌结构（4组面子+1对将）。\n大四喜的牌型 以下是大四喜的牌型举例：\n东东东（刻子） + 南南南（刻子） + 西西西（刻子） + 北北北（刻子） + 55筒（将牌）。 东东东东（杠） + 南南南（刻子） + 西西西西（杠） + 北北北（刻子） + 66万（将牌）。 大四喜的番数 大四喜为88番，是国标麻将中的最高番种之一，需要四组风牌形成刻子或杠，这要求玩家起手风牌较多，或通过摸牌、副露凑齐。由于其成型难度和对运气、技巧的极高要求，能够成功胡出大四喜是玩家牌技和耐心的极大体现。\n大四喜的注意事项 风牌齐全：必须包含东、南、西、北这四种风牌。\n四组刻子或杠：东、南、西、北这四种风牌都必须形成刻子（或杠）。不能有单独的对子或孤张的风牌。\n完整胡牌结构：除了四组风牌的刻子外，还需要一个将牌（对子）来满足胡牌条件。\n大四喜与其他番种的关系 小四喜（64番）：如果牌型中有东、南、西、北四种风牌，其中三组为刻子，一组为对子，则是小四喜。大四喜需要所有风牌都形成刻子，因此大四喜包含小四喜，但番值更高。\n碰碰胡（6番）：大四喜的胡牌牌型全由刻子构成，必然符合碰碰胡。\n双暗刻（2番）：如果四组风牌的刻子中有两组或三组为暗刻，可以同时满足这些条件。\n明杠（1番）：如果四组刻子中有杠牌，可以叠加明杠或暗杠的番种。\n大四喜的策略与实战意义 起手判断：如果起手牌中已有两组或更多的风牌对子/刻子，可以考虑追求大四喜。如果风牌数量不足，建议尽早放弃大四喜目标。\n优先碰牌或杠牌：风牌的数量有限，建议尽早通过碰牌或杠牌凑齐刻子，减少对手争夺关键牌的机会。\n隐藏意图：在未副露足够的风牌前，尽量通过摸牌形成暗刻，以减少对手的防守意识。\n听牌选择：大四喜的听牌范围通常较窄（单一风牌或孤张听牌），建议优先选择隐蔽或较难被察觉的听牌形式。\n参考链接 大四喜\n大三元 什么是大三元？ 大三元是指玩家的胡牌牌型中，包含中、发、白三组字牌的刻子（或杠），即中、发、白全部成刻子，同时满足胡牌的基本结构要求（4组面子+1对将）。\n大三元的牌型 以下是大三元的牌型举例：\n中中中（刻子）+ 发发发（刻子）+ 白白白（刻子）+ 123筒（顺子）+ 55筒（将牌）。 带杠牌：\n中中中中（杠）+ 发发发发（杠）+ 白白白（刻子）+ 666万（刻子）+ 11条（将牌）。 暗刻：\n中中中（暗刻）+ 发发发（暗刻）+ 白白白（暗刻）+ 456筒（顺子）+ 77筒（将牌）。\n大三元的番数 在国标麻将中，“大三元”是一个88番的顶级番种，也是所有玩家追求的高分牌型之一。因其牌型依赖中、发、白三种字牌的刻子而得名，“大三元”在牌局中象征着玩家的极高运气和技巧。\n大三元的注意事项 三种字牌齐全：必须包含中、发、白三种字牌。\n三组刻子或杠：中、发、白这三种字牌必须全部形成刻子（或杠），不能有单独的对子或孤张。\n完整胡牌结构：除了中、发、白的三组刻子外，还需要一个将牌（对子）和一个额外的顺子或刻子来满足胡牌条件。\n大三元与其他番种的关系 小三元（64番）：如果牌型中有中、发、白三种字牌，其中两组为刻子，一组为对子，则是小三元。大三元需要中、发、白全部形成刻子，因此大三元包含小三元，但番值更高。\n碰碰胡（6番）：大三元的胡牌牌型全由刻子或杠牌构成，因此符合碰碰胡。\n双暗刻（16番）/三暗刻（32番）：如果中、发、白的三组刻子中有两组或三组为暗刻，可以满足这些条件。\n明杠（8番）/暗杠（16番）：如果中、发、白的刻子中有杠牌，可以叠加明杠或暗杠的番种。\n大三元的策略与实战意义 起手判断：如果起手牌中已有两组字牌的对子或刻子（如中中、发发），可以考虑追求大三元。如果字牌数量较少或被对手早早打出过多，建议尽早放弃大三元目标。\n优先碰牌或杠牌：字牌数量有限，建议尽早通过碰牌或杠牌凑齐刻子，避免对手阻断关键牌。\n隐藏意图：在未凑齐两组以上的刻子时，尽量通过摸牌形成暗刻，减少对手的防守意识。\n听牌规划：大三元的听牌范围通常较窄（如中、发、白的孤张听牌），尽量选择更隐蔽或灵活的听牌方式。\n参考链接 大三元\n绿一色 什么是绿一色？ 绿一色是指胡牌的牌型全部由绿色的牌组成，这些牌包括：条子中的2、3、4、6、8条，字牌中的发（“白板”不算）这些牌的颜色在传统麻将中以绿色为主，因此得名“绿一色”。\n绿一色的牌型 以下是绿一色的牌型举例： 222条（刻子）+ 333条（刻子）+ 444条（刻子）+ 888条（刻子）+ 66条（将牌）。 发发发（刻子）+ 222条（刻子）+ 666条（刻子）+ 234条（顺子）+ 88条（将牌）。 234条（顺子）+ 666条（刻子）+ 888条（刻子）+ 234条（顺子）+ 44条（将牌）。\n绿一色的番数 绿一色为88番，是国标麻将中的最高番种之一，绿一色只能使用极少数特定的牌，限制性极强。作为88番的顶级番种，一旦成功胡出，不仅能赢得高分，还会成为整个牌局的绝对亮点！\n绿一色的注意事项 必须全为绿色牌：如果牌型中出现其他数牌（如1、5条或万、筒）或字牌（如中、白），则不符合绿一色的条件。\n胡牌结构完整：必须满足国标麻将的基本胡牌结构，即4组面子（顺子、刻子或杠）+1对将。\n与清一色的区别：清一色仅要求所有牌为同一花色，但绿一色进一步限定只能使用2、3、4、6、8条和发，限制更严格。\n绿一色与其他番种的关系 绿一色作为国标麻将中的顶级番种之一，其番值已封顶，但在形成过程中可能叠加其他番种作为理论参考：\n清一色（24番）：绿一色的所有牌均为条子和发，满足清一色的条件。\n碰碰胡（6番）：如果绿一色的胡牌全由刻子或杠牌构成，符合碰碰胡的条件。\n七对（24番）：如果绿一色的胡牌全由对子构成，符合七对的条件。\n绿一色的策略与实战意义 起手判断：如果起手牌中有大量绿色牌（如条子中的2、3、4、6、8和发），可以尝试追求绿一色。如果绿色牌数量不足，建议放弃绿一色目标，转向清一色或碰碰胡。\n优先保留绿色牌：在摸牌和打牌过程中，优先保留2、3、4、6、8条和发，尽量避免打出关键牌。\n隐藏意图：避免过早副露绿色牌，减少对手的防守意识。\n分析牌池：根据场上已打出的绿色牌数量，推测对手可能的听牌范围，及时调整打牌策略。\n参考链接 绿一色\n九莲宝灯 什么是九莲宝灯？ 九莲宝灯是指胡牌时，玩家的牌型为同一花色的1到9全数字组成的特定排列，并且听任意一张该花色的牌即可胡牌。胡牌结构要求全副牌包含完整的1到9，但可以有一张重复的牌。\n九莲宝灯的牌型 以下是九莲宝灯的牌型举例： 起手牌：1112345678999筒。 听牌：任意一张筒（1到9筒均可）。 胡牌举例：若摸入3筒，则胡牌牌型为11123456789993筒。 以条为例：\n起手牌：1112345678999条。 听牌：任意一张条（1到9条均可）。 胡牌举例：若摸入8条，则胡牌牌型为11123456789998条。\n九莲宝灯的番数 九莲宝灯为88番，是国标麻将中的最高番种之一，其牌型严格、成型难度极高，但听牌范围较广，完成后分值达到顶级（88番）。\n九莲宝灯的注意事项 单一花色：所有牌必须为同一花色的数牌（万、筒、条）。不能混用不同的花色。\n九莲基础结构：牌型必须包含该花色的1到9所有数字，其中1和9必须各有3张，中间的2到8各1张。基础结构为：1112345678999。\n听牌方式：九莲宝灯的听牌范围是1到9中任意一张该花色的牌。\n胡牌结构完整：胡牌时通过摸入（或自摸）任何一张1到9的该花色牌即可。\n九莲宝灯与其他番种的关系 九莲宝灯作为国标麻将中的顶级番种之一，其番值已封顶（88番），但在形成过程中可能叠加其他番种：\n清龙（16番）：和牌中有123，456，789相连的序数牌，符合九莲宝灯。\n门前清（2番）：如果九莲宝灯的胡牌通过自摸完成，可以叠加门前清。\n四归一（2番）：如果摸到了1或9的牌可以组成四归一。\n九莲宝灯的策略与实战意义 起手判断：如果起手牌接近九莲宝灯的结构（如1和9较多，中间牌齐全），可以尝试追求九莲宝灯。如果起手牌与九莲宝灯差距较大，建议放弃，转向清一色或一气通贯等其他番种。\n隐蔽性策略：九莲宝灯的牌型特点决定了尽量不要副露，保持门前清状态，增加自摸的机会。\n听牌规划：九莲宝灯的听牌范围较广（1到9均可），但需要谨慎选择最优胡牌方式。\n快速摸齐结构：优先保留关键的1和9牌，这两张牌的数量要求较多（各需3张）。\n参考链接 九莲宝灯\n四杠 什么是四杠？ 在国标麻将中，“四杠”是一个88番的顶级番种，也是所有玩家最难达成的高分牌型之一。四杠是指胡牌的牌型中，包含四组杠牌，即通过明杠或暗杠形成的四组杠，同时满足胡牌的基本结构要求（4组面子+1对将）。\n四杠的牌型 以下是四杠的牌型举例：\n1111筒（明杠） + 2222万（暗杠） + 3333条（明杠） + 4444筒（暗杠） + 55条（将牌）。 全部为暗杠：\n5555条（暗杠） + 6666筒（暗杠） + 9999万（暗杠） + 8888条（暗杠） + 77筒（将牌）。 混合杠：\n东东东东（明杠） + 中中中中（暗杠） + 1111条（明杠） + 白白白白（暗杠） + 99筒（将牌）。 四杠的番数 四杠为88番，是国标麻将中的最高番种之一，与大四喜、大三元、九莲宝灯等并列。四组杠牌的形成极为困难，因为杠牌的数量和分布对玩家要求极高。\n四杠的注意事项 四组杠牌：胡牌的牌型中必须包含四组杠牌（可以是明杠或暗杠，也可以混合）。杠牌可以通过碰后加杠、直接暗杠或抢杠等方式形成。\n胡牌结构完整：除了四组杠牌外，还需要一个将牌（对子）来满足胡牌的基本结构（4组面子+1对将）。\n不能缺少将牌：除了四组杠牌外，仍需满足胡牌的基本结构（包括将牌），不能忽略这一点。\n四杠与其他番种的关系 四杠作为国标麻将中的顶级番种之一，番值已封顶（88番），但其形成过程中可能叠加其他番种：\n双暗刻（2番）/三暗刻（16番）：如果四杠的牌型中包含两组或三组暗刻，可以叠加这些番种。\n明杠（1番）/暗杠（2番）：每一组杠牌本身也可以分别计入明杠或暗杠的番种。\n四归一（2番）：如果某些杠牌的形成涉及四归一的条件，可以叠加四归一。\n四杠的策略与实战意义 起手判断：如果起手牌中有多个对子或刻子，且这些牌有较大概率形成杠牌，可以尝试追求四杠。\n优先杠牌：杠牌不仅增加成型速度，还能额外摸牌，增加凑齐四杠的概率，注意选择适时杠牌，以减少对手的防守意识。\n灵活调整：如果难以凑齐四杠，可以转而追求碰碰胡或其他高番种，避免浪费资源。\n防守技巧：如果对手多次杠牌，尤其是在牌局后期，可能在追求四杠或其他高番种。\n参考链接 四杠\n连七对 什么是连七对？ 连七对是指胡牌时，手牌中包含同一花色的七组对子（共14张牌），且这些对子从1到7是完全连续的数字，形成单一花色的特殊牌型。连七对的牌型要求严格，必须同时满足单一花色和对子连续性，难度远高于七对子。\n连七对的牌型 以下是连七对的牌型举例：\n以万为例：11223344556677万\n以条为例：11223344556677条\n以筒为例：11223344556677筒\n连七对的番数 在国标麻将中，“连七对”是一个88番的顶级番种，是七对子的特殊形式，因其对子排列的连续性和难度极高而被视为极稀有的高分番种。\n连七对的注意事项 单一花色：所有牌必须为同一花色（万、筒、条），不能混合其他花色。\n七组连续对子：牌型为11223344556677，必须从1到7连续组成对子。\n只能是对对胡：连七对必须是门清状态（无副露），不能有明杠、碰牌或吃牌。\n胡牌方式：可以通过自摸或点炮胡牌。\n与七对子和清一色的区别：七对子只要求牌型为7组对子，不要求对子连续性。清一色只要求单一花色，无需对子结构。\n连七对与其他番种的关系 连七对作为顶级番种之一，番值已封顶（88番），但其形成过程中不可叠加清一色，七对，不求人，门前清，无字。\n连七对的策略与实战意义 起手判断：如果起手中某一花色对子较多（如4组以上连续对子），且手牌接近1到7的连贯结构，可以尝试追求连七对。如果起手对子不足，建议放弃连七对，转向七对子或清一色。\n优先保留连续对子：在摸牌和打牌过程中，优先保留1到7的连续对子，避免打破对子结构。\n听牌限制：连七对的听牌范围通常较窄（如单钓将），胡牌机会稀少。\n隐蔽性较高：由于连七对的门前清特性，不易被对手察觉，防守压力较低。\n参考链接 连七对\n十三幺 什么是十三幺？ 十三幺是指胡牌时，玩家的牌型由所有幺九牌（数牌的1、9及字牌）各一张，再加上任意一张牌重复，形成十四张牌的特殊胡牌结构。十三幺作为一个88番的顶级番种，以其独特的牌型和极高的稀有性而著称。十三幺因其牌型复杂、听牌范围广和成型难度大，被视为麻将玩家的“荣誉牌型”之一。\n十三幺的牌型 以下是十三幺的牌型举例：1万、9万、1筒、9筒、1条、9条、东、南、西、北、中、发、白、1条。\n十三幺的番数 十三幺是国标麻将中最具独特性和挑战性的番种之一，其牌型严谨而稀有。作为88番的顶级番种，十三幺的完成需要极高的运气和耐心，但其胡牌方式简单，听牌范围广泛。\n十三幺的注意事项 必须包含所有幺九牌：数牌中的1和9（1万、9万、1筒、9筒、1条、9条），每种牌各一张。字牌中的东、南、西、北、中、发、白，每种牌各一张。\n必须有一张重复牌：重复的牌可以是任意一张幺九牌。\n胡牌方式：可以通过自摸胡牌，也可以通过点炮胡牌。\n十三幺的策略与实战意义 起手判断：如果起手牌中幺九牌数量多（如10张以上），可以尝试追求十三幺。如果起手幺九牌数量较少，建议尽早放弃，转向碰碰胡或混幺九等番种。\n优先保留幺九牌：在摸牌过程中，优先保留幺九牌，避免打出关键牌导致牌型无法完成。\n听牌选择：十三幺的听牌范围较广，胡牌可能性高，因此进入听牌阶段后可集中摸牌，不必急于胡牌。\n隐蔽性策略：避免副露幺九牌，以增加对手防守的难度。\n参考链接 十三幺\n","date":"2025-09-14T15:53:43.55+08:00","permalink":"https://ynhugo.github.io/p/%E5%9B%BD%E6%A0%87%E9%BA%BB%E5%B0%86/","title":"国标麻将"},{"content":" GIT服务器端部署及自动拉取 文件名称 1 post-receive 文件路径 裸仓库，对应服务器端.git目录\n文件位置参考：\n1 ~/org.git/hooks/post-receive 脚本内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/sh #判断是不是远端仓库 IS_BARE=$(git rev-parse --is-bare-repository) if [ -z \u0026#34;$IS_BARE\u0026#34; ]; then echo \u0026gt;\u0026amp;2 \u0026#34;fatal: post-receive: IS_NOT_BARE\u0026#34; exit 1 fi unset GIT_DIR DeployPath=\u0026#34;/data/data/com.termux/files/home/org\u0026#34; echo \u0026#34;===============================================\u0026#34; cd $DeployPath #进入web项目目录 # echo \u0026#34;deploying the web project\u0026#34; echo \u0026#34;auto pull\u0026#34; #git stash #git pull origin master #不建议使用git pull，后面会有解释 git fetch --all #这里使用git fetch进行拉取，不建议用git pull git reset --hard origin/master #gitbook build #这里的gitbook是一个电子文档管理软件，用于生成好固定格式的电子文档，一般用户到，若需要则需另行安装，由于gitbook是node.js写的，而npm是node.js的包管理器，所以要先安装npm再安装gitbook。gitbook build表示文档生成在当前目录的默认文件夹_book里面。 #sleep 15 #gitbook执行需要8秒钟时间，等待15秒是为了确保能得到返回结果 time=`date` # echo \u0026#34;web server pull at webserver at time: $time.\u0026#34; echo \u0026#34;================================================\u0026#34; 文件需要可执行权限 1 chmod +x post-receive 参考链接 GIT服务器端部署及自动拉取\n","date":"2025-09-09T10:40:55.8+08:00","permalink":"https://ynhugo.github.io/p/git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96/","title":"GIT服务器端部署及自动拉取"},{"content":" win11实现yolov5推理（无CPU） 安装Git Bash 任意版本皆可，下载链接：https://github.com/git-for-windows/git/releases/download/v2.51.0.windows.1/Git-2.51.0-64-bit.exe\n根据默认选项进行安装，建议安装在C盘，这样运行可以会更快一些。\n安装Anaconda及Git Bash Shell初始化 任意版本皆可，下载链接：https://repo.anaconda.com/archive/Anaconda3-2025.06-0-Windows-x86_64.exe\n勾选添加环境变量，其他默认\nGit Bash Shell初始化 如果Git Bash没有默认运行Anaconda自带的base虚拟环境，则进行初始化操作，反之跳过该操作\n1 conda init bash # 只有第一次需要执行该命令，下次再运行Git Bash不需要再执行 安装OpenCV 下载链接：https://sourceforge.net/projects/opencvlibrary/files/4.5.5/opencv-4.5.5-vc14_vc15.exe/download\n自定义提取目录位置，双击文件会提取opencv目录到设定的位置。\n添加环境变量，opencv下要添加环境变量的路径如下，根据对应位置，添加完整路径到环境变量。\n1 2 opencv\\build\\x64\\vc14\\bin opencv\\build\\x64\\vc15\\bin 安装Cmake 任意版本皆可，下载链接：https://github.com/Kitware/CMake/releases/download/v4.1.1/cmake-4.1.1-windows-x86_64.msi\n根据习惯选择是否添加桌面快捷方式和自定义安装路径\nVisual Studio 2022 下载社区版即可，下载链接：https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community\u0026amp;channel=Release\u0026amp;version=VS2022\u0026amp;source=VSLandingPage\u0026amp;cid=2030\u0026amp;passive=false\n根据默认选项进行安装，如果提示添加工作负荷，根据提示确定后再次点击安装即可。\n准备微软账户（或许可以忽略） 注册一个微软账号，用于第一次使用Visual Studio的账户登录，也可用自己现成的微软账号。\n注册账号的信息可以随便填。\n微软账号注册链接：https://outlook.live.com/mail/0/?prompt=create_account\n安装PyCharm 下载链接：https://www.jetbrains.com/zh-cn/pycharm/download/?section=windows\nAnaconda创建环境 在Git Bash中操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 如果Git Bash没有默认运行Anaconda自带的base环境，则进行初始化操作，反之跳过该操作 conda init bash # 查看环境变量，刚安装的Anaconda只有自带的第一个base环境 conda env list # 配置环境名称 export myenv=\u0026#34;python_3.8\u0026#34; # 创建环境 conda create -n $myenv python=3.8 -y # 激活环境 conda activate $myenv # 删除环境，仅不需要该环境的时候执行该命令 conda env remove --name $myenv -y 参考链接 Anaconda 教程\nyolov5推理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 # 设置代理，根据需要进行设置 conda config --set proxy_servers.http http://127.0.0.1:10808 export myenv=\u0026#34;python_3.8\u0026#34; # 创建环境 conda create -n $myenv python=3.8 -y # 设置复制环境变量 export myclone=${myenv}_clone # 复制环境 conda create --name $myclone --clone $myenv # 激活环境 conda activate $myenv conda install -y pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 # -c pytorch # Install the ultralytics package pip install ultralytics -i https://pypi.tuna.tsinghua.edu.cn/simple # Clone the YOLOv5 repository git clone https://github.com/ultralytics/yolov5 # Navigate to the cloned directory cd yolov5 # Install required packages pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple # Traning配置的--cfg *.yaml与Run inference using a webcam的.pt模型对应 # --------------------------------Training # Train YOLOv5n on COCO for 300 epochs python train.py --data coco.yaml --epochs 300 --weights \u0026#39;\u0026#39; --cfg yolov5n.yaml --batch-size 128 # Train YOLOv5s on COCO for 300 epochs python train.py --data coco.yaml --epochs 300 --weights \u0026#39;\u0026#39; --cfg yolov5s.yaml --batch-size 64 # Train YOLOv5m on COCO for 300 epochs python train.py --data coco.yaml --epochs 300 --weights \u0026#39;\u0026#39; --cfg yolov5m.yaml --batch-size 40 # Train YOLOv5l on COCO for 300 epochs python train.py --data coco.yaml --epochs 300 --weights \u0026#39;\u0026#39; --cfg yolov5l.yaml --batch-size 24 # Train YOLOv5x on COCO for 300 epochs python train.py --data coco.yaml --epochs 300 --weights \u0026#39;\u0026#39; --cfg yolov5x.yaml --batch-size 16 # --------------------------------Inference with detect.py # Run inference using a webcam python detect.py --weights yolov5s.pt --source 0 # Run inference on a local image file python detect.py --weights yolov5s.pt --source img.jpg # Run inference on a local video file python detect.py --weights yolov5s.pt --source vid.mp4 # Run inference on a screen capture python detect.py --weights yolov5s.pt --source screen # Run inference on a directory of images python detect.py --weights yolov5s.pt --source path/to/images/ # Run inference on a text file listing image paths python detect.py --weights yolov5s.pt --source list.txt # Run inference on a text file listing stream URLs python detect.py --weights yolov5s.pt --source list.streams # Run inference using a glob pattern for images python detect.py --weights yolov5s.pt --source \u0026#39;path/to/*.jpg\u0026#39; # Run inference on a YouTube video URL python detect.py --weights yolov5s.pt --source \u0026#39;https://youtu.be/LNwODJXcvt4\u0026#39; # Run inference on an RTSP, RTMP, or HTTP stream python detect.py --weights yolov5s.pt --source \u0026#39;rtsp://example.com/media.mp4\u0026#39; # 取消代理 conda config --remove-key proxy_servers.http 参考链接 Anaconda 教程\nPython pip 安装与使用\nultralytics/yolov5\n从PyTorch Hub加载YOLOv5\n【从零开始】win10系统部署Yolov5详细过程（CPU，无GPU）\npytorch_v1.8.0\nconda 恢复channel的默认设置\nAnaconda 的代理设置\n","date":"2025-09-08T15:57:42.51+08:00","permalink":"https://ynhugo.github.io/p/win11%E5%AE%9E%E7%8E%B0yolov5%E6%8E%A8%E7%90%86%E6%97%A0cpu/","title":"win11实现yolov5推理（无CPU）"},{"content":" 了解beancount并折腾beancount+emacs termux安装beancount和fava 1 2 3 4 5 # 安装相关依赖 pkg install -y cmake automake autoconf libtool beancount-periodic # 安装对应的包 pip install beancount fava emacs配置 1 2 3 (use-package beancount :ensure t :mode (\u0026#34;\\\\.bea\\\\(n\\\\|ncount\\\\)\\\\\u0026#39;\u0026#34; . beancount-mode)) emacs安装beancount包，支持.bean和.beancount文件\n快速上手 首先需要安装 Python3 环境，然后安装对应的包\n1 2 3 4 pip install beancount fava # 如果安装beancount包没有bean-price，可以单独安装beanprice这个包 pip install beanprice 注：在Git Bash中操作\n如果是在Git Bash中，安装完对应包后要检测是否有对应包，并将其所在路径添加环境变量\n1 2 ls /c/Users/$USERNAME/AppData/Roaming/Python/Python37/Scripts | grep bean export PATH=$PATH:/c/Users/$USERNAME/AppData/Roaming/Python/Python37/Scripts # 把 Scripts 目录加到 PATH，如果要长期生效，把上面那一行加到 ~/.bashrc 或 ~/.bash_profile。 生成一个官方提供的示例\n1 bean-example \u0026gt; example.beancount 通过 fava 命令运行 WebUI\n1 fava -H 0.0.0.0 example.beancount 默认情况下Web UI会运行在 http://localhost:5000 ，不过我最终还是指定了实际IP，方便局域网访问\n参考链接 开始用 Beancount 实践复式记账（一）：初始化\n程序员复式记账指南（上）\n程序员复式记账指南（上）快速上手\n程序员复式记账指南（下）\nBeancount 入门指南\nBeancount 3.0.0 版本中查询功能的迁移与使用指南\n复式记账Beancount入门\nBeancount plugin to generate periodic transactions\nemacs-让beancount插件支持中文账户名\n","date":"2025-08-18T02:38:06.94+08:00","permalink":"https://ynhugo.github.io/p/%E4%BA%86%E8%A7%A3beancount%E5%B9%B6%E6%8A%98%E8%85%BEbeancount-emacs/","title":"了解beancount并折腾beancount+emacs"},{"content":" ledger设置循环交易 ledger-cli如何支持循环交易 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 在 **ledger-cli** 里，“循环交易” 一般是指一种定期重复发生的交易，比如每周/每月的工资、房租、水电费、转账等。 Ledger 本身并不会像记账软件那样自动生成未来的交易，但它有两种机制可以支持这种场景： --- ## **1. 用 `~` 定义周期性交易（Periodic Transactions）** Ledger 的 journal 文件可以直接写定期规则，让它在报表时自动扩展出这些交易。 语法大致是： ```ledger ~ every month on the 5th Expenses:Rent 2000 CNY Assets:Bank:ICBC ``` ### 常用的周期表达式 ,* `~ monthly` / `~ every month` → 每月 ,* `~ weekly` / `~ every week` → 每周 ,* `~ daily` / `~ every day` → 每天 ,* 可以指定日期：`~ every month on the 15th` ,* 可以指定范围：`~ weekly from 2025/01/01 until 2025/12/31` 例如： ```ledger ~ every week Expenses:运营商:中国联通 49.75 CNY Assets:Bank:工商银行 ``` 这个不会直接写入账本，只会在你运行报表命令时自动计算这些交易的总额。 --- ## **2. 生成实际交易（Materializing Periodic Transactions）** 如果你想让循环交易“落地”成普通交易（方便将来修改或导出），可以用 Ledger 自带的扩展功能： ```bash ledger -f ledger.dat print --period \u0026#34;from 2025/01/01 to 2025/12/31\u0026#34; ``` 配合 `--actual` 可以生成真实交易而不是仅显示。 也可以用 **ledger-autoschedule**（第三方脚本）将周期交易展开为实际的交易条目存到文件里。 --- ## **3. 注意事项** ,* 周期交易不会自动影响期初余额，因为它是计算时临时展开的。 ,* 如果你的循环交易金额会变化（比如水费），那最好生成实际交易手动调整。 ,* Ledger 的日期计算遵循 `boost::date_time` 规则，复杂的周期需要测试一下（例如“每月最后一天”要用 `on last day of month`）。 --- 如果你愿意，我可以帮你写一个 **可以在 ledger-cli 里自动生成全年循环交易的脚本**，这样 journal 文件里就是全部真实交易而不是临时规则。这样你就可以和普通账目一起查询和编辑。 你是想要这种**脚本生成法**还是**\\~ every week**这种原生 Ledger 周期规则？ 问答1 问：\n1 2 3 4 5 6 ~/.../2025/05 $ ledger -f ledger.ledger bal -b 08/31 While parsing file \u0026#34;/data/data/com.termux/files/home/yenao_ledger.github.io/ledger/2025/05/ledger.ledger\u0026#34;, line 1843: While parsing periodic transaction: \u0026gt; ~ every daily Error: Unexpected date period token \u0026#39;daily\u0026#39; ~/.../2025/05 $ 答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 你这个报错是因为 Ledger 的周期语法写错了。 `~ every daily` 不是合法写法，Ledger 期望的是： ,* `~ daily`（每天） ,* `~ weekly`（每周） ,* `~ monthly`（每月） ,* 或者 `~ every day` / `~ every week` / `~ every month` ,**所以改成这样就行：** ```ledger ~ daily Expenses:运营商:中国联通 49.75 CNY Assets:Bank:工商银行 ``` 或者： ```ledger ~ every day Expenses:运营商:中国联通 49.75 CNY Assets:Bank:工商银行 ``` --- ### 补充：一些合法写法 ```ledger ~ every week ~ weekly ~ every month ~ monthly ~ every month on the 15th ~ weekly from 2025/01/01 until 2025/12/31 ``` `every` 后面不能直接跟 `daily` 这种词，必须是 `day` / `week` / `month` 或用简写。 --- 我还注意到你是在 `-b 08/31` 这种日期范围里跑的，如果用 periodic transaction，它只会在查询期间自动生成符合条件的虚拟交易，所以日期语法也要匹配你要看的范围。 如果你愿意，我可以帮你整理一个 **Ledger 周期交易合法语法速查表**，这样以后就不会踩坑了。 你要我直接写出来吗？ 问答2 问：\n1 2 3 4 5 6 ~/.../2025/05 $ tail ledger.ledger -n 4 ~ daily Assets:Bank:工商银行 -49.75 CNY Expenses:运营商:中国联通 ~/.../2025/05 $ 答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 我看出问题了――你已经写了 `~ daily` 的周期交易，但运行 `ledger bal` 时它没显示出来，是因为： 1. **Ledger 默认不展开 periodic transaction** 周期交易（`~ daily` 这种）只是一个“规则”，Ledger 在报表里只有在**查询区间有符合条件的日期**时才会临时生成虚拟交易。 2. **你的命令少了 `--period` 或指定时间范围的方式** `-b 08/13` 只是设置**起始日期**，但 Ledger 只会在该日期或之后符合周期规则的日期里计算。 如果今天是 8/13，`~ daily` 会从 8/13 开始每天都加一笔，但 `bal` 只显示累计余额，不会列出每一天的交易。 3. **Periodic transaction 默认不影响总余额（unless `--forecast`）** 如果你想在余额中看到它的影响，需要加 `--forecast` 选项。 --- ### 解决方法 #### 如果只是想让它在余额里生效 ```bash ledger -f ledger.ledger bal -b 2025/08/01 --forecast ``` `--forecast` 会把周期规则展开成未来的交易（直到你设定的结束日期）。 #### 如果想查看具体展开的交易 ```bash ledger -f ledger.ledger register --period \u0026#34;2025/08/01 to 2025/08/31\u0026#34; --forecast ``` #### 如果要生成实际交易到文件 ```bash ledger -f ledger.ledger print --forecast --period \u0026#34;2025/08/01 to 2025/08/31\u0026#34; \u0026gt; expanded.ledger ``` 这样 `expanded.ledger` 里就是每天的那笔 49.75 CNY，跟普通交易一样。 --- ?? 小结： ,* `~ daily` 不会自动在原文件变成多行交易，它只是规则。 ,* `--forecast` 是让规则“生效”的关键。 ,* 如果要真正存成普通交易，需要用 `print` 导出。 --- 我可以帮你写一个 **自动生成全年循环交易并保存到原账本的命令**，这样以后不需要 `--forecast` 也能直接算余额。 你要我帮你做这个吗？这样 49.75 CNY 会真的每天出现在账本里。 问答3 问：\n1 2 3 4 ~/.../2025/05 $ ledger -f ledger.ledger bal -b 08/13 --forecast While parsing option \u0026#39;--forecast\u0026#39; Error: No argument provided for --forecast-while ~/.../2025/05 $ 答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 你这个报错是因为 **`--forecast` 在新版 ledger-cli 已经被改成 `--forecast-while`**，而且它不是单独开关，而是需要跟一个“条件表达式”。 也就是说，旧版本的： ```bash ledger ... --forecast ``` 在你这个版本里变成了： ```bash ledger ... --forecast-while \u0026lt;EXPRESSION\u0026gt; ``` --- ## 用法示例 比如你想让它一直生成交易直到 2025/08/31： ```bash ledger -f ledger.ledger bal \\ -b 2025/08/01 \\ --forecast-while \u0026#34;date \u0026lt;= [2025-08-31]\u0026#34; ``` 这样 ledger 会展开 `~ daily` 规则，从 8/1 到 8/31 每天一笔。 如果想看具体的交易明细而不是余额： ```bash ledger -f ledger.ledger register \\ --forecast-while \u0026#34;date \u0026lt;= [2025-08-31]\u0026#34; ``` --- ## 解释 ,* `--forecast-while` 会不断展开 periodic transactions，直到条件不成立。 ,* 条件里可以用 `date`（交易日期）、`amount` 等 ledger 表达式。 ,* 日期要用方括号 `[YYYY-MM-DD]`，这样它会被当成日期而不是字符串。 --- 我可以帮你写一个命令，直接**展开全年循环交易并保存到新的 ledger 文件**，这样你就不需要每次都加 `--forecast-while` 了。 这样要做吗？这样你 ledger 文件里就有真实的每天交易记录了。 ","date":"2025-08-13T18:04:20.74+08:00","permalink":"https://ynhugo.github.io/p/ledger%E8%AE%BE%E7%BD%AE%E5%BE%AA%E7%8E%AF%E4%BA%A4%E6%98%93/","title":"ledger设置循环交易"},{"content":" 旅游/旅行 北京 八达岭长城 北海公园 白天不错，晚上还没逛过\n毛主席纪念馆 故宫 什刹海 白天和晚上都不错\n鬼笑石 夜爬鬼笑石，使用Deepseek，根据计划的日期，让Deepseek做一个攻略，然后准备一些必要的东西比如水、伞、外套，鞋子最好是方便登山防滑的，如休闲运动鞋、登山鞋，最好穿长裤，避免蚊虫叮咬或刮擦，再根据需要准备一些吃的零食，充电宝的话根据个人需要可以备一个或两个，像我的手机是5500mAh的电池容量且开了超级续航模式，对于我来说是够用，但是如果有喜欢录像或者刷视频的，建议备充电宝，雨衣的话根据个人需求及当天附近几天的天气情况准备，比如我当时上爬上去之后下的雨，我也没有准备雨衣，就在旁边店铺购买了一件雨衣，上边有休息区域，休息区域有遮阳伞，但是遮阳伞挡雨效果不好，还是会淋到。\n攻略展示 Deepseek做的攻略，引导词为标题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 8月中旬夜爬鬼笑石（北京西山森林公园）的攻略和穿搭建议如下，兼顾舒适性、安全性和观赏体验： --- ### **一、夜爬攻略** #### **1. 时间安排** - **出发时间**：建议22:00-23:00出发（根据日出时间调整，日出约5:20）。登顶需1-1.5小时，预留休息和拍照时间。 - **观景时段**：山顶凌晨1:00-4:00可赏夜景，4:30后等待日出（提前查天气）。 #### **2. 路线选择** - **常规路线**（最快）： - **起点**：西山森林公园东门（24小时开放）。 - **路线**：东门→登山步道→鬼笑石（约2km，台阶+坡道，中等难度）。 - **备选路线**： - 从香山邮局或后山小路进入（部分路段无灯，需结伴）。 #### **3. 必备装备** - **照明**：头灯/手电筒（必备，部分路段无照明）。 - **补给**：水（1-2瓶）、能量零食（巧克力、坚果）。 - **其他**：充电宝、驱蚊液、轻便雨衣（防突发降雨）、折叠坐垫（山顶休息用）。 #### **4. 注意事项** - **安全**：结伴同行，避免独行；夜间部分路段湿滑，穿防滑鞋。 - **网络**：山顶信号弱，提前下载离线地图。 - **拍照**：带三脚架（拍夜景/延时），手机可用便携补光灯。 --- ### **二、穿搭建议**（8月北京夜间气温约20-25℃，山顶体感略低） #### **1. 分层穿搭** - **内层**：速干短袖或运动背心（排汗透气）。 - **中层**：薄款防晒衣或皮肤衣（防风防露水）。 - **外层**：轻便冲锋衣或薄外套（山顶凌晨可能有风）。 - **下装**：运动速干长裤（防蚊防刮）或短裤+护膝（根据习惯）。 - **备用**：魔术头巾（擦汗/挡风）。 #### **2. 鞋袜** - **鞋子**：防滑运动鞋或登山鞋（避免凉鞋/板鞋）。 - **袜子**：透气速干袜（防磨脚）。 #### **3. 配件** - **帽子**：空顶帽（防晒）或鸭舌帽（挡风）。 - **其他**：墨镜（日出后防强光）、手套（可选，扶栏杆用）。 --- ### **三、其他Tips** 1. **交通**： - 自驾导航“西山森林公园东门”，停车场夜间开放。 - 返程打车可能需加价，建议预约车辆或拼车。 2. **门票**：西山公园免费，无需预约。 3. **环保**：自带垃圾袋，无痕爬山。 --- ,**总结**：夜爬鬼笑石以轻便、安全为主，穿搭注意防风排汗，备齐照明和补给，提前查好天气，就能享受北京绝美夜景和日出啦！ 🌄 山东东营看海 公司团建时间是在8月份，具体日期攻略中有。\n17日早餐后红滩湿地，黄河入海口一日游，下午是金泥湾赶海（下等过去的时候有点晚了，建议早点到，最佳时间可以咨询当地有经验的人）；\n18日上午去孤东海湾看海，在旁边的店铺内购买捞鱼的小网兜、夹螃蟹的夹子、小水桶，然后在堤边捞小鱼或夹螃蟹，捞鱼与夹螃蟹需要靠运气、反应，关于夹螃蟹，旁边店铺有卖生鸡肉，可以作为夹螃蟹的诱饵。\n攻略展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 各位伙伴们，咱们的东营之行明天正式开启，大概行程如下： **1**. 16日晚19点左右从公司出发，直达东营蓝海国际酒店（酒店有泳池，喜欢游泳的记得带泳衣）； **2**. 17日早上酒店早餐，每个房间2张餐券，超出部分可自行购买，每位68元（孩子的早餐是按身高，1.1米以下不收费，1.1\\~1.4米之间48元/位，1.4米以上成人价）各位按需要自行购买 **3**. 17日早餐后红滩湿地，黄河入海口一日游，午餐就近解决，晚餐东营市区 **4**．17日晚回蓝海国际酒店住宿 **5**. 18日上午半天行程暂未定，去了之后跟当地人员沟通之后再另行安排，当天午饭后返程 **备注**：明天来公司上班直接带好出行物品，长袖长裤备上；如需要沙滩玩沙工具，自备 泰山攻略 中秋节，三天假期，这个时间段不冷不热刚刚好，爬泰山可以穿夏天的服装就行，背一个包，里边放一些小零食+水。爬山途中每隔一段距离会有卖水和吃的，如果自己准备的吃的和喝的吃完了，可以在爬山途中再买，这样想的话，其实可以不背包，所以吃喝在爬山途中解决也是可以的。\n在微信公众号中购票，从红门出发。\n乌兰布统攻略 使用Deepseek做一个乌兰布统三日游的攻略，然后根据攻略去玩就可以了。\n我这边是7月底8月初，在7月31日上午出发，傍晚到达目的地，然后第二天就根据攻略去玩了，有观光游览、射击、骑马沙滩车。其中我觉得最值的就是骑马和沙滩车了，像射击什么的我没玩，跟其他地方的射击游戏差不多。\n攻略展示 强调： 一定要做好防晒！！！我以及我的同事没做防晒的都晒伤了。我想着男生有什么好做防晒的，结果悲催了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ## 2025.8乌兰布统草原（位于内蒙古赤峰市克什克腾旗）8月1日出游路线规划 ### 第一天：上午出发晚上抵达乌兰布统格尔轻奢酒店,晚上自由行 ### 第二天：游览核心景区 路线： 1. 购票进入乌兰布统景区（120元/人，有效期3天） 2. a. 影视基地：《还珠格格》《康熙王朝》取景地，登木栈道俯瞰草原全景。 b. 欧式风光区：夏季油菜花田（7月底可能仍有残余花期）、麦浪与草原交织。 c. 将军泡子：黄昏时拍摄湖泊倒影与牧归马群（可骑马或乘马车前往）。 ### 第三天：深度草原 + 湖泊湿地 主题：草原湖泊摄影与徒步 路线： 1. 清晨： a. 公主湖日出（必去！晨雾中的湖面如梦如幻，摄影黄金时间5:00-6:30）。 2. 上午： a. 盘龙峡谷：沿溪流徒步，欣赏白桦林与峡谷风光（适合避暑）。 3. 中午：野餐或在景区内牧民家吃蒙餐（推荐奶茶、奶豆腐）。 4. 下午： a. 蛤蟆坝（需单独门票30元）：夏季层次感极强的田园风光，摄影天堂。 b. 桦木沟国家森林公园：白桦林与草甸结合，适合休闲散步。 5. 傍晚：返回红山军马场，入住王志军农家院 ### 第四天：骑马+沙滩车等活动 主题：越野探险与私藏景点 路线： 1. 上午： 乌兰布统欢乐牧场（滑草、射箭等娱乐项目）。 \u0026gt; 返程前：沿途随意停车拍摄草原风光 2. 下午：返程（若时间充裕可绕道【达里诺尔湖】看日落）。 ### 注意事项： 1. 交通： a. 乌兰布统景区内景点分散 b. 注意部分路段为砂石路，雨后可能泥泞。 2. 穿衣： a. 夏季白天25℃左右，早晚温差大（需备冲锋衣或薄羽绒服）。 b. 防晒必备：墨镜、帽子、SPF50+防晒霜。 3. 其他： a. 7月底8月初为旅游旺季，提前预订住宿（红山军马场周边民宿约300-600元/晚）。 b. 尊重牧民习俗，勿随意碾压草场或驱赶牲畜。 ","date":"2025-08-09T13:10:57.09+08:00","permalink":"https://ynhugo.github.io/p/%E6%97%85%E6%B8%B8/%E6%97%85%E8%A1%8C/","title":"旅游/旅行"},{"content":" 将谷歌浏览器中的密码导入termux-pass中 注意 谷歌浏览器中导出的密码，要先将name中包含.*://的给去掉，斜杠也去掉； username中，要将.*://字符串给去掉，斜杠也去掉（其实约等于是要删除、放弃这个密码了） 脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # name,url,username,password,note mapfile -t names \u0026lt; \u0026lt;(cat Google_Passwords.csv | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $1}\u0026#39;) mapfile -t urls \u0026lt; \u0026lt;(cat Google_Passwords.csv | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39;) mapfile -t usernames \u0026lt; \u0026lt;(cat Google_Passwords.csv | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $3}\u0026#39;) mapfile -t passwords \u0026lt; \u0026lt;(cat Google_Passwords.csv | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $4}\u0026#39;) # name_num=\u0026#34;${#names[@]}\u0026#34; # echo \u0026#34;$name_num\u0026#34; if [ ! -d \u0026#34;temp\u0026#34; ]; then mkdir -p temp fi cd temp mkdir -p ${names[@]} var1=$(pwd) for ((i=0; i \u0026lt; ${#names[@]}; i++)) ; do # echo \u0026#34;${usernames[${i}]}\u0026#34; cd \u0026#34;${names[${i}]}\u0026#34; if [ \u0026#34;${usernames[${i}]}\u0026#34; == \u0026#34;\u0026#34; ]; then usernames[${i}]=\u0026#34;passwd${i}\u0026#34; fi # echo \u0026#34;${usernames[${i}]}\u0026#34; echo \u0026#34;${passwords[${i}]}\u0026#34; \u0026gt; \u0026#34;${usernames[${i}]}\u0026#34; echo \u0026#34;login: ${usernames[${i}]}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${usernames[${i}]}\u0026#34; echo \u0026#34;url: ${urls[${i}]}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${usernames[${i}]}\u0026#34; gpg --yes -r ynpass -e \u0026#34;${usernames[${i}]}\u0026#34; rm \u0026#34;${usernames[${i}]}\u0026#34; cd $var1 done ","date":"2025-08-09T03:41:08.5+08:00","permalink":"https://ynhugo.github.io/p/%E5%B0%86%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AF%BC%E5%85%A5termux-pass%E4%B8%AD/","title":"将谷歌浏览器中的密码导入termux-pass中"},{"content":" 折腾在Emacs里管理密码 \u0026lt;2025-08-08 Fri 15:36\u0026gt;\ntermux安装pass 1 apt install -y pass 创建gpg密钥 1 gpg --full-generate-key 按照提示创建密钥，注意记下其 ID。您应该使用默认密钥类型（RSA 和 RSA），但将密钥大小更改为 4,096 位以获得最大安全性。\n使用可用的 GPG 密钥，您现在可以初始化 pass。运行以下命令，将 placeholder-gpg-id 替换为您自己的 GPG ID 或 pub 。\n1 pass init placeholder-gpg-key 更新gpg密码 创建密钥的最后会让你设置一个密码短语，有时候可能会想更新密码短语。\n1 2 gpg --list-keys # 列出所有gpg密钥，找到想要更新密码的对应密钥的id gpt --edit-key ynpass # ynpass为我要更新密码的密钥的id，进入命令行执行passwd，然后先输入旧的密码，然后创建新的密码 emacs配置 1 2 3 4 (use-package pass :ensure t :commands (pass) ) 安装完后，我们可以通过 M-x pass 的方式来管理密码了。\n我们最主要使用到的两个操作是：\ni insert, 插入一个新的密码 j Jump to Entry, 跳转到我们想要的密码，查看密码 C-c,C-c 查看密码 插入新密码 我们在 pass 的界面按下 i 键后，会提示让我们输入 Password entry ，我们以 Email/example.com 为例来新建一个邮箱密码（Email这个目录是为了将密码分门别类，维护和可视化更加直观，核心在于 exmaple.com 这个邮箱所在的网站地址）。然后，它会提示你输入 Password ，以及 Confirm password ，两次密码必须输入一致。然后就添加成功了。此时，只有关于 example 的密码，还没有登录名信息，我们会在下个小节讲如何添加登录信息。\n查看一个密码 我们按下 j 键，通过 vertico 补全框架定位到 exmaple.com，光标会自动跳转到 example.com 这个条目上，然后按下回车。此时，根据它的提示，按下 C-c C-c 可以显示或者修改密码。这里，我们还需要增加一个信息，就是邮箱的登录名，我们添加一个 login 的信息如下：\n1 login: randolph@example.com 然后保存即可。\n参考链接 面向产品经理的Emacs教程：28. 在Emacs里管理密码\n如何使用 Pass，Linux 系统的命令行密码管理器\nGPG使用方法总结（密钥管理，加解密文件）\npass : 密码管理本不复杂#条目结构\npass-import 项目教程\n","date":"2025-08-08T16:32:17.65+08:00","permalink":"https://ynhugo.github.io/p/emacs%E7%AE%A1%E7%90%86%E5%AF%86%E7%A0%81/","title":"Emacs管理密码"},{"content":" ffmpeg将多个图片通过文件名时间戳或文件信息时间戳排序并生成mp4视频 1 2 3 4 5 6 7 8 # 1、准备文件列表，如果是根据文件信息时间戳排序，推荐第一种准备文件列表方式，如果是根据文件命名时间戳排序，推荐第2种方式准备文件列表 find ./ -name \u0026#34;*.jpg\u0026#34; -newermt \u0026#34;2025-08-01\u0026#34; -exec echo \u0026#34;file \u0026#34; \u0026gt;\u0026gt; jpgList.txt {} \\; # 或 ls P_*.jpg | sort -n \u0026gt; jpgList.txt; sed -i \u0026#39;s/^/file /\u0026#39; jpgList.txt # 2、根据准备的文件列表生成调色板 ffmpeg -f concat -safe 0 -i jpglist.txt -vf palettegen -y paletteg.jpg # 3、根据调色板及对应文件合成mp4视频 ffmpeg -r 1 -f image2 -f concat -safe 0 -i jpgList.txt -i paletteg.jpg -vcodec libx264 -crf 25 -pix_fmt yuv420p -y demo.mp4 参考链接 FFmpeg将有序帧（图片）转换成视频（解决了生成视频后播放闪烁的问题）\n用ffmpeg从多张图片生成动图\n如果是文件列表方式生成的可以按照如下命令操作\n视频转换成帧图片再转换成视频，如何考虑速率问题\n在指定行首添加字符串\n","date":"2025-08-05T02:12:22.75+08:00","permalink":"https://ynhugo.github.io/p/ffmpeg%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%9B%BE%E7%89%87%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E5%90%8D%E6%97%B6%E9%97%B4%E6%88%B3%E6%88%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E7%94%9F%E6%88%90mp4%E8%A7%86%E9%A2%91/","title":"ffmpeg将多个图片通过文件名时间戳或文件信息时间戳排序并生成mp4视频"},{"content":" termux+python+uiautomator2获取闹钟状态及闹钟状态设定 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import os import time import uiautomator2 as u2 connect=os.system(\u0026#39;adb devices | grep -w \u0026#34;device\u0026#34; | awk \\\u0026#39;{print $1}\\\u0026#39;\u0026#39;) d = u2.connect(connect) d.app_stop(\u0026#39;com.asus.deskclock\u0026#39;) d.app_start(\u0026#39;com.asus.deskclock\u0026#39;) # 获取某元素下的所有属性 # flag=d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.asus.deskclock:id/alarms_list\u0026#34;]/android.widget.LinearLayout[4]/android.widget.RelativeLayout[1]/android.widget.FrameLayout[1]/android.widget.LinearLayout[1]/android.widget.Switch[1]\u0026#39;).info # print(flag) for alarm_index in range(1,5): # 获取某元素下的所有属性 # flag=d.xpath(f\u0026#39;//*[@resource-id=\u0026#34;com.asus.deskclock:id/alarms_list\u0026#34;]/android.widget.LinearLayout[{alarm_index}]/android.widget.RelativeLayout[1]/android.widget.FrameLayout[1]/android.widget.LinearLayout[1]/android.widget.Switch[1]\u0026#39;).info # 获取某元素下的指定属性 flag=d.xpath(f\u0026#39;//*[@resource-id=\u0026#34;com.asus.deskclock:id/alarms_list\u0026#34;]/android.widget.LinearLayout[{alarm_index}]/android.widget.RelativeLayout[1]/android.widget.FrameLayout[1]/android.widget.LinearLayout[1]/android.widget.Switch[1]\u0026#39;).info[\u0026#39;checked\u0026#39;] # 判断闹钟复选框是未勾选状态，则打开闹钟 if flag==False: d.xpath(f\u0026#39;//*[@resource-id=\u0026#34;com.asus.deskclock:id/alarms_list\u0026#34;]/android.widget.LinearLayout[{alarm_index}]/android.widget.RelativeLayout[1]/android.widget.FrameLayout[1]/android.widget.LinearLayout[1]/android.widget.Switch[1]\u0026#39;).click() # 判断闹钟复选框是勾选状态，则关闭闹钟 else: d.xpath(f\u0026#39;//*[@resource-id=\u0026#34;com.asus.deskclock:id/alarms_list\u0026#34;]/android.widget.LinearLayout[{alarm_index}]/android.widget.RelativeLayout[1]/android.widget.FrameLayout[1]/android.widget.LinearLayout[1]/android.widget.Switch[1]\u0026#39;).click() time.sleep(0.1) d(text=\u0026#34;关闭这个重复闹钟\u0026#34;).click() time.sleep(0.1) time.sleep(1) d.swipe(28,1370,28,0,duration=0.7) for alarm_index in range(1,9): flag=d.xpath(f\u0026#39;//*[@resource-id=\u0026#34;com.asus.deskclock:id/alarms_list\u0026#34;]/android.widget.LinearLayout[{alarm_index}]/android.widget.RelativeLayout[1]/android.widget.FrameLayout[1]/android.widget.LinearLayout[1]/android.widget.Switch[1]\u0026#39;).info[\u0026#39;checked\u0026#39;] print(flag) 参考链接 uiautomator2获取UIObject元素的属性info用法\nuiautomator2详细使用方法-4. 元素定位\ntermux+uiautomator2给多个QQ好友点赞\ntermux+uiautomator2滑动屏幕\n","date":"2025-07-29T02:09:05.8+08:00","permalink":"https://ynhugo.github.io/p/termux-python-uiautomator2%E8%8E%B7%E5%8F%96%E9%97%B9%E9%92%9F%E7%8A%B6%E6%80%81%E5%8F%8A%E9%97%B9%E9%92%9F%E7%8A%B6%E6%80%81%E8%AE%BE%E5%AE%9A/","title":"termux+python+uiautomator2获取闹钟状态及闹钟状态设定"},{"content":" xss-labs靶场搭建及实战 1、安装php-study 下载链接：https://old.xp.cn/ 根据参考链接安装，直接运行安装程序默认安装D盘即可 然后启动Apache和MySQL 2、部署xss-labs 将xss-labs-master.zip改名为xss-labs（不改也行），然后将xss-labs放入php-study安装目录下的WWW目录中，然后访问xss-labs\n1 http://localhost/xss-labs/index.php 如果是在Termux中，可以进入xss-labs目录下，接着通过php命令运行服务，然后在浏览器中访问地址即可。\n1 php -S 192.168.xxx.xxx:8082 ip以手机实际的为准，端口可以自定义，只要在termux支持的端口范围并且系统没有占用就行。\n访问地址\n1 192.168.xxx.xxx:8082 3、靶场练习 根据参考链接进行xss-labs靶场练习\n参考链接 xss-labs靶场实战全通关详细过程（xss靶场详解）\n参考链接 [ 靶场环境篇 ] phpstudy 集成环境安装教程(特别详细)\n[ 靶场环境篇 ] XSS-labs 靶场环境搭建(特别详细)\nxss-labs\n","date":"2025-07-21T20:19:30.49+08:00","permalink":"https://ynhugo.github.io/p/xss-labs%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%AE%9E%E6%88%98/","title":"xss-labs靶场搭建及实战"},{"content":" termux+python+uiautomator2实现soul无限循环检测指定成员并对其进行封麦+禁言处理 代码实现 只需要修改要匹配的用户名字就行，名字由双引号括着：if d(descriptionContains=\u0026#34;行一＋一\u0026#34;).exists() or d(textContains=\u0026#34;行一＋一\u0026#34;).exists():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import os import re import time import uiautomator2 as u2 connect=os.system(\u0026#39;adb devices | grep -w \u0026#34;device\u0026#34; | awk \\\u0026#39;{print $1}\\\u0026#39;\u0026#39;) d = u2.connect(connect) element = d(resourceId=\u0026#34;cn.soulapp.android:id/tvUserCount\u0026#34;) if element.exists(): text = element.get_text() # 获取元素文本，如 \u0026#34;粉丝数：12345\u0026#34; # print(text) numbers=re.findall(r\u0026#39;\\d+\u0026#39;, text) if numbers: number = int(numbers[0]) # 取第一个匹配项 # print(\u0026#34;提取到的数字:\u0026#34;, number) else: print(\u0026#34;文本中无数字\u0026#34;) else: print(\u0026#34;未找到 tvUserCount 元素\u0026#34;) while True: for i in range(number-1): xpath = f\u0026#39;//*[@resource-id=\u0026#34;cn.soulapp.android:id/rvUser\u0026#34;]/android.widget.FrameLayout[{i+1}]/android.view.ViewGroup[1]/android.view.ViewGroup[1]/android.widget.ImageView[1]\u0026#39; d.xpath(xpath).click() if d(descriptionContains=\u0026#34;行一＋一\u0026#34;).exists() or d(textContains=\u0026#34;行一＋一\u0026#34;).exists(): print(\u0026#34;文本存在（模糊匹配）\u0026#34;) if d(text=\u0026#34;封麦\u0026#34;).exists: d(text=\u0026#34;封麦\u0026#34;).click() if d(text=\u0026#34;取消封麦\u0026#34;).exists: d(text=\u0026#34;取消封麦\u0026#34;).click() # time.sleep(1) d(resourceId=\u0026#34;cn.soulapp.android:id/iv_user_more\u0026#34;).click() time.sleep(1) if d(text=\u0026#34;禁止发言\u0026#34;).exists: d(text=\u0026#34;禁止发言\u0026#34;).click() if d(text=\u0026#34;取消禁言\u0026#34;).exists: d(text=\u0026#34;取消禁言\u0026#34;).click() else: print(\u0026#34;文本不存在\u0026#34;) d.press(\u0026#34;back\u0026#34;) 参考链接 termux+uiautomator2自动化\ntermux+uiautomator2给多个QQ好友点赞\nuiautomator2 -常用按键操作\n","date":"2025-07-20T05:38:25.68+08:00","permalink":"https://ynhugo.github.io/p/termux-python-uiautomator2%E5%AE%9E%E7%8E%B0soul%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%B5%8B%E6%8C%87%E5%AE%9A%E6%88%90%E5%91%98%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E5%B0%81%E9%BA%A6-%E7%A6%81%E8%A8%80%E5%A4%84%E7%90%86/","title":"termux+python+uiautomator2实现soul无限循环检测指定成员并对其进行封麦+禁言处理"},{"content":" crontab修改默认编辑器 如果不知道想要使用的编辑器的路径，可以用which命令确认编辑器路径，如： which vim 1 2 3 export EDITOR=\u0026#34;/usr/bin/vim\u0026#34; ; crontab -e # 或 export EDITOR=\u0026#34;/usr/bin/emacs\u0026#34; ; crontab -e # emacs是我自己喜欢用的一款编辑器 如果想方便一些，可以将变量添加到 ~/.bashrc 中，然后使用 source 生效。\n参考链接 crontab修改默认编辑器\n","date":"2025-07-15T02:26:24.28+08:00","permalink":"https://ynhugo.github.io/p/crontab%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BC%96%E8%BE%91%E5%99%A8/","title":"crontab修改默认编辑器"},{"content":" soul自动闭麦 使用场景 soul开派对，如果是一晚上不关派对且麦克风没有闭麦的情况下，当到了早上的时候，闹钟会响，然后会影响到派对里的人，这个时候有一个可以自动把soul的麦克风关闭的脚本在指定时间点自动运行，避免闹钟透过麦克风影响到其他人。\npython脚本 运行环境：termux 脚本运行前提：需要配置好uiautomator2和adb无线调试，无线调试开启后就可以使用127.0.0.1这个ip了。\n1 2 3 4 5 6 7 8 9 import sys import uiautomator2 as u2 d = u2.connect(\u0026#39;127.0.0.1\u0026#39;) # 首先检查当前是否是开麦状态（假设开麦状态下按钮可能有特定属性） # 这里需要根据实际UI情况调整判断条件 if d(resourceId=\u0026#34;cn.soulapp.android:id/ivMicButton\u0026#34;, description=\u0026#34;闭麦按钮\u0026#34;).exists: d(resourceId=\u0026#34;cn.soulapp.android:id/ivMicButton\u0026#34;, description=\u0026#34;闭麦按钮\u0026#34;).click() crontab定时任务 每天早上7点40自动运行soul自动闭麦python脚本。\n1 40 07 * * * bash $(python ~/soul自动闭麦.py) ","date":"2025-07-15T01:12:18.08+08:00","permalink":"https://ynhugo.github.io/p/soul%E8%87%AA%E5%8A%A8%E9%97%AD%E9%BA%A6/","title":"soul自动闭麦"},{"content":" termux定时运行python脚本 准备好的python脚本如下 - qq好友点赞.py 该脚本是用 rog8 pro 调出来的，该脚本如果要借鉴的话记得更改d.click()坐标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import sys import uiautomator2 as u2 d = u2.connect(\u0026#39;127.0.0.1\u0026#39;) # 可以通过传入ip参数执行该程序，如：python qq好友点赞.py 192.168.1.101 # d = u2.connect(sys.argv[1]) d.app_start(\u0026#39;com.tencent.mobileqq\u0026#39;) d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.tencent.mobileqq:id/e3u\u0026#34;]/android.widget.FrameLayout[1]\u0026#39;).click() d(resourceId=\u0026#34;com.tencent.mobileqq:id/us4\u0026#34;).click() d.click(949,650) for i in range(1): for j in range(10): xpath = f\u0026#39;//*[@resource-id=\u0026#34;com.tencent.mobileqq:id/kzn\u0026#34;]/android.widget.LinearLayout[{i+1}]/android.widget.RelativeLayout[1]/android.widget.RelativeLayout[1]/android.widget.ImageView[1]\u0026#39; d.xpath(xpath).click() d.app_stop(\u0026#39;com.tencent.mobileqq\u0026#39;) # d.app_clear(\u0026#39;com.tencent.mobileqq\u0026#39;) 使用crontab进行定时任务 首先防止设备休眠进程停止\n1 termux-wake-lock 其次开启crontab，执行命令\n1 crond 添加定时任务\n1 crontab -e 加入一行\n1 01 00 * * * bash $(python /data/data/com.termux/files/home/qq好友点赞.py) 这一行的意思每天凌晨十二点零一分开始运行命令 python qq好友点赞.py\n注意事项：\n请保持termux后台一直在运行，否则会失效。 并且这个软件似乎并不怎么费电。 如果定时任务没有执行，可能是crond服务没有开启，再执行一遍crond即可，并且确保adb的无线调试配置好了。 参考链接 Termux定时运行python脚本\nLinux Crontab 定时任务\nTermux定时任务\n","date":"2025-07-12T19:13:24.21+08:00","permalink":"https://ynhugo.github.io/p/termux%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/","title":"termux定时运行python脚本"},{"content":" 多文件字符串查找替换 1 2 3 4 5 6 7 8 9 find_str=$1 # 对应当前路径下多文件中要查找的字符串 replace_str=$2 # 对应当前路径下多文件中要替换的新字符串 mapfile -t files \u0026lt; \u0026lt;(find ./ -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; -o -name \u0026#34;*.cpp\u0026#34; | xargs grep -ainw \u0026#34;${find_str}\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39;) # -name指定了要查找的文件类型 # echo \u0026#34;${files[@]}\u0026#34; # 输出所有包含要查找的字符串的文件 for ((i = 0; i \u0026lt; \u0026#34;${#files[@]}\u0026#34;; i++)); do sed -i \u0026#34;s/${find_str}/${replace_str}/g\u0026#34; \u0026#34;${files[${i}]}\u0026#34; # 进行字符串替换，用法为：sed -i \u0026#34;s/新字符串/旧字符串/g file\u0026#34;，由于涉及到变量，因此使用双引号而不是单引号 done 使用示例 1 ~/find-replace.sh \u0026#34;text1\u0026#34; \u0026#34;text2\u0026#34; ","date":"2025-07-11T16:22:19.73+08:00","permalink":"https://ynhugo.github.io/p/%E5%A4%9A%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2/","title":"多文件字符串查找替换"},{"content":" Linux磁盘空间异常爆满的排查和处理 我采用了笨方法：在根目录下，通过du -hs命令，列出各目录所占空间大小\n1 2 3 sudo su cd / du -sh * 然后看哪个文件夹占用空间最大，再进入目录继续执行 du -sh * ，这样一步一步的追踪，通过这样的方式最终找到占用空间最大的文件。\n通过追溯，我发现有两个文件占用空间特别大，分别是这两个文件：\n1 2 /var/log/kern.log /var/log/syslog 我可以通过删除临时解决空间占用的问题，不过最根本的是解决问题产生的原因。由于我运行PCIE相关的程序，导致空间异常爆满，为了先临时解决问题是，我可以先删除这两个文件，然后再重启，发现空间异常爆满的问题解决了。\n1 2 3 4 5 6 7 8 rm /var/log/kern.log rm /var/log/syslog reboot # 或 echo \u0026#34;\u0026#34; \u0026gt; /var/log/kern.log echo \u0026#34;\u0026#34; \u0026gt; /var/log/syslog service syslog restart journalctl --vacuum-size=50M 您需要成为根用户:输入sudo su，密码，然后输入上面的命令\n这里有一个更安全的方法，允许您在回收磁盘空间的同时保留日志文件，同时也可以阻止日志文件再次这样做 安全地清除日志:在查看(或备份)日志以确定系统问题后，通过键入 \u0026gt; /var/log/syslog (包括 \u0026gt;)清除它们。您可能需要成为根用户，在这种情况下输入 sudo su 、您的密码，然后输入上面的命令)。 然后重新启动 syslog 服务( systemctl restart syslog 或 service syslog restart)。 然后，可以使用 logrotate 强制日志在达到一定大小时自动旋转和删除。在本例中，您可以使用 sudo vim /etc/logrotate.d/rsyslog 编辑配置并添加一行： maxsize 1G\n1 2 3 4 5 6 7 8 9 10 11 12 13 /var/log/syslog { rotate 7 daily maxsize 1G # add this line missingok notifempty delaycompress compress postrotate /usr/lib/rsyslog/rsyslog-rotate endscript } 这将迫使您的syslog“旋转”(即，创建一个新的日志文件并将前一个日志文件存档)，或者在该文件成为1GB之后(以第一位为准)。请注意，rotate 7意味着您的系统将只保留7次总的syslog备份，因此它只能占用7GB的空间。 注意:您可以更改maxsize、rotate N和其他设置以自定义日志–使用命令man logrotate查看更多信息。 您可能需要在文件的第二部分中添加相同的设置，它控制其他日志文件的行为(例如，kern.log用于内核事件，auth.log用于身份验证事件，等等)。此设置将使每个其他日志文件总共只占用4GB： 1 2 3 4 5 6 7 8 9 10 11 12 13 /var/log/kern.log { rotate 7 daily maxsize 1G # add this line missingok notifempty delaycompress compress postrotate /usr/lib/rsyslog/rsyslog-rotate endscript } 该配置紧挨着上一条配置。\n这将允许您的系统在不填充磁盘的情况下继续记录事件。\n参考链接 Linux 磁盘空间异常爆满的排查和处理\nLinux 中dmesg， kern.log， syslog 什么关系？有什么用？\nUbuntu 关闭rsyslog，var/log/syslog文件过大解决\n问Ubuntu:大型syslog和kern.log文件\n","date":"2025-07-11T15:03:04.98+08:00","permalink":"https://ynhugo.github.io/p/linux%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%BC%82%E5%B8%B8%E7%88%86%E6%BB%A1%E7%9A%84%E6%8E%92%E6%9F%A5%E5%92%8C%E5%A4%84%E7%90%86/","title":"Linux磁盘空间异常爆满的排查和处理"},{"content":" zip压缩文件时排除指定目录或文件 1 zip -r tet.zip ./ -x=\u0026#39;linux/01_fpga/*\u0026#39; -x=\u0026#39;linux/06_source/01_fpga/*\u0026#39; -x=\u0026#39;windows/01_fpga/*\u0026#39; -x=\u0026#39;linux.zip\u0026#39; -x=\u0026#39;windows/06_新电脑环境搭建/*\u0026#39; 参考链接 Linux命令zip：压缩文件夹时，排除指定文件或文件夹\n","date":"2025-07-11T14:02:27.45+08:00","permalink":"https://ynhugo.github.io/p/zip%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%97%B6%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6/","title":"zip压缩文件时排除指定目录或文件"},{"content":" shell脚本遍历文件及查找字符串 粘贴在终端执行效果最佳，这样只需要执行一次完整脚本，然后接下来再查找内容就只需从第3步复制粘贴到终端执行了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 1. 遍历一级目录中满足 *P*IE* 条件的目录 mapfile -t dirs1 \u0026lt; \u0026lt;(find ./ -maxdepth 1 -name \u0026#34;*P*IE*\u0026#34; -type d); echo \u0026#34;${dirs1[@]}\u0026#34; # 2. 在第一次遍历中的所以一级目录下查找满足 *windows 或 *linux 的目录，不区分大小写，作为第二次遍历的结果 for ((i = 0; i \u0026lt; \u0026#34;${#dirs1[${i}]}\u0026#34;; i++)); do mapfile -t -O \u0026#34;${#dirs2[@]}\u0026#34; dirs2 \u0026lt; \u0026lt;(find \u0026#34;${dirs1[${i}]}\u0026#34; -iname \u0026#34;*windows\u0026#34; -o -iname \u0026#34;*linux\u0026#34;) done echo \u0026#34;${dirs2[@]}\u0026#34; # 3. 在第二次遍历的目录中查找指定字符串 for ((j = 0; j \u0026lt; \u0026#34;${#dirs2[@]}\u0026#34;; j++)); do find \u0026#34;${dirs2[${j}]}\u0026#34; -name \u0026#34;*.c\u0026#34;\\ -o -name \u0026#34;*.cpp\u0026#34;\\ -o -name \u0026#34;*.h\u0026#34;\\ | xargs grep --color=always -ain\\ \u0026#34;YPcie_Set_Read_DMA_Blk\u0026#34; done ","date":"2025-07-11T12:43:56.2+08:00","permalink":"https://ynhugo.github.io/p/shell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%8F%8A%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"shell脚本遍历文件及查找字符串"},{"content":" ubuntu_16.04搭建Qt开发环境 安装依赖 1 sudo apt install -y gcc g++ make libgl1-mesa-dev Ubuntu 22.04可能需要安装的依赖： 1 sudo apt install -y gcc-12 安装向日葵可能需要的依赖 1 sudo apt --fix-broken install -y 向日葵远程控制Ubuntu 22可能会遇到黑屏问题 安装并选择lightdm，然后重启操作系统\n1 sudo apt install -y lightdm 如果在上面选择默认的视频管理插件手滑，点错了。我们可以输入如下命令，重新配置默认视频管理插件。\n1 sudo dpkg-reconfigure lightdm 参考链接 向日葵远程连接Ubuntu22主机黑屏解决方案\n准备安装包 通过网盘分享的文件：qt-opensource-linux-x64-5.14.2.run 链接: https://pan.baidu.com/s/12CXxXyqWIjq2-Mj_dO8wfQ?pwd=4qg5 提取码: 4qg5 安装Qt 前提：已在官网注册账户\n运行后，默认安装在家目录，如果需要的话也可以指定安装目录，我是默认安装在家目录，组件全选\n1 ./qt-opensource-linux-x64-5.14.2.run ","date":"2025-07-10T10:49:13.76+08:00","permalink":"https://ynhugo.github.io/p/ubuntu_16.04%E6%90%AD%E5%BB%BAqt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","title":"ubuntu_16.04搭建Qt开发环境"},{"content":" shell脚本中单行或多行屏蔽方法 单行注释符号：#\n1 # echo \u0026#34;abc\u0026#34; 多行注释： 方法一： 1 ((0)) \u0026amp;\u0026amp; {屏蔽块} 如\n1 2 3 4 ((0)) \u0026amp;\u0026amp; { echo \u0026#34;bbb\u0026#34; echo \u0026#34;ccc\u0026#34; } 方法二：COMMENT也可使用其他词替代，如 a,b,c等 1 2 3 \u0026lt;\u0026lt;COMMENT 屏蔽块 COMMENT 如\n1 2 3 4 \u0026lt;\u0026lt;COMMENT echo \u0026#34;bbb\u0026#34; echo \u0026#34;ccc\u0026#34; COMMENT 也可采用:\u0026lt;\u0026lt; \u0026#39;COMMENT\u0026#39;\n1 2 3 4 \u0026lt;\u0026lt;\u0026#39;COMMENT\u0026#39; echo \u0026#34;bbb\u0026#34; echo \u0026#34;ccc\u0026#34; COMMENT 方法三：空格 + 单引号 1 2 3 4 \u0026#39; echo \u0026#34;bbb\u0026#34; echo \u0026#34;ccc\u0026#34; \u0026#39; 方法四：!也可以换成任意字符，如a,b,c等等 1 2 3 \u0026lt;\u0026lt;! 屏蔽块 ! 如\n1 2 3 4 \u0026lt;\u0026lt;! echo \u0026#34;bbb\u0026#34; echo \u0026#34;ccc\u0026#34; ! 方法五： 1 2 3 if false; then 屏蔽块 fi 如\n1 2 3 4 if false; then echo \u0026#34;bbb\u0026#34; echo \u0026#34;ccc\u0026#34; fi 参考链接 shell脚本中单行或多行屏蔽方法\n","date":"2025-07-10T02:41:58.77+08:00","permalink":"https://ynhugo.github.io/p/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%8D%95%E8%A1%8C%E6%88%96%E5%A4%9A%E8%A1%8C%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95/","title":"shell脚本中单行或多行屏蔽方法"},{"content":" Windows硬盘数据迁移 老笔记本的硬盘空间不够用了，就一个硬盘，分两个区，一个对应C盘，另一个D盘，C盘是系统盘，D盘安装软件或存放数据。\n有一天，觉得空间不够用了，确认了笔记本可加装硬盘的参数后，购买了一个新的硬盘，将新的硬盘安装到笔记本上后，在硬盘管理中初始化硬盘后，将硬盘分两个区，一个主用区，一个备用区，并且盘符不能跟其他盘符重复，然后将D盘通过DiskGenius备份分区到镜像文件到新硬盘的备用区，接着将新硬盘的备用区的备份的镜像文件通过从镜像文件还原分区到新硬盘主分区。接着新硬盘可能会提示脱机，将新硬盘重新联机后重启后即可迁移数据成功，这个重启的时机可以自己把握，如果说刚还原完后感觉需要重启也可以重启。\n","date":"2025-07-10T02:23:40.55+08:00","permalink":"https://ynhugo.github.io/p/windows%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/","title":"Windows硬盘数据迁移"},{"content":" hugo在局域网中运行server 1 hugo server -D --bind 192.168.x.x -p 1313 ","date":"2025-07-08T23:25:19.88+08:00","permalink":"https://ynhugo.github.io/p/hugo%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E8%BF%90%E8%A1%8Cserver/","title":"hugo在局域网中运行server"},{"content":"参考链接：如何在hugo生成的网页中插入嵌入式视频-使用Hugo建立静态网站教程（进阶） 播放音乐测试 这里以网易云音乐为例，在网站根目录的layouts/下创建shortcodes/目录，然后在layouts/shortcodes/目录下创建netease.html文件，在该文件中加入如下代码定义：\n1 2 3 4 5 6 7 8 \u0026lt;iframe frameborder=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; marginwidth=\u0026#34;0\u0026#34; marginheight=\u0026#34;0\u0026#34; width=330 height=86 src=\u0026#34;//music.163.com/outchain/player?type=2\u0026amp;id={{.Get 0}}\u0026amp;auto=0\u0026amp;height=66\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 然后就可以在博客中按照如下方式添加音频了。\n测试文字属性 在网站根目录的layouts/下创建shortcodes/目录，然后在layouts/shortcodes/目录下创建align.html文件，在该文件中加入如下代码定义：\n1 \u0026lt;p style=\u0026#34;text-align:{{ index .Params 0 }}\u0026#34;\u0026gt;{{ index .Params 1 | markdownify }}\u0026lt;/p\u0026gt; 然后就可以在博客中按照如下方式设置文字属性了。\n文字居中\n测试插入github仓库 test 播放图片测试 播放视频测试 这里以B站为例，在网站根目录的layouts/下创建shortcodes/目录，然后在layouts/shortcodes/目录下创建bilibili.html文件，在该文件中加入如下代码定义：\n1 2 3 4 5 6 7 8 9 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?bvid={{.Get 0 }}\u0026amp;page={{ if .Get 1 }}{{.Get 1}}{{ else }}1{{end}}\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;/iframe\u0026gt; 然后就可以在博客中按照如下方式添加视频了。\n添加多标签 1 2 3 4 title: \u0026#34;测试\u0026#34; tags: [\u0026#34;hugo\u0026#34;, \u0026#34;blog\u0026#34;] categories: [\u0026#34;博客测试\u0026#34;] draft: false 配置主题 安装主题 把这个主题克隆到 themes 目录:\ngit clone https://github.com/dillonzq/LoveIt.git themes/LoveIt\n配置主题 站点配置文件的修改 将根目录\\themes\\LoveIt\\exampleSite路径下的config.toml文件复制到根目录下，覆盖掉根目录下的hugo.toml文件。然后，我们在notepad++中打开并对其作一定的修改就可以直接使用，具体可以修改的内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 baseURL = \u0026#39;https://example.com/\u0026#39; theme = \u0026#39;loveit\u0026#39; # theme # 主题 # themes directory # 主题目录 # themesDir = \u0026#34;../..\u0026#34; # website title # 网站标题 title = \u0026#34;yenao\u0026#34; # determines default content language [\u0026#34;en\u0026#34;, \u0026#34;zh-cn\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;pl\u0026#34;, ...] # 设置默认的语言 [\u0026#34;en\u0026#34;, \u0026#34;zh-cn\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;pl\u0026#34;, ...] defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # language code [\u0026#34;en\u0026#34;, \u0026#34;zh-CN\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;pl\u0026#34;, ...] # 网站语言, 仅在这里 CN 大写 [\u0026#34;en\u0026#34;, \u0026#34;zh-CN\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;pl\u0026#34;, ...] languageCode = \u0026#34;zh-cn\u0026#34; # language name [\u0026#34;English\u0026#34;, \u0026#34;简体中文\u0026#34;, \u0026#34;Français\u0026#34;, \u0026#34;Polski\u0026#34;, ...] # 语言名称 [\u0026#34;English\u0026#34;, \u0026#34;简体中文\u0026#34;, \u0026#34;Français\u0026#34;, \u0026#34;Polski\u0026#34;, ...] languageName = \u0026#34;简体中文\u0026#34; # whether to include Chinese/Japanese/Korean # 是否包括中日韩文字 hasCJKLanguage = false # default amount of posts in each pages # 默认每页列表显示的文章数目 paginate = 100 # google analytics code [UA-XXXXXXXX-X] # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \u0026#34;\u0026#34; # copyright description used only for seo schema # 版权描述，仅仅用于 SEO copyright = \u0026#34;\u0026#34; # whether to use robots.txt # 是否使用 robots.txt enableRobotsTXT = true # whether to use git commit log # 是否使用 git 信息 enableGitInfo = true # whether to use emoji code # 是否使用 emoji 代码 enableEmoji = true # ignore some build errors # 忽略一些构建错误 ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;, \u0026#34;error-missing-instagram-accesstoken\u0026#34;] # Author config # 作者配置 [author] name = \u0026#34;夜闹\u0026#34; email = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # Menu config # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \u0026#34;posts\u0026#34; # you can add extra information before the name (HTML format is supported), such as icons # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # you can add extra information after the name (HTML format is supported), such as icons # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; name = \u0026#34;Posts\u0026#34; url = \u0026#34;/posts/\u0026#34; # title will be shown when you hover on this menu link # 当您将鼠标悬停在此菜单链接上时, 将显示标题 title = \u0026#34;\u0026#34; [[menu.main]] weight = 2 identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; [[menu.main]] weight = 3 identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; [params] # site default theme [\u0026#34;auto\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34;] # 网站默认主题 [\u0026#34;auto\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34;] defaultTheme = \u0026#34;auto\u0026#34; # public git repo url only then enableGitInfo is true # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \u0026#34;https://github.com/dillonzq/LoveIt\u0026#34; # which hash function used for SRI, when empty, no SRI is used # [\u0026#34;sha256\u0026#34;, \u0026#34;sha384\u0026#34;, \u0026#34;sha512\u0026#34;, \u0026#34;md5\u0026#34;] # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\u0026#34;sha256\u0026#34;, \u0026#34;sha384\u0026#34;, \u0026#34;sha512\u0026#34;, \u0026#34;md5\u0026#34;] fingerprint = \u0026#34;\u0026#34; # date format # 日期格式 dateFormat = \u0026#34;2006-01-02\u0026#34; # website title for Open Graph and Twitter Cards # 网站标题, 用于 Open Graph 和 Twitter Cards title = \u0026#34;LoveIt\u0026#34; # website description for RSS, SEO, Open Graph and Twitter Cards # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \u0026#34;Hugo theme - LoveIt\u0026#34; # website images for Open Graph and Twitter Cards # 网站图片, 用于 Open Graph 和 Twitter Cards # images = [\u0026#34;/logo.png\u0026#34;] # Header config # 页面头部导航栏配置 [params.header] # desktop header mode [\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;] # 桌面端导航栏模式 [\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;] desktopMode = \u0026#34;auto\u0026#34; # mobile header mode [\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;] # 移动端导航栏模式 [\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;] mobileMode = \u0026#34;auto\u0026#34; # Header title config # 页面头部导航栏标题配置 [params.header.title] # URL of the LOGO # LOGO 的 URL logo = \u0026#34;\u0026#34; # title name # 标题名称 name = \u0026#34;yenao\u0026#34; # you can add extra information before the name (HTML format is supported), such as icons # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026lt;i class=\u0026#39;far fa-kiss-wink-heart fa-fw\u0026#39; aria-hidden=\u0026#39;true\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; # you can add extra information after the name (HTML format is supported), such as icons # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; # whether to use typeit animation for title name # 是否为标题显示打字机动画 typeit = false # Footer config # 页面底部信息配置 [params.footer] enable = false # Custom content (HTML format is supported) # 自定义内容 (支持 HTML 格式) custom = \u0026#34;\u0026#34; # whether to show Hugo and theme info # 是否显示 Hugo 和主题信息 hugo = true # whether to show copyright info # 是否显示版权信息 copyright = true # whether to show the author # 是否显示作者 author = true # site creation time # 网站创立年份 since = 2019 # ICP info only in China (HTML format is supported) # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \u0026#34;\u0026#34; # license info (HTML format is supported) # 许可协议信息 (支持 HTML 格式) license= \u0026#39;\u0026lt;a rel=\u0026#34;license external nofollow noopener noreffer\u0026#34; href=\u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;CC BY-NC 4.0\u0026lt;/a\u0026gt;\u0026#39; # Section (all posts) page config # Section (所有文章) 页面配置 [params.section] # special amount of posts in each section page # section 页面每页显示文章数量 paginate = 100 # date format (month and day) # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # amount of RSS pages # RSS 文章数目 rss = 100 # List (category or tag) page config # List (目录或标签) 页面配置 [params.list] # special amount of posts in each list page # list 页面每页显示文章数量 paginate = 1000 # date format (month and day) # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # amount of RSS pages # RSS 文章数目 rss = 100 # App icon config # 应用图标配置 [params.app] # optional site title override for the app when added to an iOS home screen or Android launcher # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \u0026#34;LoveIt\u0026#34; # whether to omit favicon resource links # 是否隐藏网站图标资源链接 noFavicon = false # modern SVG favicon to use in place of older style .png and .ico files # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \u0026#34;\u0026#34; # Android browser theme color # Android 浏览器主题色 themeColor = \u0026#34;#ffffff\u0026#34; # Safari mask icon color # Safari 图标颜色 iconColor = \u0026#34;#5bbad5\u0026#34; # Windows v8-11 tile color # Windows v8-11 磁贴颜色 tileColor = \u0026#34;#da532c\u0026#34; # Search config # 搜索配置 [params.search] enable = true # type of search engine [\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;] # 搜索引擎的类型 [\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;] type = \u0026#34;algolia\u0026#34; # max index length of the chunked content # 文章内容最长索引长度 contentLength = 4000 # placeholder of the search bar # 搜索框的占位提示语 placeholder = \u0026#34;\u0026#34; # max number of results length # 最大结果数目 maxResultLength = 10 # snippet length of the result # 结果内容片段长度 snippetLength = 30 # HTML tag name of the highlight part in results # 搜索结果中高亮部分的 HTML 标签 highlightTag = \u0026#34;em\u0026#34; # whether to use the absolute URL based on the baseURL in search index # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \u0026#34;\u0026#34; appID = \u0026#34;\u0026#34; searchKey = \u0026#34;\u0026#34; # Home page config # 主页信息设置 [params.home] # amount of RSS pages # RSS 文章数目 rss = 100 # Home page profile # 主页个人信息 [params.home.profile] enable = true # Gravatar Email for preferred avatar in home page # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # URL of avatar shown in home page # 主页显示头像的 URL avatarURL = \u0026#34;/images/avatar.png\u0026#34; # title shown in home page (HTML format is supported) # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;\u0026#34; # subtitle shown in home page (HTML format is supported) # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \u0026#34;A Clean, Elegant but Advanced Hugo Theme\u0026#34; # whether to use typeit animation for subtitle # 是否为副标题显示打字机动画 typeit = true # whether to show social links # 是否显示社交账号 social = true # disclaimer (HTML format is supported) # 免责声明 (支持 HTML 格式) disclaimer = \u0026#34;\u0026#34; # Home page posts # 主页文章列表 [params.home.posts] enable = true # special amount of posts in each home posts page # 主页每页显示文章数量 paginate = 100 # Social config in home page # 主页的社交信息设置 [params.social] GitHub = \u0026#34;\u0026#34; Linkedin = \u0026#34;\u0026#34; Twitter = \u0026#34;\u0026#34; Instagram = \u0026#34;\u0026#34; Facebook = \u0026#34;\u0026#34; Telegram = \u0026#34;\u0026#34; Medium = \u0026#34;\u0026#34; Gitlab = \u0026#34;\u0026#34; Youtubelegacy = \u0026#34;\u0026#34; Youtubecustom = \u0026#34;\u0026#34; Youtubechannel = \u0026#34;\u0026#34; Tumblr = \u0026#34;\u0026#34; Quora = \u0026#34;\u0026#34; Keybase = \u0026#34;\u0026#34; Pinterest = \u0026#34;\u0026#34; Reddit = \u0026#34;\u0026#34; Codepen = \u0026#34;\u0026#34; FreeCodeCamp = \u0026#34;\u0026#34; Bitbucket = \u0026#34;\u0026#34; Stackoverflow = \u0026#34;\u0026#34; Weibo = \u0026#34;\u0026#34; Odnoklassniki = \u0026#34;\u0026#34; VK = \u0026#34;\u0026#34; Flickr = \u0026#34;\u0026#34; Xing = \u0026#34;\u0026#34; Snapchat = \u0026#34;\u0026#34; Soundcloud = \u0026#34;\u0026#34; Spotify = \u0026#34;\u0026#34; Bandcamp = \u0026#34;\u0026#34; Paypal = \u0026#34;\u0026#34; Fivehundredpx = \u0026#34;\u0026#34; Mix = \u0026#34;\u0026#34; Goodreads = \u0026#34;\u0026#34; Lastfm = \u0026#34;\u0026#34; Foursquare = \u0026#34;\u0026#34; Hackernews = \u0026#34;\u0026#34; Kickstarter = \u0026#34;\u0026#34; Patreon = \u0026#34;\u0026#34; Steam = \u0026#34;\u0026#34; Twitch = \u0026#34;\u0026#34; Strava = \u0026#34;\u0026#34; Skype = \u0026#34;\u0026#34; Whatsapp = \u0026#34;\u0026#34; Zhihu = \u0026#34;\u0026#34; Douban = \u0026#34;\u0026#34; Angellist = \u0026#34;\u0026#34; Slidershare = \u0026#34;\u0026#34; Jsfiddle = \u0026#34;\u0026#34; Deviantart = \u0026#34;\u0026#34; Behance = \u0026#34;\u0026#34; Dribbble = \u0026#34;\u0026#34; Wordpress = \u0026#34;\u0026#34; Vine = \u0026#34;\u0026#34; Googlescholar = \u0026#34;\u0026#34; Researchgate = \u0026#34;\u0026#34; Mastodon = \u0026#34;\u0026#34; Thingiverse = \u0026#34;\u0026#34; Devto = \u0026#34;\u0026#34; Gitea = \u0026#34;\u0026#34; XMPP = \u0026#34;\u0026#34; Matrix = \u0026#34;\u0026#34; Bilibili = \u0026#34;\u0026#34; Discord = \u0026#34;\u0026#34; DiscordInvite = \u0026#34;\u0026#34; Lichess = \u0026#34;\u0026#34; ORCID = \u0026#34;\u0026#34; Pleroma = \u0026#34;\u0026#34; Kaggle = \u0026#34;\u0026#34; MediaWiki= \u0026#34;\u0026#34; Plume = \u0026#34;\u0026#34; HackTheBox = \u0026#34;\u0026#34; RootMe= \u0026#34;\u0026#34; Email = \u0026#34;\u0026#34; RSS = \u0026#34;\u0026#34; # Page global config # 文章页面全局配置 [params.page] # whether to hide a page from home page # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # whether to hide a page from search results # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # whether to enable twemoji # 是否使用 twemoji twemoji = false # whether to enable lightgallery # 是否使用 lightgallery lightgallery = false # whether to enable the ruby extended syntax # 是否使用 ruby 扩展语法 ruby = true # whether to enable the fraction extended syntax # 是否使用 fraction 扩展语法 fraction = true # whether to enable the fontawesome extended syntax # 是否使用 fontawesome 扩展语法 fontawesome = true # whether to show link to Raw Markdown content of the content # 是否显示原始 Markdown 文档内容的链接 linkToMarkdown = true # whether to show the full text content in RSS # 是否在 RSS 中显示全文内容 rssFullText = true # Table of the contents config # 目录配置 [params.page.toc] # whether to enable the table of the contents # 是否使用目录 enable = true # whether to keep the static table of the contents in front of the post # 是否保持使用文章前面的静态目录 keepStatic = false # whether to make the table of the contents in the sidebar automatically collapsed # 是否使侧边目录自动折叠展开 auto = true # Code config # 代码配置 [params.page.code] # whether to show the copy button of the code block # 是否显示代码块的复制按钮 copy = true # the maximum number of lines of displayed code by default # 默认展开显示的代码行数 maxShownLines = 1000 # KaTeX mathematical formulas config (KaTeX https://katex.org/) # KaTeX 数学公式配置 (KaTeX https://katex.org/) [params.page.math] enable = true # default inline delimiter is $ ... $ and \\( ... \\) # 默认行内定界符是 $ ... $ 和 \\( ... \\) inlineLeftDelimiter = \u0026#34;\u0026#34; inlineRightDelimiter = \u0026#34;\u0026#34; # default block delimiter is $$ ... $$, \\[ ... \\], \\begin{equation} ... \\end{equation} and some other functions # 默认块定界符是 $$ ... $$, \\[ ... \\], \\begin{equation} ... \\end{equation} 和一些其它的函数 blockLeftDelimiter = \u0026#34;\u0026#34; blockRightDelimiter = \u0026#34;\u0026#34; # KaTeX extension copy_tex # KaTeX 插件 copy_tex copyTex = true # KaTeX extension mhchem # KaTeX 插件 mhchem mhchem = true # Mapbox GL JS config (Mapbox GL JS https://docs.mapbox.com/mapbox-gl-js) # Mapbox GL JS 配置 (Mapbox GL JS https://docs.mapbox.com/mapbox-gl-js) [params.page.mapbox] # access token of Mapbox GL JS # Mapbox GL JS 的 access token accessToken = \u0026#34;pk.eyJ1IjoiZGlsbG9uenEiLCJhIjoiY2s2czd2M2x3MDA0NjNmcGxmcjVrZmc2cyJ9.aSjv2BNuZUfARvxRYjSVZQ\u0026#34; # style for the light theme # 浅色主题的地图样式 lightStyle = \u0026#34;mapbox://styles/mapbox/light-v10?optimize=true\u0026#34; # style for the dark theme # 深色主题的地图样式 darkStyle = \u0026#34;mapbox://styles/mapbox/dark-v10?optimize=true\u0026#34; # whether to add NavigationControl (https://docs.mapbox.com/mapbox-gl-js/api/#navigationcontrol) # 是否添加 NavigationControl (https://docs.mapbox.com/mapbox-gl-js/api/#navigationcontrol) navigation = true # whether to add GeolocateControl (https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol) # 是否添加 GeolocateControl (https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol) geolocate = true # whether to add ScaleControl (https://docs.mapbox.com/mapbox-gl-js/api/#scalecontrol) # 是否添加 ScaleControl (https://docs.mapbox.com/mapbox-gl-js/api/#scalecontrol) scale = true # whether to add FullscreenControl (https://docs.mapbox.com/mapbox-gl-js/api/#fullscreencontrol) # 是否添加 FullscreenControl (https://docs.mapbox.com/mapbox-gl-js/api/#fullscreencontrol) fullscreen = true # Social share links in post page # 文章页面的分享信息设置 [params.page.share] enable = true Twitter = true Facebook = true Linkedin = false Whatsapp = false Pinterest = false Tumblr = false HackerNews = true Reddit = false VK = false Buffer = false Xing = false Line = true Instapaper = false Pocket = false Flipboard = false Weibo = true Blogger = false Baidu = false Odnoklassniki = false Evernote = false Skype = false Trello = false Mix = false # Comment config # 评论系统设置 [params.page.comment] enable = true # Disqus comment config (https://disqus.com/) # Disqus 评论系统设置 (https://disqus.com/) [params.page.comment.disqus] enable = false # Disqus shortname to use Disqus in posts # Disqus 的 shortname，用来在文章中启用 Disqus 评论系统 shortname = \u0026#34;\u0026#34; # Gitalk comment config (https://github.com/gitalk/gitalk) # Gitalk 评论系统设置 (https://github.com/gitalk/gitalk) [params.page.comment.gitalk] enable = false owner = \u0026#34;\u0026#34; repo = \u0026#34;\u0026#34; clientId = \u0026#34;\u0026#34; clientSecret = \u0026#34;\u0026#34; # Valine comment config (https://github.com/xCss/Valine) # Valine 评论系统设置 (https://github.com/xCss/Valine) [params.page.comment.valine] enable = true appId = \u0026#34;QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI\u0026#34; appKey = \u0026#34;WBmoGyJtbqUswvfLh6L8iEBr\u0026#34; placeholder = \u0026#34;\u0026#34; avatar = \u0026#34;mp\u0026#34; meta= \u0026#34;\u0026#34; pageSize = 10 # automatically adapt the current theme i18n configuration when empty # 为空时自动适配当前主题 i18n 配置 lang = \u0026#34;\u0026#34; visitor = true recordIP = true highlight = true enableQQ = false serverURLs = \u0026#34;https://leancloud.hugoloveit.com\u0026#34; # emoji data file name, default is \u0026#34;google.yml\u0026#34; # [\u0026#34;apple.yml\u0026#34;, \u0026#34;google.yml\u0026#34;, \u0026#34;facebook.yml\u0026#34;, \u0026#34;twitter.yml\u0026#34;] # located in \u0026#34;themes/LoveIt/assets/lib/valine/emoji/\u0026#34; directory # you can store your own data files in the same path under your project: # \u0026#34;assets/lib/valine/emoji/\u0026#34; # emoji 数据文件名称, 默认是 \u0026#34;google.yml\u0026#34; # [\u0026#34;apple.yml\u0026#34;, \u0026#34;google.yml\u0026#34;, \u0026#34;facebook.yml\u0026#34;, \u0026#34;twitter.yml\u0026#34;] # 位于 \u0026#34;themes/LoveIt/assets/lib/valine/emoji/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/lib/valine/emoji/\u0026#34; emoji = \u0026#34;\u0026#34; # Facebook comment config (https://developers.facebook.com/docs/plugins/comments) # Facebook 评论系统设置 (https://developers.facebook.com/docs/plugins/comments) [params.page.comment.facebook] enable = false width = \u0026#34;100%\u0026#34; numPosts = 10 appId = \u0026#34;\u0026#34; # automatically adapt the current theme i18n configuration when empty # 为空时自动适配当前主题 i18n 配置 languageCode = \u0026#34;\u0026#34; # Telegram comments config (https://comments.app/) # Telegram comments 评论系统设置 (https://comments.app/) [params.page.comment.telegram] enable = false siteID = \u0026#34;\u0026#34; limit = 5 height = \u0026#34;\u0026#34; color = \u0026#34;\u0026#34; colorful = true dislikes = false outlined = false # Commento comment config (https://commento.io/) # Commento comment 评论系统设置 (https://commento.io/) [params.page.comment.commento] enable = false # utterances comment config (https://utteranc.es/) # utterances comment 评论系统设置 (https://utteranc.es/) [params.page.comment.utterances] enable = false # owner/repo repo = \u0026#34;\u0026#34; issueTerm = \u0026#34;pathname\u0026#34; label = \u0026#34;\u0026#34; lightTheme = \u0026#34;github-light\u0026#34; darkTheme = \u0026#34;github-dark\u0026#34; # giscus comment config (https://giscus.app/) # giscus comment 评论系统设置 (https://giscus.app/zh-CN) [params.page.comment.giscus] # You can refer to the official documentation of giscus to use the following configuration. # 你可以参考官方文档来使用下列配置 enable = false repo = \u0026#34;\u0026#34; repoId = \u0026#34;\u0026#34; category = \u0026#34;Announcements\u0026#34; categoryId = \u0026#34;\u0026#34; # automatically adapt the current theme i18n configuration when empty # 为空时自动适配当前主题 i18n 配置 lang = \u0026#34;\u0026#34; mapping = \u0026#34;pathname\u0026#34; reactionsEnabled = \u0026#34;1\u0026#34; emitMetadata = \u0026#34;0\u0026#34; inputPosition = \u0026#34;bottom\u0026#34; lazyLoading = false lightTheme = \u0026#34;light\u0026#34; darkTheme = \u0026#34;dark\u0026#34; # Third-party library config # 第三方库配置 [params.page.library] [params.page.library.css] # someCSS = \u0026#34;some.css\u0026#34; # located in \u0026#34;assets/\u0026#34; 位于 \u0026#34;assets/\u0026#34; # Or 或者 # someCSS = \u0026#34;https://cdn.example.com/some.css\u0026#34; [params.page.library.js] # someJavascript = \u0026#34;some.js\u0026#34; # located in \u0026#34;assets/\u0026#34; 位于 \u0026#34;assets/\u0026#34; # Or 或者 # someJavascript = \u0026#34;https://cdn.example.com/some.js\u0026#34; # Page SEO config # 页面 SEO 配置 [params.page.seo] # image URL # 图片 URL images = [] # Publisher info # 出版者信息 [params.page.seo.publisher] name = \u0026#34;xxxx\u0026#34; logoUrl = \u0026#34;/images/avatar.png\u0026#34; # TypeIt config # TypeIt 配置 [params.typeit] # typing speed between each step (measured in milliseconds) # 每一步的打字速度 (单位是毫秒) speed = 100 # blinking speed of the cursor (measured in milliseconds) # 光标的闪烁速度 (单位是毫秒) cursorSpeed = 1000 # character used for the cursor (HTML format is supported) # 光标的字符 (支持 HTML 格式) cursorChar = \u0026#34;|\u0026#34; # cursor duration after typing finishing (measured in milliseconds, \u0026#34;-1\u0026#34; means unlimited) # 打字结束之后光标的持续时间 (单位是毫秒, \u0026#34;-1\u0026#34; 代表无限大) duration = -1 # Site verification code for Google/Bing/Yandex/Pinterest/Baidu # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [params.verification] google = \u0026#34;\u0026#34; bing = \u0026#34;\u0026#34; yandex = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; baidu = \u0026#34;\u0026#34; # Site SEO config # 网站 SEO 配置 [params.seo] # image URL # 图片 URL image = \u0026#34;/images/Apple-Devices-Preview.png\u0026#34; # thumbnail URL # 缩略图 URL thumbnailUrl = \u0026#34;/images/screenshot.png\u0026#34; # Analytics config # 网站分析配置 [params.analytics] enable = false # Google Analytics [params.analytics.google] id = \u0026#34;\u0026#34; # whether to anonymize IP # 是否匿名化用户 IP anonymizeIP = true # Fathom Analytics [params.analytics.fathom] id = \u0026#34;\u0026#34; # server url for your tracker if you\u0026#39;re self hosting # 自行托管追踪器时的主机路径 server = \u0026#34;\u0026#34; # Plausible Analytics [params.analytics.plausible] dataDomain = \u0026#34;\u0026#34; # Yandex Metrica [params.analytics.yandexMetrica] id = \u0026#34;\u0026#34; # Cookie consent config # Cookie 许可配置 [params.cookieconsent] enable = false # text strings used for Cookie consent banner # 用于 Cookie 许可横幅的文本字符串 [params.cookieconsent.content] message = \u0026#34;\u0026#34; dismiss = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # CDN config for third-party library files # 第三方库文件的 CDN 设置 [params.cdn] # CDN data file name, disabled by default # [\u0026#34;jsdelivr.yml\u0026#34;] # located in \u0026#34;themes/LoveIt/assets/data/cdn/\u0026#34; directory # you can store your own data files in the same path under your project: # \u0026#34;assets/data/cdn/\u0026#34; # CDN 数据文件名称, 默认不启用 # [\u0026#34;jsdelivr.yml\u0026#34;] # 位于 \u0026#34;themes/LoveIt/assets/data/cdn/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/data/cdn/\u0026#34; data = \u0026#34;jsdelivr.yml\u0026#34; # Compatibility config # 兼容性设置 [params.compatibility] # whether to use Polyfill.io to be compatible with older browsers # 是否使用 Polyfill.io 来兼容旧式浏览器 polyfill = false # whether to use object-fit-images to be compatible with older browsers # 是否使用 object-fit-images 来兼容旧式浏览器 objectFit = false # Markup related configuration in Hugo # Hugo 解析文档的配置 [markup] # Syntax Highlighting (https://gohugo.io/content-management/syntax-highlighting) # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false is a necessary configuration (https://github.com/dillonzq/LoveIt/issues/158) # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark is from Hugo 0.60 the default library used for Markdown # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # whether to use HTML tags directly in the document # 是否在文档中直接使用 HTML 标签 unsafe = true # Table Of Contents settings # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 # Sitemap config # 网站地图配置 [sitemap] changefreq = \u0026#34;weekly\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; priority = 0.5 # Permalinks config (https://gohugo.io/content-management/urls/#permalinks) # Permalinks 配置 (https://gohugo.io/content-management/urls/#permalinks) [Permalinks] # posts = \u0026#34;:year/:month/:filename\u0026#34; posts = \u0026#34;:filename\u0026#34; # Privacy config (https://gohugo.io/about/hugo-and-gdpr/) # 隐私信息配置 (https://gohugo.io/about/hugo-and-gdpr/) [privacy] # privacy of the Google Analytics (replaced by params.analytics.google) # Google Analytics 相关隐私 (被 params.analytics.google 替代) [privacy.googleAnalytics] # ... [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true # Options to make output .md files # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\u0026#34;text/plain\u0026#34;] suffixes = [\u0026#34;md\u0026#34;] # Options to make output .md files # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \u0026#34;text/plain\u0026#34; isPlainText = true isHTML = false # Options to make hugo output files # 用于 Hugo 输出文档的设置 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] page = [\u0026#34;HTML\u0026#34;, \u0026#34;MarkDown\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;] # Multilingual # 多语言 [languages] [languages.en] weight = 1 languageCode = \u0026#34;en\u0026#34; languageName = \u0026#34;English\u0026#34; hasCJKLanguage = false copyright = \u0026#34;This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\u0026#34; [languages.en.menu] [[languages.en.menu.main]] weight = 1 identifier = \u0026#34;posts\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Posts\u0026#34; url = \u0026#34;/posts/\u0026#34; title = \u0026#34;\u0026#34; [[languages.en.menu.main]] weight = 2 identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; [[languages.en.menu.main]] weight = 3 identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; [[languages.en.menu.main]] weight = 4 identifier = \u0026#34;documentation\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Docs\u0026#34; url = \u0026#34;/categories/documentation/\u0026#34; title = \u0026#34;\u0026#34; [[languages.en.menu.main]] weight = 5 identifier = \u0026#34;about\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;About\u0026#34; url = \u0026#34;/about/\u0026#34; title = \u0026#34;\u0026#34; [[languages.en.menu.main]] weight = 6 identifier = \u0026#34;github\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fab fa-github fa-fw\u0026#39; aria-hidden=\u0026#39;true\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;\u0026#34; url = \u0026#34;https://github.com/dillonzq/LoveIt\u0026#34; title = \u0026#34;GitHub\u0026#34; [languages.en.params] [languages.en.params.search] enable = true type = \u0026#34;algolia\u0026#34; contentLength = 4000 placeholder = \u0026#34;\u0026#34; maxResultLength = 10 snippetLength = 30 highlightTag = \u0026#34;em\u0026#34; absoluteURL = false [languages.en.params.search.algolia] index = \u0026#34;index.en\u0026#34; appID = \u0026#34;PASDMWALPK\u0026#34; searchKey = \u0026#34;b42948e51daaa93df92381c8e2ac0f93\u0026#34; [languages.en.params.home] rss = 10 [languages.en.params.home.profile] enable = true gravatarEmail = \u0026#34;\u0026#34; avatarURL = \u0026#34;/images/avatar.png\u0026#34; title = \u0026#34;\u0026#34; subtitle = \u0026#34;A Clean, Elegant but Advanced Hugo Theme\u0026#34; typeit = true social = true disclaimer = \u0026#34;\u0026#34; [languages.en.params.social] GitHub = \u0026#34;xxxx\u0026#34; Twitter = \u0026#34;xxxx\u0026#34; Instagram = \u0026#34;xxxx\u0026#34; Facebook = \u0026#34;xxxx\u0026#34; Telegram = \u0026#34;xxxx\u0026#34; Youtubelegacy = \u0026#34;xxxx\u0026#34; Phone = \u0026#34;555-555-555\u0026#34; Email = \u0026#34;xxxx@xxxx.com\u0026#34; RSS = true [languages.en.params.social.Mastodon] id = \u0026#34;@xxxx\u0026#34; prefix = \u0026#34;https://mastodon.technology/\u0026#34; [languages.zh-cn] weight = 2 languageCode = \u0026#34;zh-CN\u0026#34; languageName = \u0026#34;简体中文\u0026#34; hasCJKLanguage = true copyright = \u0026#34;This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\u0026#34; [languages.zh-cn.menu] [[languages.zh-cn.menu.main]] weight = 1 identifier = \u0026#34;posts\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;所有文章\u0026#34; url = \u0026#34;/posts/\u0026#34; title = \u0026#34;\u0026#34; [[languages.zh-cn.menu.main]] weight = 2 identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; [[languages.zh-cn.menu.main]] weight = 3 identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;分类\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; [[languages.zh-cn.menu.main]] weight = 4 identifier = \u0026#34;documentation\u0026#34; pre = \u0026#34;\u0026#34; name = \u0026#34;文档\u0026#34; url = \u0026#34;/categories/documentation/\u0026#34; title = \u0026#34;\u0026#34; [[languages.zh-cn.menu.main]] weight = 5 identifier = \u0026#34;about\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;关于\u0026#34; url = \u0026#34;/about/\u0026#34; title = \u0026#34;\u0026#34; [[languages.zh-cn.menu.main]] weight = 6 identifier = \u0026#34;github\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fab fa-github fa-fw\u0026#39; aria-hidden=\u0026#39;true\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;\u0026#34; url = \u0026#34;https://github.com/dillonzq/LoveIt\u0026#34; title = \u0026#34;GitHub\u0026#34; [languages.zh-cn.params] [languages.zh-cn.params.search] enable = true type = \u0026#34;algolia\u0026#34; contentLength = 4000 placeholder = \u0026#34;\u0026#34; maxResultLength = 10 snippetLength = 50 highlightTag = \u0026#34;em\u0026#34; absoluteURL = false [languages.zh-cn.params.search.algolia] index = \u0026#34;index.zh-cn\u0026#34; appID = \u0026#34;PASDMWALPK\u0026#34; searchKey = \u0026#34;b42948e51daaa93df92381c8e2ac0f93\u0026#34; [languages.zh-cn.params.home] rss = 100 [languages.zh-cn.params.home.profile] enable = false gravatarEmail = \u0026#34;\u0026#34; avatarURL = \u0026#34;/images/avatar.png\u0026#34; title = \u0026#34;\u0026#34; subtitle = \u0026#34;一个简洁、优雅且高效的 Hugo 主题\u0026#34; typeit = true social = true disclaimer = \u0026#34;\u0026#34; [languages.zh-cn.params.social] GitHub = \u0026#34;xxxx\u0026#34; Weibo = \u0026#34;xxxx\u0026#34; Steam = \u0026#34;xxxx\u0026#34; Zhihu = \u0026#34;xxxx\u0026#34; Douban = \u0026#34;xxxx\u0026#34; Devto = \u0026#34;xxxx\u0026#34; Bilibili = \u0026#34;xxxx\u0026#34; Email = \u0026#34;xxxx@xxxx.com\u0026#34; Phone = \u0026#34;555-555-555\u0026#34; RSS = true 配置环境变量 1 2 3 export HUGO1=/cygdrive/d/share/hugo/hugo1 export H1P=/cygdrive/d/share/hugo/hugo1/content/posts export H1U=\u0026#34;source /cygdrive/d/share/hugo/hugo1/upload.sh\u0026#34; upload.sh脚本包含的是博客编译并上传的命令\n在 Hugo 的 config.yaml 文件中配置菜单 你需要在 menu 字段下添加相应的内容。在你提供的配置文件中，你可以看到以下部分用于定制菜单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 menu: main: [] social: - identifier: github name: GitHub url: https://github.com/ynhugo params: icon: brand-github - identifier: twitter name: Twitter url: https://twitter.com params: icon: brand-twitter 在上面的示例中，menu 字段下定义了两个菜单：main 和 social。你可以根据自己的需求添加或修改菜单项。例如，如果你想在 main 菜单中添加一个链接到主页的菜单项，可以像这样修改配置：\n1 2 3 4 5 6 menu: main: - identifier: home name: 首页 url: / weight: 1 这样就会在网站的主菜单中添加一个指向首页的链接。记得根据自己的网站需求和页面结构来调整菜单配置。对于其他文件，通常不需要额外的配置来支持菜单的显示，只需在 config.yaml 中正确配置即可。\n在 Hugo 的配置文件中添加图标通常需要使用图标库或者自定义图标 在你提供的配置文件中，看到有一个示例使用了 icon: brand-github 和 icon: brand-twitter 来指定图标。这里使用的是 FontAwesome 图标库中的图标类名。\n如果你想使用其他图标库或自定义图标，可以按照以下步骤进行：\n**选择图标库：**选择一个适合你需求的图标库，比如 Font Awesome、Material Icons 等。确保你能够获取到所需图标的类名或标识符。\n**下载或引入图标库：**根据图标库的要求，下载相应的图标文件或通过 CDN 引入。将图标库的 CSS 文件或 JavaScript 文件链接添加到你的 Hugo 主题中。\n**配置图标：**在 Hugo 的配置文件中，为菜单项指定相应的图标类名或标识符。例如，如果你选择了 Font Awesome 图标库，可以像下面这样配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 menu: social: - identifier: github name: GitHub url: https://github.com/ynhugo params: icon: fab fa-github - identifier: twitter name: Twitter url: https://twitter.com params: icon: fab fa-twitter 在上述示例中，fab 表示 Font Awesome 的品牌图标系列，后面跟着具体的图标名称。根据你选择的图标库和图标名称，替换 fab fa-github 和 fab fa-twitter 部分即可。\n**查看效果：**保存配置文件并重新生成 Hugo 网站，查看菜单是否显示了相应的图标。 记得根据实际情况调整图标库和图标类名，确保图标能够正确显示在你的网站上。\n在 Hugo 中，创建对应菜单的首页文件通常是通过创建 content 文件来实现的 你可以按照以下步骤来创建对应菜单的首页文件：\n确定菜单对应的内容页面： 首先确定菜单项所对应的内容页面。比如，如果你创建了一个 \u0026ldquo;blog\u0026rdquo; 菜单，那么你可能需要创建一个用于显示博客列表的页面。\n创建内容文件： 在 Hugo 网站的 content 目录下，根据菜单对应的内容类型创建相应的 Markdown 文件。假设你要创建一个 \u0026ldquo;blog\u0026rdquo; 菜单对应的页面，可以在 content 目录下创建一个名为 blog.md 的文件。\n编辑内容文件： 编辑刚创建的 Markdown 文件，添加页面所需的 Front Matter 和内容。Front Matter 是位于文件开头的一组 YAML 元数据，用于定义页面的属性，比如标题、日期、标签等。\n例如，一个简单的 blog.md 文件可能如下所示：\n1 2 3 4 5 6 7 --- title: \u0026#34;博客\u0026#34; date: 2024-03-24 description: \u0026#34;这是我的博客页面\u0026#34; --- 这里是博客页面的内容。 保存文件并生成网站： 保存 blog.md 文件并重新生成 Hugo 网站。在生成的网站中，你应该能够在菜单中看到相应的 \u0026ldquo;博客\u0026rdquo; 链接，并且点击链接后会跳转到你刚创建的内容页面。\n根据你的网站主题和页面结构，有时候不同的主题可能需要在不同的位置进行配置或创建文件，具体操作可能会有些许差异。请根据你使用的主题及其文档说明进行相应的操作。\n添加About 栏 如果 ~/hugo_blog/content/ 下面没有about 文件夹的话\n在 ~/hugo_blog/content/ 创建 about 目录，并在该目录下添加 index.md 文件\n1 2 3 4 5 6 7 8 9 10 11 12 --- title : \u0026#34;About\u0026#34; lastmod : 2022-03-10T19:36:26+08:00 draft : false menu: main: weight: -90 params: icon: user --- Hellow, World! :@ 注意: Even 主题中 文件头部是用 +++ +++ 包起来的 而Stack 主题中 文件头部是用 \u0026mdash; \u0026mdash; 包起来的 而且在Stack 中 menu: 到时user 部分不能动, 哪怕是改了缩进都会导致识别不出About\n参考链接 博客切换到STACK 主题\n要使用其他图标，你��以按照以下步骤获取对应的 SVG 代码： 打开一个提供免费图标的网站，比如 Tabler Icons、FontAwesome 或 Feather Icons。\n在网站上搜索你想要使用的图标，然后找到该图标对应的 SVG 代码。这些网站通常会提供直接复制的 SVG 代码。\n复制选定图标的完整 SVG 代码。\n将复制的 SVG 代码粘贴到 Hugo 博客的 Markdown 或 HTML 文件中，遵循之前提到的插入方法。\n确保格式正确，保存文件并在浏览器中查看效果。\n","date":"2025-07-08T19:01:41.14+08:00","permalink":"https://ynhugo.github.io/p/hugo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%BC%BA%E7%AF%87/","title":"hugo博客增强篇"},{"content":" 安装Cygwi 基本选项 Cygwin\n选择通过网络安装 选择root目录，安装用户选择仅个人 选择安装的包的路径 使用系统代理，选择下载源如中科大的或阿里云等国内下载源\n安装工具选择 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 binutils gcc-core gdb mingw64-i686-gcc-core make(必装) cmake screen # 还有的如： openssh unzip vim tmux git wget curl zip bc dos2unix w3m lynx emacs rsync expect jq cpio cygwin 命令行安装库 cygwin安装程序介绍 在Cygwin中安装库的过程通常涉及使用Cygwin的包管理工具setup.exe。以下是通过命令行安装库的步骤：\n打开Cygwin终端。 输入setup.exe -q命令来运行安装程序，并进入交互式安装模式。 当安装程序启动时，选择需要安装的库。 选择库后，按照屏幕上的提示进行安装。 如果你想要在不启动setup.exe的情况下从命令行安装库，可以使用以下命令：\n1 ./setup-x86_64.exe -q -P \u0026lt;package_name\u0026gt; 其中\u0026lt;package_name\u0026gt;是你想要安装的库的名称。例如，如果你想要安装openssh，你可以运行：\n1 ./setup-x86_64.exe -q -P openssh 请注意，你可能需要管理员权限来安装库，这取决于你的操作系统设置。如果是这样，你需要以管理员身份运行Cygwin终端。\n前提 exe 程序需要放到cgwin的目录下 运行程序之前必须先安装cygwin 一键安装命令 1 ./setup-x86_64.exe -q -P binutils gcc-core gdb mingw64-i686-gcc-core make cmake screen openssh unzip vim tmux git wget curl zip bc dos2unix w3m lynx emacs rsync expect jq cpio 参考链接 cygwin 命令行安装库\n一种简便的安装Cygwin的方法\n配置apt-cyg 方式一 用记事本创建一个名为apt-cyg的文件，复制粘贴进去如下内容，并且文本写完后，用vscode打开，把windows下的换行符CRLF改成linux下的LF 接下来，把刚刚的apt-cyg文件剪贴到Cygwin安装目录的bin文件夹里\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 #!/bin/bash # apt-cyg: install tool for Cygwin similar to debian apt-get # # The MIT License (MIT) # # Copyright (c) 2013 Trans-code Design # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \u0026#34;Software\u0026#34;), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \u0026#34;AS IS\u0026#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. if [ ${BASH_VERSINFO}${BASH_VERSINFO[1]} -lt 42 ] then echo \u0026#39;Bash version 4.2+ required\u0026#39; exit fi usage=\u0026#34;\\ NAME apt-cyg - package manager utility SYNOPSIS apt-cyg [operation] [options] [targets] DESCRIPTION apt-cyg is a package management utility that tracks installed packages on a Cygwin system. Invoking apt-cyg involves specifying an operation with any potential options and targets to operate on. A target is usually a package name, file name, URL, or a search string. Targets can be provided as command line arguments. OPERATIONS install Install package(s). remove Remove package(s) from the system. update Download a fresh copy of the master package list (setup.ini) from the server defined in setup.rc. download Retrieve package(s) from the server, but do not install/upgrade anything. show Display information on given package(s). depends Produce a dependency tree for a package. rdepends Produce a tree of packages that depend on the named package. list Search each locally-installed package for names that match regexp. If no package names are provided in the command line, all installed packages will be queried. listall This will search each package in the master package list (setup.ini) for names that match regexp. category Display all packages that are members of a named category. listfiles List all files owned by a given package. Multiple packages can be specified on the command line. search Search for downloaded packages that own the specified file(s). The path can be relative or absolute, and one or more files can be specified. searchall Search cygwin.com to retrieve file information about packages. The provided target is considered to be a filename and searchall will return the package(s) which contain this file. mirror Set the mirror; a full URL to a location where the database, packages, and signatures for this repository can be found. If no URL is provided, display current mirror. cache Set the package cache directory. If a file is not found in cache directory, it will be downloaded. Unix and Windows forms are accepted, as well as absolute or regular paths. If no directory is provided, display current cache. OPTIONS --nodeps Specify this option to skip all dependency checks. --version Display version and exit. \u0026#34; version=\u0026#34;\\ apt-cyg version 1 The MIT License (MIT) Copyright (c) 2005-9 Stephen Jungels \u0026#34; function wget { if command wget -h \u0026amp;\u0026gt;/dev/null then command wget \u0026#34;$@\u0026#34; else warn wget is not installed, using lynx as fallback set \u0026#34;${*: -1}\u0026#34; lynx -source \u0026#34;$1\u0026#34; \u0026gt; \u0026#34;${1##*/}\u0026#34; fi } function find-workspace { # default working directory and mirror # work wherever setup worked last, if possible cache=$(awk \u0026#39; BEGIN { RS = \u0026#34;\\n\\\\\u0026lt;\u0026#34; FS = \u0026#34;\\n\\t\u0026#34; } $1 == \u0026#34;last-cache\u0026#34; { print $2 } \u0026#39; /etc/setup/setup.rc) mirror=$(awk \u0026#39; /last-mirror/ { getline print $1 } \u0026#39; /etc/setup/setup.rc) mirrordir=$(sed \u0026#39; s / %2f g s : %3a g \u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$mirror\u0026#34;) mkdir -p \u0026#34;$cache/$mirrordir/$arch\u0026#34; cd \u0026#34;$cache/$mirrordir/$arch\u0026#34; if [ -e setup.ini ] then return 0 else get-setup return 1 fi } function get-setup { touch setup.ini mv setup.ini setup.ini-save wget -N $mirror/$arch/setup.bz2 if [ -e setup.bz2 ] then bunzip2 setup.bz2 mv setup setup.ini echo Updated setup.ini else echo Error updating setup.ini, reverting mv setup.ini-save setup.ini fi } function check-packages { if [[ $pks ]] then return 0 else echo No packages found. return 1 fi } function warn { printf \u0026#39;\\e[1;31m%s\\e[m\\n\u0026#39; \u0026#34;$*\u0026#34; \u0026gt;\u0026amp;2 } function apt-update { if find-workspace then get-setup fi } function apt-category { check-packages find-workspace for pkg in \u0026#34;${pks[@]}\u0026#34; do awk \u0026#39; $1 == \u0026#34;@\u0026#34; { pck = $2 } $1 == \u0026#34;category:\u0026#34; \u0026amp;\u0026amp; $0 ~ query { print pck } \u0026#39; query=\u0026#34;$pks\u0026#34; setup.ini done } function apt-list { local sbq for pkg in \u0026#34;${pks[@]}\u0026#34; do let sbq++ \u0026amp;\u0026amp; echo awk \u0026#39;NR\u0026gt;1 \u0026amp;\u0026amp; $1~pkg \u0026amp;\u0026amp; $0=$1\u0026#39; pkg=\u0026#34;$pkg\u0026#34; /etc/setup/installed.db done let sbq \u0026amp;\u0026amp; return awk \u0026#39;NR\u0026gt;1 \u0026amp;\u0026amp; $0=$1\u0026#39; /etc/setup/installed.db } function apt-listall { check-packages find-workspace local sbq for pkg in \u0026#34;${pks[@]}\u0026#34; do let sbq++ \u0026amp;\u0026amp; echo awk \u0026#39;$1~pkg \u0026amp;\u0026amp; $0=$1\u0026#39; RS=\u0026#39;\\n\\n@ \u0026#39; FS=\u0026#39;\\n\u0026#39; pkg=\u0026#34;$pkg\u0026#34; setup.ini done } function apt-listfiles { check-packages find-workspace local pkg sbq for pkg in \u0026#34;${pks[@]}\u0026#34; do (( sbq++ )) \u0026amp;\u0026amp; echo if [ ! -e /etc/setup/\u0026#34;$pkg\u0026#34;.lst.gz ] then download \u0026#34;$pkg\u0026#34; fi gzip -cd /etc/setup/\u0026#34;$pkg\u0026#34;.lst.gz done } function apt-show { find-workspace check-packages for pkg in \u0026#34;${pks[@]}\u0026#34; do (( notfirst++ )) \u0026amp;\u0026amp; echo awk \u0026#39; $1 == query { print fd++ } END { if (! fd) print \u0026#34;Unable to locate package \u0026#34; query } \u0026#39; RS=\u0026#39;\\n\\n@ \u0026#39; FS=\u0026#39;\\n\u0026#39; query=\u0026#34;$pkg\u0026#34; setup.ini done } function apt-depends { find-workspace check-packages for pkg in \u0026#34;${pks[@]}\u0026#34; do awk \u0026#39; @include \u0026#34;join\u0026#34; $1 == \u0026#34;@\u0026#34; { apg = $2 } $1 == \u0026#34;requires:\u0026#34; { for (z=2; z\u0026lt;=NF; z++) reqs[apg][z-1] = $z } END { prpg(ENVIRON[\u0026#34;pkg\u0026#34;]) } function smartmatch(small, large, values) { for (each in large) values[large[each]] return small in values } function prpg(fpg) { if (smartmatch(fpg, spath)) return spath[length(spath)+1] = fpg print join(spath, 1, length(spath), \u0026#34; \u0026gt; \u0026#34;) if (isarray(reqs[fpg])) for (each in reqs[fpg]) prpg(reqs[fpg][each]) delete spath[length(spath)] } \u0026#39; setup.ini done } function apt-rdepends { find-workspace for pkg in \u0026#34;${pks[@]}\u0026#34; do awk \u0026#39; @include \u0026#34;join\u0026#34; $1 == \u0026#34;@\u0026#34; { apg = $2 } $1 == \u0026#34;requires:\u0026#34; { for (z=2; z\u0026lt;=NF; z++) reqs[$z][length(reqs[$z])+1] = apg } END { prpg(ENVIRON[\u0026#34;pkg\u0026#34;]) } function smartmatch(small, large, values) { for (each in large) values[large[each]] return small in values } function prpg(fpg) { if (smartmatch(fpg, spath)) return spath[length(spath)+1] = fpg print join(spath, 1, length(spath), \u0026#34; \u0026lt; \u0026#34;) if (isarray(reqs[fpg])) for (each in reqs[fpg]) prpg(reqs[fpg][each]) delete spath[length(spath)] } \u0026#39; setup.ini done } function apt-download { check-packages find-workspace local pkg sbq for pkg in \u0026#34;${pks[@]}\u0026#34; do (( sbq++ )) \u0026amp;\u0026amp; echo download \u0026#34;$pkg\u0026#34; done } function download { local pkg digest digactual pkg=$1 # look for package and save desc file awk \u0026#39;$1 == pc\u0026#39; RS=\u0026#39;\\n\\n@ \u0026#39; FS=\u0026#39;\\n\u0026#39; pc=$pkg setup.ini \u0026gt; desc if [ ! -s desc ] then echo Unable to locate package $pkg exit 1 fi # download and unpack the bz2 or xz file # pick the latest version, which comes first set -- $(awk \u0026#39;$1 == \u0026#34;install:\u0026#34;\u0026#39; desc) if (( ! $# )) then echo \u0026#39;Could not find \u0026#34;install\u0026#34; in package description: obsolete package?\u0026#39; exit 1 fi dn=$(dirname $2) bn=$(basename $2) # check the md5 digest=$4 case ${#digest} in 32) hash=md5sum ;; 128) hash=sha512sum ;; esac mkdir -p \u0026#34;$cache/$mirrordir/$dn\u0026#34; cd \u0026#34;$cache/$mirrordir/$dn\u0026#34; if ! test -e $bn || ! $hash -c \u0026lt;\u0026lt;\u0026lt; \u0026#34;$digest $bn\u0026#34; then wget -O $bn $mirror/$dn/$bn $hash -c \u0026lt;\u0026lt;\u0026lt; \u0026#34;$digest $bn\u0026#34; || exit fi tar tf $bn | gzip \u0026gt; /etc/setup/\u0026#34;$pkg\u0026#34;.lst.gz cd ~- mv desc \u0026#34;$cache/$mirrordir/$dn\u0026#34; echo $dn $bn \u0026gt; /tmp/dwn } function apt-search { check-packages echo Searching downloaded packages... for pkg in \u0026#34;${pks[@]}\u0026#34; do key=$(type -P \u0026#34;$pkg\u0026#34; | sed s./..) [[ $key ]] || key=$pkg for manifest in /etc/setup/*.lst.gz do if gzip -cd $manifest | grep -q \u0026#34;$key\u0026#34; then package=$(sed \u0026#39; s,/etc/setup/,, s,.lst.gz,, \u0026#39; \u0026lt;\u0026lt;\u0026lt; $manifest) echo $package fi done done } function apt-searchall { cd /tmp for pkg in \u0026#34;${pks[@]}\u0026#34; do printf -v qs \u0026#39;text=1\u0026amp;arch=%s\u0026amp;grep=%s\u0026#39; $arch \u0026#34;$pkg\u0026#34; wget -O matches cygwin.com/cgi-bin2/package-grep.cgi?\u0026#34;$qs\u0026#34; awk \u0026#39; NR == 1 {next} mc[$1]++ {next} /-debuginfo-/ {next} /^cygwin32-/ {next} {print $1} \u0026#39; FS=-[[:digit:]] matches done } function apt-install { check-packages find-workspace local pkg dn bn requires wr package sbq script for pkg in \u0026#34;${pks[@]}\u0026#34; do if grep -q \u0026#34;^$pkg \u0026#34; /etc/setup/installed.db then echo Package $pkg is already installed, skipping continue fi (( sbq++ )) \u0026amp;\u0026amp; echo echo Installing $pkg download $pkg read dn bn \u0026lt;/tmp/dwn echo Unpacking... cd \u0026#34;$cache/$mirrordir/$dn\u0026#34; tar -x -C / -f $bn # update the package database awk \u0026#39; ins != 1 \u0026amp;\u0026amp; pkg \u0026lt; $1 { print pkg, bz, 0 ins = 1 } 1 END { if (ins != 1) print pkg, bz, 0 } \u0026#39; pkg=\u0026#34;$pkg\u0026#34; bz=$bn /etc/setup/installed.db \u0026gt; /tmp/awk.$$ mv /etc/setup/installed.db /etc/setup/installed.db-save mv /tmp/awk.$$ /etc/setup/installed.db [ -v nodeps ] \u0026amp;\u0026amp; continue # recursively install required packages requires=$(awk \u0026#39;$1==\u0026#34;requires\u0026#34;, $0=$2\u0026#39; FS=\u0026#39;: \u0026#39; desc) cd ~- wr=0 if [[ $requires ]] then echo Package $pkg requires the following packages, installing: echo $requires for package in $requires do if grep -q \u0026#34;^$package \u0026#34; /etc/setup/installed.db then echo Package $package is already installed, skipping continue fi apt-cyg install --noscripts $package || (( wr++ )) done fi if (( wr )) then echo some required packages did not install, continuing fi # run all postinstall scripts [ -v noscripts ] \u0026amp;\u0026amp; continue find /etc/postinstall -name \u0026#39;*.sh\u0026#39; | while read script do echo Running $script $script mv $script $script.done done echo Package $pkg installed done } function apt-remove { check-packages cd /etc cygcheck awk bash bunzip2 grep gzip mv sed tar xz \u0026gt; setup/essential.lst for pkg in \u0026#34;${pks[@]}\u0026#34; do if ! grep -q \u0026#34;^$pkg \u0026#34; setup/installed.db then echo Package $pkg is not installed, skipping continue fi if [ ! -e setup/\u0026#34;$pkg\u0026#34;.lst.gz ] then warn Package manifest missing, cannot remove $pkg. Exiting exit 1 fi gzip -dk setup/\u0026#34;$pkg\u0026#34;.lst.gz awk \u0026#39; NR == FNR { if ($NF) ess[$NF] next } $NF in ess { exit 1 } \u0026#39; FS=\u0026#39;[/\\\\\\\\]\u0026#39; setup/{essential,$pkg}.lst esn=$? if [ $esn = 0 ] then echo Removing $pkg if [ -e preremove/\u0026#34;$pkg\u0026#34;.sh ] then preremove/\u0026#34;$pkg\u0026#34;.sh rm preremove/\u0026#34;$pkg\u0026#34;.sh fi mapfile dt \u0026lt; setup/\u0026#34;$pkg\u0026#34;.lst for each in ${dt[*]} do [ -f /$each ] \u0026amp;\u0026amp; rm /$each done for each in ${dt[*]} do [ -d /$each ] \u0026amp;\u0026amp; rmdir --i /$each done rm -f setup/\u0026#34;$pkg\u0026#34;.lst.gz postinstall/\u0026#34;$pkg\u0026#34;.sh.done awk -i inplace \u0026#39;$1 != ENVIRON[\u0026#34;pkg\u0026#34;]\u0026#39; setup/installed.db echo Package $pkg removed fi rm setup/\u0026#34;$pkg\u0026#34;.lst if [ $esn = 1 ] then warn apt-cyg cannot remove package $pkg, exiting exit 1 fi done } function apt-mirror { if [ \u0026#34;$pks\u0026#34; ] then awk -i inplace \u0026#39; 1 /last-mirror/ { getline print \u0026#34;\\t\u0026#34; pks } \u0026#39; pks=\u0026#34;$pks\u0026#34; /etc/setup/setup.rc echo Mirror set to \u0026#34;$pks\u0026#34;. else awk \u0026#39; /last-mirror/ { getline print $1 } \u0026#39; /etc/setup/setup.rc fi } function apt-cache { if [ \u0026#34;$pks\u0026#34; ] then vas=$(cygpath -aw \u0026#34;$pks\u0026#34;) awk -i inplace \u0026#39; 1 /last-cache/ { getline print \u0026#34;\\t\u0026#34; vas } \u0026#39; vas=\u0026#34;${vas//\\\\/\\\\\\\\}\u0026#34; /etc/setup/setup.rc echo Cache set to \u0026#34;$vas\u0026#34;. else awk \u0026#39; /last-cache/ { getline print $1 } \u0026#39; /etc/setup/setup.rc fi } if [ -p /dev/stdin ] then mapfile -t pks fi # process options until [ $# = 0 ] do case \u0026#34;$1\u0026#34; in --nodeps) nodeps=1 shift ;; --noscripts) noscripts=1 shift ;; --version) printf \u0026#34;$version\u0026#34; exit ;; update) command=$1 shift ;; list | cache | remove | depends | listall | download | listfiles |\\ show | mirror | search | install | category | rdepends | searchall ) if [[ $command ]] then pks+=(\u0026#34;$1\u0026#34;) else command=$1 fi shift ;; ,*) pks+=(\u0026#34;$1\u0026#34;) shift ;; esac done set -a if type -t apt-$command | grep -q function then readonly arch=${HOSTTYPE/i6/x} apt-$command else printf \u0026#34;$usage\u0026#34; fi 方式二 虽然我们上面安装好了 Cygwin，但还是很不方便，为什么呢？主要是因为 Cygwin目前设计的还不是很人性化。如果我们安装好Cygwin后，如果缺少了某个包想安装的话就特别麻烦。还需要重新安装 Cygwin才能解决，有没有更好的方式呢？\n你遇到的困难，别人也会遇到，不同的是你要么忍了，要么不用了。可别人遇到困难后会去解决困难，这才是人与人之间最大的不同。\n话扯的有点远哈。没错，已经有人帮我们解决了这个问题。这是一个很好用的开源工具，它叫 apt-cyg。它与 Ubuntu系统中的 apt一样特别好用，而且使用的方式与 apt也是一个样子的。\n如何安装它呢？网上有很多方法，但很多不可行。大家按我这个方法操作一定可以安装成功。\n其实，apt-cyg就是一个脚本。我们只需要将这个脚本下载下来就OK了。这里是apt-cyg的下载地址。大家可以在Cygwin下执行下面的命令就好了。\n第一步：\n1 wget -c https://raw.githubusercontent.com/transcode-open/apt-cyg/master/apt-cyg 第二步:\n1 install apt-cyg /bin 需要添加的环境变量 1 2 3 C:\\Cygwin\\bin C:\\Cygwin\\sbin C:\\Cygwin\\usr\\sbin 参考链接 windows下安装Cygwin详细教程\nCygwin的安装使用，及其软件包apt-cyg的配置使用，以及apt-cyg错误“/usr/bin/apt-cyg: line 25: $‘\\r‘: command not found”解决\n在当前文件夹打开 可以在文件资源管理器的地址栏运行cygwin的mintty，前提是设置好环境变量\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/cygwin%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"Cygwin安装与配置"},{"content":" 脚本内容 创建一个txt文件如test.txt，将以下脚本内容添加到txt文件中，如果需要通过Vmware安装虚拟操作系统到VHD文件，那么先不分离vdisk，即先不执行 detach vdisk ,当然也可以在脚本执行完后手动手动再连接磁盘文件，即先执行 select vdisk filed:\\test_vhd.vhd ，然后再执行 attach vdisk ，这个时候就可以在vmware中添加本地硬盘的时候看到对应磁盘文件的ID了\n1 2 3 4 5 6 7 create vdisk file=d:\\test_vhd.vhd maximum=1024 type=fixed select vdisk file=d:\\test_vhd.vhd attach vdisk create partition primary assign letter=Z format quick label=vhd detach vdisk 在D盘根目录创建一个1G的固定磁盘，选中并连接该磁盘文件，接着创建主分区并快速格式化，然后分离该磁盘文件\n脚本执行方式 1 diskpart -s test.txt 参考链接 windows 基于命令行制作vhd虚拟磁盘\ndiskpart 脚本和示例\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/diskpart%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC/","title":"Diskpart自动脚本"},{"content":" 设置Emacs的HOME目录 总的来说，Emacs的默认配置文件放在变量HOME所指的路径下，所以，只要我们把.emacs扔到HOME所指向的目录就可以了，下面就简单介绍一下在Windows下设置home目录的几种方法，并进行简单的对比。\n第一种方法，改变home环境变量的值。 这种方法，改变了$home变量，也会影响Cygwin或是其他一些应用程序，因为有一些程序会根据Windows的home环境变量来寻找数据存放的路径。\n第二种方法，不改变Windows默认的home值，设置默认的.emacs文件读取你自己的Emacs配置文件，并重新设定Emacs的home目录。 你可以在Emacs中输入C-x C-f，然后打开路径~（即当前的home环境变量所指的路径，一般来说是这样的路径：C:/Documents and Settings/water/Application Data）。\n看看显示的是哪个目录，如果此目录下没有.emacs，可以创建一个.emacs或_emacs，然后在这个.emacs文件里，加入如下语句： (load-file \u0026#34;E:/water/.emacs\u0026#34;) 文件 E:/water/.emacs 才是我们真正的Emacs配置文件，我们可以在这个真正的配置文件里用如下语句设置我们的home目录：\n1 2 3 4 ;; (setenv \u0026#34;HOME\u0026#34; \u0026#34;C:/cygwin/home/username\u0026#34;) ;; (setenv \u0026#34;PATH\u0026#34; \u0026#34;C:/cygwin/home/username\u0026#34;) ;; (set default-directory \u0026#34;C:/cygwin/home/username\u0026#34;) ;; (add-to-list \u0026#39;load-path \u0026#34;C:/cygwin/home/username/.emacs.d/init.el\u0026#34;) 这个方法的优点是比较简单同样也方便对.emacs文件备份，不会对其它应用程序产生任何影响。\n第三种方法，修改注册表，在注册表中进行如下设置： HKEY_LOCAL_MACHINE§OFTWARE\\GNU\\Emacs\\HOME=%emacs_dir% 以上三种方法都可以设置好Emacs的Home目录，但是，系统是按什么顺序来解析它们的呢？大体上的顺序是这样的：\n如果设置了环境变量HOME，则使用HOME指定的目录。 如果设置了注册表里的值HKCU§OFTWARE\\GNU\\Emacs\\HOME，则使用这个值所指定的目录作为home目录。并不是太推荐使用这种方法，因为会导致用户共享一个home目录。 如果 C:\\.emacs 文件存在，则使用 C:\\.emacs 这个文件。这个是为了向低版本的Emacs兼容，因为低版本的Emacs就是默认用这个文件作为配置文件。 把用户的AppData目录作为home目录（通常来说，就是类似这样的目录 C:/Documents and Settings/water/Application Data ），这个用户的数据目录根据Windows版本的不同而有所不同。 我个人比较喜欢用第二种方法，即简单又方便备份。\n其实，如果你只是想要Emacs能找到你的.emacs的话，也可以不用管HOME目录的，写个批处理文件emacs.bat: path-of-emacs.exe -q -l path-of-your.emacs\nemacs查看快捷键是否被占用 先执行C-h c，然后按下执行某快捷键，查看minibuffer提示快捷键情况\nemacs查看函数 先执行C-h a，然后输入某一函数并回车，查看函数说明\n基于时间创建文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defun extract-time-keyword () \u0026#34;提取当前时间的关键词\u0026#34; (interactive) (let ((time (format-time-string \u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;))) (setq time-keyword (replace-regexp-in-string \u0026#34;[-:]\u0026#34; \u0026#34;\u0026#34; time)) (message \u0026#34;提取的时间关键词为：%s\u0026#34; time-keyword) (create-new-file time-keyword))) (defun create-new-file (time-keyword) \u0026#34;使用时间关键词创建新文件\u0026#34; (let ((file-path (concat \u0026#34;~/path/to/files/\u0026#34; time-keyword \u0026#34;.txt\u0026#34;))) (with-temp-file file-path (insert \u0026#34;这是一个新文件，创建时间：\u0026#34; time-keyword)))) (global-set-key (kbd \u0026#34;C-c t\u0026#34;) \u0026#39;extract-time-keyword) 完善后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defun extract-time-keyword () \u0026#34;提取当前时间的关键词\u0026#34; (interactive) (let ((time (format-time-string \u0026#34;%Y-%m-%d\u0026#34;))) (setq time-keyword (replace-regexp-in-string \u0026#34;[-:]\u0026#34; \u0026#34;\u0026#34; time)) (message \u0026#34;提取的时间关键词为：%s\u0026#34; time-keyword) (create-new-file time-keyword))) (defun create-new-file (time-keyword) \u0026#34;使用时间关键词创建新文件\u0026#34; (let ((file-path (concat \u0026#34;./\u0026#34; time-keyword \u0026#34;.txt\u0026#34;))) (with-temp-file file-path (insert time-keyword \u0026#34;: name\\n1. \u0026#34;)))) (global-set-key (kbd \u0026#34;C-c t\u0026#34;) \u0026#39;extract-time-keyword) 基于时间添加代码块并设置tangle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defun add-code-block () \u0026#34;在当前位置添加一个代码块，并以时间作为块名进行命名\u0026#34; (interactive) (let* ((time (format-time-string \u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;)) ; 获取当前时间 (clean-time (replace-regexp-in-string \u0026#34;[-:]\u0026#34; \u0026#34;\u0026#34; time)) ; 去除时间中的破折号和冒号 (block-name (concat \u0026#34;block-\u0026#34; clean-time)) ; 构建代码块名 (code-block (format \u0026#34;* %s ; 创建时间：%s ,#+BEGIN_SRC emacs-lisp :tangle %s.el ;; 在这里插入你的代码\\n#+END_SRC\u0026#34; block-name time block-name))) (insert code-block))) ; 在当前位置插入代码块 ;; 设置快捷键 C-c b 绑定到 add-code-block 函数 (global-set-key (kbd \u0026#34;C-c b\u0026#34;) \u0026#39;add-code-block) 完善后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (defun add-code-block () \u0026#34;在当前位置添加一个代码块，并以时间作为块名进行命名\u0026#34; (interactive) (let* ((time (format-time-string \u0026#34;%Y-%m-%d\u0026#34;)) ; 获取当前时间 (clean-time (replace-regexp-in-string \u0026#34;[-:]\u0026#34; \u0026#34;\u0026#34; time)) ; 去除时间中的破折号和冒号 (block-name (concat clean-time)) ; 构建代码块名 (code-block (format \u0026#34;* %s ,#+BEGIN_SRC emacs-lisp :tangle %s.el %s: name\\n1. ,#+END_SRC\u0026#34; block-name clean-time block-name))) (insert code-block))) ; 在当前位置插入代码块 ;; 设置快捷键 C-c b 绑定到 add-code-block 函数 (global-set-key (kbd \u0026#34;C-c b\u0026#34;) \u0026#39;add-code-block) wsl-ubuntu18.04.6安装最新版本emamcs教程 1 2 3 4 $sudo add-apt-repository ppa:ubuntu-elisp/ppa $sudo apt update $sudo apt install emacs-snapshot emacs-snapshot-el $emacs --version #查看emacs版本 在linux环境设置emacs守护进程 常规操作 1 2 3 4 5 6 7 8 9 10 # 启动emacs server： $ emacs --daemon # 编辑文件 $ emacsclient file $ emacsclient -t file # 字符界面 $ emacsclient -c file # GUI界面 # 添加命令行别名 # 为了方便在终端上使用，在~/.bashrc文件中加入如下两行： alias ec=\u0026#39;emacsclient -t -a \u0026#34;\u0026#34;\u0026#39; alias sec=\u0026#39;sudo emacsclient -t -a \u0026#34;\u0026#34;\u0026#39; 脚本操作 如果安装了dashboard，想启动时已dashboard作为启动界面，可以更改alias别名的定义\n1 alias ec=\u0026#39;emacsclient -c -e \u0026#34;(dashboard-setup-startup-hook)\u0026#34;\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 find ./ -name \u0026#34;*~\u0026#34; | xargs rm ps -ef | grep \u0026#34;emacs --daemon\u0026#34; | grep -v \u0026#34;grep\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 if [ $? -ne 0 ] then nohup emacs --daemon \u0026amp; fi alias \u0026#39;emacs\u0026#39;=\u0026#39;emacsclient\u0026#39; if [ -e \u0026#34;~/null\u0026#34; ] then rm ~/null fi if [ -e \u0026#34;~/nohup.out\u0026#34; ] then rm ~/nohup.out fi alias ec=\u0026#39;emacsclient -c -e \u0026#34;(dashboard-setup-startup-hook)\u0026#34;\u0026#39; 在windows环境可以如下操作 首先下载emacs最新版本，并将其添加windows系统环境变量，然后在终端中执行\u0026#34;emacs –daemon\u0026#34;，如果该命令占用终端，可以将其作为守护进程运行，在cygwin环境中参考linux环境操作 还有就是在.emacs.d/下有了server(socket文件)后，可以执行\u0026#34;emacs –server-file .emacs/server\u0026#34;指定socket文件路径 第二步的前提是通过第一步产生了server文件，或者在emacs中通过运行\u0026#34;server-start\u0026#34;设置守护进程\n在windows创建守护进程脚本 1 2 3 4 5 6 7 @echo off if \u0026#34;%1\u0026#34;==\u0026#34;h\u0026#34; goto begin start mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;\u0026#34;\u0026#34;%~nx0\u0026#34;\u0026#34; h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin emacs --daemon doskey emacs=emacsclient 在windows_Cygwin创建启动脚本，因从守护进程运行的emacsclient与正常运行emacs效果不一样，因此只是介绍方法，不过多介绍 1 2 3 #!/usr/bin/bash cmd /c emacs --daemon \u0026amp; 在emacs中获取终端家目录或者用户，用户对就\u0026#34;USER\u0026#34; 1 2 3 4 5 6 (setq terminal-home (getenv \u0026#34;HOME\u0026#34;)) (setq relative-path \u0026#34;Documents/example.txt\u0026#34;) (setq absolute-path (expand-file-name relative-path terminal-home)) (message \u0026#34;Absolute path: %s\u0026#34; absolute-path) emacs的init.el，我保存在.emacs.d/init.el中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 ;; 实用参考链接 ;; 列出一些常用学习链接 ;; https://zhuanlan.zhihu.com/p/385214753 ;; https://github.com/emacs-china/Spacemacs-rocks#%E5%AE%89%E8%A3%85-spacemacs ;; https://www.cnblogs.com/holbrook/archive/2012/04/12/2444992.html ;; https://www.cnblogs.com/ts65214/p/5561646.html ;; 目录配置 ;; (setenv \u0026#34;HOME\u0026#34; \u0026#34;C:/cygwin/home/username\u0026#34;) ;; (setenv \u0026#34;PATH\u0026#34; \u0026#34;C:/cygwin/home/username\u0026#34;) ;; (set default-directory \u0026#34;C:/cygwin/home/username\u0026#34;) ;; (add-to-list \u0026#39;load-path \u0026#34;C:/cygwin/home/username/.emacs.d/init.el\u0026#34;) ;; 函数配置 (setq inhibit-startup-message 1) ;; 禁止Emacs显示启动画面 (fset \u0026#39;display-startup-echo-area-message \u0026#39;ignore) ;; 禁止Echo Area显示For information about GNU Emacs and the GNU system,type C-h C-a (setq-default indent-tabs-mode 1) ;; 在缩进时使用制表符 (setq-default tab-width 4) ;; 指定制表符的宽度为4个空格 (setq c-default-style \u0026#34;linux\u0026#34;) ;; 指定C语言的默认代码样式为Linux风格，这其中包含了一些特定的规则和约定，例如缩进方式、括号对齐等等，可心根据自己的喜好和项目要求来修改这个值 (setq c-basic-offset 4) ;; 在C语言模式下，每个缩进级别使用4个空格 (recentf-mode 0) ;; recentf-mode是一个Emacs历史记录插件，它允许你在Emacs会话之间保留文件的历史记录，一旦启用recentf-mode，它将自动跟踪你最近打开的文件，并将它们保存在一个列表中，当你需要再次访问这些文件时，可以通过recentf-mode提供的命令和功能来查找和打开它们 ;; (tool-bar-mode 0) ;; 禁用工具栏显示，工具栏通过包含了一些常用的功能按键 (menu-bar-mode 0) ;; 禁用菜单栏显示，菜单栏通过包含了一系列的菜单项 ;; (scroll-bar-mode 0) ;; 禁用滚动条显示，滚动条通过用来显示当前文档的滚动位置 ;; (global-hl-line-mode 1) ;; 全局高亮当前行模式，这个模式会在当前行添加高这显示 (global-linum-mode 1) ;; 全局显示行号，这个模式会在每行的左侧显示行号 (column-number-mode 1) ;; 显示列号 (xterm-mouse-mode 1) ;; 启用xterm鼠标模式，这个模式允许使用鼠标进行交互操作 ;; (desktop-save-mode 1) ;; 启用Emacs的桌面保存模式，当桌面保存模式开启后，Emacs会在退出时保存当前的工作 环境(打开的文件、窗口配置等)，以便在下次启动时自动恢复 (save-place-mode 1) ;; 是用来启用Emacs的记忆光标位置模式，开启后，Emacs会记录你最后离开每个文件时的光 标位置，在再次打开该文件时会自动将光标定位到上次的位置 ;; (toggle-truncate-lines t) ;; 换行模式，每次加载变量的值都会被再次取反 (add-hook \u0026#39;org-mode-hook (lambda () (setq truncate-lines nil))) ;; org-mode固定自动换行 (setq default-major-mode \u0026#39;text-mode) (add-to-list \u0026#39;default-frame-alist \u0026#39;(foreground-color . \u0026#34;#FFFFFF\u0026#34;)) ;; 配置emacs前景颜色 (add-to-list \u0026#39;default-frame-alist \u0026#39;(background-color . \u0026#34;#000000\u0026#34;)) ;; 配置emacs背景颜色 (defun g-org-insert-note-header () ;; 定义一个名为g-org-insert-note-header ()的函数 (interactive) ;; 函数的一个特殊声明，表示函数可以被用户调用 (insert \u0026#34;#+options: ^:nil\\n#+title: \\n#+options: \\n:t\\n#+author: yenao\\n\u0026#34;)) ;; insert函数用于在当前光标位置插入指定的文本内容，当你调用这个函数时，它会在当前光标位置插入文本#+options: ^:nil、#+title: 和#+author: yenao (with-eval-after-load \u0026#39;eww (custom-set-variables \u0026#39;(eww-search-prefix \u0026#34;https://bing.com/search?q=\u0026#34;))) ;; 参考链接：https://www.jianshu.com/p/af9e43f7f13e ;; 尝试配置GTD (unless (file-exists-p \u0026#34;~/.emacs.d/OneDrive\u0026#34;) (make-directory \u0026#34;~/.emacs.d/OneDrive\u0026#34;) );; 检测OneDrive目录是否存在，如果不存在就创建这个目录 (unless (file-exists-p \u0026#34;~/.emacs.d/OneDrive/org\u0026#34;) (make-directory \u0026#34;~/.emacs.d/OneDrive/org\u0026#34;) );; 检测org目录是否存在，如果不存在就创建这个目录 (let ((filename \u0026#34;~/.emacs.d/my-agenda.el\u0026#34;)) ;; 如果my-agenda.el文件不存在，就创建这个文件，如果需要往 该文件内写入内容，将该段该中insert的注释取消即可 (unless (file-exists-p filename) (with-temp-file filename ;; (insert \u0026#34;这是文件内容\u0026#34;) ;; 写入文件内容 ))) (let ((filename \u0026#34;~/.emacs.d/OneDrive/org/todo.org\u0026#34;)) ;; 如果todo.org文件不存在，就创建这个文件，如果需要往该文件内写入内容，将该段该中insert的注释取消即可 (unless (file-exists-p filename) (with-temp-file filename ;; (insert \u0026#34;这是文件内容\u0026#34;) ;; 写入文件内容 ))) (load-file \u0026#34;~/.emacs.d/my-agenda.el\u0026#34;) ;; 加载my-agenda.el配置文件 (setq org-agenda-files \u0026#39;(\u0026#34;~/.emacs.d/OneDrive/org\u0026#34;)) ;; 指定data存放目录 (setq org-default-notes-file \u0026#34;~/.emacs.d/OneDrive/org/todo.org\u0026#34;) ;; 配置好data目录后，再配置具体要将信息写于哪个文件，可以配置多个文件，出于简化，这里将所有的agenda todo写入~/Onedrive/org/todo.org文件下 (global-set-key \u0026#34;\\C-cl\u0026#34; \u0026#39;org-store-link) (global-set-key \u0026#34;\\C-cc\u0026#34; \u0026#39;org-capture) (global-set-key \u0026#34;\\C-ca\u0026#34; \u0026#39;org-agenda) (global-set-key \u0026#34;\\C-cb\u0026#34; \u0026#39;org-iswitchb) (define-key global-map \u0026#34;\\C-cr\u0026#34; \u0026#39;remember) (setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO(t!)\u0026#34; \u0026#34;NEXT(n)\u0026#34; \u0026#34;WAITTING(w)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34; \u0026#34; \u0026#34; \u0026#34;DONE(d@/!)\u0026#34; \u0026#34;ABORT(a@/!)\u0026#34;))) (setq org-tag-alist \u0026#39;((\u0026#34;@office\u0026#34; . ?w) (\u0026#34;@home\u0026#34; . ?h) (\u0026#34;traffic\u0026#34; . ?t) (\u0026#34;computer\u0026#34; . ?c) (\u0026#34;nocomputer\u0026#34; . ?n) (\u0026#34;either\u0026#34; . ?e) (\u0026#34;immediately\u0026#34; . ?i) (\u0026#34;wait\u0026#34; . ?w) (\u0026#34;action\u0026#34; . ?a))) ; 插件配置 (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa-stable\u0026#34; . \u0026#34;https://stable.melpa.org/packages/\u0026#34;) t) ;; 配置melpa-stable仓库，如果不配置的话，use-package安装不了，比如在wsl-ubuntu18.04环境上就是这样 (package-initialize) ;; 配置use-package用于安装各种插件 (eval-when-compile (require \u0026#39;use-package) ) ;; 配置company用于文本补全 (use-package company :ensure t :init (global-company-mode 1) ;; 启用全局的自动补全功能，这将使得在所有的缓冲区中的文本输入时，company会自动显示可能的实例选项 :config (setq company-minimun-prefix-length 1) ;; 只需敲一个字母就开始进行自动补全 (setq company-tooltip-align-annotations t) ;; 设定自动补全提示框与注解的对齐方式，如果设为nil，则对 齐，如果设为t，则不对齐 (setq company-idle-delay 0.0) ;; 设置自动补全的延时，在输入之后立即触发自动补全 (setq company-show-numbers 1) ;; 给选项编号(按快捷键M-1、M-2等等来进行选择) (setq company-selection-wrap-around 1) ;; 当光标移到最后一个选项后，再按下TAB键时，光标将回到第一个 选项 (setq company-transformers \u0026#39;(company-sort-by-occurrence)) ;; 根据选择的频率进行排序，如果不喜欢可以 去掉 ) (use-package ox-hugo :ensure t ) ","date":"2025-07-08T18:57:42.57+08:00","permalink":"https://ynhugo.github.io/p/emacs_config/","title":"emacs_config"},{"content":"搭建hugo博客 这里跟着官网教程进行配置，刚开始折腾hugo博客的话，最重要的是折腾成功，官网教程简单实用。\n安装hugo 1 apt install hugo 创建站点目录 然后在硬盘中找一个自己想要存放博客的位置，创建站点目录，例如我要创建的站点目录的名字叫做hugo1.\n1 hugo new site hugo1 然后名字叫做hugo1的站点目录就创建好了。\n配置博客主题 还是刚开始说的，能够快速折腾成功还是挺重要的，因此还是根据官方教程操作，配置一个主题名叫做ananke的主题。\n1 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke 然后在站点目录的hugo.toml文件中最下边添加一行内容，添加的内容是\n1 theme = \u0026#39;ananke\u0026#39; 可以用用shell命令添加\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 创建博客 创建属于该博客的第一篇内容，名字就叫\u0026quot;我的第一篇博客\u0026quot;吧\n1 hugo new posts/我的第一篇博客.md 然后在站点目录下的content/posts/下就相应的出现了一个文件\u0026quot;我的第一篇博客.md\u0026quot;\n本地预览 1 hugo server -D 部署博客 配置github仓库 在github创建账户，然后创建仓库，仓库命名格式为\u0026quot;yourname.github.io\u0026quot;，配置仓库的主分支为master，配置仓库设置界面的pages的主分支为master。\n在本地生成ssh密钥 1 ssh-keygen 三次回车后密钥就生成了，生成的密钥在家目录下的.ssh目录下，将.ssh/的id_rsa.pub的内容复制到剪切板，然后 回到github网站，在帐户设置的SSH and GPG keys界面中添加剪切板的ssh公钥，然后给添加该密钥的记录随便起一 个名字用于区分可以了。\n配置hugo 将自己仓库的名字yourname.github.io添加到站点目录的hugo.toml配置文件中，将示例链接替换掉，然后设置博客 的语言，接着设置博客的名称，最后一行也就是第四行是咱刚开始就添加过了的，所以不用修改。\n1 2 3 4 baseURL = \u0026#39;yourname.github.io\u0026#39; languageCode = \u0026#39;zh-cn\u0026#39; title = \u0026#39;MyBlogs\u0026#39; theme = \u0026#39;ananke\u0026#39; 部署 先将博客的草稿模式关闭，将true修改为false，然后回到站点目录的第一级目录，然后执行命令run，再进入publib目录，先添加github的仓库链接，然后执行git命令进行部署hugo的操作。\n1 git remote add origin git@github.com:yourname/yourname.github.io.git 1 2 3 git add . git commit -m \u0026#34;upload\u0026#34; git push -u origin master 部署失败解决方法 如果部署过程出现问题，可以执行以下命令来解决\n1 2 3 4 5 6 7 8 9 #!/data/data/com.termux/files/usr/bin/bash git remote rm origin git remote add origin git@github.com:ynhugo/ynhugo.github.io.git git add .; git commit -m upload; git push -u origin master /data/data/com.termux/files/home/hugo/hugo1/content/posts ","date":"2025-07-08T18:57:42.57+08:00","permalink":"https://ynhugo.github.io/p/linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/","title":"linux环境搭建hugo博客"},{"content":"linux环境如何添加环境变量 在linux环境找到/etc/profile文件，在该文件最底部用export定义变量并赋值，然后将该变量升级为环境变量，即与PATH变量连在一起，以我要添加hugo站点目录作为环境变量为例，我的站点目录在家目录下，我添加的内容作如下\n1 2 export HUGO1=$HOME/hugo/hugo1 export PATH=$PATH:$HUGO1; ","date":"2025-07-08T18:57:42.58+08:00","permalink":"https://ynhugo.github.io/p/linux%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"linux环境如何添加环境变量"},{"content":"下载列表 秋刀鱼绿色精简版\nwindows 激活工具\nWindows一键激活脚本\n微软 虚拟光驱\n文件校验工具 Hash\n录屏工具 Captura\n串口调试助手\nBESnew 二进制文件查看工具\nBCompare 文件或文件夹比较工具，适用于大型文件或文件夹\nUltraEdit_v27.00.0.54_x64_zh-CN\nFirewall_App_Blocker_1.6.zip\ntree for windows\ncurl\nwget\nqbittorrent\ntransmissionbt\naria2c\nchrome-stable\nchrominum-browser for ubuntu\ntimestamp\n一键修改Windows的cmd的默认编码chcp65001\nmingw-get-setup.exe\nDownload Resilio Sync for Windows, Mac, Linux \u0026amp; FreeBSD\nResilioSyncPro.btskey.zip\n下载 google 历史版本 https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/software/","title":"software"},{"content":"搭建alist教程 alist配置官方文档。\n安装alist 安装程序后在命令行界面运行就可以了，第一次运行的时候先获取到用户名和密码，然后根据提供的用户名和密码进行网页访问并修改密码。\n后台运行 在termux的家目录编辑\u0026quot;.bashrc\u0026quot;文件，如果没有这个文件可以创建这个文件，该命名的文件在启动termux后可以自动运行，不过alist不能重复启动，为避免使用ssh连接termux时再次启动启动alist，我写了一个脚本进行判断，如果alist已经运行就不再重复运行，执行命令时产生的附带文件如nohup.out和null也通过判断是否存在，如果存在则删除，在这一部分我在网上找了两个链接参考了一下，分别是shell判断进程是否存在，不存在则启动和Shell脚本实用小技巧-教你屏蔽执行命令的所有显示信息，包含错误信息和Shell 判断文件或文件夹是否存在（不存在则创建），这样这个脚本就可以实现alist在后台运行了，并且不需要自己手动做任何操作了。 想要完成上面描述的效果，则需要将下面的脚本内容添加到\u0026quot;.bashrc\u0026quot;中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/data/data/com.termux/files/usr/bin/bash ps -ef | grep \u0026#34;alist\u0026#34; | grep -v \u0026#34;grep\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 if [ $? -ne 0 ] then nohup alist server \u0026amp; fi if [ -e \u0026#34;/data/data/com.termux/files/home/null\u0026#34; ] then rm /data/data/com.termux/files/home/null fi if [ -e \u0026#34;/data/data/com.termux/files/home/nohup.out\u0026#34; ] then rm /data/data/com.termux/files/home/nohup.out fi[\u0026lt;35;177;4m 最后启动该文件即可\n1 source .bashrc alist操作方式 使用alist的命令有两个就够用了，分别是用于获取alist密码的运行alist服务的。\n获取用户名和密码 1 alist admin 运行alist服务 1 alist server 运行服务之后通过提示的端口进行网页访问，链接格式是这样的\u0026quot;127.0.0.1:5244\u0026quot;，通过这个链接进行访问你就可以访问alist的界面了。\n添加存储 接下来就需要添加存储了，将百度网盘或者阿里云网盘添加进alist存储，也可以添加本地目录； 第一次访问alist时界面什么都没有，未来添加过网盘后首页应付出现相应的网盘了，添加网盘首先要做的操作是点 击首页最底部的管理，然后再点击存储，接着点击添加，接下来就可以选择要添加的网盘的类型了，添加好的网盘可以在主页浏览。\n浏览官方文档 官方文档 刚开始接触alist只需要看\u0026quot;安装\u0026quot;和\u0026quot;添加存储\u0026quot;就够用了，相关内容介绍的也都比较到位，至少我们平时用的百度网 盘和阿里云网盘是没有问题的，其他网盘有待折腾，包括网上也会有许多不错的教程可以参考学习。\n添加百度网盘 需要关注的有两点，刷新令牌和web代理； 刷新令牌可以根据官方文档进行操作获取并进行添加，web代理也勾选一下，挂载路径随便设置，格式是一个斜杠加 自定义名称，就像这样\u0026quot;/BaiduNetdisk\u0026quot;，剩下的不需要动，接着点击保存就可以了。\n添加阿里云网盘Open 即添加阿里云盘，Open是开源的意思，即跟添加另一个阿里云盘时要做的操作不一样，但是目的都是一样的； 添加阿里云盘只需要关注刷新令牌，然后设置挂载路径，其他地方不需要做，接着保存就可以了；\n添加本机存储 即添加本地目录，只需要设置根文件夹路径和挂载路径即可，根文件夹路径是termux的某个目录，就像这样\u0026quot;/data/data/com.termux/files/home/Alist\u0026quot;，这个路径中\u0026quot;/data/data/com.termux/files/home\u0026quot;对应termux的家目录，在家目录我创建了一个名字叫做\u0026quot;Alist\u0026quot;的目录，这就是我要添加到alist的目录，做完这些后保存就可以了； 我在添加本地存储的时候我有考虑过如果我想添加多个文件夹到本地存储怎么办，我总不能一个一个的复制到设定的目录中吧，因此我想了为要添加到本地存储的目录创建软链接，就像快捷方式一样，这些快捷方式都被我添加到我设定的根文件夹路径中，使用的创建软链接的命令是\u0026quot;ln\u0026quot;，\u0026ldquo;ln\u0026quot;的使用方法可以参考这个链接Linux命令大全(手册)。\n注意事项 alist程序在运行的过程中会在同一目录下创建data目录用来存放配置文件和一些数据文件，如果alist程序在其他地方运行了，会另外创建data目录，这意味着在不同地方运行的alist的data目录的数据不一样，最能直观感受到的就 是当你进行网页访问的时候，两次运行的用户名和密码不同，即配置文件不同，因此alist程序安排好运行路径之后 就不要再动了，不然会导致alist配置文件异常。\n","date":"2025-07-08T18:57:42.57+08:00","permalink":"https://ynhugo.github.io/p/termux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAalist%E6%95%99%E7%A8%8B/","title":"termux环境搭建alist教程"},{"content":"参考链接：在VMware上体验了一把Android x86 9\n下载安卓9.0映像文件 我是在这个网站下载的https://www.fosshub.com/Android-x86.html，选择的是Android-x86 64-bit ISO file，对应版本是9.0-r2-k49。\n打开vmware进行安装 1.点击文件，接着点击创建虚拟机；\n2.选择自定义，然后点击下一步；\n3.硬件兼容性默认，然后点击下一步；\n4.点击稍后安装操作系统，然后点击下一步；\n5.客户机系统选择Linux，版本选择其他Linux 5.x 内核64位，然后点击下一步；\n6.虚拟机名称自定义，选择安装位置，然后点击下一步；\n7.内核数量根据自己电脑硬件情况自定义，然后点击下一步；\n8.内存选择2GB或者4GB，然后点击下一步；\n9.网络类型选择使用网络地址转换(NAT)，然后点击下一步；\n10.IO控制器类型默认，然后点击下一步；\n11.磁盘类型默认，然后点击下一步；\n12.创建新虚拟磁盘，然后点击下一步；\n13.最大磁盘大小这里我分配了40GB，可以自由分配，并且我选择了将虚拟磁盘拆分成多个文件，然后点击下一步；\n14.在指定磁盘文件这里，我的做法是在安卓系统的安装位置中再建一个用来存放磁盘文件的子目录，作为磁盘文 件的目录，然后点击下一步；\n15.在这一步中，先点击自定义硬件，然后点击新CD/DVD(IDE)，在右侧点击使用ISO映像文件，接着点击浏览到下载的安卓映像文件所在的目录选择安卓映像文件，然后点击打开，点击关闭，最后点击完成;\n16.为保险起见，我为安卓系统做一个快照，在安卓系统的标签鼠标右键点击，在弹出的菜单中点击快照，点击拍摄快照，快照的名称和描述可以自定义，再次点击拍摄快照，一秒到两秒钟的时间快照就制作完成了，未开 机状态下的快照制作过程花费时间是最短的；\n17.点击开启此虚拟机，底部弹窗可以叉掉，点进安卓系统的界面的时候鼠标消失了，可以通过快捷键ctrl+alt 恢复鼠标，不过目前要安装安卓系统，因此先不恢复鼠标，在安卓系统的启动界面通过上下方向键选择第三个Installation - Install Android-x86 to harddisk选项后敲回车，加载后进入选择分区界面，用上下方向键选择第一个Create/Modify partitions后，默认选择OK，然后敲回车，再次弹出窗口，默认选择No，再次敲回车，进入创建分区界面，将光标通过左右方向键移到New后敲回车，选择primary后敲回车，在设置分区空间大小界面什么都不要做，再次敲回车，在分区界面默认选中了sda1，将移动光标选中write，然后敲回车，接着分区界面提示yes or no，输入yes，然后敲回车，加载之后选中Quit，然后敲回车，在Choose filesystem界面中默认选中了sda1，光标默认选中OK，其他什么都不做，直接敲回车，在下一个界面中选ext4，然后敲回车，在Confirm界 面选中Yes，然后敲回车，加载后再次在Confirm界面选中Yes，然后敲回车，接下来进入到了Question界面 ，依然是选中Yes，然后敲回车开始了安卓系统安装的过程，加载后先什么都不要做，鼠标右键点击当前安卓系统 的标签，在可移动设备的列表中把CD/DVD(IDE)的连接断开，在进行下一步操作之前如果想保险一点可以先将安 卓系统关机并做一个快照然后重新启动，系统在加载后进入到了GRUB启动模式选择界面，选择第二个模式Android-x86 9.0-r2（Debug mode），然后敲回车，系统开始加载，耐心等待一会儿后，尝试敲回车，如果没有反应就继续加载过程，然后再次尝试敲回车，出现一行只有:/android #，并且旁边有光标在来回闪烁，意味着进入到了安卓系 统的终端环境中，接下来要做几个操作，在命令行界面输入mount -o remount,rw /mnt后回车，执行该命令后在下一行返回一行字符串，不用管，输入下一条命令vi /mnt/grub/ment.lst后敲回车，修改ment.lst文件，进入这 个文件后点击键盘的字母i进入编辑模式，然后将光标通过方向键移动到需要修改的位置在这个文件中有四个title，分别是Android-x86 9.0-r2、Android-x86 9.0-r2（Debug mode）、Android-x86 9.0-r2（Debug nomodeset）和Android-x86 9.0-r2（Debug video=LVDS-1 :d），需要修改语句是的是第一个titleAndroid-x86 9.0-r2下边的kernel /android-9.0-r2/kernel quiet root=/dev/ram0 SRC=/android-9.0-r2，将该条语句中的root 改为nomodeset_root，然后点击按键esc退出编辑模式，再执行快捷键shift+;，这个快捷键由按键shift和 标点符号;组成，执行快捷键后进入底行模式，输入字母wq后回车便退出该文件，接下来在系统标签右击展开 菜单，点击电源列表的重新启动客户机，在模式选择界面选中第一个模式后回车，或者你也可以什么都不做，系统会自动默认选择第一个模式并运行，耐心等待一会儿进入安卓系统。\n配置安卓系统 第一次启动进行安卓系统开机时需要设置语言，把语言设置成简体中文，然后点击开始，跳过网络设置，一些隐私设置能不勾选就不要勾选，屏幕锁定也不设置，点击以后再说，主屏幕应用选择Quickstep并设置始终选择，至此 安卓系统就配置完成了。\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/vmware%E5%AE%89%E8%A3%85android%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/","title":"vmware安装android系统教程"},{"content":"搭建alist教程 alist配置官方文档。\n下载alist 下载程序后在命令行界面运行就可以了，第一次运行的时候先获取到用户名和密码，然后根据提供的用户名和密码进行网页访问并修改密码。\n从终端运行 当前步骤需要做的操作，假设你已经进入程序所在的目录，那么只需要执行 ctrl+l 快捷键，然后回车即可打开相应终端，通过这样的方式打开的终端，终端显示的路径是你的alist程序所在目录的路径。\n后台运行 创建一个bat脚本，脚本内容如下，参考链接：Windows如何后台运行bat文件。\n1 2 3 4 5 6 @echo off if \u0026#34;%1\u0026#34;==\u0026#34;h\u0026#34; goto begin start mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;\u0026#34;\u0026#34;%~nx0\u0026#34;\u0026#34; h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin alist server 然后我为该脚本创建了一个快捷方式，并添加到windows的程序和启动菜单中，这样除了可以手动启动以alist还可以在电脑启动时自动运行alist，并且是在后台运行，有的喜欢将添加快捷方式放到桌面的也没有问题，再提一下windows的程序和启动菜单是\u0026quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\u0026quot; 和 \u0026ldquo;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\u0026rdquo;。\nalist操作方式 使用alist的命令有两个就够用了，分别是用于获取alist密码的运行alist服务的。\n获取用户名和密码 1 alist.exe admin 或者 .\\alist.exe admin 运行alist服务 1 alist.exe server 或者 .\\alist.exe server 运行服务之后通过提示的端口进行网页访问，链接格式是这样的\u0026quot;127.0.0.1:5244\u0026quot;，通过这个链接进行访问你就可以访问alist的界面了。\n添加存储 接下来就需要添加存储了，将百度网盘或者阿里云网盘添加进alist存储，也可以添加本地目录； 第一次访问alist时界面什么都没有，未来添加过网盘后首页应付出现相应的网盘了，添加网盘首先要做的操作是点击首页最底部的管理，然后再点击存储，接着点击添加，接下来就可以选择要添加的网盘的类型了，添加好的网盘可以在主页浏览。\n浏览官方文档 官方文档 刚开始接触alist只需要看\u0026quot;安装\u0026quot;和\u0026quot;添加存储\u0026quot;就够用了，相关内容介绍的也都比较到位，至少我们平时用的百度网盘和阿里云网盘是没有问题的，其他网盘有待折腾，包括网上也会有许多不错的教程可以参考学习。\n添加百度网盘 需要关注的有两点，刷新令牌和web代理； 刷新令牌可以根据官方文档进行操作获取并进行添加，web代理也勾选一下，挂载路径随便设置，格式是一个斜杠加自定义名称，就像这样\u0026quot;/BaiduNetdisk\u0026quot;，剩下的不需要动，接着点击保存就可以了。\n添加阿里云网盘Open 即添加阿里云盘，Open是开源的意思，即跟添加另一个阿里云盘时要做的操作不一样，但是目的都是一样的； 添加阿里云盘只需要关注刷新令牌，然后设置挂载路径，其他地方不需要做，接着保存就可以了；\n添加本机存储 即添加本地目录，只需要设置根文件夹路径和挂载路径即可，根文件夹路径是windows硬盘的某个目录，就像这样\u0026quot;D:\\alist\u0026quot;,做完这些后保存就可以了； 我在添加本地存储的时候我有考虑过如果我想添加多个文件夹到本地存储怎么办，我总不能一个一个的复制到设定的目录中吧，因此我想了为要添加到本地存储的目录创建软链接，就像快捷方式一样，这些快捷方式都被我添加到我设定的根文件夹路径中，使用的创建软链接的命令是\u0026quot;mklink\u0026quot;，官方命令说明如下。\n1 2 3 4 5 6 7 8 9 10 11 创建符号链接。 MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接而非符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。 注意事项 alist程序在运行的过程中会在同一目录下创建data目录用来存放配置文件和一些数据文件，如果alist程序在其他地方运行了，会另外创建data目录，这意味着在不同地方运行的alist的data目录的数据不一样，最能直观感受到的就是当你进行网页访问的时候，两次运行的用户名和密码不同，即配置文件不同，因此alist程序安排好运行路径之后就不要再动了，或者可以将data目录一块移动。\n","date":"2025-07-08T18:57:42.57+08:00","permalink":"https://ynhugo.github.io/p/windows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAalist%E6%95%99%E7%A8%8B/","title":"windows环境搭建alist教程"},{"content":"搭建hugo博客 这里跟着官网教程进行配置，刚开始折腾hugo博客的话，最重要的是折腾成功，官网教程简单实用。\n安装hugo 到官方的github仓库下载对应windows系统的hugo博客框 架，然后将下载下来的文件进行解压，解压后的目录根据个人喜好选择是否重命名，我将解压后的目录命名为hugo，该目录中有一个hugo.exe文件，其它两个文件不用看，删了都不影响，将hugo.exe程序所在目录的路径添加至环境变量。\n创建站点目录 然后在硬盘中找一个自己想要存放博客的位置，创建站点目录，例如我要创建的站点目录的名字叫做hugo1.\n1 hugo new site hugo1 然后名字叫做hugo1的站点目录就创建好了。\n配置博客主题 还是刚开始说的，能够快速折腾成功还是挺重要的，因此还是根据官方教程操作，配置一个主题名叫做ananke的主题。\n1 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke 然后在站点目录的hugo.toml文件中最下边添加一行内容，添加的内容是\n1 theme = \u0026#39;ananke\u0026#39; 可以用用shell命令添加\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 创建博客 创建属于该博客的第一篇内容，名字就叫\u0026quot;我的第一篇博客\u0026quot;吧\n1 hugo new posts/我的第一篇博客.md 然后在站点目录下的content/posts/下就相应的出现了一个文件\u0026quot;我的第一篇博客.md\u0026quot;\n本地预览 1 hugo server -D 部署博客 配置github仓库 在github创建账户，然后创建仓库，仓库命名格式为\u0026quot;yourname.github.io\u0026quot;，配置仓库的主分支为master，配置仓库设置界面的pages的主分支为master。\n在本地生成ssh密钥 1 ssh-keygen 三次回车后密钥就生成了，生成的密钥在家目录下的.ssh目录下，将.ssh/的id_rsa.pub的内容复制到剪切板，然后 回到github网站，在帐户设置的SSH and GPG keys界面中添加剪切板的ssh公钥，然后给添加该密钥的记录随便起一 个名字用于区分可以了。\n配置hugo 将自己仓库的名字yourname.github.io添加到站点目录的hugo.toml配置文件中，将示例链接替换掉，然后设置博客 的语言，接着设置博客的名称，最后一行也就是第四行是咱刚开始就添加过了的，所以不用修改。\n1 2 3 4 baseURL = \u0026#39;yourname.github.io\u0026#39; languageCode = \u0026#39;zh-cn\u0026#39; title = \u0026#39;MyBlogs\u0026#39; theme = \u0026#39;ananke\u0026#39; 部署 先将博客的草稿模式关闭，将true修改为false，然后回到站点目录的第一级目录，然后执行命令run，再进入publib目录，先添加github的仓库链接，然后执行git命令进行部署hugo的操作。\n1 git remote add origin git@github.com:yourname/yourname.github.io.git 1 2 3 git add . git commit -m \u0026#34;upload\u0026#34; git push -u origin master 部署失败解决方法 如果部署过程出现问题，可以执行以下命令来解决\n1 2 3 4 5 6 7 8 9 #!/data/data/com.termux/files/usr/bin/bash git remote rm origin git remote add origin git@github.com:ynhugo/ynhugo.github.io.git git add .; git commit -m upload; git push -u origin master /data/data/com.termux/files/home/hugo/hugo1/content/posts ","date":"2025-07-08T18:57:42.57+08:00","permalink":"https://ynhugo.github.io/p/windows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/","title":"windows环境搭建hugo博客"},{"content":" 科学上网工具如果具有Tun模式，是可以将Tun共享给指定的网络设备，从而使其网络可以科学上网\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/windows%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/","title":"windows通过共享网络方式实现科学上网"},{"content":"易经真的很容易.pdf\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/%E6%9B%BE%E4%BB%95%E5%BC%BA/","title":"曾仕强"},{"content":"笔记文件 点击访问 搭建hexo.pdf\n视频教程 hexo博客搭建教程 准备工作 需要安装：nodejs、git-bash 因官网下载太慢，这里使用nodejs的国内网站和git-bash的镜像网站进行下载 nodejs链接：http://nodejs.cn/download/ nodejs下载地址：https://cdn.npmmirror.com/binaries/node/v16.17.0/node-v16.17.0-x64.msi git-bash链接：https://registry.npmmirror.com/binary.html?path=git-for-windows/ git-bash下载地址：https://cdn.npmmirror.com/binaries/git-for-windows/v2.38.0.windows.1/Git-2.38.0-64-bit.exe 接下来安装nodejs和git-bash nodejs安装教程： git-bash安装教程： 开始搭建 接下来开始搭建hexo： 在git-bash中执行命令 npm install hexo-cli -g\t#安装博客框架 执行 hexo init myBlog\t#生成博客的站点目录 执行命令 hexo s 可以启动本地博客，博客显示的内容 在站点目录的 source/_posts/ 路径下 修改配置文件 准备一个qq邮箱之外的邮箱，邮箱的实用性越高越好，因此我建议的邮箱是微软的Outlook邮箱，官网是 outlook.live.com 可以在注册一个Outlook邮箱,注册完Outlook邮箱之后就可以到 github.com官网 注册了，搭建hexo的前提是在github.com官网 注册并搭建一个用于部署hexo的仓库。 在github注册并新建一个仓库，仓库格式为 用户名.github.io，然后将该仓库生成的\tssh链接复制下来，打开刚刚创建的站点目录下的 _config.yml vim _config.yml 在该文件的最下面，有一段代码： 1 2 3 4 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: \u0026#39; \u0026#39; 将代码更改为： 1 2 3 4 5 6 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: \u0026#39;git\u0026#39;\t#部署博客类型 repo: git@github.com:zzfxdyn/zzfxdyn.github.io.git\t#仓库生成的链接 branch: main\t#仓库默认分支 同时将该文件中url：http://example.com改为 https://仓库名 npm install hexo-deployer-git --save\t#安装博客部署插件 生成ssh密钥 ssh-keygen -t rsa -C \u0026quot;注册github时的邮箱\u0026quot; 连续多次回车，生成ssh密钥在，按照提示的路径进入该路径下复制 id_rsa.pub 的内容 默认路径为 ~/.ssh,在git-bash中通过命令 cd ~/.ssh 进入该路径 cat id_rsa.pub\t#显示id_rsa.pub的内容，然后鼠标选中复制 复制的内容为生成的密钥的公钥，回到浏览器，打开github的设置，点击SSH and GPG Keys， 添加新的密钥，自定义一个名字，粘贴密钥并确定 回到git-bash，配置好站点目录文件后执行命令 git config --global user.email \u0026quot;you@example.com\u0026quot; git config --global user.name \u0026quot;Your Name\u0026quot; 执行 hexo clean \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo d 测试博客部署插件是否安装成功 vim编辑器的使用方法 vim之所以被称之为强大的编辑器是因为本身支持很多的模式 命令模式 命令行模式(底行模式) 编辑模式(插入模式) 可视 可视块 可视行 注意 : 不要使用vim打开目录文件 注意 : 用vim编写完成的文件内容要用正常的保存退出方式,不要直接关闭终端 否则会生成交换文件(交换文件是隐藏文件) vim hello.c | 按iIoOaA\tV\t按: 编辑模式\u0026lt;----------命令模式----------\u0026gt;命令行模式 ---------\u0026gt;\t\u0026lt;---------\t按esc\t按esc或者删掉: 命令行模式的操作 :w\t保存 :q\t退出 :wq\t保存并且退出 如何修改hosts文件 第一种方法 也是网上推荐较多的，比较常用的方法 第二种方法 通过网站获得github网站的ip，我用的是 ipaddress.com 这个网站，点击进入网站后会显示一个403页面，再点击 Go to Homepage 即可真正进入网站。 ","date":"2025-07-08T18:57:42.57+08:00","permalink":"https://ynhugo.github.io/p/%E6%90%AD%E5%BB%BAhexo/","title":"搭建hexo"},{"content":"子午流注与灵龟八法.pdf 中华上下五千年.azw3 中华经典藏书全套装.epub 中国古代志怪经典精选合集.mobi 了凡四训\u0026ndash;中华经典藏书.epub 佛教十三经.epub 医林改错.pdf 古文观止.epub 诸子百家系列套装.epub 国学宝库 国学宝库\n【纪录片】中国风水文化-100集-修复版 ","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/%E5%9B%BD%E5%AD%A6%E5%AE%9D%E5%BA%93/","title":"国学宝库"},{"content":" shell环境基于时间创建文件 1 2 3 4 5 6 7 8 9 10 #!/usr/bin/bash var1=`date | tr \u0026#39;年\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;月\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;日\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $1}\u0026#39;` var2=`date | tr \u0026#39;年\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;月\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;日\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39;` var3=`date | tr \u0026#39;年\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;月\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;日\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;` touch $var1$var2$var3.txt echo \u0026#34;$var1$var2$var3: yenao\u0026#34; \u0026gt; $var1$var2$var3.txt echo \u0026#34;1. \u0026#34; \u0026gt;\u0026gt; $var1$var2$var3.txt windows环境基于时间创建文件 1 2 3 4 5 6 7 8 9 set var1=%date:~0,4% set var2=%date:~5,2% set var3=%date:~8,2% if not exist %var1%%var2%%var3%.txt ( type nul \u0026gt; %var1%%var2%%var3%.txt echo %var1%%var2%%var3%: yenao \u0026gt; %var1%%var2%%var3%.txt echo 1. \u0026gt;\u0026gt; %var1%%var2%%var3%.txt ) ","date":"2025-07-08T18:57:42.6+08:00","permalink":"https://ynhugo.github.io/p/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6/","title":"基于时间创建文件"},{"content":"渐法顿法天元人元九层循序.epub 炁體源流（上）.pdf 炁體源流（下）.pdf 《金刚长寿功》高清扫描版.pdf 八部金刚功.epub 金刚功 金刚功练前准备，掌握立掌、空心掌、方拳，熟悉三焦、劳宫穴等 长寿功 雄功—男性性气功.pdf 米晶子济世良方.pdf ","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/%E7%B1%B3%E6%99%B6%E5%AD%90/","title":"米晶子"},{"content":"人纪-金匮.pdf 佛州汉唐跟诊日志：师从倪海厦先生见闻录.mobi 倪海厦-人纪-简体横版伤寒论.pdf 倪海厦-人纪-简体横版神农本草经.pdf 倪海厦-人纪-简体针灸教程.pdf 倪海厦-天纪-天机道-听课笔记.pdf.pdf 倪海厦-天纪-天机道-终稿.pdf 倪海厦《天纪》—人间道01听课笔记.pdf 倪海厦人间道听课笔记.pdf 倪海厦地脉道听课笔记.pdf 倪海厦教授养生演讲稿.mobi 倪海厦注解伤寒论【自编纯文本】.pdf 四柱命卦.pdf 地脉道-倪海厦.epub 地脉道·人间道·天机道【文字版】.pdf 天机道-倪海厦.pdf 梁冬对话倪海厦七讲.epub 黄帝内经倪海厦注释版-上册.pdf 黄帝内经倪海厦注解版-下册.pdf 倪海厦《易经》详解 47集全 倪海厦《仲景心法》合集 字幕版 ","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/%E5%80%AA%E6%B5%B7%E5%8E%A6/","title":"倪海厦"},{"content":"简要说明实现过程 在官网下载.tar.gz格式的二进制文件，在Cygwin环境中编译出make，再将make命令所在文件夹移到windows环境中， 同时make命令的执行依赖cygwin1.dll文件，将/bin/下的cygwin1.dll文件复制一份到make命令的文件中，然后再将 make命令所在文件夹的路径添加到电脑的环境变量中，打开cmd窗口，执行 make -v，正常输出显示make的版本信息。\n编译过程 ./configure mkae make install\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/%E5%A6%82%E4%BD%95%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E5%AE%9E%E7%8E%B0make%E5%91%BD%E4%BB%A4/","title":"如何在windows环境实现make命令"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { unsigned int a = 0, b = 1, c = 0; unsigned int i; for(i = 2; i \u0026lt;= 1000; i++) { c = b + a; //前两个数的和为第三个数 a = b; //更新 a 为上一个数 b = c; //更新 b 为当前数 } printf(\u0026#34;斐波那契数列第1000个数为：%u\\n\u0026#34;, c); return 0; } ","date":"2025-07-08T18:57:42.6+08:00","permalink":"https://ynhugo.github.io/p/%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","title":"用c语言实现斐波那契数列"},{"content":"实用邮箱 实用的邮箱 outlook outlook这个邮箱服务是微软的，因此实用性不必多言，该邮箱注册过程简单，不需要添加手机号验证。\ngmail gmail这个邮箱服务是谷歌的，因此实用性同样不必多言，该邮箱注册门槛较高，可以根据自己的能力注册，如果真的需要该邮箱的话还可以到一些提供出售这类邮箱的网站买一个用。\n虚拟邮箱 然后就是虚拟邮箱了，我常用的一个是mail.gw/en，我常用的一个是mail.tm，这个网站页面有广告，如果使用了广告拦截器的话需要暂停并刷新一下才能使用，虚拟邮箱网上有一大堆，但是我推荐的这些响应比较快，因此使用方便，缺点就是该虚拟邮箱提供的是垃圾邮箱，不够实用，有的网站对邮箱的标准较高的话该邮箱就废了，这个时候就可以考虑前边推荐的实用邮箱了。\n接码平台 我常用的俄罗斯的一个接码平台sms-activate，我对该接码平台的感受就是实用，最低充值一美元是通过借记卡充值，其他充值方式目前最低充值二美元。\n","date":"2025-07-08T18:57:42.59+08:00","permalink":"https://ynhugo.github.io/p/%E6%B3%A8%E5%86%8C%E8%BE%85%E5%8A%A9%E9%AA%8C%E8%AF%81%E6%8E%A8%E8%8D%90/","title":"注册辅助验证推荐"},{"content":" 为 Android 构建 APK：使用 Termux 的终极指南 配置编译环境部分可以忽略，原本想配置android-sdk的，但是下载的文件跟安卓架构好像不是很匹配，先略过。\n第 1 部分：下载并安装 Termux 获取 Termux Termux 可从 Google Play 商店或 F-Droid 获取。安装后，启动 Termux 并等待初始化过程完成。\n第 2 部分：安装 Gradle 安装 Gradle Gradle 是构建、测试和部署 Android 应用程序的构建自动化工具。在 Termux 中，使用以下命令安装 Gradle：\n1 pkg install gradle Termux配置安卓编译环境 直接复制粘贴到终端运行即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if [ ! \u0026#34;$(env | grep --color=always \u0026#34;cmdline-tools/latest/bin\u0026#34;)\u0026#34; ]; then if [ ! -f \u0026#34;$(basename $HOME/commandlinetools*.zip)\u0026#34; ]; then cd $HOME curl -O https://googledownloads.cn/android/repository/commandlinetools-linux-13114758_latest.zip ANDROID_HOME=~/android/sdk mkdir -p ${ANDROID_HOME}/latest unzip $(basename commandlinetools*.zip) -d $ANDROID_HOME # cmdline-tools 的产物需要移动到cmdline-tools/latest目录中，这是android sdk固定的路径组织形式 # 压缩包没有包含在latest文件夹中，自己移动一下 mv $ANDROID_HOME/cmdline-tools/* $ANDROID_HOME/latest mv $ANDROID_HOME/latest $ANDROID_HOME/cmdline-tools # 双引号与单引号不要动，单引号是为了避免通过echo命令重定向到~/.bashrc的内容中的变量被执行 echo \u0026#34;export ANDROID_HOME=~/android/sdk\u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PATH=$ANDROID_HOME/cmdline-tools/latest/bin:$PATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc rm $(basename $HOME/commandlinetools*.zip) fi fi 参考链接 Termux配置安卓编译环境\nsdkmanager介绍\n仅限命令行工具 | sdkmanager\n第 3 部分：创建 Android 项目 gradle-apk.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/bash java_version=$(java --version | awk \u0026#39;NR==1{print $2}\u0026#39; | awk -F. \u0026#39;{print $1}\u0026#39;) echo \u0026#34;Detected Java version: $java_version\u0026#34; mkdir -p MyApplication cd MyApplication expect \u0026lt;\u0026lt;EOF # log_user 1 # exp_internal 1 spawn gradle init # 确认修改目录 expect -re \u0026#34;.*overwritten.* \\\\[yes, no\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } # 选择 build类型 expect -re \u0026#34;.*Application.*\\\\[1..4\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } # 选择语言 expect -re \u0026#34;.*Java.*\\\\[1..6\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } # 输入 Java 版本 expect -re \u0026#34;.*target Java version.*min: 7, default: 21.*\u0026#34; { send \u0026#34;$java_version\\r\u0026#34; } expect -re \u0026#34;Project name.*default: MyApplication.*:\u0026#34; { send \u0026#34;\\r\u0026#34; } expect -re \u0026#34;.*default: Single application project.*\\\\[1..2\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } expect -re \u0026#34;.*default: Kotlin.*\\\\[1..2\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } expect -re \u0026#34;.*default: JUnit Jupiter.*\\\\[1..4\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } expect -re \u0026#34;.*build using new APIs and behavior.*\\\\[yes, no\\\\]\u0026#34; { send \u0026#34;\\r\u0026#34; } expect eof EOF gradle build gradle run 参考链接 为 Android 构建 APK：使用 Termux 的终极指南\ngradle 打包命令 Android gradle命令行打包生成apk\n","date":"2025-07-06T17:12:23.57+08:00","permalink":"https://ynhugo.github.io/p/%E4%B8%BA-android-%E6%9E%84%E5%BB%BA-apk%E4%BD%BF%E7%94%A8-termux-%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/","title":"为 Android 构建 APK：使用 Termux 的终极指南"},{"content":" python+uiautomator2实现termux的数据清除与初始化配置，待完善 执行方式 1 python cfg.py 安装依赖 1 pip3 install pywinauto cfg.sh 1 2 3 4 5 6 7 8 9 10 11 12 # 打开镜像选择界面 termux-change-repo pkg update pkg install -y termux-auth expect android-tools openssh expect \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; spawn passwd expect \u0026#34;New password:\u0026#34; { send \u0026#34;..Qq1ssh..\\r\u0026#34; } expect \u0026#34;Retype new password:\u0026#34; { send \u0026#34;..Qq1ssh..\\r\u0026#34; } expect eof EOF cfg.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # coding: utf-8 # import uiautomator2 as u2 import subprocess import os import time # 首先确保手机与电脑通过USB连接或者电脑通过ip连接手机adb，如：adb connect 192.168.3.178:5555 result = subprocess.check_output([\u0026#39;adb\u0026#39;, \u0026#39;devices\u0026#39;]).decode(\u0026#39;utf-8\u0026#39;) devices = [line.split(\u0026#39;\\t\u0026#39;)[0] for line in result.splitlines() if \u0026#39;\\tdevice\u0026#39; in line] connect = devices[0] d = u2.connect(connect) # 清除app的数据 d.app_clear(\u0026#39;com.termux\u0026#39;) # 直接通过包名打开app d.app_start(\u0026#39;com.termux\u0026#39;) time.sleep(1) d(resourceId=\u0026#34;com.termux:id/drawer_layout\u0026#34;).click() # 获取存储访问的权限 os.system(f\u0026#39;adb -s {connect} shell input text \u0026#34;termux-setup-storage\u0026#34;\u0026#39;) os.system(f\u0026#39;adb -s {connect} shell input keyevent 66\u0026#39;) # 发送回车键 # 弹窗请求允许，点击允许 d(resourceId=\u0026#34;com.android.permissioncontroller:id/permission_allow_button\u0026#34;).click() # 拷贝脚本 os.system(f\u0026#39;adb -s {connect} push cfg.sh /storage/self/primary/Download/\u0026#39;), time.sleep(1) cmd = \u0026#34;cp -a storage\\/shared\\/Download\\/cfg.sh ~/\u0026#34;.replace(\u0026#34; \u0026#34;, \u0026#34;%s\u0026#34;) os.system(f\u0026#39;adb -s {connect} shell input text \u0026#34;{cmd}\u0026#34;\u0026#39;) os.system(f\u0026#39;adb -s {connect} shell input keyevent 66\u0026#39;) # 回车 # 运行脚本 cmd = \u0026#34;bash ~/cfg.sh\u0026#34;.replace(\u0026#34; \u0026#34;, \u0026#34;%s\u0026#34;) os.system(f\u0026#39;adb -s {connect} shell input text \u0026#34;{cmd}\u0026#34;\u0026#39;) os.system(f\u0026#39;adb -s {connect} shell input keyevent 66\u0026#39;) # 回车 # 换源 # 模拟按键操作（需根据实际UI调整延迟） # time.sleep(2) os.system(f\u0026#39;adb -s {connect} shell input keyevent KEYCODE_SPACE\u0026#39;) # 全选 # time.sleep(2) d.shell(\u0026#39;input keyevent KEYCODE_ENTER\u0026#39;) # 确认 # time.sleep(2) os.system(f\u0026#39;adb -s {connect} shell input keyevent KEYCODE_DPAD_DOWN 2\u0026#39;) # 选择中国镜像（按2次方向键下） # time.sleep(2) os.system(f\u0026#39;adb -s {connect} shell input keyevent KEYCODE_ENTER\u0026#39;) # 确认 time.sleep(30) 参考链接 uiautomator2 进行app的启动,关闭和清空\nbash脚本+python+uiautomator2实现手机自动化配置\ntermux+uiautomator2自动化\n","date":"2025-07-05T16:50:01.67+08:00","permalink":"https://ynhugo.github.io/p/python-uiautomator2%E5%AE%9E%E7%8E%B0termux%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B8%85%E9%99%A4%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E5%BE%85%E5%AE%8C%E5%96%84/","title":"python+uiautomator2实现termux的数据清除与初始化配置(待完善)"},{"content":" bash脚本+python+uiautomator2实现手机自动化配置 项目资源 bash脚本+python+uiautomator2实现手机自动化配置.zip\n实现功能 批量软件下载与安装，以及安装的软件中的科学上网软件的订阅链接配置，订阅链接的配置需要等所以软件下载安装完后根据终端提示进行操作，进行相应按键操作后python脚本会自动进行订阅链接配置。\n须知 ：该项目执行的手机切勿黑屏，不然安装软件会报异常导致软件不能正常安装。\n该项目基本实现完全自动化，除了订阅链接的配置，之所以没有也根据自动化的方式实现，是考虑到用户根据自身需要可以手动添加根软件真正匹配的订阅链接，因为不是有的订阅链接不是很通用，这样做可以为了避免出问题。\n另外该项目中某些软件的下载链接可能国内不能顺利访问或速度很慢，如果遇到这样的情况，可以电脑安装clash-verge科学上网软件，电脑通过该软件实现科学上网后，将该软件的TUN（在软件的设置界面中）打开，这样就可以实现终端也能访问外网了，这样在终端执行该项目会更方便一些。\n环境配置 windows安装好python3的版本 安装git-bash 安装配置好Cygwin，在Cygwin中要安装常用工具如 curl、wget、jq 如果要配置科学上网软件的订阅链接的话，首先修改 科学上网软件如果更换了，同时需要通过该项目配置科学上网软件的订阅链接，可以查看自己的科学上网软件的包名，将实际的包名替换进该项目中，该项目配置了两个科学上网软件订阅链接，如果只需要配置一个科学上网软件，可以将另外一个注释掉。另外项目中两个软件的界面操作是根据软件界面的实际控件进行操作的，如果更换其他软件了，请根据软件的控制进行修改。 如果需要知道查看包名的方法的话，请按照如下方式操作： 1 2 3 4 # 根据关键词 v2ray 匹配科学上网软件v2ranNG的包名 adb -s aefcb1f3 shell pm list packages | grep \u0026#34;v2ray\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $2}\u0026#39; # 同时查看软件软件对应的包名 adb -s aefcb1f3 shell pm list packages | grep -e \u0026#34;v2ray\u0026#34; -e \u0026#34;clash\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $2}\u0026#39; 在执行该项目前，需要基本确保环境配置好了，如果实际执行提示缺少什么库，可以根据终端提示的打印信息，再借助Deepseek完成环境的配置。 1 2 3 4 5 pip install uiautomator2 pip install keyboard pip install -U weditor # -U 选项是 --upgrade 的简写，如果系统中已经安装了 weditor（或指定的包），-U 会强制 检查最新版本 并升级到最新版。 PYTHONIOENCODING=utf-8 PYTHONUTF8=1 pip install -U weditor # 在git-bash有时候直接安装会提示编码问题，因此临时设置 Python 默认编码为 utf-8（推荐），-U 选项是 --upgrade 的简写，如果系统中已经安装了 weditor（或指定的包），-U 会强制 检查最新版本 并升级到最新版。 adb devices # 确认设备已连接 执行方式 在git-bash中运行该项目，cfg.sh与cfg.py和cfg.json要在同一目录下\n根据以下执行方式运动该项目后，bash脚本会自动下载软件并安装，同时python脚本会根据手机界面的提示是否继续安装来作出反应，如果要配置科学上网软件的订阅链接的话，按字母 p 键（可长按，避免按一下时间太短导致脚本检测不到），当订阅链接配置完成后，根据提示按 q 键或按Ctrl-c结束该项目即可。\n1 2 3 4 bash cfg.sh \u0026amp; # 第一步，先以后台执行的方式执行bash脚本，当所有程序安装完后自动结束该脚本 python cfg.py # 第二步，运行python脚本，循环检测，直到所有程序安装完后手动暂停该脚本 # 或 bash cfg.sh \u0026amp; \\python cfg.py # 跟前边的执行方式一样，不过这个执行方式是通过一条命令完成 cfg.json .android.url对应的值对应软件下载链接，如果链接运行直接就能下载文件的话，则直接将下载链接添加到json文件中，如果是类似于api.github.com/repos这样格式的链接，返回的是json格式的数据，需要从中提取出需要下载的文件的下载链接，将提取表达式添加到json中即可。\ngithub的文件之所以没有下载指定版本，是为了通过对api.github.com/repos内容中提出最新版本的文件。\nairport_name 对应科学上网的机场，如果需要用到该键值的话，可以将 airport subscribed links 替换为自己真实的订阅链接，然后通过修改代码添加到科学上网软件中。同时安装好科学上网软件，如果安装的科学上网软件更换了，记得将python代码中的对应科学上网软件的包名也给替换成实际的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;android\u0026#34;:{ \u0026#34;url\u0026#34;:[ {\u0026#34;lawnchair\u0026#34;:\u0026#34;$(curl -s https://api.github.com/repos/LawnchairLauncher/lawnchair/releases/latest | jq -r \u0026#39;.assets[]\u0026#39; | jq -r \u0026#39;.browser_download_url\u0026#39; | grep \u0026#39;Lawnchair\u0026#39;)\u0026#34;}, {\u0026#34;via\u0026#34;:\u0026#34;https://res.viayoo.com/v1/via-release-cn.apk\u0026#34;}, {\u0026#34;termux\u0026#34;:\u0026#34;https://f-droid.org/repo/com.termux_1022.apk\u0026#34;}, {\u0026#34;clash-meta\u0026#34;:\u0026#34;$(curl -s https://api.github.com/repos/MetaCubeX/ClashMetaForAndroid/releases/latest | jq -r \u0026#39;.assets[]\u0026#39; | jq -r \u0026#39;.browser_download_url\u0026#39; | grep \u0026#39;arm64\u0026#39;)\u0026#34;}, {\u0026#34;v2rayng\u0026#34;:\u0026#34;$(curl -s https://api.github.com/repos/2dust/v2rayNG/releases/latest | jq -r \u0026#39;.assets[]\u0026#39; | jq -r \u0026#39;.browser_download_url\u0026#39; | grep \u0026#39;arm64\u0026#39;)\u0026#34;} ], \u0026#34;value\u0026#34;:[ {\u0026#34;lawnchair\u0026#34;:\u0026#34;y\u0026#34;}, {\u0026#34;via\u0026#34;:\u0026#34;y\u0026#34;}, {\u0026#34;termux\u0026#34;:\u0026#34;y\u0026#34;}, {\u0026#34;clash-meta\u0026#34;:\u0026#34;y\u0026#34;}, {\u0026#34;v2rayng\u0026#34;:\u0026#34;y\u0026#34;} ] }, \u0026#34;airport\u0026#34;:{ \u0026#34;airport_name\u0026#34;:\u0026#34;https://example.AirportSubscribedLinks.test\u0026#34; }, \u0026#34;function\u0026#34;:[ {\u0026#34;download_application\u0026#34;:\u0026#34;y\u0026#34;}, {\u0026#34;install_application\u0026#34;:\u0026#34;y\u0026#34;}, {\u0026#34;get_subscription\u0026#34;:\u0026#34;y\u0026#34;} ] } cfg.sh 根据json文件中要下载文件对应的value判断是否下载，如果value值为y，则下载对应文件，如果为n则跳过\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/usr/bin/bash # 定义总文件数组 apk_array=($(jq -r \u0026#39;.android.value[] | keys[]\u0026#39; cfg.json)) # printf \u0026#39;%s\\n\u0026#39; \u0026#34;${apk_array[@]}\u0026#34; # 定义要安装文件的数组 apk_files=() # 两种文件下载方式： # 方式一 # # 下载安装文件，如果文件已存在则跳过 # download_application() { # while IFS= read -r url; do # if [[ \u0026#34;$url\u0026#34; == \\$\\(* ]]; then url=$(eval echo \u0026#34;$url\u0026#34;); fi # apk_files+=($(basename \u0026#34;$url\u0026#34;)) # if [[ ! -f $(basename \u0026#34;$url\u0026#34;) ]]; then wget --no-check-certificate \u0026#34;$url\u0026#34;; fi # done \u0026lt; \u0026lt;(jq -r \u0026#39;.android.url[].[]\u0026#39; cfg.json) # } # 方式二 # 根据json文件中要下载文件对应的value判断是否下载，如果value值为y，则下载对应文件，否则跳过 download_application() { for i in ${apk_array[@]}; do # printf \u0026#39;%s\\n\u0026#39; $i; value=$(jq -r \u0026#34;.android.value[] | select(has(\\\u0026#34;$i\\\u0026#34;)) | .\\\u0026#34;$i\\\u0026#34;\u0026#34; cfg.json) if [ \u0026#34;$value\u0026#34; == \u0026#34;y\u0026#34; ]; then url=$(jq -r \u0026#34;.android.url[] | select(has(\\\u0026#34;$i\\\u0026#34;)) | .\\\u0026#34;$i\\\u0026#34;\u0026#34; cfg.json) if [[ \u0026#34;$url\u0026#34; == \\$\\(* ]]; then url=$(eval echo \u0026#34;$url\u0026#34;); fi # echo \u0026#34;$url\u0026#34; apk_files+=($(basename \u0026#34;$url\u0026#34;)) if [[ ! -f $(basename \u0026#34;$url\u0026#34;) ]]; then wget \u0026#34;$url\u0026#34;; fi fi done } # 安装文件 install_application() { # printf \u0026#39;%s\\n\u0026#39; \u0026#34;${apk_files[@]}\u0026#34; for i in \u0026#34;${apk_files[@]}\u0026#34;; do adb -s $(adb devices | grep -w \u0026#34;device\u0026#34; | awk \u0026#39;NR==1{print $1}\u0026#39;) install \u0026#34;$i\u0026#34; done echo \u0026#34;所有程序已安装完成，如果要配置科学上网软件的订阅链接的话请按字母 p 健，然后等待python脚本自动配置，完成配置或不需要配置可按Ctrl-c结束\u0026#34; } function main() { set -e download_application install_application $1 } main $1 cfg.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 # coding: utf-8 # import signal import sys import subprocess import uiautomator2 as u2 import keyboard import json import time def get_device_id(): # 获取第第一个已连接的Android设备ID try: result = subprocess.check_output([\u0026#39;adb\u0026#39;, \u0026#39;devices\u0026#39;]).decode(\u0026#39;utf-8\u0026#39;) devices = [line.split(\u0026#39;\\t\u0026#39;)[0] for line in result.splitlines() if \u0026#39;\\tdevice\u0026#39; in line] return devices[0] if devices else None except (subprocess.CalledProcessError, IndexError): return None def signal_handler(signal, frame): # print(\u0026#39;Caught Ctrl+C / SIGINT signal\u0026#39;) # 在这里添加你想要做的清理操作 # 例如停止子进程，关闭文件等 # ... # 退出程序的代码 sys.exit(0) # def parse_json_airport(): # with open(\u0026#39;cfg.json\u0026#39;, \u0026#39;r\u0026#39;) as fcc_file: # fcc_data = json.load(fcc_file) # print(fcc_data) def parse_json_airport(): with open(\u0026#39;cfg.json\u0026#39;, \u0026#39;r\u0026#39;) as file: data = file.read() data_dict = json.loads(data) # name_value = data_dict[\u0026#39;airport\u0026#39;] # print(name_value) # # 或 # airport_value = data_dict.get(\u0026#39;airport\u0026#39;, \u0026#39;airport not found\u0026#39;) # print(f\u0026#34;Name: {name_value}, airport: {airport_value}\u0026#34;) sub_value=data_dict[\u0026#39;airport\u0026#39;] [\u0026#39;airport_name\u0026#39;] # print(test_value) return sub_value def main(): running = True device_id = get_device_id() if not device_id: print(\u0026#34;Error: No connect Android device found\u0026#34;) sys.exit(1) print(f\u0026#34;Connected device: {device_id}\u0026#34;) # 初始化uiautomator2连接 try: d = u2.connect(device_id) print(\u0026#34;Device connected successfully\u0026#34;) while running: try: # 检测元素A是否存在 if d(resourceId=\u0026#34;com.android.packageinstaller:id/vbutton_title\u0026#34;, text=\u0026#34;继续安装\u0026#34;).exists(timeout=0): d(resourceId=\u0026#34;com.android.packageinstaller:id/vbutton_title\u0026#34;, text=\u0026#34;继续安装\u0026#34;).click() print(\u0026#34;点击元素\u0026#34;) time.sleep(1) # 操作后等待页面稳定 continue # 回到循环开头重新检测 elif keyboard.is_pressed(\u0026#39;p\u0026#39;): print(\u0026#34;按下了键盘上的 p 键，暂停while循环\u0026#34;) # 配置科学上网软件的订阅链接 print(\u0026#34;开始配置科学上网软件的订阅链接\u0026#34;) print(\u0026#34;开始调用 parse_json_airport()\u0026#34;) airport_sub_value = parse_json_airport() # 获取json文件中配置的订阅链接 # 以下两个软件的界面操作是根据软件界面的实际控件进行操作的，如果更换其他软件了，请根据软件的控制进行修改 print(\u0026#34;配置v2rayNG订阅链接\u0026#34;) d.app_stop(\u0026#39;com.v2ray.ang\u0026#39;) d.app_start(\u0026#39;com.v2ray.ang\u0026#39;) d(description=\u0026#34;Open navigation drawer\u0026#34;).click() d(resourceId=\u0026#34;com.v2ray.ang:id/design_menu_item_text\u0026#34;, text=\u0026#34;订阅分组设置\u0026#34;).click() d(resourceId=\u0026#34;com.v2ray.ang:id/add_config\u0026#34;).click() d(resourceId=\u0026#34;com.v2ray.ang:id/et_remarks\u0026#34;).click() d.send_keys(\u0026#34;tolink\u0026#34;, clear=True) d(resourceId=\u0026#34;com.v2ray.ang:id/et_url\u0026#34;).click() d.send_keys(airport_sub_value, clear=True) d(resourceId=\u0026#34;com.v2ray.ang:id/save_config\u0026#34;).click() time.sleep(1.5) d.app_stop(\u0026#39;com.v2ray.ang\u0026#39;) print(\u0026#34;配置clash-meta订阅链接\u0026#34;) d.app_stop(\u0026#39;com.github.metacubex.clash.meta\u0026#39;) d.app_start(\u0026#39;com.github.metacubex.clash.meta\u0026#39;) d(resourceId=\u0026#34;com.github.metacubex.clash.meta:id/text_view\u0026#34;, text=\u0026#34;配置\u0026#34;).click() d(resourceId=\u0026#34;com.github.metacubex.clash.meta:id/add_view\u0026#34;).click() d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.github.metacubex.clash.meta:id/main_list\u0026#34;]/android.widget.LinearLayout[2]\u0026#39;).click() d(resourceId=\u0026#34;com.github.metacubex.clash.meta:id/text_view\u0026#34;, text=\u0026#34;新配置\u0026#34;).click() d.send_keys(\u0026#34;tolink\u0026#34;, clear=True) d(resourceId=\u0026#34;android:id/button1\u0026#34;).click() d(resourceId=\u0026#34;com.github.metacubex.clash.meta:id/text_view\u0026#34;, text=\u0026#34;仅接受 http(s) 和 content 类型\u0026#34;).click() d.send_keys(airport_sub_value, clear=True) d(resourceId=\u0026#34;android:id/button1\u0026#34;).click() d(resourceId=\u0026#34;com.github.metacubex.clash.meta:id/action_layout\u0026#34;).click() d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.github.metacubex.clash.meta:id/main_list\u0026#34;]/android.widget.RelativeLayout[1]/android.widget.RadioButton[1]\u0026#39;).click() time.sleep(1.5) d.app_stop(\u0026#39;com.github.metacubex.clash.meta\u0026#39;) input(\u0026#34;按回车继续，然后按字母 q 键退出或按 Ctrl-c 结束\u0026#34;) elif keyboard.is_pressed(\u0026#39;q\u0026#39;): print(\u0026#34;按下了键盘上的 \u0026#39;q\u0026#39; 键，退出while循环\u0026#34;) running = False else: # print(\u0026#34;未找到目标元素，等待重试...\u0026#34;) time.sleep(0.5) # 降低CPU占用 except Exception as e: print(f\u0026#34;发生异常: {e}，尝试重新连接设备\u0026#34;) d = u2.connect(device_id) # 重新初始化设备连接 time.sleep(2) return d except Exception as e: print(f\u0026#34;Connected failed: {str(e)}\u0026#34;) sys.exit(1) if __name__ == \u0026#39;__main__\u0026#39;: signal.signal(signal.SIGINT, signal_handler) d = main() 参考链接 Cygwin安装与配置\njq用法\n如何获取 Github 上最新的 release 文件\npython脚本自动配置手机 - 搜索\n使用Python控制手机（一）_python操作手机的脚本-CSDN博客\ntermux+uiautomator2自动化\ntermux+uiautomator2给多个QQ好友点赞\nuiautomator\n(12 条消息) UIAutomator2 的使用教程 - 知乎\nuiautomator+while循环 - 搜索\nAndroid的uiautomator设置循环检测 - CSDN文库\n用Python程序如何捕获Ctrl+C终止信号？\nPython 在Python中优雅地捕捉Ctrl + C / SIGINT并优雅地退出多进程\nPython 解析 JSON――如何读取 JSON 文件\npython json 读取指定key\nPython | 一文搞定Python中对于json数据键值对遍历\n","date":"2025-07-03T17:40:20.84+08:00","permalink":"https://ynhugo.github.io/p/bash%E8%84%9A%E6%9C%AC-python-uiautomator2%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE/","title":"bash脚本+python+uiautomator2实现手机自动化配置"},{"content":" termux+uiautomator2滑动屏幕 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import sys import uiautomator2 as u2 import time d = u2.connect(sys.argv[1]) # 滑动 # d.swipe(0, 692, 0, 0, duration=1) for i in range(10): # 滑动10次 # 方法1：直接滑动 d.swipe(253, 984, 253, 752, duration=1) # # 方法2：尝试通过元素滑动（更推荐） # scrollable = d.xpath(\u0026#39;//*[@scrollable=\u0026#34;true\u0026#34;]\u0026#39;).get() # if scrollable: # scrollable.swipe(\u0026#34;up\u0026#34;) time.sleep(1.5) # 滑动间隔 print(f\u0026#34;已完成第 {i+1} 次滑动\u0026#34;) 参数duration数值可调，也可去除，不过建议保留这个参数\n","date":"2025-06-30T00:46:48.34+08:00","permalink":"https://ynhugo.github.io/p/termux-uiautomator2%E6%BB%91%E5%8A%A8%E5%B1%8F%E5%B9%95/","title":"termux+uiautomator2滑动屏幕"},{"content":" 批量处理博客中时间戳编译报错 1 2 3 4 5 6 7 8 9 10 11 12 13 files=( # 博客文件 ) files_num=${#files[@]} # echo \u0026#34;${files_num}\u0026#34; # echo \u0026#34;${files[0]}\u0026#34; for ((i = 0; i \u0026lt; files_num; i++)) do timestamp=$(stat \u0026#34;${files[${i}]}\u0026#34; | grep \u0026#34;Modify\u0026#34; | awk \u0026#39;{$1=\u0026#34;\u0026#34;; print $0}\u0026#39;) newtimestamp=$(date -d \u0026#34;${timestamp}\u0026#34; \u0026#34;+%Y-%m-%dT%H:%M:%S.%2N%z\u0026#34;) # echo \u0026#34;date: $newtimestamp\u0026#34; sed -i \u0026#34;1,5s/date:.*/date: $newtimestamp/g\u0026#34; \u0026#34;${files[${i}]}\u0026#34; done ","date":"2025-06-28T18:45:44.7+08:00","permalink":"https://ynhugo.github.io/p/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%97%B6%E9%97%B4%E6%88%B3%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/","title":"批量处理博客中时间戳编译报错"},{"content":" termux+uiautomator2给多个QQ好友点赞 安装依赖和uiautomator2库并通过打印设备详情测试环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 安装依赖 apt install -y clang libxml2 libxslt python-pip libjpeg-turbo zlib android-tools pip install cython lxml # 安装库 pip install --pre uiautomator2 # 初始化设备 # 手机无线调试并执行adb配对，然后连接手机ip对应的adb设备，端口为5555是因为配置连接后执行 adb tcpip 5555 设置的 adb connect 192.168.1.101:5555 { echo \u0026#39;import uiautomator2 as u2\u0026#39; echo \u0026#39;d = u2.connect(\u0026#34;192.168.1.101\u0026#34;)\u0026#39; echo \u0026#39;print (d.info)\u0026#39; } \u0026gt; testdemo.py python -m uiautomator2 init\t# 前提是USB调试打开的情况下已经连接无线调试或者USB连接电脑 python testdemo.py 最后执行testdemo.py打印信息如下：\n{\u0026#39;currentPackageName\u0026#39;: \u0026#39;com.tencent.mobileqq\u0026#39;, \u0026#39;displayHeight\u0026#39;: 2400, \u0026#39;displayRotation\u0026#39;: 0, \u0026#39;displaySizeDpX\u0026#39;: 411, \u0026#39;displaySizeDpY\u0026#39;: 914, \u0026#39;displayWidth\u0026#39;: 1080, \u0026#39;productName\u0026#39;: \u0026#39;CN_AI2401\u0026#39;, \u0026#39;screenOn\u0026#39;: True, \u0026#39;sdkInt\u0026#39;: 35, \u0026#39;naturalOrientation\u0026#39;: True}\n环境没有问题了之后就可以进行下一步了，借助WEditor写QQ好友点赞脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import sys import uiautomator2 as u2 d = u2.connect(\u0026#39;192.168.1.101\u0026#39;) # 可以通过传入ip参数执行该程序，如：python qq好友点赞.py 192.168.1.101 # d = u2.connect(sys.argv[1]) d.app_start(\u0026#39;com.tencent.mobileqq\u0026#39;) d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.tencent.mobileqq:id/e3u\u0026#34;]/android.widget.FrameLayout[1]\u0026#39;).click() d(resourceId=\u0026#34;com.tencent.mobileqq:id/us4\u0026#34;).click() d.click(949,650) for i in range(1): for j in range(10): xpath = f\u0026#39;//*[@resource-id=\u0026#34;com.tencent.mobileqq:id/kzn\u0026#34;]/android.widget.LinearLayout[{i+1}]/android.widget.RelativeLayout[1]/android.widget.RelativeLayout[1]/android.widget.ImageView[1]\u0026#39; d.xpath(xpath).click() d.app_stop(\u0026#39;com.tencent.mobileqq\u0026#39;) # d.app_clear(\u0026#39;com.tencent.mobileqq\u0026#39;) 在WEditor中连接adb设备之后，通过不断的不断的双击控件和刷新界面，进而不断的更新控件操作脚本，然后再根据规律将点选的XPath中嵌入for循环变量，来实现给多个好友点赞，变量i对应多个好友，一共给6个好友点赞，通过{i+1}来切换好友，{i+1}是因为变量是从0开始的，而第一个好友对应的变量是从1开始的，所以变量i加1，然后每个好友通过变量j循环点赞10次。如果只要给第1个好友点赞，可以直接修改循环变量i的范围由6改为1，或者修改{i+1}为固定值比如3或者5，由于是修改为固定值，此时没有变量j的参与，所以把花括号也去掉。\n脚本优化-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import os import time import uiautomator2 as u2 connect=os.system(\u0026#39;adb devices | grep -w \u0026#34;device\u0026#34; | awk \\\u0026#39;{print $1}\\\u0026#39;\u0026#39;) d = u2.connect(connect) # d = u2.connect(\u0026#39;127.0.0.1\u0026#39;) # 也可以通过传入ip参数执行该程序，如：python qq好友点赞.py 192.168.1.101 # d = u2.connect(sys.argv[1]) # d.app_stop(\u0026#39;com.tencent.mobileqq\u0026#39;) # 如果是调试时可以取消注释该行，该行代码作用是为了每次打开指定软件前先关闭指定软件 d.app_start(\u0026#39;com.tencent.mobileqq\u0026#39;) d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.tencent.mobileqq:id/e3u\u0026#34;]/android.widget.FrameLayout[1]\u0026#39;).click() d(resourceId=\u0026#34;com.tencent.mobileqq:id/uu4\u0026#34;).click() d(resourceId=\u0026#34;com.tencent.mobileqq:id/l0g\u0026#34;).click() time.sleep(0.5) if d(resourceId=\u0026#34;com.tencent.mobileqq:id/h7r\u0026#34;).exists: d(resourceId=\u0026#34;com.tencent.mobileqq:id/h7s\u0026#34;).click() time.sleep(0.3) else: for i in range(1): xpath = f\u0026#39;//*[@resource-id=\u0026#34;com.tencent.mobileqq:id/kzn\u0026#34;]/android.widget.LinearLayout[{i+1}]/android.widget.RelativeLayout[1]/android.widget.RelativeLayout[1]/android.widget.ImageView[1]\u0026#39; for j in range(10): d.xpath(xpath).click() time.sleep(0.3) d.app_stop(\u0026#39;com.tencent.mobileqq\u0026#39;) 最后添加了d.app_stop()，qq点完赞后会自动关闭。\n执行方式 1 python qq好友点赞.py 参考链接 运行python脚本时传入参数的几种方式（接收外部参数）\n参考链接 无线调试ADB使用配对码链接Android\n安卓设备脱离pc自动化测试，Termux模拟器下python+uiautomator2的环境设置。本人亲测，踩坑总结。\nATX 另一种在 Android 手机内执行 UI 自动化测试方法-Termux\nWEditor\n","date":"2025-06-28T02:00:13.57+08:00","permalink":"https://ynhugo.github.io/p/termux-uiautomator2%E7%BB%99%E5%A4%9A%E4%B8%AAqq%E5%A5%BD%E5%8F%8B%E7%82%B9%E8%B5%9E/","title":"termux+uiautomator2给多个QQ好友点赞"},{"content":" termux+uiautomator2自动化 termux环境设置 1 2 3 4 5 6 7 8 9 10 11 apt install -y clang libxml2 libxslt python-pip libjpeg-turbo zlib android-tools pip install cython lxml pip install --pre uiautomator2 python -m uiautomator2 init\t# 前提是USB调试打开的情况下已经连接无线调试或者USB连接电脑 adb connect 192.168.3.175:5555 { echo \u0026#39;import uiautomator2 as u2\u0026#39; echo \u0026#39;dev = u2.connect(\u0026#34;192.168.3.175\u0026#34;)\u0026#39; echo \u0026#39;print (dev.info)\u0026#39; } \u0026gt; testdemo.py python testdemo.py 给QQ好友点赞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import uiautomator2 as u2 def main(): u = u2.connect(\u0026#39;192.168.3.193\u0026#39;) # 输入设备 # print(u.info) # QQ好友点赞 u.app_start(\u0026#39;com.tencent.mobileqq\u0026#39;) u.click(88,173) u(text=\u0026#39;夜闹\u0026#39;).click() u.click(975,695) for i in range(10): u.click(1018,1157) if __name__ == \u0026#39;__main__\u0026#39;: main() 元素定位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import uiautomator2 as u2 def main(): u = u2.connect(\u0026#39;192.168.3.193\u0026#39;) # 元素定位 xml = u.dump_hierarchy() # print(xml) # 保存到文件（方便分析） with open(\u0026#34;ui_dump.xml\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(xml) if __name__ == \u0026#39;__main__\u0026#39;: main() 使用 weditor 可视化查看元素 1 2 pip install weditor setuptools python -m weditor 浏览器会自动打开 http://localhost:17310，选择设备后即可 实时查看界面元素（类似 Appium Inspector）。\n参考链接 WEditor\nuiauto.dev帮助你快速编写App UI自动化脚本\n十分钟弄懂最快的APP自动化工具uiautomator\n参考链接 安卓设备脱离pc自动化测试，Termux模拟器下python+uiautomator2的环境设置。本人亲测，踩坑总结。\nATX 另一种在 Android 手机内执行 UI 自动化测试方法-Termux\n【uiautomator2 】app最重要的操作：点击、滑动、输入、按键、截屏操作\n十分钟弄懂最快的APP自动化工具uiautomator\n","date":"2025-06-27T20:34:11.38+08:00","permalink":"https://ynhugo.github.io/p/termux-uiautomator2%E8%87%AA%E5%8A%A8%E5%8C%96/","title":"termux+uiautomator2自动化"},{"content":" expect使用示例 如果通过对expect重定向的方式写脚本的话，这样的脚本适合出现在脚本文件中，如果是通过expect -c这样的方式调用，则运行在命令行上\n示例一 该示例适合运行在脚本文件中，然后通过expect命令运行脚本文件，比如脚本名test.sh\n1 2 3 4 5 6 7 8 9 10 11 12 expect \u0026lt;\u0026lt; \u0026#39;END\u0026#39; set pass \u0026#34;segfault\u0026#34; spawn ssh root@segfault.net expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password:\u0026#34; { send -- \u0026#34;$pass\\r\u0026#34; } } expect \u0026#34;Continuing in 60 sec...\u0026#34; { sleep 60; send \u0026#34;\\r\u0026#34; } # expect \u0026#34;Press any key to continue\u0026#34; { send \u0026#34;\\r\u0026#34; } expect \u0026#34;Would you like to see your SECRET now? (y/N)\u0026#34; { send \u0026#34;y\u0026#34; } interact END 运行方式 1 expect test.sh 示例二 该示例适合运行在命令行，如果将该示例添加到脚本文件运行则会执行不了，直接复制该示例粘贴到命令行上回车运行即可\n1 2 3 4 5 6 7 8 9 10 11 12 expect -c \u0026#39; set pass \u0026#34;segfault\u0026#34; spawn ssh root@segfault.net expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password:\u0026#34; { send -- \u0026#34;$pass\\r\u0026#34; } } expect \u0026#34;Continuing in 60 sec...\u0026#34; { sleep 60; send \u0026#34;\\r\u0026#34; } # expect \u0026#34;Press any key to continue\u0026#34; { send \u0026#34;\\r\u0026#34; } expect \u0026#34;Would you like to see your SECRET now? (y/N)\u0026#34; { send \u0026#34;y\u0026#34; } interact \u0026#39; 示例三 这是一个常规示例，同样，运行在命令行上\n1 2 3 4 5 6 7 8 9 expect -c \u0026#39; set pass \u0026#34;Mind@123\u0026#34; spawn ssh root@192.168.0.2 expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password:\u0026#34; { send -- \u0026#34;$pass\\r\u0026#34; } } interact \u0026#39; ","date":"2025-06-27T14:26:36.09+08:00","permalink":"https://ynhugo.github.io/p/expect%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/","title":"expect使用示例"},{"content":" Git如何配置命令行Git使用SSH密钥 生成 SSH 密钥 1 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 配置 Git 使用 SSH 密钥 打开命令行终端，并输入以下命令来查看公钥内容： 1 cat ~/.ssh/id_rsa.pub\t# 复制显示的公钥内容 将显示的公钥内容复制到剪贴板。 打开 Git 服务器上的账户页面，进入 SSH 密钥的设置页面。 在页面上点击 “Add SSH Key” 或类似的按钮，并将刚才复制的公钥粘贴到相应的输入框中。 保存设置，服务器就会将你的公钥添加到授权列表中。 接下来，打开命令行终端，并使用以下命令来配置 Git 使用 SSH 密钥： 1 2 3 git config --global user.email \u0026#34;your_email@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; git config --global core.sshCommand \u0026#34;ssh -i ~/.ssh/id_rsa\u0026#34; 其中，your_email@example.com 需要替换为你的邮箱地址，Your Name 需要替换为你的用户名。\n现在，你就可以使用命令行 Git 来进行远程操作了，而无需每次都输入密码。 参考链接 Git 如何配置命令行 Git 使用 SSH 密钥\n","date":"2025-06-26T16:10:46.65+08:00","permalink":"https://ynhugo.github.io/p/git%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E8%A1%8Cgit%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5/","title":"Git如何配置命令行Git使用SSH密钥"},{"content":" conda命令 除了界面操作，我们还可以在命令行使用 conda 来管理不同环境。\nconda 是 Anaconda 发行版中的包管理器，用于安装、更新、卸载软件包，以及创建和管理不同的 Python 环境。\n以下是一些常用的Conda命令及其简要介绍：\n环境管理 创建一个名为 \u0026#34;myenv\u0026#34; 的新环境: 1 conda create --name myenv 创建指定版本的环境： 1 conda create --name myenv python=3.8 以上代码创建一个名为 \u0026#34;myenv\u0026#34; 的新环境，并指定 Python 版本为 3.8。\n激活环境： 1 conda activate myenv 以上代码激活名为 \u0026#34;myenv\u0026#34; 的环境。\n要退出当前环境使用以下命令： 1 deactivate 查看所有环境： 1 conda env list 以上代码查看所有已创建的环境。\n复制环境： 1 conda create --name myclone --clone myenv 以上代码通过克隆已有环境创建新环境。\n删除环境： 1 conda env remove --name myenv 以上代码删除名为 \u0026#34;myenv\u0026#34; 的环境。\n包管理 安装包： 1 conda install package_name 以上代码安装名为 \u0026#34;package_name\u0026#34; 的软件包。\n安装指定版本的包： 1 conda install package_name=1.2.3 以上代码安装 \u0026#34;package_name\u0026#34; 的指定版本。\n更新包： 1 conda update package_name 以上代码更新已安装的软件包。\n卸载包： 1 conda remove package_name 以上代码卸载已安装的软件包。\n查看已安装的包： 1 conda list 查看当前环境下已安装的所有软件包及其版本。\n其他常用命令 查看帮助： 1 conda --help 以上代码获取 conda 命令的帮助信息。\n查看 conda 版本： 1 conda --version 以上代码查看安装的 conda 版本。\n搜索包： 1 conda search package_name 以上代码在 conda 仓库中搜索指定的软件包。\n清理不再需要的包： 1 conda clean --all 以上代码清理 conda 缓存，删除不再需要的软件包。\nJupyter Notebook（可选） 安装 Jupyter Notebook： 1 conda install jupyter 以上代码安装 Jupyter Notebook。\n启动 Jupyter Notebook： 1 jupyter notebook 以上代码在已激活的环境中启动 Jupyter Notebook。\n参考链接 Anaconda 教程\n","date":"2025-06-24T18:46:13.74+08:00","permalink":"https://ynhugo.github.io/p/conda%E5%91%BD%E4%BB%A4/","title":"conda命令"},{"content":" 安装Conda 1 2 3 4 5 6 7 8 9 10 # 1. 先 cd 到家目录下 cd # 2. 下载安装包：在此地址 https://www.anaconda.com/download/success 中找到安装包的链接 wget https://repo.anaconda.com/archive/Anaconda3-2024.02-1-Linux-x86_64.sh # 3. 安装 anaconda bash Anaconda3-2024.02-1-Linux-x86_64.sh # 4. 按照 anaconda 提示进行安装，默认安装到 /home/用户名/anaconda3 参考链接 WSL2的安装与配置（创建Anaconda虚拟环境、更新软件包、安装PyTorch、VSCode）\n","date":"2025-06-24T18:42:34.67+08:00","permalink":"https://ynhugo.github.io/p/linux%E5%AE%89%E8%A3%85conda%E6%95%99%E7%A8%8B/","title":"Linux安装Conda教程"},{"content":" termux安装Conda教程 安装Ubuntu 1 2 3 4 5 6 7 8 #- 安装proot-distro pkg install proot-distro -y #- 查看有哪些系统 proot-distro list #- 安装ubuntu系统 proot-distro install ubuntu #- 登录ubuntu系统 proot-distro login ubuntu 安装Conda 1 2 3 4 #- 下载miniconda安装脚本 wget -v https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh #- 运行安装脚本 bash Miniconda3-latest-Linux-aarch64.sh 参考链接 【Termux】termux+ubuntu+vscode+conda环境搭建\n","date":"2025-06-24T18:38:08.39+08:00","permalink":"https://ynhugo.github.io/p/termux%E5%AE%89%E8%A3%85conda%E6%95%99%E7%A8%8B/","title":"termux安装Conda教程"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 醒世歌 憨山德清〔明代〕 红尘白浪两茫茫，忍辱柔和是妙方。 到处随缘延岁月，终身安分度时光。 休将自己心田昧，莫把他人过失扬。 谨慎应酬无懊恼，耐烦作事好商量。 从来硬弩弦先断，每见钢刀口易伤。 惹祸只因闲口舌，招愆多为狠心肠。 是非不必争人我，彼此何须论短长。 世事由来多缺陷，幻躯焉得免无常。 吃些亏处原无碍，退让三分也不妨。 春日才看杨柳绿，秋风又见菊花黄。 荣华终是三更梦，富贵还同九月霜。 老病死生谁替得，酸甜苦辣自承当。 人从巧计夸伶俐，天自从容定主张。 谄曲贪嗔堕地狱，公平正直即天堂。 麝因香重身先死，蚕为丝多命早亡。 一剂养神平胃散，两盅和气二陈汤。 生前枉费心千万，死后空留手一双。 悲欢离合朝朝闹，寿夭穷通日日忙。 休得争强来斗胜，百年浑是戏文场。 顷刻一声锣鼓歇，不知何处是家乡。 参考链接:\n醒世歌\n","date":"2025-06-23T15:17:58+08:00","permalink":"https://ynhugo.github.io/p/%E9%86%92%E4%B8%96%E6%AD%8C/","title":"醒世歌"},{"content":" ubuntu24.04安装仓颉工具链 Linux 版本工具链的支持与安装 Ubuntu 24.04 1 sudo apt-get install -y binutils gcc make libc6-dev libc++-dev libgcc-9-dev 参考链接 适用于各 Linux 发行版的仓颉工具链依赖安装命令\n编译安装依赖工具 OpenSSL 3 从以下链接可以下载到 OpenSSL 3 的源码：\nhttps://www.openssl.org/source/old/\n建议使用 OpenSSL 3.0.7 或更高版本。\n此处以 OpenSSL 3.0.7 为例，下载后使用以下命令解压压缩包：\n1 tar xf openssl-3.0.7.tar.gz 解压完成后进入目录：\n1 cd openssl-3.0.7 编译 OpenSSL：\n注意：\n如果系统已经安装了 OpenSSL，建议使用 –prefix=\u0026lt;path\u0026gt; 选项指定一个自定义安装路径，例如 –prefix=/usr/local/openssl-3.0.7 或开发者的个人目录。在系统目录已经存在 OpenSSL 的场景下直接使用以下命令编译安装可能会使系统 OpenSSL 被覆盖，并导致依赖系统 OpenSSL 的应用不可用。\n1 2 ./Configure --libdir=lib --prefix=/usr/local/openssl-3.0.7 make -j$(nproc) 测试 OpenSSL：\n1 make -j$(nproc) test 将 OpenSSL 安装至系统目录（或先前指定的 –prefix 目录），可能需要提供 root 权限以成功执行以下命令：\n1 2 3 make install # 或 sudo make -j$(nproc) install 如果先前编译 OpenSSL 时没有通过 –prefix 设置自定义安装路径，则 OpenSSL 安装已经完成了。如果先前通过 –prefix 指定了自定义的安装路径，还需要设置以下变量，以使仓颉工具链可以找到 OpenSSL 3。\n注意：\n如果系统中原先存在其他版本的 OpenSSL，通过以下方式配置后，除了仓颉工具链外，其他编译开发工具默认使用的 OpenSSL 版本也可能受到影响。如果使用其他编译开发工具时出现 OpenSSL 不兼容的情况，请仅为仓颉开发环境配置以下变量。\n请将 \u0026lt;prefix\u0026gt; 替换为指定的自定义安装路径。\n1 2 3 4 # export LIBRARY_PATH=\u0026lt;prefix\u0026gt;/lib:$LIBRARY_PATH # export LD_LIBRARY_PATH=\u0026lt;prefix\u0026gt;/lib:$LD_LIBRARY_PATH export LIBRARY_PATH=/usr/local/openssl-3.0.7/lib:$LIBRARY_PATH export LD_LIBRARY_PATH=/usr/local/openssl-3.0.7/lib:$LD_LIBRARY_PATH 通过以上方式所配置的环境变量仅在当前执行命令的 shell 会话窗口有效。若希望 shell 每次启动时都自动配置，可以在 $HOME/.bashrc 、 $HOME/.zshrc 或其他 shell 配置文件（依开发者的 shell 种类而定）加入以上命令。\n若希望配置可以默认对所有用户生效，可以执行以下命令：\n请将 \u0026lt;prefix\u0026gt; 替换为指定的自定义安装路径。\n1 2 3 4 5 6 7 8 9 sudo chown -R $USER:$USER /etc/profile echo \u0026#34;export LIBRARY_PATH=/usr/local/openssl-3.0.7/lib:$LIBRARY_PATH\u0026#34; /etc/profile sudo chown -R root:root /etc/profile source /etc/profile sudo chown -R $USER:$USER /etc/ld.so.conf echo \u0026#34;export LD_LIBRARY_PATH=/usr/local/openssl-3.0.7/lib:$LD_LIBRARY_PATH\u0026#34; /etc/ld.so.conf sudo chown -R root:root /etc/ld.so.conf sudo ldconfig 执行完毕后重新打开 shell 会话窗口即可生效。\n至此，OpenSSL 3 已经成功安装，可以回到原来的章节继续阅读或尝试运行仓颉编译器了。\n参考链接 https://www.openssl.org/source/old/\n安装仓颉工具链 1 2 tar xvf Cangjie-0.53.18-linux_x64.tar.gz source cangjie/envsetup.sh 参考链接 安装仓颉工具链\nCangjie 0.53.18\n运行第一个仓颉程序 首先，请在适当目录下新建一个名为 hello.cj 的文本文件，并向文件中写入以下仓颉代码：\n1 2 3 4 // hello.cj main() { println(\u0026#34;你好，仓颉\u0026#34;) } 在这段代码中，使用了仓颉的注释语法，可以在 / 符号之后写单行注释，也可以在一对 /* 和 * 符号之间写多行注释，这与 C/C++ 等语言的注释语法相同。注释内容不影响程序的编译和运行。\n然后，请在此目录下执行如下命令：\n1 cjc hello.cj -o hello 这里仓颉编译器会将 hello.cj 中的源代码编译为此平台上的可执行文件 hello，在命令行环境中运行此文件，将看到程序输出了如下内容：\n1 2 $ ./hello 你好，仓颉 参考链接 运行第一个仓颉程序\n","date":"2025-06-22T22:20:37.33+08:00","permalink":"https://ynhugo.github.io/p/ubuntu24.04%E5%AE%89%E8%A3%85%E4%BB%93%E9%A2%89%E5%B7%A5%E5%85%B7%E9%93%BE/","title":"ubuntu24.04安装仓颉工具链"},{"content":" 使用Timeshift快照备份与恢复 前言 在 Linux 系统的运维管理中，可靠的快照备份与恢复工具尤为关键。TimeShift 作为一款轻量化却功能强大的快照工具，广泛应用于系统状态的备份与恢复。本文将深入探讨 TimeShift 的原理、备份方式、优缺点，以及如何通过真实操作验证 TimeShift 的备份恢复效果。\n一、TimeShift 的工作原理 TimeShift 通过文件系统快照实现备份与恢复，支持基于 rsync 和 Btrfs 两种模式：\nRsync 模式：利用 rsync 工具的增量备份功能，仅备份变化的文件。 Btrfs 模式：依赖于 Btrfs 文件系统的原生快照功能，以更高的效率完成备份。 优缺点对比：\n优点：自动化程度高，增量备份占用存储小，支持多版本快照管理。 缺点：无法选择备份特定文件或目录，限制较大。 二、TimeShift 的备份方式 TimeShift 的备份分为手动和自动：\n手动备份：通过命令行或图形界面，按需创建快照。 自动备份：根据配置文件中的时间策略自动创建快照。支持按小时、每日、每周和每月等多种频率。 优缺点对比：\n优点：自动化程度高，增量备份占用存储小，支持多版本快照管理。 缺点：无法选择备份特定文件或目录，限制较大。 三、TimeShift 的安装和配置 在 Ubuntu Server 24 系统上，安装 TimeShift：\n1 2 sudo apt update sudo apt install timeshift 配置 TimeShift 时，可以编辑 /etc/timeshift/timeshift.json 文件，将“备份设备”设置为适合的磁盘，并根据需求修改快照的 exclude（排除）项。\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;backup_device_uuid\u0026#34;: \u0026#34;YOUR-DEVICE-UUID\u0026#34;, \u0026#34;btrfs_mode\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;schedule_daily\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;count_daily\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;exclude\u0026#34;: [ \u0026#34;/home/**\u0026#34;, \u0026#34;/root/**\u0026#34; ] } 四、TimeShift 的实际操作流程 创建系统快照 首先执行一次完整快照：\n1 sudo timeshift --create --comments \u0026#34;Initial Snapshot\u0026#34; --tags D 查看已创建的快照 使用以下命令查看当前快照：\n1 sudo timeshift --list 删除旧快照 可以使用 –delete 参数删除旧快照，释放空间：\n1 2 3 sudo timeshift --delete --snapshot \u0026#34;Name（时间）\u0026#34; # 如下： sudo timeshift --delete --snapshot \u0026#39;2024-11-11_17-23-52\u0026#39; 当系统出现问题时，通过还原快照快速恢复： 1 2 3 sudo timeshift --restore --snapshot \u0026#34;Name（时间）\u0026#34; # 如下： sudo timeshift --restore --snapshot \u0026#39;2024-11-11_17-23-52\u0026#39; 五、TimeShift 快照操作步骤 下面是详细的备份和恢复步骤。\n设置备份目标目录 我们可以通过配置 /etc/timeshift/timeshift.json 中的 backup_device_uuid 来确定备份位置。 通过如下命令可以查看磁盘 UUID ：\n1 2 3 blkid # 或 lsblk -o name,mountpoint,size,uuid 自定义备份和排除目录 在配置文件中 exclude 参数中可以追加自定义排除的目录：\n1 2 3 4 \u0026#34;exclude\u0026#34;: [ \u0026#34;/home/**\u0026#34;, \u0026#34;/root/**\u0026#34; ] 开始备份操作 执行一次完整备份：\n1 sudo timeshift --create --comments \u0026#34;Manual Backup\u0026#34; 还原到指定快照 使用 –restore 命令将系统还原至特定快照：\n1 2 3 sudo timeshift --restore --snapshot \u0026#34;Name（时间）\u0026#34; # 如下： sudo timeshift --restore --snapshot \u0026#39;2024-11-11_17-23-52\u0026#39; 测试 TimeShift 备份还原的效果 我们可以通过安装一个新的软件（如 PHP），来测试 TimeShift 快照的备份与还原是否正常工作：\n备份前的系统状态 首先，执行一次完整的系统快照。确保在备份前，系统中还没有安装 PHP，执行以下命令验证：\n1 php --version 若系统返回 “command not found”，说明 PHP 未安装。\n现在运行以下命令创建一个快照：\n1 sudo timeshift --create --comments \u0026#34;Pre-PHP Installation Snapshot\u0026#34; --tags D 安装 PHP 并验证 接着，我们通过包管理器安装 PHP：\n1 2 sudo apt update sudo apt install php 安装完成后，再次检查 PHP 是否正确安装：\n1 php --version 若显示 PHP 的版本信息，则说明 PHP 安装成功。\n还原到快照并验证 现在，我们将系统恢复到安装 PHP 之前的快照状态：\n1 sudo timeshift --restore --snapshot \u0026#39;Pre-PHP Installation Snapshot\u0026#39; 还原过程完成后，系统将恢复到之前的快照状态。在恢复后会重启系统，以确保所有配置正确应用。\n重启后，运行以下命令再次检查 PHP 状态：\n1 php --version 如果系统返回 “command not found”，说明 TimeShift 成功还原了快照，PHP 的安装也一并被移除。\n六、总结 TimeShift 在系统故障恢复和状态回滚方面具有显著优势，特别是可以在不影响当前系统使用的情况下，快速创建快照并恢复系统至任意指定状态。本文通过实际操作展示了 TimeShift 的可靠性和操作简便性，使其成为服务器和工作环境下备份与灾难恢复的理想选择。\n补充说明：默认不备份的目录与原因 TimeShift 默认会跳过以下一些目录，以确保备份和恢复的效率、空间占用和可靠性：\n/dev、/proc、/sys、/run：这些目录属于动态、虚拟文件系统。它们包含设备文件、内核和进程信息等。备份这些目录并没有实际意义，因为其内容会在系统启动时自动生成，且不包含持久数据。 /tmp：临时文件目录，用于存放短期使用的文件。系统重启后，该目录内容会被清空，备份它没有实际作用。 /media、/mnt：挂载点目录，主要用于挂载外部存储设备和临时文件系统。备份它们可能会包含无关的外部数据，占用备份空间。 活动目录的备份注意事项 对于一些活动性很强的目录，如 /var 和 /home 下的部分数据（例如数据库和日志文件），TimeShift 也建议谨慎对待：\n活动中的数据库或日志文件：例如 /var/lib/mysql 中的数据库文件，通常需要在数据库服务关闭或停止写入时才能进行一致性备份。如果数据库在运行时备份，可能会导致数据不完整或数据不一致问题。 动态生成的日志和缓存：例如 /var/log 中的日志文件和 /var/cache 中的缓存文件。这些内容在系统使用过程中持续变化，备份时会浪费大量存储空间，并且在恢复时不会对系统配置和正常功能产生实际影响。 因此，TimeShift 主要关注系统配置和核心文件，而将频繁更新的活动目录或临时文件排除在备份之外，以优化备份效率和系统稳定性。\nTimeShift 非常适合服务器和工作环境的备份和灾难恢复需求。理解这些目录的特性，可以帮助我们更好地使用 TimeShift 进行备份和恢复，确保备份的完整性和有效性。\n参考链接 深入探究 Linux 系统的快照备份与恢复：TimeShift 实践与原理解析\nLinux 中获取硬盘分区或文件系统的 UUID 的七种方法\n","date":"2025-06-22T13:07:14.43+08:00","permalink":"https://ynhugo.github.io/p/%E4%BD%BF%E7%94%A8timeshift%E5%BF%AB%E7%85%A7%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","title":"使用Timeshift快照备份与恢复"},{"content":" wsl2子系统的备份和还原 在cygwin下操作：\n1 2 3 4 5 6 7 8 9 10 11 # 先看下自己安装的 WSL 名字是什么，下面是我的名字是 Ubuntu-22.04，你要做替换 wsl -l # 进入 D 盘，然后新建 wslubuntu 文件夹，你可以叫其他名字，用来承载新迁移的目录 cd /cygdrive/d/ mkdir wslubuntu cd wslubuntu # 接着开始迁移 wsl --export Ubuntu-24.04 ./Ubuntu-24.04.tar wsl --unregister Ubuntu-24.04 wsl --import Ubuntu-24.04 ./ Ubuntu-24.04.tar # 再次使用 wsl -l 命令查看，然后启动 Ubuntu-22.04 看下是否迁移正常。 在同一路径下导出再导入后，会发现多了一个.vhdx文件\n参考链接 建议立刻将 WSL + VSCode 作为你的最强生产力环境，起飞吧\nwsl2子系统的备份和还原\nWSL2迁移后默认登陆用户为root的解决方案 第一步，在wsl的root用户下面用vim打开/etc/wsl.conf文件\n1 vim /etc/wsl.conf 第二步，在文件中添加以下代码, 仅需把user_name替换成你原来wsl的用户名即可\n1 2 [user] default=user_name 如\n1 2 [user] default=pengyuyan 重启wsl,在powershell下输入\n1 2 wsl --shutdown wsl 参考链接 WSL2迁移后默认登陆用户为root的解决方案\n解决“wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理” 解决WSL中的localhost代理配置问题 问题背景 在使用Windows子系统Linux（WSL）的过程中，用户可能会遇到一个特定的网络问题，即系统提示\u0026#34;wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。\u0026#34;这通常意味着WSL的网络配置与Windows系统的代理设置不兼容。\n解决方案概述 为了解决这个问题，我们需要调整WSL的网络配置，使其能够正确地反映Windows系统的代理设置。这可以通过创建一个.wslconfig文件并设置特定的网络模式来实现。\n解决方案步骤 步骤1: 创建.wslconfig文件\n打开文件资源管理器，导航到您的用户目录，路径通常是C:\\Users\\\u0026lt;your_username\u0026gt;。 在该目录下，创建一个新的文本文件，并将其命名为.wslconfig（注意没有文件扩展名）。 步骤2: 编辑.wslconfig文件\n右键点击.wslconfig文件，选择“用记事本打开”。 在打开的文本编辑器中，输入以下内容： 1 2 3 4 5 6 [experimental] autoMemoryReclaim=gradual networkingMode=mirrored dnsTunneling=true firewall=true autoProxy=true -保存并关闭文件。\n步骤3: 应用配置并重启WSL\n打开命令提示符或PowerShell。 输入以下命令以关闭WSL的所有分发版： 1 wsl --shutdown 等待命令执行完成，这将关闭所有正在运行的WSL实例。 步骤4: 重启WSL\n重新打开命令提示符或PowerShell。 输入wsl命令来启动WSL。 步骤5: 验证问题是否解决\n检查是否还有关于localhost代理的提示。 如果问题已解决，您可以继续使用WSL。 参考链接 解决“wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理”\n在WSL使用文件资源管理器中打开当前所在路径 在WSL输入一下命令，Windows会弹出WSL在本地的存储\n1 explorer.exe . 参考链接 windows子系统(WSL)与本地互相访问；挂载U盘\n","date":"2025-06-21T02:09:19.06+08:00","permalink":"https://ynhugo.github.io/p/wsl%E6%95%99%E7%A8%8B/","title":"wsl教程"},{"content":" Ubuntu Linux 更换内核版本升级指南-mainline 快速切换任意版本的 Linux 内核 第一步，我们需要先安装 mainline 的软件包。只需要添加它的软件源，然后用 apt 安装即可：\n1 2 3 sudo apt update sudo add-apt-repository ppa:cappelikan/ppa -y sudo apt update \u0026amp;\u0026amp; sudo apt install mainline -y 安装好工具后，我们就可以指定想要安装的内核版本了。比如要安装 6.12.3 版本，可以直接运行：\n1 sudo mainline install 6.12.3 等待安装完成后，只需要重启系统即可：\n1 sudo reboot 使用 uname -r 命令直接查看内核版本号：\n1 uname -r 参考链接 Ubuntu Linux 内核版本升级指南：mainline\n如何在 Ubuntu 中安装 Linux Mainline 主线内核\n","date":"2025-06-20T15:06:33.94+08:00","permalink":"https://ynhugo.github.io/p/ubuntu-linux-%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97-mainline/","title":"Ubuntu Linux 更换内核版本升级指南-mainline"},{"content":" jq用法 一、参数说明 r: 去掉结果中的 \u0026#34; 双引号 c: 在一行显示 二、函数说明 length: 统计键(值)总数 type: 获取元素类型 to_entries: 条目 map:数组中的元素进行映射转换 to_entries: from_entries: keys: 查找json中所有的键, 默认获取第一层键，指定键则获取子键 has：用来是判断是否存在某个key sort_by: 数组排序 reduce: 累加 三、示例 3.1、显示所有值 格式化阅读json文件 1 cat cfg.json | jq 直接打开文件 1 jq . cfg.json 一行显示值 1 jq -c . cfg.json 查找所有键 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ jq \u0026#39;keys\u0026#39; cfg.json [ \u0026#34;conda\u0026#34;, \u0026#34;function\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;source\u0026#34; ] $ jq \u0026#39;.source | keys\u0026#39; cfg.json [ \u0026#34;url\u0026#34; ] $ jq \u0026#39;.source.url | keys\u0026#39; cfg.json [ \u0026#34;acl-runtime\u0026#34;, \u0026#34;ais_bench\u0026#34;, \u0026#34;audio\u0026#34;, \u0026#34;cann\u0026#34;, \u0026#34;graphic\u0026#34;, \u0026#34;miniconda\u0026#34;, \u0026#34;mxvision\u0026#34;, \u0026#34;wifi\u0026#34; ] 去掉方括号 1 2 3 4 5 6 7 8 9 $ jq \u0026#39;.source.url | keys[]\u0026#39; cfg.json \u0026#34;acl-runtime\u0026#34; \u0026#34;ais_bench\u0026#34; \u0026#34;audio\u0026#34; \u0026#34;cann\u0026#34; \u0026#34;graphic\u0026#34; \u0026#34;miniconda\u0026#34; \u0026#34;mxvision\u0026#34; \u0026#34;wifi\u0026#34; 显示所有子值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ jq \u0026#39;.source[]\u0026#39; cfg.json { \u0026#34;miniconda\u0026#34;: \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.1.0-1-Linux-aarch64.sh\u0026#34;, \u0026#34;cann\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%207.0.RC1/Ascend-cann-toolkit_7.0.RC1_linux-aarch64.run\u0026#34;, \u0026#34;mxvision\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/MindX/MindX%205.0.RC3/Ascend-mindxsdk-mxvision_5.0.RC3_linux-aarch64.run\u0026#34;, \u0026#34;acl-runtime\u0026#34;: \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/aclruntime-0.0.2-cp39-cp39-linux_aarch64.whl\u0026#34;, \u0026#34;ais_bench\u0026#34;: \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/ais_bench-0.0.2-py3-none-any.whl\u0026#34;, \u0026#34;audio\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/audio.zip\u0026#34;, \u0026#34;graphic\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/graphic.zip\u0026#34;, \u0026#34;wifi\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip\u0026#34; } $ jq \u0026#39;.source.url[]\u0026#39; cfg.json \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.1.0-1-Linux-aarch64.sh\u0026#34; \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%207.0.RC1/Ascend-cann-toolkit_7.0.RC1_linux-aarch64.run\u0026#34; \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/MindX/MindX%205.0.RC3/Ascend-mindxsdk-mxvision_5.0.RC3_linux-aarch64.run\u0026#34; \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/aclruntime-0.0.2-cp39-cp39-linux_aarch64.whl\u0026#34; \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/ais_bench-0.0.2-py3-none-any.whl\u0026#34; \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/audio.zip\u0026#34; \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/graphic.zip\u0026#34; \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip\u0026#34; 去掉所有值 的双引号 1 2 3 4 5 6 7 8 9 $ jq -r \u0026#39;.source.url[]\u0026#39; cfg.json https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.1.0-1-Linux-aarch64.sh https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%207.0.RC1/Ascend-cann-toolkit_7.0.RC1_linux-aarch64.run https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/MindX/MindX%205.0.RC3/Ascend-mindxsdk-mxvision_5.0.RC3_linux-aarch64.run https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/aclruntime-0.0.2-cp39-cp39-linux_aarch64.whl https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/ais_bench-0.0.2-py3-none-any.whl https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/audio.zip https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/graphic.zip https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip 统计键值总数 1 2 3 4 5 $ jq \u0026#34;length\u0026#34; cfg.json 4 $ jq \u0026#34;.source.url | length\u0026#34; cfg.json # 统计指定子键总数 8 获取元素类型 1 2 $ jq \u0026#34;.source.url | type\u0026#34; cfg.json \u0026#34;object\u0026#34; 取 [] 方括号中的值 1 2 $ jq \u0026#39;.source.url[\u0026#34;wifi\u0026#34;]\u0026#39; cfg.json \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip\u0026#34; 获取 json 中所有 key 和 value 1 2 3 4 5 6 7 $ jq \u0026#39;to_entries | map(\u0026#34;\\(.key)=\\(.value | tostring)\u0026#34;)\u0026#39; cfg.json [ \u0026#34;source={\\\u0026#34;url\\\u0026#34;:{\\\u0026#34;miniconda\\\u0026#34;:\\\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.1.0-1-Linux-aarch64.sh\\\u0026#34;,\\\u0026#34;cann\\\u0026#34;:\\\u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%207.0.RC1/Ascend-cann-toolkit_7.0.RC1_linux-aarch64.run\\\u0026#34;,\\\u0026#34;mxvision\\\u0026#34;:\\\u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/MindX/MindX%205.0.RC3/Ascend-mindxsdk-mxvision_5.0.RC3_linux-aarch64.run\\\u0026#34;,\\\u0026#34;acl-runtime\\\u0026#34;:\\\u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/aclruntime-0.0.2-cp39-cp39-linux_aarch64.whl\\\u0026#34;,\\\u0026#34;ais_bench\\\u0026#34;:\\\u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/ais_bench-0.0.2-py3-none-any.whl\\\u0026#34;,\\\u0026#34;audio\\\u0026#34;:\\\u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/audio.zip\\\u0026#34;,\\\u0026#34;graphic\\\u0026#34;:\\\u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/graphic.zip\\\u0026#34;,\\\u0026#34;wifi\\\u0026#34;:\\\u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip\\\u0026#34;}}\u0026#34;, \u0026#34;function={\\\u0026#34;pre_process\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;apt_install\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;install_miniconda\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;python_pip_install\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;install_cann\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;install_mxvision\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;install_acllite\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;add_audio\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;add_local_desktop\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;add_remote_desktop\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;add_wifi\\\u0026#34;:\\\u0026#34;y\\\u0026#34;,\\\u0026#34;post_process\\\u0026#34;:\\\u0026#34;y\\\u0026#34;}\u0026#34;, \u0026#34;conda={\\\u0026#34;source\\\u0026#34;:\\\u0026#34;channels:\\\\n - defaults\\\\n show_channel_urls: true\\\\n default_channels:\\\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\\\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\\\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\\\\n custom_channels:\\\\n conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\\n msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\\n bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\\n menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\\n pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\\n pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\\n simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\\u0026#34;}\u0026#34;, \u0026#34;python={\\\u0026#34;source\\\u0026#34;:\\\u0026#34;[global]\\\\n index-url = https://pypi.tuna.tsinghua.edu.cn/simple\\\\n [install]\\\\n trusted-host = https://pypi.tuna.tsinghua.edu.cn\\\u0026#34;}\u0026#34; ] 示例 key 和 value 的值组合 文件内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 $ jq to_entries cfg.json [ { \u0026#34;key\u0026#34;: \u0026#34;source\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;url\u0026#34;: { \u0026#34;miniconda\u0026#34;: \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.1.0-1-Linux-aarch64.sh\u0026#34;, \u0026#34;cann\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%207.0.RC1/Ascend-cann-toolkit_7.0.RC1_linux-aarch64.run\u0026#34;, \u0026#34;mxvision\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/MindX/MindX%205.0.RC3/Ascend-mindxsdk-mxvision_5.0.RC3_linux-aarch64.run\u0026#34;, \u0026#34;acl-runtime\u0026#34;: \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/aclruntime-0.0.2-cp39-cp39-linux_aarch64.whl\u0026#34;, \u0026#34;ais_bench\u0026#34;: \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/ais_bench-0.0.2-py3-none-any.whl\u0026#34;, \u0026#34;audio\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/audio.zip\u0026#34;, \u0026#34;graphic\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/graphic.zip\u0026#34;, \u0026#34;wifi\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip\u0026#34; } } }, { \u0026#34;key\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;pre_process\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;apt_install\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_miniconda\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;python_pip_install\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_cann\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_mxvision\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_acllite\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_audio\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_local_desktop\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_remote_desktop\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_wifi\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;post_process\u0026#34;: \u0026#34;y\u0026#34; } }, { \u0026#34;key\u0026#34;: \u0026#34;conda\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;source\u0026#34;: \u0026#34;channels:\\n - defaults\\n show_channel_urls: true\\n default_channels:\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\\n custom_channels:\\n conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\u0026#34; } }, { \u0026#34;key\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;source\u0026#34;: \u0026#34;[global]\\n index-url = https://pypi.tuna.tsinghua.edu.cn/simple\\n [install]\\n trusted-host = https://pypi.tuna.tsinghua.edu.cn\u0026#34; } } ] 用函数执行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 jq \u0026#34;to_entries | from_entries\u0026#34; cfg.json { \u0026#34;source\u0026#34;: { \u0026#34;url\u0026#34;: { \u0026#34;miniconda\u0026#34;: \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.1.0-1-Linux-aarch64.sh\u0026#34;, \u0026#34;cann\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%207.0.RC1/Ascend-cann-toolkit_7.0.RC1_linux-aarch64.run\u0026#34;, \u0026#34;mxvision\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/MindX/MindX%205.0.RC3/Ascend-mindxsdk-mxvision_5.0.RC3_linux-aarch64.run\u0026#34;, \u0026#34;acl-runtime\u0026#34;: \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/aclruntime-0.0.2-cp39-cp39-linux_aarch64.whl\u0026#34;, \u0026#34;ais_bench\u0026#34;: \u0026#34;https://aisbench.obs.myhuaweicloud.com/packet/ais_bench_infer/0.0.2/ais_bench-0.0.2-py3-none-any.whl\u0026#34;, \u0026#34;audio\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/audio.zip\u0026#34;, \u0026#34;graphic\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/graphic.zip\u0026#34;, \u0026#34;wifi\u0026#34;: \u0026#34;https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/images/resources/wifi.zip\u0026#34; } }, \u0026#34;function\u0026#34;: { \u0026#34;pre_process\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;apt_install\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_miniconda\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;python_pip_install\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_cann\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_mxvision\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;install_acllite\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_audio\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_local_desktop\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_remote_desktop\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;add_wifi\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;post_process\u0026#34;: \u0026#34;y\u0026#34; }, \u0026#34;conda\u0026#34;: { \u0026#34;source\u0026#34;: \u0026#34;channels:\\n - defaults\\n show_channel_urls: true\\n default_channels:\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\\n custom_channels:\\n conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\\n simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\u0026#34; }, \u0026#34;python\u0026#34;: { \u0026#34;source\u0026#34;: \u0026#34;[global]\\n index-url = https://pypi.tuna.tsinghua.edu.cn/simple\\n [install]\\n trusted-host = https://pypi.tuna.tsinghua.edu.cn\u0026#34; } } 参考链接 shell jq命令，解析 json 文件\n","date":"2025-06-20T10:23:56.06+08:00","permalink":"https://ynhugo.github.io/p/jq%E7%94%A8%E6%B3%95/","title":"jq用法"},{"content":" 在shell环境提取书签文件中某一链接的技巧 1 cat bookmarks_2023_7_12.html | grep \u0026#34;emacs\u0026#34; | grep \u0026#34;https\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39; 使某命令在后台运行的方法，但是我没有感受到效果 1 2 3 4 if [[ \u0026#34;$@\u0026#34; == *\u0026#34;syncthing\u0026#34;* ]]; then nohup \u0026#34;$@\u0026#34; \u0026amp; fi 查找某项目所有文件包含的头文件并排序去重 1 2 grep --color=auto -rain \u0026#34;#include\u0026#34; ./ | tr \u0026#39;:\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $4}\u0026#39; | sort | uniq ;; 如果要查看有多少个结果，可以在上面命令的最后以管道的形式加上 wc -l linux如何只复制目录结构而不复制数据 1 find ./ -type d | xargs tar -cvf anna.tar --no-recursion 将目录结构压缩到指定目录，然后手动解压即可得到目录结构\n\u0026#34;–no-recursion\u0026#34;表示不递归\nfind + grep 查找关键词 这个命令是在当前目录及其子目录中查找所有扩展名为 .h 或 .cpp 的文件，并在找到的文件中搜索包含 \u0026#34;sigToTh\u0026#34; 的内容\n1 find ./ -name \u0026#34;*.cpp\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs grep --color=auto -rwin \u0026#34;keyword\u0026#34; 查看Zynq各工程版本的命令 1 find ./ -maxdepth 2 -name \u0026#34;*.xpr\u0026#34; | xargs head -5 linux命令将\u0026#34;./\u0026#34;替换为空格 1 find ./ -maxdepth 1 -type f | sed -e \u0026#39;s/\\.\\//\\ /g\u0026#39; linux命令将\u0026#34;./\u0026#34;删除 在sed命令中，替换操作的分隔符可以使用除了反斜杠 (\\)、换行符以及所选字符之一以外的任何字符。在上面的命令中，我们使用了竖线 (|) 作为分隔符，因为这个字符不太可能出现在文件路径中，以避免干扰正则表达式的匹配。\n在sed命令中，也可以使用斜杠 (/) 作为分隔符。但是，在本例中，文件路径中包含斜杠字符，会引起匹配错误。因此，我们选择使用竖线作为分隔符。\n在sed命令中，正则表达式和替换字符串之间用分隔符分隔开来。因为我们使用的是竖线作为分隔符，所以需要在每个竖线字符前后都加上一个竖线字符，即 \u0026#34;s|pattern|replacement|\u0026#34;。\n最终，两个竖线字符 (||) 表示空字符串，用于替换字符串为空。在这个命令中，我们使用sed命令将文件路径中开头的 \u0026#34;./\u0026#34; 删除，如下所示：\n其中，\u0026#34;^\\\\./\u0026#34;表示以 \u0026#34;./\u0026#34; 开头的字符串，\u0026#34;|\u0026#34; 是分隔符，\u0026#34;\u0026#34; 表示替换为空字符串。\n1 find ./ -maxdepth 1 -type f | sed -e \u0026#39;s|^\\./||\u0026#39; 查找文件并高亮显示 1 find ./ -name \u0026#34;stm32*\u0026#34; | grep --color \u0026#34;.\u0026#34; linux查看cpu核数 1 cat /proc/cpuinfo | grep -w \u0026#34;cpu cores\u0026#34; | head -1 | awk \u0026#39;{print $4}\u0026#39; 通过find查找文件和通过grep查找关键词并排除进制文件 排除二进制文件：–binary-files=without-match\n1 find ./ -type f | xargs grep --color --binary-files=without-match -n \u0026#34;sit0\u0026#34; 通过find查找最近一天的文件，通过grep命令匹配当天的文件 1 2 work_dir=${USER} alias cr=\u0026#39;clear \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; find ${HOME}/${work_dir}/reports/*.txt -mtime -1 | xargs cat | grep -A 100 \u0026#34;$(date -I | sed -e \u0026#39;s/-//g\u0026#39;)\u0026#34;\u0026#39; 在Shell脚本中，单个等号 `=` 和双等号 `==` 在条件判断时有一些区别 单个等号 =\n在条件判断中，单个等号用于判断字符串是否相等。 用法示例：[ \u0026#34;$var\u0026#34; = \u0026#34;value\u0026#34; ]，表示变量 $var 的值是否等于字符串 \u0026#34;value\u0026#34;。 双等号 ==\n在条件判断中，双等号也用于判断字符串是否相等，但是推荐在 Bash 中使用双等号进行字符串比较。 用法示例： \u0026#34;$var\u0026#34; == \u0026#34;value\u0026#34; ，表示变量 $var 的值是否等于字符串 \u0026#34;value\u0026#34;。 主要区别在于：\n单个等号 = 可以在绝大多数的Shell中使用，而双等号 == 是Bash特有的语法。 双等号 == 支持更多高级的模式匹配功能，例如正则表达式匹配。 总的来说，在Bash脚本中推荐使用双等号 == 来进行字符串比较，更加灵活且符合习惯。如果你不确定当前环境是否支持双等号 ==，可以使用单个等号 = 来进行字符串比较。\n处理 URL 中获取的变量的乱码 例如变量 cfv 打印到终端上的是\u0026#34;v2.2.5\u0026#34;，但是在用 wget 下载的时候，链接中 cfv 的值就变成了\u0026#34;v2.2.5%0D\u0026#34;这是为什么呢\n在这样的情况下，出现链接中包含了 %0D 的原因可能是因为在获取 cfv 变量的过程中，字符串结尾包含了回车符（Carriage Return）。\n回车符通常用 \\r 表示，在 URL 中，\\r 会被转义成 %0D。这可能是由于在从网页内容中提取 cfv 变量时，结尾包含了回车符导致的。在处理字符串时，特别是从网页内容中提取的字符串，需要格外注意是否包含了不可见的控制字符，如回车符或换行符。\n为了解决这个问题，可以在提取 cfv 变量后，对其进行处理以去除结尾的回车符或其他不可见字符。在 Bash 脚本中，可以使用 sed 命令来去除结尾的回车符，例如：\n1 cfv=$(echo $cfv | sed \u0026#39;s/\\r//g\u0026#39;) 这样处理后，cfv 变量中就不会包含回车符，从而避免在 URL 中出现 %0D 的情况。\nshell位运算，左移，右移，与运算，进制转换 进行移位运算 左移29位，以十六进制输出\n1 a=$((0x1\u0026lt;\u0026lt;29)); printf \u0026#34;0x%04X\u0026#34; $a 进行与运算 1 a=$((0x03\u0026amp;0x07)); printf \u0026#34;0x%X\u0026#34; $a 进行或运算 1 a=$((0x03|0x07)); printf \u0026#34;0x%X\u0026#34; $a 参考链接 第八篇 shell位运算，左移，右移，与运算，进制转换\n如何用shell脚本实现回车继续 在 Bash 脚本中，你可以使用 read 命令来等待用户按下回车键继续执行脚本。下面是一个简单的示例：\n1 2 3 4 5 6 7 #!/bin/bash # 显示提示信息 echo \u0026#34;按下回车键继续...\u0026#34; # 读取用户输入（等待用户按下回车键） read -p \u0026#34;（按下回车键继续）\u0026#34; continue 在这个示例中，read -p \u0026#34;（按下回车键继续）\u0026#34; continue 会等待用户按下回车键，并且在用户按下回车键之后继续执行脚本。\n当脚本执行到这一行时，它会暂停等待用户输入。用户按下回车键之后，脚本会继续执行后面的命令。\n你也可以根据自己的需求修改提示信息和变量名。这样的代码片段可以用于需要用户确认或者暂停执行的情况。\nshell 如何只刷新当前行 在 shell 中，要实现只刷新当前行而不换行，可以使用 ANSI 控制码 \\r。这个控制码会将光标移动到当前行的开头，然后你可以输出新的内容，从而实现只刷新当前行而不换行。示例代码如下：\n1 2 3 4 5 6 7 8 #!/usr/bin/bash echo -n \u0026#34;Loading: 10%\u0026#34; sleep 1 echo -en \u0026#34;\\rLoading: 20%\u0026#34; sleep 1 echo -en \u0026#34;\\rLoading: 30%\u0026#34; # 以此类推 在这个例子中，-n 参数用于禁止echo命令自动换行，而\\r用于将光标移动到行首，然后输出新的内容，实现了只刷新当前行的效果。\n在 Bash 中，-e 选项用于启用反斜杠转义（enable escape characters），它允许 echo 命令解释特定的转义序列。\n具体来说，当你在 echo 命令中使用 -e 选项时，可以在输出中使用以下特殊的转义序列：\n\\n：换行 \\t：制表符 \\r：回车 \\\\：反斜杠 举个例子，如果你想在输出中包含一个换行符，你可以这样使用 -e 选项：\n1 echo -e \u0026#34;Hello\\nWorld\u0026#34; 这将会输出以下内容：\n1 2 Hello World 如果不使用 -e 选项，\\n 将会被当作普通字符输出，而不会被解释为换行符。\nshell 通过只刷新当前行显示时间 1 2 $ while true; do echo -en \u0026#34;\\r\\e[34m$(date)\\e[0m\u0026#34;; sleep 1; done 2024年03月18日 11:10:40 显示 grep 匹配关键词之前或之后指定行数 显示 grep 匹配关键词之前指定行数 1 grep \u0026#34;MODULE_LICENSE\u0026#34; -B 27 /usr/src/linux-headers-`uname -r`/include/linux/module.h 显示 grep 匹配关键词之后指定行数 1 grep \u0026#34;MODULE_LICENSE\u0026#34; -A 27 /usr/src/linux-headers-`uname -r`/include/linux/module.h Ubuntu 匹配 IP 地址 只打印匹配到的内容，不打印多余的内容\n如果您需要提取出 IP 地址，可以使用正则表达式来匹配并提取 IP 地址。以下是一个示例命令，可以从文本中提取出 IP 地址：\n1 ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; 在这个命令中，我们使用了 grep -oE 结合正则表达式 \\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b 来提取文本中的 IP 地址。这个正则表达式可以匹配标准的 IPv4 地址格式。\n当处理 IP 地址时，常见的 IPv4 地址由四个小节组成，每个小节是 0 到 255 之间的数字。在正则表达式中，可以使用以下模式来匹配一个标准的 IPv4 地址：\n\\b：表示单词边界，用于确保匹配的是完整的 IP 地址而不是部分匹配。 ([0-9]{1,3}\\.){3}：匹配三个由数字组成的小节，每个小节包含 1 到 3 个数字（{1,3} 表示重复 1 到 3 次），并且每个小节之间用点号分隔。 [0-9]{1,3}：匹配最后一个小节，同样包含 1 到 3 个数字。 \\b：再次使用单词边界，以确保 IP 地址的结尾是一个单词边界。 因此，这个正则表达式 \\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b 可以准确地匹配一个标准的 IPv4 地址格式。\n在命令中使用 grep -oE 来执行正则表达式匹配操作，-o 选项表示只输出匹配到的部分，-E 表示使用扩展的正则表达式语法。\nshell脚本如何创建数组或列表 在 shell 脚本中，您可以使用类似以下的语法来创建数组：\n1 2 3 4 5 6 7 # 创建一个包含多个元素的数组 my_array=(element1 element2 element3) # 或者逐个添加元素到数组中 my_array[0]=element1 my_array[1]=element2 my_array[2]=element3 另外，您也可以使用 declare 命令来声明一个数组：\n1 2 declare -a my_array my_array=(element1 element2 element3) 要访问数组中的元素，可以使用下标来引用：\n1 2 3 4 5 6 echo ${my_array[0]} # 输出第一个元素 echo ${my_array[1]} # 输出第二个元素 echo ${my_array[2]} # 输出第三个元素 # 输出整个数组 echo ${my_array[@]} 除了数组，您也可以使用空格分隔的列表，如下所示：\n1 my_list=\u0026#34;item1 item2 item3\u0026#34; 然后，您可以使用变量来引用整个列表或者单独的元素：\n1 2 echo $my_list # 输出整个列表 echo $my_list # 输出第一个元素 这是在 shell 脚本中创建数组和列表的简单方法。根据您的需求选择合适的数据结构来存储元素。\n如何自动获取数组个数 在 shell 脚本中，您可以使用 ${#array[@]} 来获取数组中元素的个数。以下是一个示例：\n1 2 3 4 5 6 7 8 # 创建一个包含多个元素的数组 my_array=(element1 element2 element3) # 获取数组中元素的个数 array_length=${#my_array[@]} # 输出数组中元素的个数 echo \u0026#34;数组中元素的个数为: $array_length\u0026#34; 通过 ${#my_array[@]}，您可以轻松地获取数组 my_array 中元素的个数，并将其存储在变量 array_length 中以供后续使用。\n如果您需要获取列表的元素个数，可以使用类似的方法：\n1 2 3 4 5 6 7 8 9 # 创建一个空格分隔的列表 my_list=\u0026#34;item1 item2 item3\u0026#34; # 将列表转换为数组（以便使用相同的方式获取元素个数） list_array=($my_list) list_length=${#list_array[@]} # 输出列表中元素的个数 echo \u0026#34;列表中元素的个数为: $list_length\u0026#34; 这样就可以自动获取数组和列表中元素的个数，方便您在脚本中进行后续处理。\n如何找到文件安装位置 要找到软件包的安装位置，可以使用 dpkg 命令来查询已安装软件包的安装信息。以下是一些常用的命令和选项：\n列出所有已安装的软件包及其安装路径： 1 dpkg -l 这条命令会列出系统上所有已安装的软件包以及它们的版本号、描述等信息，其中包含了软件包的安装路径。\n查询特定软件包的安装路径： 1 dpkg -L package_name 将 package_name 替换为你想要查询的软件包名称，这条命令会列出指定软件包的安装路径。\n查询文件属于哪个软件包： 1 dpkg -S /path/to/file 将 /path/to/file 替换为你想要查询的文件路径，这条命令会告诉你该文件属于哪个软件包。\n要获取软件包的精确安装路径，可以使用以下命令来查询软件包的安装位置： 1 dpkg-query -L package_name 将 package_name 替换为你想要查询的软件包名称。这条命令会列出指定软件包的安装路径，包括所有安装文件和目录的详细路径信息。\n如何将多行数据存储到数组中 你可以使用循环来逐行读取并存储到数组中。在Bash中，可以按照以下方式操作：\n1 2 3 4 5 6 7 8 9 10 # 初始化一个空数组 myArray=() # 使用循环逐行读取数据并存储到数组中 while IFS= read -r line; do myArray+=(\u0026#34;$line\u0026#34;) # 将每行数据添加到数组中 done \u0026lt; \u0026lt;(find ./ -name \u0026#39;*.org\u0026#39; -exec head -n 5 {} \\; | grep -w \u0026#34;^date:\u0026#34;) # 打印整个数组 printf \u0026#39;%s\\n\u0026#39; \u0026#34;${myArray[@]}\u0026#34; 这段代码会从find命令和grep命令中获取多行数据，并逐行存储到名为myArray的数组中。最后，通过 printf 将整个数组打印出来。\n在 Bash 中，IFS（Internal Field Separator）是一个特殊的环境变量，用于指定字段的分隔符，默认情况下包含空格、制表符和换行符。当对 IFS 进行设置时，会影响到后续命令中对字段的解析方式，例如 read 命令。\n在 Bash 的 read 命令中，-r 和 -a 都是选项（或称为标志），用于对输入进行处理和赋值。它们的作用如下：\n-r 选项：\n当使用 -r 选项时，read 命令会禁用反斜杠转义。这意味着如果输入中包含反斜杠字符 \\，它不会被特殊对待，而是按照原样赋值给变量。通常情况下，建议在使用 read 命令时始终加上 -r 选项，以避免意外的反斜杠转义。 -a 选项：\n当使用 -a 选项时，read 命令会将读取的输入赋值给指定的数组变量，而不是普通的字符串变量。这样可以方便地将输入按照特定的分隔符（如空格）分割成多个部分，并存储到数组中的各个元素中。 因此，-r 选项用于禁用反斜杠转义，而 -a 选项用于将输入赋值给数组变量。\n在终端执行示例-1 查找\u0026#34;*.org\u0026#34;文件并存入数组，然后打印数组第一个元素到终端验证效果\n1 mapfile -t file_array \u0026lt; \u0026lt;(find ./ -name \u0026#34;*.org\u0026#34; -type f -exec readlink -f {} +); echo ${file_array[0]} 在终端执行示例-2 该示例在vivado工程包含sdk应用程序的条件下，查找sdk工程中的.mss文件，然后去搜索zynq芯片ps端的配置是否存在，从而确认ps端的配置情况\n1 mapfile -t file_array \u0026lt; \u0026lt;(find ./ -name \u0026#34;*.mss\u0026#34; -type f); for i in \u0026#34;${file_array[@]}\u0026#34;; do echo -e \u0026#34;\\n\u0026#34;; grep --color=always -Hn \u0026#34;psu_uart\u0026#34; \u0026#34;${i}\u0026#34;; done 查看文件创建时间，并把创建时间组成使用hugo命令创建博客时生成的时间戳： 以 ssh配置.org 为例，查看该文件的创建时间，然后组成时间戳\n1 target=\u0026#34;ssh配置.org\u0026#34;; fileCreateTime=\u0026#34;date: $(stat ${target} | tail -n 1 | grep -Eo \u0026#34;\\b[0-9]{4}-[0-9]{2}-[0-9]{2}\\b\u0026#34;)T$(stat ${target} | tail -n 1 | grep -Eo \u0026#34;\\b[0-9]{2}:[0-9]{2}:[0-9]{2}\\b\u0026#34;)+08:00\u0026#34;; echo ${fileCreateTime} 运行后，打印如下时间戳\n1 date: 2024-03-26T00:24:29+08:00 在 awk 中，可以使用字符串连接符来连接多个关键词或字段 你可以使用逗号 , 来连接多个字段或字符串，并通过空格或其他字符来分隔它们。下面是一个示例，演示了如何在 awk 中连接多个关键词：\n假设我们有一个名为 data.txt 的文本文件，内容如下：\n1 2 3 4 5 Alice 25 Bob 30 Charlie 27 David 22 Eve 35 现在假设我们想要使用 awk 命令来输出年龄大于 25 的人的姓名和年龄，并在输出时添加一些额外的描述性文字。我们可以这样做：\n1 awk \u0026#39;$2 \u0026gt; 25 {print \u0026#34;Name: \u0026#34; $1 \u0026#34;, Age: \u0026#34; $2}\u0026#39; data.txt 这个命令的含义是，对于每一行数据，如果第二列（年龄）大于 25，则输出 \u0026#34;Name: \u0026#34;、姓名、\u0026#34;, Age: \u0026#34;、年龄。运行这个命令后，输出将会是：\n1 2 3 Name: Bob, Age: 30 Name: Charlie, Age: 27 Name: Eve, Age: 35 在这个示例中，我们使用了字符串连接符 , 来连接固定的文字和字段，以便形成输出的完整描述。你可以根据自己的需求使用不同的连接方式和格式来构建输出。\n要使用 AWK 输出指定行 你可以结合 AWK 的条件判断功能来实现。以下是一个简单的示例：\n假设有一个名为 example.txt 的文本文件，内容如下：\n#+end_src Line 1: This is the first line Line 2: This is the second line Line 3: This is the third line Line 4: This is the fourth line Line 5: This is the fifth line\n#+end_src\n如果要输出第3行的内容，可以使用以下命令：\n1 awk \u0026#39;NR==3\u0026#39; example.txt 这行命令中，NR==3 表示当前行号等于3时执行相应操作，example.txt 是输入文件。\n如果要输出多行（比如输出第2行到第4行的内容），可以使用类似的方式：\n1 awk \u0026#39;NR\u0026gt;=2 \u0026amp;\u0026amp; NR\u0026lt;=4\u0026#39; example.txt 这样会输出第2行到第4行的内容。\nhugo 批量插入文件的 Linux 脚本参考 1 find ./ -type f | xargs readlink -f| awk -F \u0026#39;/\u0026#39; \u0026#39;{print \u0026#34;[[/\u0026#34;$8\u0026#34;/\u0026#34;$9\u0026#34;/\u0026#34;$10\u0026#34;/\u0026#34;$11\u0026#34;/\u0026#34;$12\u0026#34;][\u0026#34;$12\u0026#34;]]\u0026#34;}\u0026#39; 批量创建文件并添加指定内容到文件中 1 for i in {1..5}; do touch $i.org; echo -e \u0026#34;1\\n2\\n3\\n4\\n5\\n\u0026#34; \u0026gt;\u0026gt; $i.org; done 如果您想要使用 grep 命令从文件中的指定范围检索内容，可以结合使用 head 和 tail 命令来实现。下面是一个示例： 假设您想在文件 example.txt 的第 10 行到第 20 行之间检索包含特定内容的行，可以按照以下步骤进行：\n1 head -n 20 example.txt | tail -n +10 | grep \u0026#34;要查找的内容\u0026#34; 这个命令的含义是先使用 head 命令获取文件前 20 行，然后再通过 tail 命令取其中的第 10 行到最后一行，最后使用 grep 命令在这个范围内查找包含特定内容的行。\n请将上述命令中的 \u0026#34;要查找的内容\u0026#34; 替换为您需要查找的实际内容。\n想办法将文件存入数组 将文件存入数组，然后查看数组成员个数，再将数组的第四个成员值打印出来\n1 mapfile -t file_array \u0026lt; \u0026lt;(find ./ -name \u0026#34;*.org\u0026#34; -type f -exec readlink -f {} +); echo \u0026#34;${#file_array[@]}\u0026#34;; echo \u0026#34;${file_array[3]}\u0026#34;; mapfile 是一个 Bash 内置命令，用于将输入按行分割并存储到数组中。\n具体来说，mapfile 命令会从标准输入中读取数据，并将每一行作为数组的一个元素存储起来。这在处理文本文件、命令输出或其他需要按行进行处理的情况下非常有用。\nHere 文档（\u0026lt;\u0026lt;）是用来输入多行字符串的，而不是用来处理命令替换的。\n以下是 mapfile 命令的一般语法：\nbash mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] array\n-n count：指定要读取的行数。 -O origin：从数组的哪个索引位置开始存储数据。 -s count：跳过输入的前几行。 -t：去掉每个元素末尾的换行符。 -u fd：从指定文件描述符读取输入。 -C callback：对每个读取的行调用一个回调函数进行处理。 使用 mapfile 命令可以简化将文本文件内容读入数组的过程，同时避免了使用循环逐行读取的繁琐操作。\n总之，mapfile 命令的作用是将输入按行分割并存储到数组中，为处理大量文本数据提供了便利的方法。\nsftp 批量执行命令教程 通过以下方式批量执行命令\n1 2 3 4 sftp ssh \u0026lt;\u0026lt; __EOF__ cd / ls __EOF__ sftp 批量执行命令教程-示例 将运行命令粘贴到终端并回车直接运行，也可以以脚本的形式运行\n1 2 3 4 5 6 7 8 9 10 11 12 $ sftp sdf \u0026lt;\u0026lt; __EOF__ cd / ls __EOF__ Connected to sdf. sftp\u0026gt; cd / sftp\u0026gt; ls arpa bin boot boot.cfg com dev etc ftp lib libdata libexec lost+found mail mnt netbsd proc sbin sdf stand sys tmp udd usr var www 参考链接 shell ssh sftp 远程自动部署程序、上传文件，sftp文件上传下载shell脚本\nexpect 1.用expect实现与shell交互，用ssh连接termxu实例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/expect #这一句为声明，声明的方式为`#` + `!` + `expect路径`果不知道expectr的路径，可以执行`which expect`来查看 set host \u0026#34;192.168.0.0\u0026#34; #非本人ip，随便编的ip地址 set password \u0026#34;123456\u0026#34; spawn ssh -p 8022 $host expect { \u0026#34;*yes/no*\\r\u0026#34; #如果检测到包含部分字符串，输出内容与shell交互 { send \u0026#34;yes\\r\u0026#34; } \u0026#34;*assword:\u0026#34; { send \u0026#34;$password\\r\u0026#34; } } interact #连接后保持连接状态 2.用 expect 登录 termux 并执行脚本实例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/expect set host \u0026#34;192.168.0.0\u0026#34; set password \u0026#34;..Qq1ssh..\u0026#34; set script \u0026#34;touch 54545455454545454544545545445455545454454454.sh\u0026#34; #假设脚本内容只是创建一个文件 spawn ssh -p 8022 $host expect { \u0026#34;*yes/no*\\r\u0026#34; { send \u0026#34;yes\\r\u0026#34; } \u0026#34;*assword:\u0026#34; { send \u0026#34;$password\\r\u0026#34; } } expect \u0026#34;*\u0026#34; #匹配到任意字符 send \u0026#34;$script\\r\u0026#34; #执行脚本 expect \u0026#34;*\u0026#34; #匹配到任意内容 send \u0026#34;exit\\r\u0026#34; #退出 send \u0026#34;\\r\u0026#34; #换行 expect eof #执行完后退出 3. expect eof 与 interact 的区别： 这两个命令作为结束语句用的，如果只是执行一次任务就退出，那么可以用expect eof，如果连接后想要保持连接状态，那么就用interact\n4.注意事项： 有一点需要注意，执行脚本的方式有很多种，但是执行expect脚本的时候只能用 expect ./ 的方式执行，目前我知道的两种方式，不然会执行失败。\n如何使用wget下载整个网站 wget 是用于从网站下载资源的 linux 命令，基本用法是 wget url:\n1 wget http://www.w3schools.com/ 一般来说，网站的页面会有很多链接，点击之后可以链接到其他页面，其他页面也可能有链接，就这样一级一级链接下去，如果要把这些所有关联的页面都下载下来，用法是：\n1 wget -r http://www.w3schools.com/ 但是大部分网站不允许你下载所有网站的内容，如果网站检测不到浏览器标识，会拒绝你的下载连接或者给你发送回一个空白网页。这个时候在 wget 后面加上 user-agent 就可以：\n1 wget -r -p -U Mozilla http://www.w3schools.com/ 为了避免被网站加入黑名单，我们可以限制下载的速度以及两次下载之间的等待时间：\n1 wget --wait=20 --limit-rate=20K -r -p -U Mozilla http://www.w3schools.com/ 如何只是想下载特定文件夹下的网页，使用 –no-parent 只下载 /js 下的所有页面\n1 wget --wait=20 --limit-rate=20K --no-parent -r -p -U Mozilla http://www.w3schools.com/js/default.asp 参考链接 Linux 如何使用 wget 下载整个网站\ncat命令 1 2 cat a \u0026gt; b #将a中文件覆盖到文件b中 cat a \u0026gt;\u0026gt; b #将a中文件追加到文件b中 在SSH命令中，使用-D参数来创建动态端口转发时 不需要指定本地地址。正确的用法是只指定端口号，例如：\n1 ssh -D 1080 root@segfault.net 这将在本地主机上创建一个SOCKS代理，监听在端口1080上，并将流量通过SSH通道转发到远程主机segfault.net。在这个命令中，root是远程主机的用户名，segfault.net是远程主机的地址。\nfind命令查找并复制文件到指定路径 提取视频到“视频提取”这个目录中\n1 find ./ -name \u0026#34;*.mp4\u0026#34; -type f -exec cp \u0026#39;{}\u0026#39; 视频提取 \\; ffmpeg-ffplay自动播放视频列表 将当前中路径下的视频文件名称保存到数组中，然后通过for循环和ffplay依次播放数组中的文件\n1 mapfile -t file_array \u0026lt; \u0026lt;(ls | sort); for i in \u0026#34;${file_array[@]}\u0026#34;; do ffplay -autoexit \u0026#34;${i}\u0026#34;; done 查找文件并进行排序 1 find ./ -type f -exec ls -l --time-style=+%s {} \\; | sort -k6n | awk \u0026#39;{print $1, $2, $3, $4, $5, strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, $6), $7, $8, $9, $10}\u0026#39; 这个命令是一个复杂的管道命令，它主要用于列出当前目录及其子目录中所有文件的详细信息，并按文件修改时间进行排序。让我们一步步拆解这个命令：\nfind ./ -type f -exec ls -l –time-style=+%s {} \\;：\nfind ./ -type f：使用 find 命令查找当前目录 (./) 及其子目录中的所有文件 (-type f)。 -exec ls -l –time-style=+%s {} \\;：对于找到的每一个文件，执行 ls -l 命令来显示详细信息，并使用 –time-style=+%s 选项以秒数的形式显示修改时间。 sort -k6n：\nsort 命令用于排序输入的行。 -k6n：指定排序的关键字为第6列（修改时间），并使用数字方式进行排序。 awk \u0026#39;{print $1, $2, $3, $4, $5, strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, $6), $7}\u0026#39;：\nawk 是一种文本处理工具，用于对文本进行逐行处理。 \u0026#39;{print $1, $2, $3, $4, $5, strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, $6), $7}\u0026#39;：对输入的每一行进行处理，打印出第1到第7列的内容，并将第6列的时间戳转换为指定格式的日期时间字符串。 综合起来，这个命令的作用是列出当前目录及其子目录中所有文件的详细信息，并按文件修改时间进行排序，最后以指定的格式输出。\n在这个命令中，find 和 ls 是结合使用的，但它们的工作方式是分开的。find 命令是用来查找文件的，它会递归地遍历指定目录及其子目录，找到符合条件的文件。而 -exec ls -l –time-style=+%s {} \\; 这部分则是在找到每一个文件后都会执行一次 ls -l 命令来获取文件的详细信息。\n换句话说，find 命令是逐个找到文件，然后立即通过 -exec 选项将每个找到的文件传递给 ls -l 命令进行处理。这意味着，不是等到所有文件都找到后再一次性地通过 ls -l 命令处理，而是边找到文件边处理。\n这样做的好处是可以实时获取每个文件的详细信息，并且可以在处理每个文件时进行额外的操作，例如这里的 –time-style=+%s 选项用来显示文件的修改时间戳。\nshopt 使用技巧 Linux 环境启用 extglob 扩展 例如在 bash shell 中，rm -rf !(file) 无效，因为 !(pattern) 是 extglob 扩展，需要打开扩展模式才能使用。要配置 shopt 来启用 extglob 扩展，可以按照以下步骤进行：\n打开终端。 运行 shopt -s extglob 命令来启用 extglob 扩展。 现在你应该可以使用 !(pattern) 这样的模式来排除某些文件，例如 rm -rf !(file)。 请注意，在使用 extglob 扩展时要格外小心，确保不会意外删除重要文件。\nshopt -s extglob 与 shopt -u extglob 有区别吗 shopt -s extglob 和 shopt -u extglob 是 bash shell 中的两个不同命令，它们分别用于启用和禁用 extglob 扩展。这两个命令的作用如下：\nshopt -s extglob：这个命令用于启用 extglob 扩展，允许在 bash shell 中使用扩展模式，比如 !(pattern)、*(pattern)、+(pattern)、?(pattern) 和 @(pattern)。 shopt -u extglob：这个命令用于禁用 extglob 扩展，即关闭扩展模式，使得在 bash shell 中不能再使用上述提到的扩展模式。 因此，这两个命令的区别在于一个用于启用扩展模式，另一个用于禁用扩展模式。\nLinux 下切换目录省略 cd 命令 shopt -s autocd：启用 Bash 的 autocd 选项，使得在输入目录路径时可以省略 cd 命令，直接切换到该目录。\nshell脚本如何获取参数数量 在Shell脚本中，你可以使用内置变量 $# 来获取传递给脚本或函数的参数数量。这个变量表示传递给脚本或函数的参数数量。\n例如，假设你有一个名为 script.sh 的Shell脚本，可以通过 $# 来获取传递给该脚本的参数数量，如下所示：\n1 2 3 #!/bin/bash echo \u0026#34;Number of arguments: $#\u0026#34; 当你执行 ./script.sh arg1 arg2 arg3 时，它将输出：\n1 Number of arguments: 3 这表明传递给脚本的参数数量为3。\n如何获取最后一个参数 要获取最后一个参数，你可以使用特殊变量 $ 后跟参数的索引。在 Bash 中，$# 表示参数的总数，而 ${!#} 表示最后一个参数。\n如何获取多个参数的内容 要获取多个参数的内容，你可以使用 $1, $2, $3 等等来访问每个参数的值。如果你不确定要获取多少个参数，可以使用循环来处理它们。\n以下是一个示例脚本，演示如何获取并打印所有参数的内容：\n1 2 3 4 5 6 7 8 9 #!/usr/bin/bash args=\u0026#34;$#\u0026#34; echo \u0026#34;Total arguments: $args\u0026#34; for ((i = 1; i \u0026lt;= args; i++)); do echo \u0026#34;Argument $i: ${!i}\u0026#34; done 当你执行 ./script.sh arg1 arg2 arg3 时，它将输出：\n1 2 3 4 Total arguments: 3 Argument 1: arg1 Argument 2: arg2 Argument 3: arg3 这表明脚本正确地获取并打印了所有参数的内容。\nLinux命令中短横线的作用 用以下命令举例\n1 tar -cpzf - ./ | tar -xpzf - -C dir 这个命令可以分解为两个部分：\ntar -cpzf - ./：这部分将当前目录中的所有文件和子目录打包成一个tar文件，并通过标准输出（stdout）输出。 -c 表示创建归档文件，-p 保留文件权限和属性，-z 使用gzip进行压缩，-f - 将归档文件输出到标准输出。 tar -xpzf - -C dir：这部分将从标准输入（stdin）读取tar文件，并将其解压缩到指定的目录。-x 表示提取文件，-p 保留文件权限和属性，-z 使用gzip进行解压缩，-f - 从标准输入读取归档文件，-C dir表示将文件提取到指定的目录。 综合起来，整个命令的作用是将当前目录中的所有文件和子目录打包成一个tar文件，并通过管道传输给另一个命令，该命令将tar文件解压缩到指定的目录（dir）。这样就实现了将当前目录中的文件和子目录传输到指定目录并进行解压缩的操作。\nLinux下如何查看当前用的是zsh还是bash 要查看当前正在使用的是 zsh 还是 bash，可以使用以下命令：\n1 echo $SHELL 这个命令会输出当前 shell 的路径。通常情况下，如果你的 shell 是 bash，它会输出 /bin/bash；如果是 zsh，它会输出 /bin/zsh。\n通过lshw命令确定系统是否支持 ECC 内存 使用 lshw 命令： lshw 是一个用于列出系统硬件信息的工具，可以使用它来查看系统的内存信息，包括 ECC 支持情况。运行以下命令：\n1 sudo lshw -class memory | grep -i ecc linux如何查看内存大小 在Linux系统中，有多种方式可以查看系统内存大小。以下是几种常用的方法：\n使用free命令 free命令可以查看系统内存的总量、使用量和空闲量等信息。在终端中输入以下命令即可查看：\n1 free -h 该命令会以人类可读的方式显示内存信息，例如：\n1 2 3 total used free shared buff/cache available Mem: 7.7G 2.4G 1.1G 1.1G 4.2G 4.3G Swap: 2.0G 0B 2.0G 其中，total表示内存总量，used表示已使用的内存量，free表示空闲的内存量。\n使用cat命令 /proc/meminfo文件包含了系统内存的详细信息。您可以使用cat命令查看该文件的内容，如下所示：\n1 cat /proc/meminfo 该命令会输出系统内存的详细信息，例如\n1 2 3 4 5 6 7 8 MemTotal: 8051920 kB MemFree: 1172128 kB MemAvailable: 4458368 kB Buffers: 125528 kB Cached: 4023852 kB SwapCached: 0 kB Active: 2927372 kB Inactive: 2965436 kB 其中，MemTotal表示内存总量，以千字节为单位。\n使用dmidecode命令 dmidecode命令可以显示系统硬件信息，包括内存信息。在终端中输入以下命令即可查看：\n1 sudo dmidecode -t memory 该命令会输出系统中所有内存模块的详细信息，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # dmidecode 3.2 Getting SMBIOS data from sysfs. SMBIOS 2.7 present. Handle 0x1000, DMI type 16, 23 bytes Physical Memory Array Location: System Board Or Motherboard Use: System Memory Error Correction Type: None Maximum Capacity: 32 GB Error Information Handle: Not Provided Number Of Devices: 4 Handle 0x1100, DMI type 17, 34 bytes Memory Device Array Handle: 0x1000 Error Information Handle: Not Provided Total Width: 64 bits Data Width: 64 bits Size: 8192 MB Form Factor: DIMM Set: None Locator: ChannelA-DIMM0 Bank Locator: BANK 0 Type: DDR3 Type Detail: Synchronous Speed: 1600 MT/s Manufacturer: Kingston Serial Number: 123456789 Asset Tag: Not Specified Part Number: KHX1600C9D3K2/8GX Rank: 2 Configured Clock Speed: 1600 MT/s Minimum Voltage: 1.5 V Maximum Voltage: 1.5 V Configured Voltage: 1.5 V 其中，Maximum Capacity表示内存总量，以GB为单位。\n参考链接 linux如何查看内存大小\n使用 dd 命令来测试硬盘的写入速度，并且采用一些优化参数来减少系统缓存的影响 示例 1 2 3 4 5 6 7 8 $ time dd if=/dev/zero of=/testw.dbf bs=1M count=1000 oflag=direct 记录了1000+0 的读入 记录了1000+0 的写出 1048576000字节（1.0 GB，1000 MiB）已复制，6.8299 s，154 MB/s real 0m6.876s user 0m0.046s sys 0m0.108s time dd if=/dev/zero of=/testw.dbf bs=1M count=1000 oflag=direct：\ntime：用于测量命令执行的时间。 dd：数据传输命令。 if=/dev/zero：输入文件指定为 /dev/zero，该文件会产生无限的零字节流。 of=/testw.dbf：输出文件指定为 /testw.dbf，这是测试中要写入的文件。 bs=1M：块大小设置为 1 MB，表示每次读取或写入的数据块大小为 1 MB。 count=1000：指定了写入的块数为 1000，因此总共要写入 1000 × 1 MB = 1000 MB 的数据。 oflag=direct：该参数指示 dd 命令在执行时绕过系统缓存，直接与硬盘进行数据交换。 记录了1000+0 的读入：表示成功读取了 1000 个数据块。 记录了1000+0 的写出：表示成功写入了 1000 个数据块。 1048576000字节（1.0 GB，1000 MiB）已复制，6.8299 s，154 MB/s：\n表示总共复制了 1,048,576,000 字节，即 1.0 GB 的数据。 6.8299 s 是命令执行的实际时间。 154 MB/s 是写入速度，即每秒写入 154 MB 的数据量。 real 0m6.876s：实际时间，即命令的总执行时间。 user 0m0.046s：用户 CPU 时间，即命令在用户态消耗的 CPU 时间。 sys 0m0.108s：系统 CPU 时间，即命令在内核态消耗的 CPU 时间。 综合来看，该命令测试了硬盘的写入速度，并显示了每秒写入的数据量为 154 MB，这是在绕过系统缓存的情况下测得的结果。\nxxd使用技巧 将文本转换为ASCII对应的16进制输出 操作命令 1 echo \u0026#39;0\u0026#39; | xxd -p 使用实例 结果用ASCII表示，30表示字符0，0a表示换行符\n1 2 $ echo \u0026#39;0\u0026#39; | xxd -p 300a 将ASCII对应的16进制转换为ASCII输出 操作命令 1 echo \u0026#39;300a\u0026#39; | xxd -r -p 使用实例 1 2 $ echo \u0026#39;300a\u0026#39; | xxd -r -p 0 linux环境如何合并两个文件夹，两个目录名相同，文件有相同的也有不相同的，遇到同名文件跳过 在 Linux 环境中，你可以使用 rsync 命令来合并两个文件夹，并在遇到同名文件时跳过。rsync 是一个强大的文件同步工具，可以用于在本地或远程系统之间同步文件和目录。\n以下是使用 rsync 命令合并两个目录的基本语法：\n1 rsync -av --ignore-existing 源目录/ 目标目录/ 这里的参数含义如下：\n-a, –archive：以归档模式进行同步，包括递归地复制子目录、保持文件权限、保持文件修改时间等。 -v, –verbose：显示详细的输出信息，让你知道正在发生什么。 –ignore-existing：忽略已经存在于目标目录中的文件，不进行覆盖，这样就能实现遇到同名文件时跳过的效果。 源目录/：指定源目录的路径。 目标目录/：指定目标目录的路径。 例如，假设你有两个目录 folder1 和 folder2，你想将它们合并到一个目录 merged_folder 中，可以使用以下命令：\n1 2 rsync -av --ignore-existing folder1/ merged_folder/ rsync -av --ignore-existing folder2/ merged_folder/ 这样就会将 folder1 和 folder2 中的文件合并到 merged_folder 中，并在遇到同名文件时跳过。\nLinux history 命令详解：如何查看、显示时间、清空、重复和控制历史记录 当然，让我们详细解释 history 命令的各个方面：\n### 1. 查看历史记录\n使用 history 命令可以查看 Bash shell 中执行过的命令历史记录。这将显示按照执行顺序排列的历史记录列表，每个命令前面带有一个数字。\n### 2. 显示时间戳\n默认情况下，history 命令不会显示每个命令执行的时间戳。但是，你可以通过设置 HISTTIMEFORMAT 环境变量来显示时间戳。例如：\n1 export HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; 这将在历史记录中显示日期和时间。\n### 3. 清空历史记录\n要清空 Bash shell 中的命令历史记录，可以使用 history -c 命令：\n1 history -c 这将删除当前会话中的所有历史记录。要永久删除历史记录，可以编辑或者删除历史记录文件，通常是 ~/.bash_history。\n### 4. 重复执行历史命令\n要重复执行历史记录中的命令，可以使用 ! 后跟命令的历史编号。例如，要重新执行历史记录中编号为 123 的命令：\n1 !123 你还可以使用 !! 来重复执行上一条命令。\n### 5. 控制历史记录\n你可以使用 HISTSIZE 和 HISTFILESIZE 环境变量来控制历史记录的大小。HISTSIZE 定义了保存在内存中的历史记录数目，HISTFILESIZE 定义了保存在历史记录文件中的历史记录数目。如果 HISTFILESIZE 比 HISTSIZE 小，那么当 shell 退出时，会将 HISTSIZE 指定的数量的命令写入历史记录文件中。\nLinux终端打印如何删除指定列或多列 要删除Linux终端中的指定列或多列，你可以使用一些命令和技巧。以下是几种方法：\n使用awk命令删除指定列： 如果你知道要删除的列的位置，你可以使用awk命令来实现。例如，如果要删除第3列，你可以使用以下命令： 1 awk \u0026#39;{$3=\u0026#34;\u0026#34;; print}\u0026#39; input_file 这将从input_file中删除第3列并输出结果。你还可以使用逗号分隔多个列的位置，例如：\n1 awk \u0026#39;{$2=\u0026#34;\u0026#34;; $4=\u0026#34;\u0026#34;; print}\u0026#39; input_file 这将删除第2列和第4列，并输出结果。\n使用cut命令删除指定列： 如果你知道要删除的列的位置，你也可以使用cut命令。例如，如果要删除第3列，你可以使用以下命令： 1 cut -d\u0026#39; \u0026#39; -f1,2,4- input_file 这将从input_file中删除第3列并输出结果。你可以通过指定列的位置来删除多列。\n这个命令是用来在Linux终端中删除指定列的。让我们一步步解析：\ncut：这是用于剪切文本的命令。 -d\u0026#39; \u0026#39;：这个选项指定了字段的分隔符。在这里，-d 后跟着一个空格 (\u0026#39; \u0026#39;) 表示字段是以空格作为分隔符的。 -f1,2,4-：这个选项指定了要保留的字段。在这里，-f 表示字段，后面跟着的 1,2,4- 表示要保留第1、第2列以及第4列及之后的所有列。 input_file：这是要进行操作的输入文件的名称。 因此，整个命令的含义是从input_file中剪切出第1、第2、第4列及之后的所有列，并将结果输出到终端。\n使用sed命令删除指定列： sed命令可以用来对文本进行替换和删除操作。例如，如果要删除第3列，你可以使用以下命令： 1 sed \u0026#39;s/\\([^ ]* *\\)\\{2\\}[^ ]* *//\u0026#39; input_file 这将从input_file中删除第3列并输出结果。你可以通过调整正则表达式来删除多列。\nshell排序，强大的sort 在Shell中，sort命令是一个强大的工具，用于对文本文件进行排序。它可以按照字母顺序或数字顺序对文件的行进行排序，并且可以根据需要进行自定义配置。\n以下是一些常见用法：\n按字母顺序排序： 1 sort filename 按数字顺序排序： 1 sort -n filename 逆序排序： 1 sort -r filename 按照指定列排序： 1 sort -k \u0026lt;column_number\u0026gt; filename 去重并排序： 1 sort -u filename 将结果输出到新文件： 1 sort input_filename \u0026gt; output_filename 这些只是 sort 命令的一些基本用法示例。根据你的需求，你可以结合使用不同的选项来实现各种排序操作。\n当前目录下多文件根据排序顺序一对一对的依次进行比较 1 mapfile -t files \u0026lt; \u0026lt;(ls); for((i=0; i\u0026lt;7; i++)); do diff \u0026#34;${files[i]}\u0026#34; \u0026#34;${files[i+1]}\u0026#34;; done 从当前目前进入到一个子目录过滤文件字符串并返回到当前目录 单次手动操作 1 cd $(ls | awk \u0026#39;NR==15\u0026#39;); find ./ -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs grep --color=always -n \u0026#34;keyword\u0026#34;; cd ../ 多次自动操作 1 for ((i=15; i\u0026lt;21; i++)); do cd $(ls | awk \u0026#34;NR==${i}\u0026#34;); find ./ -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs grep --color=always -n \u0026#34;keyword\u0026#34;; cd ../; done Linux下gh批量下载github某仓库中Release所有版本文件 工具官网 https://github.com/cli/cli\n查看指定仓库中的所有版本 1 mapfile -t file_version \u0026lt; \u0026lt;(gh release list -R 201853910/VMwareWorkstation | awk \u0026#39;{$NF=\u0026#34;\u0026#34;; print}\u0026#39; | sed -e \u0026#39;s/Latest//g\u0026#39; | awk \u0026#39;{print $NF}\u0026#39;); for i in \u0026#34;${file_version[@]}\u0026#34;; do echo \u0026#34;${i}\u0026#34;; sleep 1; done 下载所有版本的Release 1 mapfile -t file_version \u0026lt; \u0026lt;(gh release list -R 201853910/VMwareWorkstation | awk \u0026#39;{$NF=\u0026#34;\u0026#34;; print}\u0026#39; | sed -e \u0026#39;s/Latest//g\u0026#39; | awk \u0026#39;{print $NF}\u0026#39;); for i in \u0026#34;${file_version[@]}\u0026#34;; do gh release download \u0026#34;${i}\u0026#34; -D Vmwares/ -R 201853910/VMwareWorkstation; done 参考链接 使用cli批量下载GitHub仓库中所有的release\n从文件列表中查找指定关键词脚本 1 clear \u0026amp;\u0026amp; mapfile -t dts \u0026lt; \u0026lt;(cat temp.txt); for i in \u0026#34;${dts[@]}\u0026#34;; do echo \u0026#34;${i}:\u0026#34;; grep --color=always -ain \u0026#34;hdmi\u0026#34; \u0026#34;${i}\u0026#34;; echo -e \u0026#34;\\e[32m==========================================================================================\\e[0m\u0026#34;; done Linux 下计算圆周率 1 time echo \u0026#34;scale=5000; 4*a(1)\u0026#34; | bc -l -q time命令：指令执行时所消耗的时间\nbc -l：设置标准数学库\nbc -q：显示正常的GNU bc环境信息\n查找文件关键词并替换 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash # 将var2变量值替换掉var1变量值 var1=\u0026#34;10.8.98.80\u0026#34;\t# 待被替换的关键词 var2=\u0026#34;192.168.0.64\u0026#34;\t# 作为替换的关键词 mapfile -t files \u0026lt; \u0026lt;(find ./ -name \u0026#34;*.cpp\u0026#34; | xargs readlink -f | xargs grep -l \u0026#34;${var1}\u0026#34;) # 查找包含var1变量值的文件存入数组 fileNum=${#files[@]} for ((i = 0; i \u0026lt; fileNum; i++)); do sed -i \u0026#34;s/${var1}/${var2}/g\u0026#34; \u0026#34;${files[i]}\u0026#34; # 将var1替换为var2 done 输出累加数+时间戳，按回车继续 1 count=0; while true; do ((count++)); echo -en \u0026#34;\\r\\n$(date)-----\\e[31m${count}\\e[0m\u0026#34;; read -p \u0026#34;\u0026#34; continue; done 要仅查找 driver 目录下的 Pciedma_DLL.h 文件，可以使用以下 find 命令： 1 find *SGDMA* -type d -name \u0026#34;driver\u0026#34; -exec find {} -name \u0026#34;Pciedma_DLL.h\u0026#34; \\; 这个命令首先在包含 SGDMA 的目录下找到所有名为 driver 的目录，然后在这些目录中查找 Pciedma_DLL.h 文件。\nLinux tar命令解压时提示时间戳异常的处理办法 方法一 1 ta --touch -zxvf test.tar.gz 方法二 1 tar -m -zxvf test.tar.gz -m或–modification-time 还原文件时，不变更文件的更改时间。\n参考链接 Linux tar命令解压时提示时间戳异常的处理办法\nLinux终端批量造数 Linux终端批量造十进制数 1 clear \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; for ((i = 0; i \u0026lt; 65536; i++)); do echo -en \u0026#34;${i} \u0026#34;; done Linux终端批量造十六进制数 %x：小写\n%X：大写\n0x%04X：十六位大写，4*4=16\n0x%08X：三十二位大写，8*4=32\n0x%016X：六十四位大写，16*4=64，依次类推\nLinux终端批量造十六进制数-16位 1 clear \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; for ((i = 0; i \u0026lt; 65536; i++)); do printf \u0026#34;0x%04X \u0026#34; $i; done Linux终端批量造十六进制数-32位 1 clear \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; for ((i = 0; i \u0026lt; 65536; i++)); do printf \u0026#34;0x%08X \u0026#34; $i; done Linux终端批量造十六进制数-64位 1 clear \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; for ((i = 0; i \u0026lt; 65536; i++)); do printf \u0026#34;0x%016X \u0026#34; $i; done 在Windows的文件资源管理器的地址栏使用mintty命令或者当前文件夹路径 1 mintty -e /bin/bash -c \u0026#34;pwd | clip\u0026#34; 或者\n1 D:\\cygwin\\bin\\mintty.exe -e /bin/bash -c \u0026#34;pwd | clip\u0026#34; 查找文件并依次进行比较 1 mapfile -t files \u0026lt; \u0026lt;(find ./ -name \u0026#34;M6678_SRIO.h\u0026#34;); for ((i = 0; i \u0026lt; ${#files[@]}; i++)); do diff \u0026#34;${files[i]}\u0026#34; \u0026#34;${files[i+1]}\u0026#34;; done 将连续的两个字节以一个字节单位倒序处理，并计算对应的10进制结果 1 input=$(xxd -l 4 output_0001.bmp | awk \u0026#39;{print $3}\u0026#39; | sed -e \u0026#39;s/../\u0026amp;\\ /g\u0026#39; | awk \u0026#39;{print $2$1}\u0026#39; | tr \u0026#39;[a-z]\u0026#39; \u0026#39;[A-Z]\u0026#39;); echo \u0026#34;obase=10; ibase=16; ${input}\u0026#34; | bc 命令拆解 这个命令的作用是从 output_0001.bmp 文件中提取前 4 字节的数据，将其转换为十进制数。让我们逐步拆解它：\n提取数据： 1 xxd -l 4 output_0001.bmp xxd 工具将 output_0001.bmp 文件的前 4 字节以十六进制格式输出。每行输出包括地址、十六进制数据和 ASCII 表示。\n提取十六进制数据： 1 awk \u0026#39;{print $3}\u0026#39; awk 从 xxd 的输出中提取第三列，这一列包含了十六进制数据。\n格式化数据： 1 sed -e \u0026#39;s/../\u0026amp;\\ /g\u0026#39; sed 用于在每两个字符之间插入一个空格，使其变成以空格分隔的十六进制对。\n重排数据： 1 awk \u0026#39;{print $2$1}\u0026#39; awk 将第一列和第二列的十六进制对连接起来，通常这一步用来调整字节顺序。\n转换为大写： 1 tr \u0026#39;[a-z]\u0026#39; \u0026#39;[A-Z]\u0026#39; tr 将十六进制数中的小写字母转换为大写字母。\n计算十进制值： 1 echo \u0026#34;obase=10; ibase=16; ${input}\u0026#34; | bc bc 用于将处理后的十六进制字符串转换为十进制值。obase=10 设置输出为十进制，ibase=16 设置输入为十六进制。\n总结： 这个命令将 BMP 文件的前 4 字节提取、格式化并转化为十进制数。\n参考链接 Linux终端中的字符串使用总结（截取，切片，查找替换，转换，变量赋值等）\nshell分隔字符串插入空格\n删除文件指定字节二进制数据 1 output=$(input=$(xxd -l 4 output_0001.bmp | awk \u0026#39;{print $3}\u0026#39; | sed -e \u0026#39;s/../\u0026amp;\\ /g\u0026#39; | awk \u0026#39;{print $2$1}\u0026#39; | tr \u0026#39;[a-z]\u0026#39; \u0026#39;[A-Z]\u0026#39;); echo \u0026#34;obase=10; ibase=16; ${input}\u0026#34; | bc); dd if=output_0001.bmp of=newBmp.bmp skip=\u0026#34;${output}\u0026#34; bs=1024 将二进制文件16进制输出的情况下每两个字符后添加一个0并输出到另一个文件 1 xxd -p output_0001.bmp | sed \u0026#39;s/../\u0026amp;0/g\u0026#39; \u0026gt; output.bmp 查找指定类型文件中的内容返回结果，并且会自动去除第一列的空格 由于结果并不是在第一列显示，因此让第一列为空，再把空格去掉\n1 echo \u0026#34;使用示例：$(find ./ -name \u0026#34;*.cpp\u0026#34; | xargs grep --color=always \u0026#34;$1\u0026#34; \u0026#34;$2\u0026#34; | awk \u0026#39;{$1=\u0026#34;\u0026#34;; print $0}\u0026#39; | sed -e \u0026#39;s/^[ ]*//g\u0026#39; | sed -e \u0026#39;s/[ ]*$//g\u0026#39;)\u0026#34; 显示文件最后修改时间 方式一 1 stat ts1.c 方式二 1 date -Ins -r ts1.c | tr \u0026#39;,\u0026#39; \u0026#39;.\u0026#39; visual studio的dll相关文件拷贝到Qt工程的driver目录技巧 1 mapfile -t files \u0026lt; \u0026lt;(find ./ -name \u0026#34;*DLL.h\u0026#34; -o -name \u0026#34;*.x64.dll\u0026#34; -o -name \u0026#34;*.x64.lib\u0026#34;); for i in \u0026#34;${files[@]}\u0026#34;; do cp -vf \u0026#34;${i}\u0026#34; ../03_Demo/PCIE_SGDMA-4CH_HTFD/driver/; done 命令行的shell脚本练习：read与case组合 1 read key; case \u0026#34;${key}\u0026#34; in *) echo \u0026#34;${key}\u0026#34;;;esac 执行结果：\n1 2 3 $ read key; case \u0026#34;${key}\u0026#34; in *) echo \u0026#34;${key}\u0026#34;;;esac test test 运行后输入test并回车，然后将输入结果打印出来。\nshell脚本将case语句放在for循环中 - ChatGPT 在 Shell 脚本中，可以将 case 语句放入 for 循环中，以便对每个循环的项进行不同的处理。case 语句用于匹配某个条件，并根据条件执行相应的操作，结合 for 循环可以对多个元素做类似的处理。\n以下是一个基本的例子，展示如何在 for 循环中使用 case 语句：\n示例：使用 case 语句和 for 循环 假设你有一组文件名，你想根据文件扩展名进行不同的处理，可以在 for 循环中使用 case 语句来分类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash # 假设有一组文件名 files=(\u0026#34;file1.txt\u0026#34; \u0026#34;file2.jpg\u0026#34; \u0026#34;file3.png\u0026#34; \u0026#34;file4.txt\u0026#34; \u0026#34;file5.doc\u0026#34;) # 遍历文件名列表 for file in \u0026#34;${files[@]}\u0026#34;; do # 提取文件的扩展名 extension=\u0026#34;${file##*.}\u0026#34; # 使用 case 语句处理不同的扩展名 case \u0026#34;$extension\u0026#34; in txt) echo \u0026#34;$file 是一个文本文件\u0026#34; ;; jpg|png) echo \u0026#34;$file 是一个图片文件\u0026#34; ;; doc) echo \u0026#34;$file 是一个文档文件\u0026#34; ;; *) echo \u0026#34;$file 是其他类型的文件\u0026#34; ;; esac done 说明： files=(\u0026#34;file1.txt\u0026#34; \u0026#34;file2.jpg\u0026#34; \u0026#34;file3.png\u0026#34; \u0026#34;file4.txt\u0026#34; \u0026#34;file5.doc\u0026#34;)：这是一个包含文件名的数组。 for file in \u0026#34;${files[@]}\u0026#34;：遍历数组中的每个文件名。 extension=\u0026#34;${file##*.}\u0026#34;：通过 Shell 参数扩展提取文件的扩展名（即最后一个点 . 后面的部分）。 case \u0026#34;$extension\u0026#34; in … esac：根据文件扩展名做不同的处理。| 用于在 case 语句中匹配多个选项（例如 jpg|png）。 运行结果： 1 2 3 4 5 file1.txt 是一个文本文件 file2.jpg 是一个图片文件 file3.png 是一个图片文件 file4.txt 是一个文本文件 file5.doc 是一个文档文件 关键点： for 循环遍历一个列表或数组，并且对每个元素执行循环体中的操作。 case 语句用于根据不同条件执行不同的代码块。在这个例子中，判断的是文件的扩展名。 是 case 语句中的默认匹配模式，表示所有未匹配的情况。 这个示例展示了如何结合 for 循环和 case 语句来处理一系列数据，并根据不同的条件执行相应的操作。在 Shell 脚本中，这种结构非常常见且有效，尤其适用于分类处理和不同条件下的动作。\ncase语句+shift偏移参数 脚本代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 case $1 in param1) shift # 移除第一个参数，$1 变成了原来的 $2 for i in \u0026#34;$@\u0026#34;; do # 循环处理剩余参数 case $i in 2) echo \u0026#34;2\u0026#34; ;;\t3) echo \u0026#34;3\u0026#34; ;; ,*) # 默认处理未匹配的情况 echo \u0026#34;Unrecognized input: $i\u0026#34; ;; esac done ;; param2) shift # 移除第一个参数，$1 变成了原来的 $2 for i in \u0026#34;$@\u0026#34;; do # 循环处理剩余参数 case $i in 2) echo \u0026#34;3\u0026#34; ;;\t3) echo \u0026#34;4\u0026#34; ;; ,*) # 默认处理未匹配的情况 echo \u0026#34;Unrecognized input: $i\u0026#34; ;; esac done ;; ,*) # 处理未匹配的主参数 echo \u0026#34;Invalid command: $1\u0026#34; ;; esac 运行示例 1 2 3 $ ./ts2.sh param1 2 3 2 3 1 2 3 $ ./ts2.sh param2 2 3 3 4 sed命令在包含指定关键词的行首与包含指定关键词的下一行的行首添加\u0026#39;//\u0026#39; 示例命令 1 sed \u0026#39;/KEYWORD/{s/^/\\/\\//;n;s/^/\\/\\//}\u0026#39; input.txt 解释： /KEYWORD/：查找包含 KEYWORD 的行。 {…}：表示一个代码块，包含多个操作。 s/^/\\/\\//：在匹配的行行首添加 //。这里的 ^ 是行首的符号。 n：n 命令让 sed 跳到下一行进行处理（并打印出该行）。 再次执行 s/^/\\/\\//：在下一行的行首也添加 //。 解决使用脚本创建Makefile内容不对齐问题 使用echo命令，要加入-e选项开启转义，然后在需要加入制表符的地方插入\\t，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { echo -e \u0026#39;DRIVER_NAME = xilinx-axidma\u0026#39; echo -e \u0026#39;$(DRIVER_NAME)-objs = axi_dma.o axidma_chrdev.o axidma_dma.o axidma_of.o\u0026#39; echo -e \u0026#39;obj-m := $(DRIVER_NAME).o\u0026#39; echo -e \u0026#39;\u0026#39; echo -e \u0026#39;SRC := $(shell pwd)\u0026#39; echo -e \u0026#39;\u0026#39; echo -e \u0026#39;all:\u0026#39; echo -e \u0026#39;\\t$(MAKE) -C $(KERNEL_SRC) M=$(SRC)\u0026#39; echo -e \u0026#39;\u0026#39; echo -e \u0026#39;modules_install:\u0026#39; echo -e \u0026#39;\\t$(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install\u0026#39; echo -e \u0026#39;\u0026#39; echo -e \u0026#39;clean:\u0026#39; echo -e \u0026#39;\\trm -f *.o *~ core .depend .*.cmd *.ko *.mod.c\u0026#39; echo -e \u0026#39;\\trm -f Module.markers Module.symvers modules.order\u0026#39; echo -e \u0026#39;\\trm -rf .tmp_versions Modules.symvers\u0026#39; } \u0026gt; ./project-spec/meta-user/recipes-modules/xilinx-axidma/files/Makefile scp使用技巧 1 2 3 4 # 删除指定IP连接记录并上传本地公钥到远端 sed -i \u0026#39;/192.168.1.10/d\u0026#39; ~/.ssh/known_hosts; ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.10 # 上传应用程序 scp test_axi_dma_v1/Debug/test_axi_dma_v1.elf root@192.168.1.10:/run/media/mmcblk0p1 使用Petalinux实现ZYNQ的linux程序开发（实现简单的socket通信程序）\nsed使用技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 查看有多少个pcie控制器 sed -i \u0026#39;/^[[:space:]]*\\/\\*/d\u0026#39; product/hi1910B-pcie-rc-M150-B50.dtsi sed -i \u0026#39;/^[[:space:]]*\\*\\//d\u0026#39; product/hi1910B-pcie-rc-M150-B50.dtsi mapfile -t array1 \u0026lt; \u0026lt;(grep -oE \u0026#34;pcie@.*{\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi); for ((i = 0; i \u0026lt; ${#array1[@]}; i++)); do echo \u0026#34;${array1[i]}\u0026#34;; done # 添加 ^[[:space:]]* 只匹配行首的注释 str1=\u0026#34;/*\u0026#34; str2=\u0026#34;*/\u0026#34; sed -i \u0026#34;/${array1[2]}/i\\\\${str1}\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi mapfile -t array2 \u0026lt; \u0026lt;(grep -noE \u0026#34;};\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39;); for ((i = 0; i \u0026lt; ${#array2[@]}; i++)); do echo \u0026#34;${array2[i]}\u0026#34;; done sed -i \u0026#34;${array2[2]} a ${str2}\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi sed -i \u0026#34;/${array1[3]}/i\\\\${str1}\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi mapfile -t array2 \u0026lt; \u0026lt;(grep -noE \u0026#34;};\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39;); for ((i = 0; i \u0026lt; ${#array2[@]}; i++)); do echo \u0026#34;${array2[i]}\u0026#34;; done sed -i \u0026#34;${array2[3]} a ${str2}\u0026#34; product/hi1910B-pcie-rc-M150-B50.dtsi 这段脚本的主要功能是修改设备树文件(hi1910B-pcie-rc-M150-B50.dtsi)，具体操作包括删除现有注释、查找PCIe控制器定义、并在特定PCIe控制器前后添加注释标记\nBash 命令行选项解析 1 2 3 4 5 6 7 8 9 10 11 while getopts \u0026#34;hv\u0026#34; opt; do case \u0026#34;$opt\u0026#34; in h) echo \u0026#34;h\u0026#34; ;; v) echo \u0026#34;v\u0026#34; ;;\tesac done shift \u0026#34;$((OPTIND - 1))\u0026#34; 解析：Deepseek 这个脚本是一个典型的 Bash shell 脚本片段，用于处理命令行参数。下面我来逐行解析它的功能：\n1. while getopts \u0026#34;hv\u0026#34; opt; do getopts 是 Bash 内置的命令行选项解析器 \u0026#34;hv\u0026#34; 定义了脚本接受的选项：\n-h 是一个选项 -v 是另一个选项 opt 是变量，用于存储当前处理的选项字符 这个 while 循环会遍历所有提供的命令行选项 2. case \u0026#34;$opt\u0026#34; in 开始一个 case 语句，根据当前选项 $opt 的值执行不同的操作 3. h) 当选项是 -h 时的处理分支 echo \u0026#34;h\u0026#34;：简单地输出字母 \u0026#34;h\u0026#34; ;; 表示这个 case 分支的结束 4. v) 当选项是 -v 时的处理分支 echo \u0026#34;v\u0026#34;：简单地输出字母 \u0026#34;v\u0026#34; ;; 表示这个 case 分支的结束 5. esac 和 done esac 结束 case 语句 done 结束 while 循环 6. shift \u0026#34;$((OPTIND - 1))\u0026#34; OPTIND 是 getopts 维护的变量，表示下一个要处理的参数的索引 $((OPTIND - 1)) 计算需要移除的已处理选项数量 shift 命令将位置参数向左移动，移除已经处理过的选项 这样处理之后，$1 将指向第一个非选项参数 示例用法： 如果运行脚本时输入 script.sh -h -v：\n会输出： h v 如果运行 script.sh -h file.txt：\n会输出 h 然后 file.txt 会成为第一个位置参数（$1） 总结： 这个脚本处理两个选项：\n-h：输出 \u0026#34;h\u0026#34; -v：输出 \u0026#34;v\u0026#34; 然后使用 shift 调整位置参数，使得后续代码可以方便地处理非选项参数。\n这是一个基础的命令行选项处理框架，实际应用中通常会在各个 case 分支中执行更复杂的操作，而不仅仅是 echo。\n参考链接 ascend-devkit/src/image-builder/src/minimal/base.sh\n对比文件是否一致 pcie4通道测试，测试回环，会产生4个文件，文件是以通道号命名的，4个文件存放在以时间戳命名的目录中，将原始文件与以时间戳命名的目录中的4个文件对比是否一致，假如多次进行回环测试，会产生多个以时间戳命名的目录，那个每次比对文件是否一致就会比较麻烦，因为每次都要手动指定以时间戳命名的目录，为了方便，我简单写了个脚本。2025开头的是以时间戳命名的目录，~/00_zdk/TestFiles/111asdfasdf.dat是原始文件，原始文件需手动指定。\n1 nr=1; dir=$(find ./ -name \u0026#34;2025*\u0026#34; -type d | sort | awk -v line=\u0026#34;$nr\u0026#34; \u0026#39;NR==line{print}\u0026#39;); echo $dir; for i in \u0026#34;$dir\u0026#34;/*.dat; do diff ${i} ~/00_zdk/TestFiles/111asdfasdf.dat; done 为wget命令设置代理 端口号根据实际代理进行配置，以下命令仅供参考：\n1 wget -c -e \u0026#34;https_proxy=https://127.0.0.1:8087\u0026#34; $file 参考链接 为wget命令设置代理\nbash shell生成一个指定范围内的随机数： 1 2 3 4 5 6 7 8 # 生成 0-32767 之间的随机数 echo $RANDOM # 生成指定范围的随机数（例如：1-100） echo $(( RANDOM % 100 + 1 )) # 生成 50-150 之间的随机数 echo $(( RANDOM % 101 + 50 )) ","date":"2025-06-15T12:28:46+08:00","permalink":"https://ynhugo.github.io/p/shell%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/","title":"shell环境操作技巧"},{"content":" QEMU启动arm-Linux内核+edu 脚本内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 # 参考链接 # [[https://www.cnblogs.com/mrlayfolk/p/18231986][QEMU EDU设备模拟PCI设备驱动编写]] # [[https://www.cnblogs.com/from-zero/p/14327440.html][QEMU源码编译安装【教程】]] #!/bin/bash buildroot_version=\u0026#34;2022.02.2\u0026#34; qemu_version=\u0026#34;4.1.1\u0026#34; work_dir_name=\u0026#34;qemu-arm-linux\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; # if [ -d \u0026#34;${work_dir}\u0026#34; ]; then sudo rm -rf ${work_dir}; fi mkdir -p ${work_dir} # 安装依赖文件 sudo apt install -y make gcc g++ libpixman-1-dev gcc-arm-linux-gnueabi python-dev qemu qemu-kvm libvirt-bin bridge-utils virt-manager uml-utilities bridge-utils u-boot-tools ed tftp-hpa tftpd-hpa xinetd nfs-kernel-server device-tree-compiler flex bison libncurses5-dev libelf-dev libssl-dev qemu-system-x86 git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev pkg-config libsdl2-dev libgtk-3-dev ninja-build python3-pyparsing # buildroot编译 cd ${work_dir}; if [ ! -f \u0026#34;buildroot-\u0026#34;${buildroot_version}\u0026#34;.tar.gz\u0026#34; ]; then wget https://www.buildroot.org/downloads/buildroot-\u0026#34;${buildroot_version}\u0026#34;.tar.gz\tfi if [ ! -d \u0026#34;buildroot-\\\u0026#34;${buildroot_version}\\\u0026#34;\u0026#34; ]; then tar xf buildroot-\u0026#34;${buildroot_version}\u0026#34;.tar.gz fi cd buildroot-\u0026#34;${buildroot_version}\u0026#34; make qemu_aarch64_virt_defconfig make -j$(nproc) # QEMU编译和安装 cd ${work_dir}; if [ ! -f \u0026#34;qemu-\u0026#34;${qemu_version}\u0026#34;.tar.xz\u0026#34; ]; then wget https://download.qemu.org/qemu-\u0026#34;${qemu_version}\u0026#34;.tar.xz fi if [ ! -d \u0026#34;qemu-\\\u0026#34;${qemu_version}\\\u0026#34;\u0026#34; ]; then tar xf qemu-\u0026#34;${qemu_version}\u0026#34;.tar.xz\tfi cd qemu-\u0026#34;${qemu_version}\u0026#34; ./configure --prefix=$PWD --target-list=aarch64-softmmu --enable-debug --enable-sdl --enable-kvm --enable-tools --disable-curl sudo make install -j$(nproc) # 拷贝文件 cd ${work_dir} # 新建目录 mkdir -p release/qemu-arm64/bin # 拷贝QEUM编译出的文件到新建目录 cp -a qemu-4.1.1/libexec/ release/qemu-arm64/ -rf cp -a qemu-4.1.1/share/ release/qemu-arm64/ -rf # 拷贝buildroot编译的文件到新建目录 cp -a buildroot-2022.02.2/output/images/* release/qemu-arm64/bin -ra # 修改启动脚本, 然后运行 cd release/qemu-arm64/bin cp -a start-qemu.sh start-qemu-bak.sh echo \u0026#39;qemu-system-aarch64 -M virt -cpu cortex-a53 -nographic -smp 1 -kernel Image -append \u0026#34;rootwait root=/dev/vda console=ttyAMA0\u0026#34; -netdev user,id=eth0 -device virtio-net-device,netdev=eth0 -drive file=rootfs.ext4,if=none,format=raw,id=hd0 -device virtio-blk-device,drive=hd0 -nographic -device edu\u0026#39; \u0026gt; start-qemu.sh sudo ./start-qemu.sh 参考链接 QEMU EDU设备模拟PCI设备驱动编写\nQEMU源码编译安装【教程】\n使用qemu搭建arm嵌入式linux开发环境\n","date":"2025-06-02T03:40:02.73+08:00","permalink":"https://ynhugo.github.io/p/qemu%E5%90%AF%E5%8A%A8arm-linux%E5%86%85%E6%A0%B8-edu/","title":"QEMU启动arm-Linux内核+edu"},{"content":" 华为昇腾开发套件Ubuntu22.04环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sudo groupadd HwHiAiUser sudo useradd -g HwHiAiUser -d /home/HwHiAiUser -m HwHiAiUser -s /bin/bash sudo passwd HwHiAiUser usermod -a -G sudo HwHiAiUser sudo userdel -rf hwhiaiuser # su HwHiAiUser reboot su - root echo \u0026#39;HwHiAiUser ALL=(ALL) ALL\u0026#39; \u0026gt;\u0026gt; /etc/sudoers exit sudo apt update sudo apt install -y net-tools git emacs openssh-server vim fcitx5 fcitx5-* # 确保语言安装了中文简体并且中设置默认输入法为fcitx，然后重启 reboot 参考链接 创建运行用户\n如何让HwHiAiUser用户sudo —-小白入门知识汇总4\nLinux 完全删除用户\nDebian11.5和Ubuntu22.04安装fcitx5中文输入法(五笔拼音)\n","date":"2025-04-28T19:21:38.11+08:00","permalink":"https://ynhugo.github.io/p/%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BE%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6ubuntu22.04%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"华为昇腾开发套件Ubuntu22.04环境配置"},{"content":" ubuntu通过配置grub文件修改启动菜单启动顺序和修改默认启动内核 ubuntu设置启动菜单默认启动项 计算您的启动菜单条目。 无需记住所有引导条目的完整图块，您可以对它们进行计数并使用该数字来设置默认引导条目。\n要预览菜单，请按 Ctrl+Alt+T 打开终端窗口，然后运行以下命令来安装 grub-emu 工具并使用它模拟启动菜单：\n首先，运行命令安装 grub-emu：\n1 sudo apt install grub-emu 然后，运行 grub-emu 以启动一个带有系统启动菜单的窗口：\n1 sudo grub-emu 计数从数字 0 开始。第一个条目是 0，第二个条目是 1，第三个条目是 2 …\n如果你想设置一个子菜单项来默认启动另一个内核，例如第二主菜单选项（在我的例子中为Ubuntu的高级选项，计数1）和第三 子菜单项（例如，Ubuntu with Linux Kernel 6.x.x…，计数 2），则目标编号为 1\u0026gt;2。\n编辑默认操作系统/内核的配置文件 接下来，打开终端 (Ctrl+Alt+T) 并运行命令来编辑 grub 配置文件：\n1 sudo emacs /etc/default/grub 并且，当文件打开时，通过将数字 0（表示第一个）替换为上一步中获得的相应数字来设置 GRUB_DEFAULT=”0″。\n提示：您可以设置 GRUB_DEFAULT=saved 加上新行 GRUB_SAVEDEFAULT=true ，这样它会记住上次的启动项，并在下次启动时将其设置为默认值。\n1 2 GRUB_DEFAULT=saved GRUB_SAVEDEFAULT=true 最后，保存文件并退出。并且，运行以下命令来更新更改。\n1 sudo update-grub 更改系统内核版本 查看都有那些内核 1 cat /boot/grub/grub.cfg | grep menuentry 查看 /boot/grub/grub.cfg 中的内容 menuentry(主菜单）：是系统每次启动默认的kernel，对应 /etc/default/grub 中 GRUB_DEFAULT=0\nsubmenu(子菜单）：包含系统中所有的启动kernel。\n打开/boot/grub/grub.cfg文件，对应ubuntu有menuentry和submenu，在submenu中还有数个menuentry，将submenu中想要作为默认启动的内核版本移动到submenu中的最靠前的位置。由于我们是直接修改/boot/grub/grub.cfg文件，直接修改grub.cfg就不要执行update了。 参考链接 配置 Ubuntu 24.04 中默认引导的操作系统或内核\nUbuntu 修改默认启动内核（kernel） - zhuang6 - 博客园\nUbuntu修改grub和grub.cfg文件不起作用_ubuntu grub.cfg-CSDN博客\nubuntu修改启动项等待时间、修改启动项顺序、更改启动内核_ubuntu20.04修改启动顺序-CSDN博客\n【 GRUB 】修改启动列表项，自定义列表项内容，添加自定义GRUB主题_修改 grub-CSDN博客\nUbuntu显示grub启动菜单以及修改默认启动项\n解决双硬盘下一个windows两个linux操作系统的grub引导问题_多ubuntu grub 多硬盘-CSDN博客\n","date":"2025-04-28T17:05:48.95+08:00","permalink":"https://ynhugo.github.io/p/ubuntu%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AEgrub%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E8%8F%9C%E5%8D%95%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F/","title":"ubuntu通过配置grub文件修改启动菜单启动顺序"},{"content":" ubuntu账户添加sudo权限 解决方案 方法1：使用已有sudo权限的账户 使用系统中已有的具有 sudo 权限的账户登录\n然后执行：sudo adduser username sudo\n方法2：直接修改sudoers文件 使用root账户登录（如果有）\n编辑sudoers文件：visudo\n添加一行：username ALL=(ALL:ALL) ALL\n保存退出\n方法3：单用户模式修改（需要物理访问） 重启系统，在GRUB菜单中选择恢复模式\n进入root shell\n执行：adduser username sudo\n重启系统\n方法4：使用su切换到root（如果知道root密码） 执行：su -\n输入root密码\n执行：adduser username sudo\n注意事项 修改sudoers文件时要特别小心，错误的编辑可能导致系统无法使用sudo\n建议优先使用方法1，即使用已有sudo权限的账户来添加新权限\n如果没有其他sudo用户，可能需要联系系统管理员或使用物理访问权限来解决问题\n参考链接 [已解决]user is not in the sudoers file. This incident will be reported.(简单不容易出错的方式)\n","date":"2025-04-22T14:00:26.64+08:00","permalink":"https://ynhugo.github.io/p/ubuntu%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0sudo%E6%9D%83%E9%99%90/","title":"ubuntu账户添加sudo权限"},{"content":" PlantUML绘图 PlantUML的安装和配置 我们首先来安装和配置 plantuml ：\n需要提前通过 brew install plantuml 安装 plantuml 这个软件包 配置Emacs和Org mode支持 plantuml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 (use-package plantuml-mode :ensure t :mode (\u0026#34;\\\\.plantuml\\\\\u0026#39;\u0026#34; . plantuml-mode) :init ;; enable plantuml babel support ;; (add-to-list \u0026#39;org-src-lang-modes \u0026#39;(\u0026#34;plantuml\u0026#34; . plantuml)) (org-babel-do-load-languages \u0026#39;org-babel-load-languages (append org-babel-load-languages \u0026#39;((plantuml . t)))) :config (setq org-plantuml-exec-mode \u0026#39;plantuml) (setq org-plantuml-executable-path \u0026#34;plantuml\u0026#34;) (setq plantuml-executable-path \u0026#34;plantuml\u0026#34;) (setq plantuml-default-exec-mode \u0026#39;executable) ;; set default babel header arguments (setq org-babel-default-header-args:plantuml \u0026#39;((:exports . \u0026#34;results\u0026#34;) (:results . \u0026#34;file\u0026#34;) )) ) 我们安装配置完 plantuml 后，可以在org文件里，输入下面的代码块，然后光标移动到代码块内部，按下 C-c C-c 执行代码块， plantuml 就会自动解析文本执行，并生成你想要的图片啦：\n参考链接 面向产品经理的Emacs教程：15. 在Org mode里用纯文本画图\n活动图\n","date":"2025-04-16T18:59:46.55+08:00","permalink":"https://ynhugo.github.io/p/plantuml%E7%BB%98%E5%9B%BE/","title":"PlantUML绘图"},{"content":" petalinux2018.3实现QSPI跑操作系统 -\u0026gt;Subsystem AUTO Hardware Settings -\u0026gt;Flash Settings 1 2 3 4 5 6 7 8 9 10 11 12 *** partition 0 *** (boot) name (0x300000) size *** partition 1 *** (bootenv) name (0x10000) size *** partition 2 *** (kernel) name (0xD00000) size *** partition 3 *** (bootscr) name (0x10000) size -\u0026gt;Subsystem AUTO Hardware Settings -\u0026gt;Flash Settings -\u0026gt;Advanced bootable images storage Settings 1 2 3 4 5 boot image settings -\u0026gt;image storage media (primary flash) u-boot env paratition settings -\u0026gt;image storage media (primary flash)\tkernel image settings -\u0026gt;image storage media (primary flash) jffs2 rootfs image settings -\u0026gt;image storage media (primary flash)\tdtb image settings -\u0026gt;image storage media (from boot image) Image Packaging Configuration 1 Root filesystem type (INITRAMFS) petalinux-build 1 petalinux-build petalinux-package 1 petalinux-package --boot --format BIN --fsbl --fpga --u-boot --kernel --force copy script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 pc_path=\u0026#34;/mnt/hgfs/00_zdk/vivado/TES801/finish/version_8/Vivado_SL/TES801CH569_ETH_F0/prj/top.sdk\u0026#34; pc_image_path=\u0026#34;$pc_path/petalinux_images/qspi/prj_1\u0026#34; echo \u0026#34;copy hdf:\u0026#34; echo \u0026#34;cp -rf $pc_path ./\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;clone xilinx_axidma:\u0026#34; echo \u0026#34;git clone https://gitcode.com/gh_mirrors/xil/xilinx_axidma.git\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;copy driver:\u0026#34; echo \u0026#34;cp -vf ./build/tmp/sysroots-components/plnx_zynq7/xilinx-axidma/lib/modules/4.14.0-xilinx-v2018.3/extra/xilinx-axidma.ko $pc_image_path\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;copy image:\u0026#34; echo \u0026#34;cp -vf images/linux/BOOT.BIN $pc_image_path\u0026#34; echo \u0026#34;cp -vf images/linux/zynq_fsbl.elf $pc_image_path\u0026#34; echo \u0026#34;或\u0026#34; echo \u0026#34;cp -vf images/linux/BOOT.BIN images/linux/zynq_fsbl.elf $pc_image_path\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;copy rootfs.tar.gz:\u0026#34; echo \u0026#34;cp -vf images/linux/rootfs.tar.gz $pc_image_path\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;copy xilinx_axidma examples:\u0026#34; echo \u0026#34;cp -vrf xilinx_axidma/outputs/ $pc_image_path\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;sftp使用技巧:\u0026#34; echo \u0026#34;cat ~/.ssh/known_hosts \u0026gt; ~/.ssh/known_hosts; ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.10\u0026#34; echo \u0026#34;sftp root@192.168.1.10 \u0026lt;\u0026lt; EOF\u0026#34; # echo \u0026#34;cd /run/media/mmcblk0p1\u0026#34; echo \u0026#34;put -r outputs/axidma_transfer\u0026#34; echo \u0026#34;EOF\u0026#34; 参考链接 ZYNQ_LINUX的根文件系统设置为QSPI_FLASH，JFFS2。\n","date":"2025-03-26T01:15:42.36+08:00","permalink":"https://ynhugo.github.io/p/petalinux2018.3%E5%AE%9E%E7%8E%B0qspi%E8%B7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"petalinux2018.3实现QSPI跑操作系统"},{"content":" socket基于tcp的服务端与客户端实例 先运行服务端再运行客户端，服务端收到客户端下属的开始指令后，两边同时创建线程，服务端收到客户端下属的停止指令后，两边同时停止线程\nserver.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; // Flags for open() #include \u0026lt;sys/stat.h\u0026gt; // Open() system call #include \u0026lt;sys/types.h\u0026gt; // Types for open() #include \u0026lt;unistd.h\u0026gt; // Close() system call #include \u0026lt;string.h\u0026gt; // Memory setting and copying #include \u0026lt;getopt.h\u0026gt; // Option parsing #include \u0026lt;errno.h\u0026gt; // Error codes #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;netinet/in.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define DEFAULT_PORT 4000 #define MAXLINE 4096 #define socket_send_size 4096 int socket_fd, connect_fd; int flag1; // 全局变量 pthread_t worker_thread = 0; // 工作线程 ID volatile int thread_running = 0; // 线程运行状态 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 互斥锁 int flag1; int socket_fd, connect_fd; void cleanup_handler() {\t} void *receive_file(void *arg) { printf(\u0026#34;enter therad\\n\u0026#34;);\tpthread_cleanup_push(cleanup_handler, NULL); int i = 0, rc = 0; unsigned char send_buffer[socket_send_size] = {0}; memset(send_buffer, 0, socket_send_size); while (flag1 == 1) { #if 1 for (i = 0; i \u0026lt; 4; i++) { if (flag1 != 1) break; } send(connect_fd, \u0026amp;send_buffer[0], socket_send_size, 0); #endif } pthread_cleanup_pop(0); pthread_exit(NULL); } void create_thread() { pthread_mutex_lock(\u0026amp;mutex); if (!thread_running) { int ret = pthread_create(\u0026amp;worker_thread, NULL, \u0026amp;receive_file, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;);\texit(EXIT_FAILURE); } thread_running = 1; printf(\u0026#34;Main: Created thread\\n\u0026#34;); } else { printf(\u0026#34;Main: Thread is already running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 销毁线程 void destroy_thread() { pthread_mutex_lock(\u0026amp;mutex); if (thread_running) { printf(\u0026#34;Main: Stopping thread...\\n\u0026#34;); int ret = pthread_cancel(worker_thread); if (ret != 0) { perror(\u0026#34;pthread_cancel\u0026#34;); exit(EXIT_FAILURE); } // 等待线程退出并回收资源 ret = pthread_join(worker_thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } thread_running = 0; printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); } else { printf(\u0026#34;Main: No thread is running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 主函数 /*---------------------------------------------------------------------------- * Main *----------------------------------------------------------------------------*/ int main(void) {\t// Socket相关变量 struct sockaddr_in servaddr; unsigned char buff[MAXLINE]; int n; //初始化Socket if( (socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ) { printf(\u0026#34;create socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } // 解决 Address already in use 问题 int opt = 1; setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)); //初始化 memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。 servaddr.sin_port = htons(DEFAULT_PORT);//设置的端口为DEFAULT_PORT //将本地地址绑定到所创建的套接字上 if( bind(socket_fd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) == -1) { printf(\u0026#34;bind socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } //开始监听是否有客户端连接 if( listen(socket_fd, 2) == -1) { printf(\u0026#34;listen socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } printf(\u0026#34;======waiting for client\u0026#39;s request======\\n\u0026#34;); flag1 = 0; printf(\u0026#34;start:\\nFA 00 00 08 00 00 00 01\\n\u0026#34;); printf(\u0026#34;stop:\\nFA 00 00 08 00 00 00 02\\n\u0026#34;); while (1) { if( (connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL)) == -1) { printf(\u0026#34;accept socket error: %s(errno: %d)\u0026#34;,strerror(errno),errno); usleep(10); continue; } printf(\u0026#34;mark-1\\n\u0026#34;); while (1) { //接受客户端传过来的数据 n = recv(connect_fd, buff, MAXLINE, 0); usleep(100); printf(\u0026#34;mark-2\\n\u0026#34;); if(n \u0026gt; 0) { // 判断是开始还是停止 if (buff[0] == 0xFA \u0026amp;\u0026amp; buff[7] == 0x01) { // 开始 printf(\u0026#34;start\\n\u0026#34;); //sleep(1200); //测试长时间不执行操作，网口是否仍正常工作 flag1 = 1; // 复位\tcreate_thread(); system(\u0026#34;date\u0026#34;); } else if (buff[0] == 0xFA \u0026amp;\u0026amp; buff[7] == 0x02) { flag1 = 2; // 停止\tdestroy_thread(); system(\u0026#34;date\u0026#34;); } } else if (n \u0026lt; 0) { usleep(100); continue; } else { close(connect_fd); printf(\u0026#34;mark-3\\n\u0026#34;); usleep(100); break; } } usleep(10); } close(connect_fd); close(socket_fd); return 0; } client.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define DEFAULT_PORT 4000 #define MAXLINE 4096 // 全局变量 pthread_t worker_thread = 0; // 工作线程 ID volatile int thread_running = 0; // 线程运行状态 volatile int thread_should_exit = 0; // 线程退出标志 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 互斥锁 // 线程清理函数 void cleanup_handler(void *arg) { printf(\u0026#34;Thread: Cleaning up resources...\\n\u0026#34;); } // 工作线程函数 void *receive_file(void *arg) { printf(\u0026#34;Thread: Entered thread\\n\u0026#34;); // 注册清理函数 pthread_cleanup_push(cleanup_handler, NULL); while (!thread_should_exit) { // 模拟工作 printf(\u0026#34;Thread: Working...\\n\u0026#34;); sleep(1); } // 清理 pthread_cleanup_pop(1); printf(\u0026#34;Thread: Exiting...\\n\u0026#34;); return NULL; } // 创建线程 void create_thread() { pthread_mutex_lock(\u0026amp;mutex); if (!thread_running) { thread_should_exit = 0; // 重置退出标志 int ret = pthread_create(\u0026amp;worker_thread, NULL, receive_file, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } thread_running = 1; printf(\u0026#34;Main: Created thread\\n\u0026#34;); } else { printf(\u0026#34;Main: Thread is already running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 销毁线程 void destroy_thread() { pthread_mutex_lock(\u0026amp;mutex); if (thread_running) { printf(\u0026#34;Main: Stopping thread...\\n\u0026#34;); thread_should_exit = 1; // 设置退出标志 // 等待线程退出并回收资源 int ret = pthread_join(worker_thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } thread_running = 0; printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); } else { printf(\u0026#34;Main: No thread is running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 解析 16 进制输入 int parse_hex_input(const char *input, unsigned char *output, size_t output_size) { char *endptr; for (size_t i = 0; i \u0026lt; output_size; i++) { output[i] = (unsigned char)strtol(input + 2 * i, \u0026amp;endptr, 16); if (endptr != input + 2 * (i + 1)) { return -1; // 非法输入 } } return 0; } int main(int argc, char *argv[]) { int i = 0; int input = 0; int sockfd; struct sockaddr_in servaddr; // 检查命令行参数 if (argc != 2) { printf(\u0026#34;Usage: %s \u0026lt;ipaddress\u0026gt;\\n\u0026#34;, argv[0]); exit(EXIT_FAILURE); } // 创建 Socket if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { printf(\u0026#34;Create socket error: %s (errno: %d)\\n\u0026#34;, strerror(errno), errno); exit(EXIT_FAILURE); } // 设置服务器地址 memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(DEFAULT_PORT); if (inet_pton(AF_INET, argv[1], \u0026amp;servaddr.sin_addr) \u0026lt;= 0) { printf(\u0026#34;inet_pton error for %s\\n\u0026#34;, argv[1]); close(sockfd); exit(EXIT_FAILURE); } // 连接到服务器 if (connect(sockfd, (struct sockaddr *)\u0026amp;servaddr, sizeof(servaddr)) \u0026lt; 0) { printf(\u0026#34;Connect error: %s (errno: %d)\\n\u0026#34;, strerror(errno), errno); close(sockfd); exit(EXIT_FAILURE); } printf(\u0026#34;Connected to server at %s:%d\\n\u0026#34;, argv[1], DEFAULT_PORT); printf(\u0026#34;start:\\nFA 00 00 08 00 00 00 01\\n\u0026#34;); printf(\u0026#34;stop:\\nFA 00 00 08 00 00 00 02\\n\u0026#34;); // 主循环 while (1) { unsigned char input_buf[8] = {0}; char input_str[17]; // 8 个 16 进制数，每个占 2 字符，加上结束符 for (i = 0; i \u0026lt; 8; i++) { scanf(\u0026#34;%x\u0026#34;, \u0026amp;input); input_buf[i] = input; } // 打印输入 printf(\u0026#34;Input: \u0026#34;); for (int i = 0; i \u0026lt; 8; i++) { printf(\u0026#34;%02X \u0026#34;, input_buf[i]); } printf(\u0026#34;\\n\u0026#34;); // 根据输入启动或停止线程 if (input_buf[0] == 0xFA \u0026amp;\u0026amp; input_buf[7] == 0x01) { create_thread(); send(sockfd, \u0026amp;input_buf[0], sizeof(input_buf), 0); } else if (input_buf[0] == 0xFA \u0026amp;\u0026amp; input_buf[7] == 0x02) { destroy_thread(); send(sockfd, \u0026amp;input_buf[0], sizeof(input_buf), 0); } } // 清理资源 destroy_thread(); // 确保线程退出 pthread_mutex_destroy(\u0026amp;mutex); close(sockfd); return 0; } 运行方式 server端 1 ./server 显示结果并等待客户端连接\n1 2 3 4 5 ======waiting for client\u0026#39;s request====== start: FA 00 00 08 00 00 00 01 stop: FA 00 00 08 00 00 00 02 client端 运行客户端后下发指令\nstart: FA 00 00 08 00 00 00 01 stop: FA 00 00 08 00 00 00 02\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 $ ./client 127.0.0.1 Connected to server at 127.0.0.1:4000 start: FA 00 00 08 00 00 00 01 stop: FA 00 00 08 00 00 00 02 FA 00 00 08 00 00 00 01 Input: FA 00 00 08 00 00 00 01 Main: Created thread Thread: Entered thread Thread: Working... Thread: Working... Thread: Working... Thread: Working... FA 00 00 08 00 00 00 02Thread: Working... Input: FA 00 00 08 00 00 00 02 Main: Stopping thread... Thread: Cleaning up resources... Thread: Exiting... Main: Thread has exited. FA 00 00 08 00 00 00 01 Input: FA 00 00 08 00 00 00 01 Main: Created thread Thread: Entered thread Thread: Working... Thread: Working... Thread: Working... Thread: Working... FA 00 00 08 00 00 00 02Thread: Working... Input: FA 00 00 08 00 00 00 02 Main: Stopping thread... Thread: Cleaning up resources... Thread: Exiting... Main: Thread has exited. 此时服务端收到客户端下发的指令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $ ./server ======waiting for client\u0026#39;s request====== start: FA 00 00 08 00 00 00 01 stop: FA 00 00 08 00 00 00 02 mark-1 mark-2 start Main: Created thread enter therad 2025年03月20日 17:44:57 mark-2 Main: Stopping thread... Main: Thread has exited. 2025年03月20日 17:45:02 mark-2 start Main: Created thread enter therad 2025年03月20日 17:45:10 mark-2 Main: Stopping thread... Main: Thread has exited. 2025年03月20日 17:45:16 参考链接 socket基于tcp通信实例\nsocket基于tcp服务端实例\nsocket基于tcp客户端实例\n","date":"2025-03-20T17:38:32+08:00","permalink":"https://ynhugo.github.io/p/socket%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B/","title":"socket基于tcp的服务端与客户端实例"},{"content":" socket基于tcp客户端实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define DEFAULT_PORT 4000 #define MAXLINE 4096 // 全局变量 pthread_t worker_thread = 0; // 工作线程 ID volatile int thread_running = 0; // 线程运行状态 volatile int thread_should_exit = 0; // 线程退出标志 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 互斥锁 // 线程清理函数 void cleanup_handler(void *arg) { printf(\u0026#34;Thread: Cleaning up resources...\\n\u0026#34;); } // 工作线程函数 void *receive_file(void *arg) { printf(\u0026#34;Thread: Entered thread\\n\u0026#34;); // 注册清理函数 pthread_cleanup_push(cleanup_handler, NULL); while (!thread_should_exit) { // 模拟工作 printf(\u0026#34;Thread: Working...\\n\u0026#34;); sleep(1); } // 清理 pthread_cleanup_pop(1); printf(\u0026#34;Thread: Exiting...\\n\u0026#34;); return NULL; } // 创建线程 void create_thread() { pthread_mutex_lock(\u0026amp;mutex); if (!thread_running) { thread_should_exit = 0; // 重置退出标志 int ret = pthread_create(\u0026amp;worker_thread, NULL, receive_file, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } thread_running = 1; printf(\u0026#34;Main: Created thread\\n\u0026#34;); } else { printf(\u0026#34;Main: Thread is already running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 销毁线程 void destroy_thread() { pthread_mutex_lock(\u0026amp;mutex); if (thread_running) { printf(\u0026#34;Main: Stopping thread...\\n\u0026#34;); thread_should_exit = 1; // 设置退出标志 // 等待线程退出并回收资源 int ret = pthread_join(worker_thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } thread_running = 0; printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); } else { printf(\u0026#34;Main: No thread is running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 解析 16 进制输入 int parse_hex_input(const char *input, unsigned char *output, size_t output_size) { char *endptr; for (size_t i = 0; i \u0026lt; output_size; i++) { output[i] = (unsigned char)strtol(input + 2 * i, \u0026amp;endptr, 16); if (endptr != input + 2 * (i + 1)) { return -1; // 非法输入 } } return 0; } int main(int argc, char *argv[]) { int i = 0; int input = 0; int sockfd; struct sockaddr_in servaddr; // 检查命令行参数 if (argc != 2) { printf(\u0026#34;Usage: %s \u0026lt;ipaddress\u0026gt;\\n\u0026#34;, argv[0]); exit(EXIT_FAILURE); } // 创建 Socket if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { printf(\u0026#34;Create socket error: %s (errno: %d)\\n\u0026#34;, strerror(errno), errno); exit(EXIT_FAILURE); } // 设置服务器地址 memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(DEFAULT_PORT); if (inet_pton(AF_INET, argv[1], \u0026amp;servaddr.sin_addr) \u0026lt;= 0) { printf(\u0026#34;inet_pton error for %s\\n\u0026#34;, argv[1]); close(sockfd); exit(EXIT_FAILURE); } // 连接到服务器 if (connect(sockfd, (struct sockaddr *)\u0026amp;servaddr, sizeof(servaddr)) \u0026lt; 0) { printf(\u0026#34;Connect error: %s (errno: %d)\\n\u0026#34;, strerror(errno), errno); close(sockfd); exit(EXIT_FAILURE); } printf(\u0026#34;Connected to server at %s:%d\\n\u0026#34;, argv[1], DEFAULT_PORT); // 主循环 while (1) { unsigned char input_buf[8] = {0}; char input_str[17]; // 8 个 16 进制数，每个占 2 字符，加上结束符 for (i = 0; i \u0026lt; 8; i++) { scanf(\u0026#34;%x\u0026#34;, \u0026amp;input); input_buf[i] = input; } // 打印输入 printf(\u0026#34;Input: \u0026#34;); for (int i = 0; i \u0026lt; 8; i++) { printf(\u0026#34;%02X \u0026#34;, input_buf[i]); } printf(\u0026#34;\\n\u0026#34;); // 根据输入启动或停止线程 if (input_buf[0] == 0xFA \u0026amp;\u0026amp; input_buf[7] == 0x01) { create_thread(); } else if (input_buf[0] == 0xFA \u0026amp;\u0026amp; input_buf[7] == 0x02) { destroy_thread(); } } // 清理资源 destroy_thread(); // 确保线程退出 pthread_mutex_destroy(\u0026amp;mutex); close(sockfd); return 0; } 参考链接 socket基于tcp通信实例\n","date":"2025-03-20T17:22:04.56+08:00","permalink":"https://ynhugo.github.io/p/socket%E5%9F%BA%E4%BA%8Etcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B/","title":"socket基于tcp客户端实例"},{"content":" 以下是一个综合示例，展示了如何在 Socket 服务端中结合线程创建与销毁，根据客户端下发的 flag 动态管理线程，并确保线程中的结构体和动态内存被正确释放。 方案设计 Socket 服务端：\n使用 socket、bind、listen 和 accept 创建 TCP 服务端。 在 while 循环中持续接收客户端连接和消息。 线程管理：\n当客户端发送 flag=1 时，创建线程。 当客户端发送 flag=2 时，销毁线程。 使用全局变量和互斥锁（pthread_mutex_t）管理线程状态。 资源释放：\n使用 pthread_cleanup_push 和 pthread_cleanup_pop 确保线程退出时释放结构体和动态内存。 线程函数：\n线程函数模拟工作逻辑，持续运行直到被取消。 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define PORT 8080 #define BUFFER_SIZE 1024 // 全局变量 pthread_t worker_thread = 0; // 工作线程 ID volatile int thread_running = 0; // 线程运行状态 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 互斥锁 // 线程数据结构体 typedef struct { int id; char* message; } ThreadData; // 清理函数 void cleanup_handler(void* arg) { ThreadData* data = (ThreadData*)arg; printf(\u0026#34;Cleanup handler: Freeing resources for thread %d\\n\u0026#34;, data-\u0026gt;id); free(data-\u0026gt;message); // 释放动态内存 free(data); // 释放结构体 } // 线程函数 void* thread_func(void* arg) { ThreadData* data = (ThreadData*)arg; // 注册清理函数 pthread_cleanup_push(cleanup_handler, data); // 允许线程被取消 pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL); pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL); printf(\u0026#34;Thread %d: %s\\n\u0026#34;, data-\u0026gt;id, data-\u0026gt;message); // 模拟线程工作 while (1) { printf(\u0026#34;Thread %d: Working...\\n\u0026#34;, data-\u0026gt;id); sleep(1); // 显式检查取消请求 pthread_testcancel(); } // 弹出清理函数（不会执行，因为线程会被取消） pthread_cleanup_pop(0); pthread_exit(NULL); } // 创建线程 void create_thread() { pthread_mutex_lock(\u0026amp;mutex); if (!thread_running) { ThreadData* data = (ThreadData*)malloc(sizeof(ThreadData)); if (!data) { perror(\u0026#34;malloc\u0026#34;); exit(EXIT_FAILURE); } data-\u0026gt;id = 1; data-\u0026gt;message = (char*)malloc(50 * sizeof(char)); if (!data-\u0026gt;message) { perror(\u0026#34;malloc\u0026#34;); free(data); exit(EXIT_FAILURE); } snprintf(data-\u0026gt;message, 50, \u0026#34;Hello from thread %d\u0026#34;, data-\u0026gt;id); int ret = pthread_create(\u0026amp;worker_thread, NULL, thread_func, data); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); free(data-\u0026gt;message); free(data); exit(EXIT_FAILURE); } thread_running = 1; printf(\u0026#34;Main: Created thread %d\\n\u0026#34;, data-\u0026gt;id); } else { printf(\u0026#34;Main: Thread is already running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 销毁线程 void destroy_thread() { pthread_mutex_lock(\u0026amp;mutex); if (thread_running) { printf(\u0026#34;Main: Stopping thread...\\n\u0026#34;); int ret = pthread_cancel(worker_thread); if (ret != 0) { perror(\u0026#34;pthread_cancel\u0026#34;); exit(EXIT_FAILURE); } // 等待线程退出并回收资源 ret = pthread_join(worker_thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } thread_running = 0; printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); } else { printf(\u0026#34;Main: No thread is running\\n\u0026#34;); } pthread_mutex_unlock(\u0026amp;mutex); } // 主函数 int main() { int server_fd, client_fd; struct sockaddr_in server_addr, client_addr; socklen_t client_len = sizeof(client_addr); char buffer[BUFFER_SIZE]; // 创建 Socket server_fd = socket(AF_INET, SOCK_STREAM, 0); if (server_fd \u0026lt; 0) { perror(\u0026#34;socket\u0026#34;); exit(EXIT_FAILURE); } // 绑定地址和端口 server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = INADDR_ANY; server_addr.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;bind\u0026#34;); close(server_fd); exit(EXIT_FAILURE); } // 监听连接 if (listen(server_fd, 5) \u0026lt; 0) { perror(\u0026#34;listen\u0026#34;); close(server_fd); exit(EXIT_FAILURE); } printf(\u0026#34;Server is listening on port %d...\\n\u0026#34;, PORT); // 主循环 while (1) { // 接受客户端连接 client_fd = accept(server_fd, (struct sockaddr*)\u0026amp;client_addr, \u0026amp;client_len); if (client_fd \u0026lt; 0) { perror(\u0026#34;accept\u0026#34;); continue; } // 接收客户端消息 memset(buffer, 0, BUFFER_SIZE); ssize_t bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0); if (bytes_received \u0026lt; 0) { perror(\u0026#34;recv\u0026#34;); close(client_fd); continue; } printf(\u0026#34;Received from client: %s\\n\u0026#34;, buffer); // 解析客户端 flag int flag = atoi(buffer); if (flag == 1) { create_thread(); } else if (flag == 2) { destroy_thread(); } else { printf(\u0026#34;Invalid flag: %d\\n\u0026#34;, flag); } // 关闭客户端连接 close(client_fd); } // 关闭服务器 Socket close(server_fd); return 0; } 代码解析 Socket 服务端：\n使用 socket、bind、listen 和 accept 创建 TCP 服务端。 在 while 循环中持续接收客户端连接和消息。 线程管理：\ncreate_thread：创建线程并初始化线程数据。 destroy_thread：取消线程并等待线程退出。 资源释放：\n使用 pthread_cleanup_push 和 pthread_cleanup_pop 确保线程退出时释放资源。 客户端消息处理：\n接收客户端消息并解析 flag。 根据 flag 的值创建或销毁线程。 总结 该方案实现了 Socket 服务端与线程管理的结合。 通过 flag 动态创建和销毁线程，确保资源被正确释放。 使用互斥锁保护全局变量，避免竞态条件。 适用于需要动态管理线程的服务器场景。 讲一下互斥锁 互斥锁（Mutex，全称 Mutual Exclusion Lock） 是一种用于多线程编程的同步机制，用于保护共享资源，防止多个线程同时访问或修改这些资源，从而避免竞态条件（Race Condition）和数据不一致的问题。\n互斥锁的作用 在多线程环境中，如果多个线程同时访问或修改共享资源（如全局变量、文件、内存等），可能会导致数据不一致或程序行为异常。互斥锁的作用是：\n确保同一时间只有一个线程可以访问共享资源。 当一个线程持有锁时，其他线程必须等待锁释放后才能访问共享资源。 互斥锁的基本操作 在 POSIX 线程库（pthread）中，互斥锁的操作包括：\n初始化互斥锁：\n使用 pthread_mutex_init 初始化互斥锁。 也可以使用静态初始化：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER。 加锁：\n使用 pthread_mutex_lock 加锁。如果锁已被其他线程持有，则当前线程会阻塞，直到锁被释放。 尝试加锁：\n使用 pthread_mutex_trylock 尝试加锁。如果锁已被其他线程持有，则立即返回错误，而不是阻塞。 解锁：\n使用 pthread_mutex_unlock 释放锁，允许其他线程获取锁。 销毁互斥锁：\n使用 pthread_mutex_destroy 销毁互斥锁，释放相关资源。 互斥锁的使用场景 保护共享资源：\n例如，多个线程需要修改同一个全局变量时，可以使用互斥锁确保线程安全。 同步线程执行：\n例如，确保某个操作在所有线程完成特定任务后再执行。 互斥锁的示例 以下是一个简单的示例，展示了如何使用互斥锁保护共享资源：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; // 共享资源 int counter = 0; // 互斥锁 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 线程函数 void* thread_func(void* arg) { for (int i = 0; i \u0026lt; 100000; i++) { // 加锁 pthread_mutex_lock(\u0026amp;mutex); // 修改共享资源 counter++; // 解锁 pthread_mutex_unlock(\u0026amp;mutex); } return NULL; } int main() { pthread_t thread1, thread2; // 创建两个线程 pthread_create(\u0026amp;thread1, NULL, thread_func, NULL); pthread_create(\u0026amp;thread2, NULL, thread_func, NULL); // 等待线程结束 pthread_join(thread1, NULL); pthread_join(thread2, NULL); // 打印最终结果 printf(\u0026#34;Counter value: %d\\n\u0026#34;, counter); // 销毁互斥锁 pthread_mutex_destroy(\u0026amp;mutex); return 0; } 代码解析 共享资源：\ncounter 是一个全局变量，被两个线程同时修改。 互斥锁保护：\n在修改 counter 之前，线程调用 pthread_mutex_lock 加锁。 修改完成后，线程调用 pthread_mutex_unlock 解锁。 线程安全：\n如果没有互斥锁，两个线程可能同时修改 counter，导致最终结果不正确。 使用互斥锁后，counter 的最终值一定是 200000。\n互斥锁的注意事项 避免死锁：\n死锁是指多个线程互相等待对方释放锁，导致程序无法继续执行。 例如，线程 A 持有锁 1 并请求锁 2，而线程 B 持有锁 2 并请求锁 1。 解决方法：按固定顺序加锁，或使用超时机制。 锁的粒度：\n锁的粒度不宜过大，否则会降低程序的并发性能。 例如，如果锁保护了整个函数，而函数中有大量不涉及共享资源的代码，会导致其他线程长时间等待。 锁的性能开销：\n加锁和解锁操作有一定的性能开销，尤其是在高并发场景下。 如果共享资源的访问频率很高，可以考虑使用更高效的同步机制（如读写锁或无锁数据结构）。\n互斥锁的变体 读写锁（pthread_rwlock_t）：\n允许多个线程同时读取共享资源，但只允许一个线程写入。 适用于读多写少的场景。 自旋锁（pthread_spinlock_t）：\n在加锁时，线程会忙等待（busy-wait），而不是阻塞。 适用于锁持有时间非常短的场景。 条件变量（pthread_cond_t）：\n用于线程间的条件同步，通常与互斥锁配合使用。 总结 互斥锁是保护共享资源的基本工具，可以避免竞态条件和数据不一致。 使用互斥锁时需要注意死锁、锁粒度和性能开销。 在实际开发中，应根据具体场景选择合适的同步机制。 通过合理使用互斥锁，可以编写出高效且线程安全的并发程序。\n前边示例为什么创建线程和销毁线程都要加锁 在前面的示例中，创建线程和销毁线程时加锁是为了解决**竞态条件（Race Condition）**问题，确保多个线程不会同时修改共享资源（如 worker_thread 和 thread_running）而导致数据不一致或程序行为异常。\n为什么需要加锁？ 1.1 共享资源的竞争 在示例中，worker_thread 和 thread_running 是全局变量，被多个线程共享。 如果没有锁保护，可能会出现以下问题：\n创建线程时：\n两个客户端同时发送 flag=1，导致两个线程同时调用 create_thread。 如果没有锁，可能会创建多个线程，而 worker_thread 只能保存一个线程 ID，导致其他线程无法被正确管理。 销毁线程时：\n一个线程正在销毁线程，而另一个线程尝试创建线程，可能导致 worker_thread 和 thread_running 的状态不一致。 1.2 数据一致性 加锁可以确保对共享资源的修改是原子操作，即同一时间只有一个线程可以修改这些资源。 例如，在 create_thread 中，加锁后可以确保：\n检查 thread_running 的状态。 创建线程并更新 worker_thread 和 thread_running。 这些操作不会被其他线程打断。 加锁的具体作用 2.1 创建线程时的加锁 在 create_thread 函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 void create_thread() { pthread_mutex_lock(\u0026amp;mutex); // 加锁 if (!thread_running) { // 创建线程并更新共享资源 ThreadData* data = (ThreadData*)malloc(sizeof(ThreadData)); // ... 初始化 data int ret = pthread_create(\u0026amp;worker_thread, NULL, thread_func, data); // ... 错误处理 thread_running = 1; // 更新状态 } pthread_mutex_unlock(\u0026amp;mutex); // 解锁 } 加锁：确保在检查 thread_running 和创建线程的过程中，不会被其他线程打断。 解锁：操作完成后释放锁，允许其他线程访问共享资源。 2.2 销毁线程时的加锁 在 destroy_thread 函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 void destroy_thread() { pthread_mutex_lock(\u0026amp;mutex); // 加锁 if (thread_running) { // 取消线程并更新共享资源 int ret = pthread_cancel(worker_thread); // ... 错误处理 ret = pthread_join(worker_thread, NULL); // ... 错误处理 thread_running = 0; // 更新状态 } pthread_mutex_unlock(\u0026amp;mutex); // 解锁 } 加锁：确保在检查 thread_running 和销毁线程的过程中，不会被其他线程打断。 解锁：操作完成后释放锁，允许其他线程访问共享资源。 不加锁的后果 如果不加锁，可能会出现以下问题：\n3.1 创建多个线程 两个客户端同时发送 flag=1，导致两个线程同时调用 create_thread。 由于没有锁保护，两个线程可能同时检查 thread_running，发现其为 0，然后同时创建线程。 最终会导致多个线程运行，而 worker_thread 只能保存一个线程 ID，其他线程无法被管理。 3.2 状态不一致 一个线程正在销毁线程，而另一个线程尝试创建线程。 由于没有锁保护，可能会导致 worker_thread 和 thread_running 的状态不一致，例如：\nthread_running 被设置为 0，但 worker_thread 仍然指向一个无效的线程 ID。 或者 thread_running 被设置为 1，但 worker_thread 尚未被正确赋值。 3.3 资源泄漏 如果没有锁保护，可能会多次创建线程，导致资源（如动态内存）泄漏。 例如，多个线程同时分配 ThreadData 结构体，但只有最后一个线程的 ThreadData 会被正确释放。 4. 加锁的最佳实践 锁的粒度：\n锁的粒度不宜过大，否则会降低程序的并发性能。 在示例中，锁只保护了必要的共享资源（worker_thread 和 thread_running）。 避免死锁：\n确保加锁和解锁成对出现。 在函数的所有退出路径（如 return 或错误处理）中都要解锁。 锁的性能：\n加锁和解锁操作有一定的性能开销，尤其是在高并发场景下。 如果共享资源的访问频率很高，可以考虑使用更高效的同步机制（如读写锁或无锁数据结构）。 总结 加锁的目的是保护共享资源，避免竞态条件和数据不一致。 在示例中，创建线程和销毁线程时加锁，是为了确保对 worker_thread 和 thread_running 的修改是原子操作。 如果不加锁，可能会导致多个线程同时修改共享资源，从而引发数据不一致、资源泄漏或程序行为异常。 通过合理使用互斥锁，可以编写出线程安全的并发程序。\n","date":"2025-03-19T11:28:06.62+08:00","permalink":"https://ynhugo.github.io/p/socket-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E7%BB%93%E5%90%88-deepseek/","title":"Socket 服务端与线程管理的结合-Deepseek"},{"content":" 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 标志位，用于通知线程退出 volatile int flag = 0; // 线程函数 void* thread_func(void* arg) { while (!flag) { printf(\u0026#34;Thread is running...\\n\u0026#34;); sleep(1); } printf(\u0026#34;Thread exiting...\\n\u0026#34;); pthread_exit(NULL); } int main() { pthread_t thread; int ret; // 创建线程 ret = pthread_create(\u0026amp;thread, NULL, thread_func, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } // 主线程等待一段时间 sleep(5); // 设置标志位，通知线程退出 flag = 1; // 等待线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Thread has exited.\\n\u0026#34;); // 创建新线程 flag = 0; // 重置标志位 ret = pthread_create(\u0026amp;thread, NULL, thread_func, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } // 主线程等待一段时间 sleep(5); // 设置标志位，通知新线程退出 flag = 1; // 等待新线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;New thread has exited.\\n\u0026#34;); return 0; } 关键点 标志位：使用volatile int flag通知线程退出。\npthread_join：确保线程正常退出并回收资源。\n重置标志位：创建新线程前重置flag。\n可以不需要等待5秒，线程创建后可以立即退出并收尸。关键在于如何正确管理线程的生命周期，确保线程能够正常退出并且资源被回收。以下是改进后的代码示例，去除了不必要的等待时间，并确保线程创建后可以立即退出并收尸 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 标志位，用于通知线程退出 volatile int flag = 0; // 线程函数 void* thread_func(void* arg) { while (!flag) { printf(\u0026#34;Thread is running...\\n\u0026#34;); sleep(1); } printf(\u0026#34;Thread exiting...\\n\u0026#34;); pthread_exit(NULL); } int main() { pthread_t thread; int ret; // 创建线程 ret = pthread_create(\u0026amp;thread, NULL, thread_func, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } // 立即设置标志位，通知线程退出 flag = 1; // 等待线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Thread has exited.\\n\u0026#34;); // 创建新线程 flag = 0; // 重置标志位 ret = pthread_create(\u0026amp;thread, NULL, thread_func, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } // 立即设置标志位，通知新线程退出 flag = 1; // 等待新线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;New thread has exited.\\n\u0026#34;); return 0; } 关键点 立即设置标志位：\n在线程创建后，立即设置flag = 1，通知线程退出。\n这样可以避免不必要的等待时间。\npthread_join：\n使用pthread_join等待线程退出并回收资源。\n即使线程立即退出，pthread_join也会确保资源被正确回收。\n重置标志位：\n在创建新线程之前，重置flag = 0，以确保新线程能够正常运行。\n线程函数中的循环：\n线程函数中的while (!flag)循环会检查标志位，如果flag为1，线程会立即退出。\n总结 不需要固定的等待时间（如5秒），可以通过标志位立即通知线程退出。\n使用pthread_join确保线程资源被回收，避免僵尸线程。\n这种方法可以动态控制线程的生命周期，适用于需要频繁创建和销毁线程的场景。\n正确处理线程中的动态内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 线程数据结构体 typedef struct { int id; char* message; } ThreadData; // 线程函数 void* thread_func(void* arg) { ThreadData* data = (ThreadData*)arg; printf(\u0026#34;Thread %d: %s\\n\u0026#34;, data-\u0026gt;id, data-\u0026gt;message); // 模拟线程工作 sleep(2); // 释放动态分配的内存 free(data-\u0026gt;message); free(data); printf(\u0026#34;Thread %d: Resources freed, exiting...\\n\u0026#34;, data-\u0026gt;id); pthread_exit(NULL); } int main() { pthread_t thread; int ret; // 动态分配线程数据 ThreadData* data = (ThreadData*)malloc(sizeof(ThreadData)); if (!data) { perror(\u0026#34;malloc\u0026#34;); exit(EXIT_FAILURE); } data-\u0026gt;id = 1; data-\u0026gt;message = (char*)malloc(50 * sizeof(char)); if (!data-\u0026gt;message) { perror(\u0026#34;malloc\u0026#34;); free(data); exit(EXIT_FAILURE); } snprintf(data-\u0026gt;message, 50, \u0026#34;Hello from thread %d\u0026#34;, data-\u0026gt;id); // 创建线程 ret = pthread_create(\u0026amp;thread, NULL, thread_func, data); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); free(data-\u0026gt;message); free(data); exit(EXIT_FAILURE); } // 等待线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); return 0; } 关键代码解析 动态分配内存：\n使用malloc为线程数据（ThreadData）和字符串（message）分配内存。\n释放内存：\n在线程退出前，调用free释放data-\u0026gt;message和data。\n线程退出：\n线程退出时，确保所有动态分配的内存都被释放，避免内存泄漏。\n使用清理函数（pthread_cleanup_push和pthread_cleanup_pop） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 线程数据结构体 typedef struct { int id; char* message; } ThreadData; // 清理函数 void cleanup_handler(void* arg) { ThreadData* data = (ThreadData*)arg; printf(\u0026#34;Cleanup handler: Freeing resources for thread %d\\n\u0026#34;, data-\u0026gt;id); free(data-\u0026gt;message); free(data); } // 线程函数 void* thread_func(void* arg) { ThreadData* data = (ThreadData*)arg; // 注册清理函数 pthread_cleanup_push(cleanup_handler, data); printf(\u0026#34;Thread %d: %s\\n\u0026#34;, data-\u0026gt;id, data-\u0026gt;message); // 模拟线程工作 sleep(2); // 弹出清理函数并执行（参数为1表示执行清理函数） pthread_cleanup_pop(1); pthread_exit(NULL); } int main() { pthread_t thread; int ret; // 动态分配线程数据 ThreadData* data = (ThreadData*)malloc(sizeof(ThreadData)); if (!data) { perror(\u0026#34;malloc\u0026#34;); exit(EXIT_FAILURE); } data-\u0026gt;id = 1; data-\u0026gt;message = (char*)malloc(50 * sizeof(char)); if (!data-\u0026gt;message) { perror(\u0026#34;malloc\u0026#34;); free(data); exit(EXIT_FAILURE); } snprintf(data-\u0026gt;message, 50, \u0026#34;Hello from thread %d\u0026#34;, data-\u0026gt;id); // 创建线程 ret = pthread_create(\u0026amp;thread, NULL, thread_func, data); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); free(data-\u0026gt;message); free(data); exit(EXIT_FAILURE); } // 等待线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); return 0; } 总结 未释放的内存不会阻止线程退出，但会导致内存泄漏。\n在线程退出前，确保释放所有动态分配的内存。\n可以使用清理函数（pthread_cleanup_push和pthread_cleanup_pop）确保资源在线程被取消时也能正确释放。\n良好的资源管理是编写健壮多线程程序的关键。\npthread_cancel pthread_cancel 是 POSIX 线程库中用于取消线程的函数。它允许一个线程请求取消另一个线程。被取消的线程会在下一个取消点（cancellation point）退出，或者在显式调用pthread_testcancel时退出。为了正确使用pthread_cancel，需要注意以下几点：\npthread_cancel 的基本用法 函数原型： 1 int pthread_cancel(pthread_t thread); thread：要取消的线程 ID。 返回值：成功返回 0，失败返回错误码。 取消点：\n取消点是线程可以响应取消请求的地方。常见的取消点包括：\nsleep、pthread_join、read、write 等阻塞函数。 显式调用 pthread_testcancel。 取消类型：\n线程的取消行为由取消类型（cancellation type）决定： 延迟取消（Deferred cancellation）：默认行为，线程只有在取消点才会响应取消请求。 异步取消（Asynchronous cancellation）：线程可以在任何时候被取消，但这种方式不安全，容易导致资源泄漏。 pthread_cancel 的使用步骤 设置线程的取消状态：\n使用 pthread_setcancelstate 设置线程是否允许被取消。 使用 pthread_setcanceltype 设置取消类型（延迟取消或异步取消）。 在线程中处理取消请求：\n如果线程需要清理资源，可以使用 pthread_cleanup_push 和 pthread_cleanup_pop 注册清理函数。 在主线程中调用 pthread_cancel：\n主线程或其他线程可以调用 pthread_cancel 取消目标线程。 等待线程退出并回收资源：\n使用 pthread_join 等待被取消的线程退出，并确保资源被正确回收。 完整示例代码 以下是一个综合示例，展示了如何使用 pthread_cancel 取消线程，并确保资源被正确释放：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 线程数据结构体 typedef struct { int id; char* message; } ThreadData; // 清理函数 void cleanup_handler(void* arg) { ThreadData* data = (ThreadData*)arg; printf(\u0026#34;Cleanup handler: Freeing resources for thread %d\\n\u0026#34;, data-\u0026gt;id); free(data-\u0026gt;message); free(data); } // 线程函数 void* thread_func(void* arg) { ThreadData* data = (ThreadData*)arg; // 注册清理函数 pthread_cleanup_push(cleanup_handler, data); // 允许线程被取消 pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL); pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL); printf(\u0026#34;Thread %d: %s\\n\u0026#34;, data-\u0026gt;id, data-\u0026gt;message); // 模拟线程工作 while (1) { printf(\u0026#34;Thread %d: Working...\\n\u0026#34;, data-\u0026gt;id); sleep(1); // 显式检查取消请求 pthread_testcancel(); } // 弹出清理函数（不会执行，因为线程会被取消） pthread_cleanup_pop(0); pthread_exit(NULL); } int main() { pthread_t thread; int ret; // 动态分配线程数据 ThreadData* data = (ThreadData*)malloc(sizeof(ThreadData)); if (!data) { perror(\u0026#34;malloc\u0026#34;); exit(EXIT_FAILURE); } data-\u0026gt;id = 1; data-\u0026gt;message = (char*)malloc(50 * sizeof(char)); if (!data-\u0026gt;message) { perror(\u0026#34;malloc\u0026#34;); free(data); exit(EXIT_FAILURE); } snprintf(data-\u0026gt;message, 50, \u0026#34;Hello from thread %d\u0026#34;, data-\u0026gt;id); // 创建线程 ret = pthread_create(\u0026amp;thread, NULL, thread_func, data); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); free(data-\u0026gt;message); free(data); exit(EXIT_FAILURE); } // 主线程等待一段时间 sleep(3); // 取消线程 printf(\u0026#34;Main: Cancelling thread %d...\\n\u0026#34;, data-\u0026gt;id); ret = pthread_cancel(thread); if (ret != 0) { perror(\u0026#34;pthread_cancel\u0026#34;); exit(EXIT_FAILURE); } // 等待线程结束并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); return 0; } 注意事项 资源泄漏：\n如果线程被取消时没有正确释放资源（如动态内存、文件描述符等），会导致资源泄漏。务必使用清理函数或手动释放资源。 异步取消的风险：\n异步取消（PTHREAD_CANCEL_ASYNCHRONOUS）可能导致线程在任意时刻被取消，容易引发资源泄漏或数据不一致。除非必要，否则不要使用异步取消。 取消点的选择：\n如果线程长时间运行而没有取消点，可以使用 pthread_testcancel 显式检查取消请求。 总结 pthread_cancel 是用于取消线程的函数，但需要配合清理函数和 pthread_join 使用，以确保资源被正确释放。 使用 pthread_cleanup_push 和 pthread_cleanup_pop 注册清理函数，避免资源泄漏。 默认的延迟取消是安全的，异步取消应谨慎使用。 通过合理设计线程的取消逻辑，可以编写出健壮的多线程程序。 在 main 函数的 while 循环中根据 flag 标志动态创建或停止线程，并确保子线程的结构体和动态申请的内存正常释放 实现思路 全局标志位：\n使用一个全局标志位（如 volatile int flag）控制线程的创建和停止。 线程管理：\n当 flag 为 1 时，创建线程。 当 flag 为 0 时，停止线程并确保资源释放。 资源释放：\n使用 pthread_cleanup_push 和 pthread_cleanup_pop 注册清理函数，确保线程被取消时资源（如结构体和动态内存）被正确释放。 线程同步：\n使用 pthread_join 等待线程退出，确保线程资源被回收。 完整代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 全局标志位 volatile int flag = 0; // 线程数据结构体 typedef struct { int id; char* message; } ThreadData; // 清理函数 void cleanup_handler(void* arg) { ThreadData* data = (ThreadData*)arg; printf(\u0026#34;Cleanup handler: Freeing resources for thread %d\\n\u0026#34;, data-\u0026gt;id); free(data-\u0026gt;message); // 释放动态内存 free(data); // 释放结构体 } // 线程函数 void* thread_func(void* arg) { ThreadData* data = (ThreadData*)arg; // 注册清理函数 pthread_cleanup_push(cleanup_handler, data); // 允许线程被取消 pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL); pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL); printf(\u0026#34;Thread %d: %s\\n\u0026#34;, data-\u0026gt;id, data-\u0026gt;message); // 模拟线程工作 while (1) { printf(\u0026#34;Thread %d: Working...\\n\u0026#34;, data-\u0026gt;id); sleep(1); // 显式检查取消请求 pthread_testcancel(); } // 弹出清理函数（不会执行，因为线程会被取消） pthread_cleanup_pop(0); pthread_exit(NULL); } int main() { pthread_t thread = 0; // 线程 ID int thread_id = 0; // 线程编号 int ret; while (1) { if (flag == 1 \u0026amp;\u0026amp; thread == 0) { // 创建线程 ThreadData* data = (ThreadData*)malloc(sizeof(ThreadData)); if (!data) { perror(\u0026#34;malloc\u0026#34;); exit(EXIT_FAILURE); } data-\u0026gt;id = ++thread_id; data-\u0026gt;message = (char*)malloc(50 * sizeof(char)); if (!data-\u0026gt;message) { perror(\u0026#34;malloc\u0026#34;); free(data); exit(EXIT_FAILURE); } snprintf(data-\u0026gt;message, 50, \u0026#34;Hello from thread %d\u0026#34;, data-\u0026gt;id); ret = pthread_create(\u0026amp;thread, NULL, thread_func, data); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); free(data-\u0026gt;message); free(data); exit(EXIT_FAILURE); } printf(\u0026#34;Main: Created thread %d\\n\u0026#34;, data-\u0026gt;id); } else if (flag == 0 \u0026amp;\u0026amp; thread != 0) { // 停止线程 printf(\u0026#34;Main: Stopping thread %d...\\n\u0026#34;, thread_id); ret = pthread_cancel(thread); if (ret != 0) { perror(\u0026#34;pthread_cancel\u0026#34;); exit(EXIT_FAILURE); } // 等待线程退出并回收资源 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Main: Thread %d has exited.\\n\u0026#34;, thread_id); thread = 0; // 重置线程 ID } // 模拟主线程工作 sleep(1); // 模拟 flag 变化 static int counter = 0; counter++; if (counter % 5 == 0) { flag = !flag; // 切换 flag 状态 printf(\u0026#34;Main: Toggling flag to %d\\n\u0026#34;, flag); } } return 0; } 代码解析 全局标志位 flag：\nflag 控制线程的创建和停止：\nflag == 1：创建线程。 flag == 0：停止线程。 线程创建：\n动态分配 ThreadData 结构体和 message 内存。 使用 pthread_create 创建线程，并将 ThreadData 传递给线程函数。 线程停止：\n使用 pthread_cancel 取消线程。 使用 pthread_join 等待线程退出，确保资源被回收。 清理函数：\n使用 pthread_cleanup_push 注册清理函数 cleanup_handler，确保线程被取消时资源被正确释放。 主循环：\n主循环根据 flag 的值动态创建或停止线程。 每 5 秒切换一次 flag 的状态，模拟控制逻辑。 总结 通过全局标志位 flag 动态控制线程的创建和停止。 使用 pthread_cleanup_push 和 pthread_cleanup_pop 确保线程资源被正确释放。 使用 pthread_cancel 和 pthread_join 安全地停止线程并回收资源。 这种方法适用于需要动态管理线程生命周期的场景，同时避免了资源泄漏和僵尸线程问题。 线程清理函数被调用的条件都有哪些 线程清理函数（通过 pthread_cleanup_push 注册）的调用条件是由 POSIX 线程库的行为定义的。清理函数会在以下情况下被调用： 线程被取消（pthread_cancel）\n如果线程收到取消请求（通过 pthread_cancel），并且线程的取消状态为 PTHREAD_CANCEL_ENABLE（默认状态），则线程会在下一个取消点退出。 在线程退出之前，所有通过 pthread_cleanup_push 注册的清理函数会按照**后进先出（LIFO）**的顺序被调用。 线程显式调用 pthread_exit\n如果线程显式调用 pthread_exit 退出，所有通过 pthread_cleanup_push 注册的清理函数会按照**后进先出（LIFO）**的顺序被调用。 线程调用 pthread_cleanup_pop 并传递非零参数\n如果线程调用 pthread_cleanup_pop 并传递一个非零参数，则弹出的清理函数会立即执行。 这种方式通常用于在某个特定条件下手动触发清理函数。 线程正常返回（从线程函数中返回）\n如果线程从线程函数中正常返回（即没有调用 pthread_exit 或 pthread_cancel），则不会调用清理函数。 这是清理函数与 C++ 析构函数的一个重要区别：清理函数不会在线程正常返回时自动调用。 线程被分离（pthread_detach）\n如果线程被分离（通过 pthread_detach），则线程退出时会自动释放资源，但清理函数仍然会被调用（如果满足上述条件）。 线程因未捕获的异常退出\n如果线程因未捕获的异常（如段错误）退出，则清理函数不会被调用。 这种情况下，线程的资源可能无法正确释放。 清理函数的调用顺序 清理函数的调用顺序是**后进先出（LIFO）**的，即最后注册的清理函数会最先被调用。例如：\n1 2 3 4 5 6 7 8 pthread_cleanup_push(cleanup1, NULL); pthread_cleanup_push(cleanup2, NULL); pthread_cleanup_push(cleanup3, NULL); // 清理函数的调用顺序是 cleanup3 -\u0026gt; cleanup2 -\u0026gt; cleanup1 pthread_cleanup_pop(1); // 调用 cleanup3 pthread_cleanup_pop(1); // 调用 cleanup2 pthread_cleanup_pop(1); // 调用 cleanup1 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 清理函数 1 void cleanup1(void* arg) { printf(\u0026#34;Cleanup 1: Freeing resources...\\n\u0026#34;); } // 清理函数 2 void cleanup2(void* arg) { printf(\u0026#34;Cleanup 2: Freeing resources...\\n\u0026#34;); } // 线程函数 void* thread_func(void* arg) { // 注册清理函数 pthread_cleanup_push(cleanup1, NULL); pthread_cleanup_push(cleanup2, NULL); printf(\u0026#34;Thread: Running...\\n\u0026#34;); // 模拟线程工作 sleep(2); // 显式调用 pthread_exit printf(\u0026#34;Thread: Calling pthread_exit...\\n\u0026#34;); pthread_exit(NULL); // 弹出清理函数（不会执行，因为线程已经退出） pthread_cleanup_pop(0); pthread_cleanup_pop(0); } int main() { pthread_t thread; int ret; // 创建线程 ret = pthread_create(\u0026amp;thread, NULL, thread_func, NULL); if (ret != 0) { perror(\u0026#34;pthread_create\u0026#34;); exit(EXIT_FAILURE); } // 等待线程结束 ret = pthread_join(thread, NULL); if (ret != 0) { perror(\u0026#34;pthread_join\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Main: Thread has exited.\\n\u0026#34;); return 0; } 总结 清理函数被调用的条件包括：\n线程被取消（pthread_cancel）。 线程显式调用 pthread_exit。 线程调用 pthread_cleanup_pop 并传递非零参数。 清理函数不会在以下情况下被调用：\n线程正常返回（从线程函数中返回）。 线程因未捕获的异常退出。 通过合理使用清理函数，可以确保线程退出时资源被正确释放，避免内存泄漏和资源浪费。\n","date":"2025-03-19T09:49:36.01+08:00","permalink":"https://ynhugo.github.io/p/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AEflag%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B-deepseek/","title":"如何根据flag结束线程并创建新线程-Deepseek"},{"content":" socket基于tcp服务端实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; // Flags for open() #include \u0026lt;sys/stat.h\u0026gt; // Open() system call #include \u0026lt;sys/types.h\u0026gt; // Types for open() #include \u0026lt;unistd.h\u0026gt; // Close() system call #include \u0026lt;string.h\u0026gt; // Memory setting and copying #include \u0026lt;getopt.h\u0026gt; // Option parsing #include \u0026lt;errno.h\u0026gt; // Error codes #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;netinet/in.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define DEFAULT_PORT 7 #define MAXLINE 4096 int socket_fd, connect_fd; int flag1; struct test { int flag1; }; /*---------------------------------------------------------------------------- * DMA File Transfer Functions *----------------------------------------------------------------------------*/ void *receive_file(void *arg) { struct test *my = (struct test *)arg; while (1) { if (my-\u0026gt;flag1 == 1) { printf(\u0026#34;test1\\n\u0026#34;); } else if (my-\u0026gt;flag1 == 2) { printf(\u0026#34;test2\\n\u0026#34;); } sleep(1); } // pthread_exit(NULL); return NULL; } /*---------------------------------------------------------------------------- * Main *----------------------------------------------------------------------------*/ int main(void) { // Socket相关变量 struct sockaddr_in servaddr; unsigned char buff[MAXLINE]; int n; int err; pthread_t tid; struct test *ts = (struct test *)malloc(sizeof(struct test)); ts-\u0026gt;flag1 = 0; //初始化Socket if( (socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ) { printf(\u0026#34;create socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } // 解决 Address already in use 问题 int opt = 1; setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)); //初始化 memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。 servaddr.sin_port = htons(DEFAULT_PORT);//设置的端口为DEFAULT_PORT //将本地地址绑定到所创建的套接字上 if( bind(socket_fd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) == -1) { printf(\u0026#34;bind socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } //开始监听是否有客户端连接 if( listen(socket_fd, 2) == -1) { printf(\u0026#34;listen socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } printf(\u0026#34;======waiting for client\u0026#39;s request======\\n\u0026#34;); // 启动线程 if ((err = pthread_create(\u0026amp;tid, NULL, \u0026amp;receive_file, ts)) != 0) { printf(\u0026#34;err = %d, can\u0026#39;t create thread\u0026#34;, err); } pthread_detach(tid); //分离线程，避免僵尸进程 while (1) { //阻塞直到有客户端连接，不然多浪费CPU资源。 if( (connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL)) == -1) { printf(\u0026#34;accept socket error: %s(errno: %d)\u0026#34;,strerror(errno),errno); continue; } while (1) { //接受客户端传过来的数据 n = recv(connect_fd, buff, MAXLINE, 0); if(n \u0026gt; 0) { // 判断是开始还是停止 if (buff[0] == 0xFA \u0026amp;\u0026amp; buff[7] == 0x01) { ts-\u0026gt;flag1 = 1; printf(\u0026#34;start\\n\u0026#34;); } else if (buff[0] == 0xFA \u0026amp;\u0026amp; buff[7] == 0x02) { ts-\u0026gt;flag1 = 2; // 停止 printf(\u0026#34;stop\\n\u0026#34;); } else if (buff[0] == 0xFA \u0026amp;\u0026amp; buff[7] == 0x03) { ts-\u0026gt;flag1 = 3; } } else { close(connect_fd); break; } } usleep(100); } close(connect_fd); close(socket_fd); return 0; } 参考链接 socket基于tcp通信实例\n","date":"2025-03-18T10:51:57.78+08:00","permalink":"https://ynhugo.github.io/p/socket%E5%9F%BA%E4%BA%8Etcp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E4%BE%8B/","title":"socket基于tcp服务端实例"},{"content":" 脚本使用方式 环境部署 第一次使用该脚本需要先搭建环境，执行命令如下：\n1 qemu-x86-linux.sh default 运行方式 在环境完备的情况下，可以使用两种启动方式启动，一种是通过图形化界面启动，还有一种是通过控制台启动，命令分别如下：\n1 2 3 qemu-x86-linux.sh run graphic 和 qemu-x86-linux.sh run nographic 输出运行命令 如果想输出启动方式，需要执行的命令如下：\n1 2 3 qemu-x86-linux.sh run_way graphic 和 qemu-x86-linux.sh run_way nographic 脚本内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 linux=\u0026#34;linux-5.19\u0026#34;; busybox=\u0026#34;busybox-1.35.0\u0026#34;; file_linux=\u0026#34;${linux}.tar.gz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; busybox_config=\u0026#34;busybox-1.35.0/.config\u0026#34;; work_dir_name=\u0026#34;qemu-x86-linux\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; mkdir -p ${work_dir}; qemu_arch=\u0026#34;qemu-system-x86_64\u0026#34; cd ${work_dir}; tools-install() { package_array=(flex bison libncurses5-dev libelf-dev libssl-dev qemu-system-x86) package_array_size=${#package_array[@]} for ((i = 0; i \u0026lt; package_array_size; i++)) do # 软件安装 if [ ! \u0026#34;$(apt list --installed | grep -wo \u0026#34;${package_array[${i}]}\u0026#34; | head -n 1)\u0026#34; = \u0026#34;${package_array[${i}]}\u0026#34; ]; then echo -e \u0026#34;\\e[34m\u0026#34; sudo apt-get install ${package_array[${i}]} -y echo -e \u0026#34;\\e[0m\u0026#34; if [ ! \u0026#34;$(apt list --installed | grep -wo \u0026#34;${package_array[${i}]}\u0026#34; | head -n 1)\u0026#34; = \u0026#34;${package_array[${i}]}\u0026#34; ]; then echo -e \u0026#34;\\e[31m${package_array[${i}]} 未安装\\e[0m\u0026#34; else echo -e \u0026#34;\\e[32m${package_array[${i}]} 已安装\\e[0m\u0026#34; fi\telse echo -e \u0026#34;\\e[32m${package_array[${i}]} 已安装\\e[0m\u0026#34; fi done\t} if [ \u0026#34;$1\u0026#34; = \u0026#34;run\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;graphic\u0026#34; ]; then\t$qemu_arch -kernel $work_dir/$linux/arch/x86/boot/bzImage -initrd $work_dir/$busybox/initramfs.cpio.gz -append \u0026#34;init=/init\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;run\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;nographic\u0026#34; ]; then\t$qemu_arch -kernel $work_dir/$linux/arch/x86/boot/bzImage -initrd $work_dir/$busybox/initramfs.cpio.gz -nographic -append \u0026#34;init=/init console=ttyS0\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;help\u0026#34; ]; then echo \u0026#34;$0 graphic\u0026#34; echo \u0026#34;$0 nographic\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;run_way\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;graphic\u0026#34; ]; then echo \u0026#34;$qemu_arch -kernel $work_dir/$linux/arch/x86/boot/bzImage -initrd $work_dir/$busybox/initramfs.cpio.gz -append \\\u0026#34;init=/init\\\u0026#34;\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;run_way\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;nographic\u0026#34; ]; then echo \u0026#34;$qemu_arch -kernel $work_dir/$linux/arch/x86/boot/bzImage -initrd $work_dir/$busybox/initramfs.cpio.gz -nographic -append \\\u0026#34;init=/init console=ttyS0\\\u0026#34;\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;default\u0026#34; ]; then tools-install # 判断linux内核是否准备好\twhile true; do if [ ! -f \u0026#34;${work_dir}/$file_linux\u0026#34; ]; then\techo -e \u0026#34;\\e[32m\u0026#34; wget https://mirrors.aliyun.com/linux-kernel/v5.x/$file_linux echo -e \u0026#34;\\e[0m\u0026#34; else echo -e \u0026#34;\\e[32m${file_linux} 已下载\\e[0m\u0026#34; break; fi\tdone # 判断busybox文件是否准备好 while true; do if [ ! -f \u0026#34;${work_dir}/$file_busybox\u0026#34; ]; then echo -e \u0026#34;\\e[33m\u0026#34; # wget --no-check-certificate https://busybox.net/downloads/busybox-1.32.0.tar.bz2 wget --no-check-certificate https://busybox.net/downloads/${file_busybox} echo -e \u0026#34;\\e[0m\u0026#34; else echo -e \u0026#34;\\e[32m$file_busybox 已下载\\e[0m\u0026#34; break; fi\tdone\t# 判断linux内核是否解压 echo -e \u0026#34;\\e[32m\u0026#34; # kernel if [ -d \u0026#34;${work_dir}/$linux\u0026#34; ]; then echo \u0026#34;$linux exists.\u0026#34; else tar xf ${work_dir}/$file_linux -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; # 判断busybox文件是否解压 echo -e \u0026#34;\\e[33m\u0026#34; if [ -d \u0026#34;${work_dir}/$busybox\u0026#34; ]; then echo \u0026#34;$busybox exists.\u0026#34; else tar xf ${work_dir}/$file_busybox -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34;\t# 编译linux内核 echo -e \u0026#34;\\e[32m\u0026#34; cd ${work_dir}/${linux}; make defconfig\t# 在x86_64架构上默认编译x86_64_defconfig make -j$(nproc) echo -e \u0026#34;\\e[0m\u0026#34; # 编译busybox，编译之后把\u0026#34;${busybox}/_install/*\u0026#34;拷贝到rootfs目录下 cd ${work_dir}/${busybox}; if [ ! -f \u0026#34;${work_dir}/${busybox}/_install/bin/busybox\u0026#34; ]; then echo \u0026#34;# 修改配置，选中如下项目，静态编译\u0026#34; echo -e \u0026#34;\\e[31m# Settings ?C\u0026gt; Build Options ?C\u0026gt; [*] Build static binary（no share libs）\\e[0m\u0026#34; echo \u0026#34;# 反选如下项目，否则后续qemu执行会提示 /bin/sh:can\u0026#39;t access tty;job control turned off\u0026#34; echo -e \u0026#34;\\e[31m# Shells ---\u0026gt; [ ] Job control\\e[0m\u0026#34; read -p \u0026#34;仅第一次编译运行时需要进行该操作，回车后要返回该界面可以执行快捷键Ctrl+z，回到menuconfig界面则执行fg，配置完毕后退出并确认保存即可，回车继续\u0026#34; continue; make menuconfig\tfi\tmake -j$(nproc) make install # 制作initramfs cd ${work_dir}/${busybox}/_install/\tmkdir -p proc sys dev tmp touch init chmod +x init cat \u0026gt; init \u0026lt;\u0026lt; \\EOF #!/bin/sh # 挂载一些必要的文件系统 mount -t proc none /proc mount -t sysfs none /sys mount -t tmpfs none /tmp mount -t devtmpfs none /dev echo echo \u0026#34;Hello Linux\u0026#34; # 显示开机消耗时间 echo \u0026#34;This boot took $(cut -d\u0026#39; \u0026#39; -f1 /proc/uptime) seconds\u0026#34; echo # 停留在控制台 exec /bin/sh EOF if [ -f \u0026#34;initramfs.cpio.gz\u0026#34; ]; then echo \u0026#34;initramfs.cpio.gz exists\u0026#34; else find . -print0 | cpio --null -ov --format=newc | gzip -9 \u0026gt; ../initramfs.cpio.gz fi # QEMU运行虚拟机，通过sd卡加载linux内核\t$qemu_arch -kernel $work_dir/$linux/arch/x86/boot/bzImage -initrd $work_dir/$busybox/initramfs.cpio.gz -nographic -device edu -append \u0026#34;init=/init console=ttyS0\u0026#34;\telif [ \u0026#34;$1\u0026#34; = \u0026#34;install\u0026#34; ]; then tools-install fi 参考链接 QEMU启动x86-Linux内核\n使用qemu搭建arm嵌入式linux开发环境\n","date":"2025-03-16T03:26:36.67+08:00","permalink":"https://ynhugo.github.io/p/qemu%E5%90%AF%E5%8A%A8x86-linux%E5%86%85%E6%A0%B8/","title":"QEMU启动x86-Linux内核"},{"content":" Linux 网络编程从入门到进阶 学习指南 网络通信基础 思考一下，如果计算机想要“交朋友”，它们需要怎样互相沟通？正如人们交流需要使用语言一样，计算机通信也必须遵守一套规则 ― 这就是网络协议。\n协议确保信息可以在不同的设备和平台之间清晰、准确地传递。要深入理解协议，我们首先要熟悉两个基础的通信模型：OSI 和 TCP/IP 模型。\nOSI 模型和 TCP/IP 模型 在网络通信的世界里，OSI（开放式系统互联通信参考模型）和 TCP/IP（传输控制协议/网际协议）模型扮演着基础框架的角色。它们各自描述了网络通信的多个层次和阶段，但以不同的方式来分类和处理数据传输的细节。\nOSI模型 OSI（Open Systems Interconnection）模型是一个概念性框架，用于描述网络中不同操作层次的功能。由七层组成，从物理硬件的电气信号（物理层），到应用层（如网页浏览器），每一层都有其独特的功能和协议。\nTCP/IP模型 TCP/IP 模型，则更加贴近实际网络中的运作。Linux 的网络协议栈就是基于该模型实现的。它是基于四层架构，将网络通信过程简化并集中在协议族上，如传输控制协议（TCP）和互联网协议（IP），这两种协议是现代网络通信中最为核心的部分。\n基本概念 地址簿：IP地址和MAC地址 想象一下，互联网是一个巨大的数字城市，而每台计算机或网络设备就像是住在这个城市里的居民。\nIP地址：数字世界的“家庭住址”\n每台设备的 IP 地址就像是它在这个数字城市里的家庭住址。当计算机需要发送信息或访问网络资源时，它会使用目的地设备的 IP 地址来确保信息正确地送达。这个地址有点像是我们现实世界中的邮寄地址，可以根据网络环境的变化而变化（例如，当设备从家庭网络移动到办公室网络时）。\nMAC地址：网络中的“身份证”\n然后，我们有 MAC 地址，这是网络设备的另一个关键标识。每台设备的 MAC 地址都是独一无二的，类似于每个人的身份证号码。它是在设备制造时就被分配的，并且在大多数情况下，这个地址是固定不变的。MAC 地址在本地网络（如家庭或办公室网络）内起着重要作用，它帮助确保信息被准确地送达到特定设备，就像邮递员需要知道收件人的详细身份信息才能将包裹准确递交。\n总结一下 ：ip 地址可以让数据包找到目的主机所在的网络，而 MAC 地址确保数据包能准确送到目的主机上。\n导航路线：子网掩码和网关 子网掩码：定位网络的“区域地图”\n子网掩码可以被视为定位网络内部和外部地址的“区域地图”。就像在一个大城市中，你需要知道哪些街道属于你的社区，哪些通往城市的其他部分。子网掩码帮助计算机确定一个 IP 地址是属于本地网络（即同一个子网）还是位于外部网络。\n内部导航：如果目的地IP地址与计算机所在的子网相匹配（根据子网掩码判断），则数据包在本地网络内传送。 外部导航：如果目的地不在本地子网内，计算机知道它需要将数据发送到更远的目的地。 网关：网络间的“中转站”\n网关在网络通信中扮演中转站的角色。当你的数据包需要从一个网络（比如你的家庭网络）发送到另一个网络（比如你的工作地点的网络）时，网关是这个旅程的第一站。\n路由决策： 网关检查数据包的目的 IP 地址，然后使用它的路由表来决定最佳的路径将数据包发送到目标网络。 总结： 子网掩码和网关共同协作，帮助数据包在复杂的网络结构中找到最有效的路径。子网掩码确定数据包是否在本地网络内，而网关指导跨网络的数据传输。\n端口 ：确保数据到达正确的“应用程序门牌号” 好了，现在我们的数据包已经知道了去哪里，但它如何确保被正确的程序接收呢？这就是端口登场的时候了。端口号就像是收件人的门牌号，确保数据不只是送到了正确的地址，而且被正确的应用程序接收。\nLinux 套接字编程 套接字是什么 在网络编程中，套接字就像是网络世界的通信端口。每一个联网的应用程序，为了能够互发消息，都会使用到这样一个端口。这个端口允许数据从一个程序流向另一个程序。简而言之，套接字是应用程序用来在网络上交流的桥梁。\n想象一下，你要用手机给朋友发一条信息。你只需要知道他们的手机号码，这样信息就可以直接发送到他们的手机上。在网络编程中，套接字的作用类似。它使用IP地址 （类似于手机号码） 来确定数据发送的目标位置，而端口号则像是确定信息应该送达到对方手机中的哪个应用程序。这样，套接字（使用 ip 地址和端口）确保了数据能够准确地发送给正在监听那个特定端口的程序。\n套接字的工作原理：\n套接字的工作原理就像是电话通话的过程。首先，你需要拨打一个号码（即IP地址+端口号）来建立连接。一旦连接建立，电话线（网络连接）就激活了，你的声音（数据）就可以通过它传送。\n在这个过程中：\n拨号 对应于网络编程中的连接 建立 ，这是通过调用套接字API来完成的，比如 connect( )函数。\n通话 对应于 数据传输 ，你可以通过套接字发送 send( ) 和接收 recv( )数据。\n挂断 对应于 结束连接 ，完成通信后，你需要关闭套接字 close( )函数，以结束会话并清理资源。\n在整个通信过程中，套接字保证了数据从一个程序准确地传送到另一个程序，无论这两个程序是在同一台计算机上还是跨越了广阔的互联网。\n在 Linux 中，套接字其实就是一系列的编程接口，Linux 提供了很多特定的 API 来创建和使用套接字，接下来，让我们学习如何使用 Linux 套接字 api 来编写各种网络服务程序。\n套接字类型 在 Linux 中，有三种套接字类型， 前两种是重点掌握的， 第三种了解即可。\nTCP套接字 (SOCK_STREAM):\n这是一种可靠的套接字连接，保证数据传输的完整性和顺序。 必须先建立连接，才能传输数据。 常用于需要准确数据传输的应用，如网页浏览和文件传输。 UDP套接字 (SOCK_DGRAM):\n不需要建立连接，但是数据传输可能会丢失，没有先后顺序。 适用于视频流和在线游戏，这些应用可以容忍一定的数据丢失。 原始套接字 (SOCK_RAW):\n允许直接对较低层次的协议如 IP 或 ICMP 进行访问和操作，它绕过了 TCP 和 UDP 的处理。 开发者可以使用原始套接字来构建自定义的协议或直接处理来自网络的数据包。 通常用于需要进行网络诊断或网络安全应用，如自定义的ping实现，或者网络嗅探器。 选择哪种类型取决于你的应用需求―是否需要可靠传输（TCP），还是速度更快但可能丢失数据也没关系（UDP）。\n选择使用原始套接字通常意味着你需要对网络协议有深入的理解，因为你将直接与网络层面的数据交互。这比处理 TCP 和 UDP 套接字更复杂，通常只在特殊情况下使用，例如网络工具的开发或定制协议的实现。\n套接字常用 API 接下来，看下常用的套接字 API：\n1 2 3 4 5 6 7 8 9 socket() : 创建套接字 bind() : 绑定套接字到本地地址 listen() : 监听网络连接 accept() : 接受网络连接 connect() : 连接到远程主机 send(), recv() : 发送和接收数据（面向连接的套接字） sendto(), recvfrom() : 发送和接收数据（无连接的套接字） close(), shutdown() : 关闭套接字 getsockopt(), setsockopt() : 获取和设置套接字选项 套接字地址结构以及地址转换 API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* sockaddr 是一个通用的套接字地址结构，它通常与特定的地址族结构（如 sockaddr_in ）一起使用。 这是因为多数套接字函数，如 bind(), connect(), 和 accept()，需要使用指向 sockaddr 结构的指针的参数。 */ struct sockaddr { sa_family_t sa_family; /* Address family */ char sa_data[]; /* Socket address */ }; // 套接字地址结构（适用于IPv4网络通信的地址结构） struct sockaddr_in { sa_family_t sin_family; # address family: AF_INET in_port_t sin_port; # port in network byte order struct in_addr sin_addr; # ip address }; struct in_addr { uint32_t s_addr; # address in network byte order }; /* 网络地址转换函数 (用于将IP地址在可打印的格式和二进制结构之间转换) 将点分十进制的IP地址（如\u0026#34;192.168.1.1\u0026#34;）转换成网络字节顺序的二进制形式 inet_pton() 将网络字节顺序的二进制IP地址转换为点分十进制字符串格式 inet_ntop() */ # demo 示例: #define INET_ADDRSTRLEN 16； char str[INET_ADDRSTRLEN]; struct in_addr ipv4addr; inet_pton(AF_INET, \u0026#34;192.168.1.1\u0026#34;, \u0026amp;ipv4addr); inet_ntop(AF_INET, \u0026amp;ipv4addr, str, INET_ADDRSTRLEN); printf(\u0026#34;The IPv4 address is: %s\\n\u0026#34;, str); 完整 demo 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define INET_ADDRSTRLEN 16 int main(void) { char str[INET_ADDRSTRLEN]; struct in_addr ipv4addr; inet_pton(AF_INET, \u0026#34;192.168.1.1\u0026#34;, \u0026amp;ipv4addr); inet_ntop(AF_INET, \u0026amp;ipv4addr, str, INET_ADDRSTRLEN); printf(\u0026#34;The IPv4 address is: %s\\n\u0026#34;, str); return 0; } 字节序转换 API 在网络编程中，字节序（也称为端序）指的是数值在内存中保存的顺序。不同的计算机体系结构可能会采用不同的字节序来表示数据。最常见的两种字节序是大端字节序（Big-Endian）和小端字节序（Little-Endian）。在网络通信中，为了确保数据在不同的系统间正确传输和解释，定义了一个统一的字节序，即：网络字节序，它采用大端字节序。\n由于主机字节序与网络字节序可能不同，因此在发送数据前，发送方需要将其主机字节序的数值转换为网络字节序；接收方收到数据后，需要将网络字节序的数值转换回主机字节序。\nLinux 提供了一组 API 来处理字节序的转换：\n1 2 3 4 5 6 7 8 9 10 11 // 将无符号长整型数/无符号短整型数从主机字节顺序转换为网络字节顺序。 htonl() 和 htons() // 将一个无符号长整型数/无符号短整型数从网络字节顺序转换为主机字节顺序。 ntohl() 和 ntohs() /* 为了方便记忆，大家可以这样理解：h 代表 host(主机)，n 代表 network(网络)， l 代表 long(四字节：代表ip)，s 代表 short（两字节：代表端口） 。 以 htons() 举例，host to network short 即：将端口从主机字节序转成网络字节序。 */ 注意：htonl 和 ntohl 一般处理的是 IP 地址，而 htons 和 ntohs 一般处理的是端口。\n参考链接 Linux 网络编程从入门到进阶 学习指南\n","date":"2025-03-14T19:20:40.36+08:00","permalink":"https://ynhugo.github.io/p/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","title":"Linux 网络编程从入门到进阶 学习指南"},{"content":" 用script命令记录终端的操作和输出信息到文件 script记录会话的一切内容：你输入的内容和你看到的内容。它甚至记录颜色；因此如果你的命令提示符或程序输出中包含颜色，script将记录它。\n记录日志 要使用script，简单执行以下命令：\n1 script 默认情况下，它向当前目录的typescript文件中写入内容。然后，你输入的一切内容都被记录到那个文件中。要往另一个文件中记录日志，只需使用script/path/to/file命令。\n完成记录后，输入exit退出。这个命令将关闭script会话并保存文件。现在你可以使用cat或其它任何程序来检查日志文件。\n使用script的缺点在于，它记录所有特殊的字符；因此你输入的文件中将充满控制字符和ANSI转义序列。你可以在script中使用一个非常简单的shell来解决这个问题：\n1 SHELL=/bin/sh PS1=”$ ” script 使用script时，不要使用交互式程序或处理窗口的程序，如vior top。它们会破坏会话的输出结果。另外，日志文件会记录你使用的任何命令行程序和你完成一项任务所采取的步骤。如果你需要在脚本中编辑一个文件，考虑退出script会话，然后用script ?Ca（它在旧会话后添加新会话）对文件进行编辑后再重新启动会话。\n录制会话 开始录制会话：\n1 2 3 script -t 2\u0026gt;demo.timing -a demo.session 或 script -t 2\u0026gt;timing -t 选项指明输出录制的时间数据 -a 选项则输出录制的文件（附加） 注：使用script时，不要使用交互式程序或处理窗口的程序，如vior top。它们会破坏会话的输出结果。\n甚至可以录制vim的编辑过程\n另外，日志文件会记录你使用的任何命令行程序和你完成一项任务所采取的步骤。如果你需要在脚本中编辑一个文件，考虑退出script会话，然后用script ?Ca（它在旧会话后添加新会话）对文件进行编辑后再重新启动会话。\n结束录制会话：\n1 exit 播放录制会话：\n1 2 3 scriptreplay demo.timing demo.session 或 scriptreplay timing typescript 最后说明：以上两个命令都属于Linux产品util-linux软件包的一部分\n有些linux发行版有script命令但没有scriptreplay命令，scriptreplay命令其实就是一个perl脚本（这意味着录制下的内容在windows也能播放（只要是一个支持ANSI控制码的终端就能再现，cmd下有些乱码），good）大家可以自己找一下util-linux软件包的源代码包，解压后搜索一下scriptreplay 就能找到这个脚本。\n参考链接 用script命令记录终端的操作和输出信息到文件\n","date":"2025-03-14T11:18:04.07+08:00","permalink":"https://ynhugo.github.io/p/%E7%94%A8script%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%E7%BB%88%E7%AB%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E5%88%B0%E6%96%87%E4%BB%B6/","title":"用script命令记录终端的操作和输出信息到文件"},{"content":" 从BSP中创建工程 Petalinux BSP安装 ZCU102 ZU9 ES2 Rev 1.0 BSP v2018.3\nBSP 使用要通过 Petalinux 来进行，因此首先激活 Petalinux 环境。source settings.sh petalinux-create -t project -s \u0026lt;BSP路径\u0026gt;，通过此命令即可使用下载好的 BSP 创建出对应的 Petalinux 工程。\n1 petalinux-create -t project -s xilinx-zcu102-zu9-es2-rev1.0-v2018.3-final.bsp -n prj_1 里面的 Pre-build 即为预先编译好的 images，可以直接拿去用。如果要求不高，至此就已经结束了。 如果想进行一些自定义，里面也有 vivado 工程、也可以像前一篇一样进行 config、build。\n参考链接 https://docs.amd.com/v/u/zh-CN/ug1144-petalinux-tools-reference-guide\nZCU102初步-使用 Petalinux 基于 BSP 构建 Linux\npetalinux驱动实践:起步篇\nZCU102初步-使用 Petalinux 基于 BSP 构建 Linux\nsftp使用技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 删除指定IP连接记录并上传本地公钥到远端 sed -i \u0026#39;/192.168.1.10/d\u0026#39; ~/.ssh/known_hosts; ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.10 # 上传应用程序 sftp root@192.168.1.10 \u0026lt;\u0026lt; EOF cd /run/media/mmcblk0p1 put test_axi_dma_v1/Debug/test_axi_dma_v1.elf EOF # 上传驱动 sftp root@192.168.1.10 \u0026lt;\u0026lt; EOF cd /run/media/mmcblk0p1 put ./build/tmp/sysroots-components/plnx_zynq7/xilinx-axidma/lib/modules/4.14.0-xilinx-v2018.3/extra/xilinx-axidma.ko EOF 如果要上传目录文件，可以加一个-r选项\n参考链接 shell ssh sftp 远程自动部署程序、上传文件，sftp文件上传下载shell脚本\n","date":"2025-03-12T01:21:24.74+08:00","permalink":"https://ynhugo.github.io/p/petalinux-%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97-ug1144/","title":"PetaLinux 工具文档参考指南 (ug1144)"},{"content":" ssh基本配置 /etc/ssh/sshd_config\n1 2 3 4 5 Port 22 PermitRootLogin yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2 PasswordAuthentication yes SSH文件权限设置 为了正确配置.ssh目录及其内涵的文件权限，可以按照以下步骤操作：\n将.ssh目录的权限设置为700：运行以下命令：chmod 700 ~/.ssh；\n将私钥文件的权限设置为600：运行以下命令：chmod 600 ~/.ssh/id_rsa；\n将公钥文件的权限设置为644：运行以下命令：chmod 644 ~/.ssh/id_rsa.pub。\n这样做的目的是，只允许当前用户读写.ssh目录和私钥文件，而其他用户只能读取公钥文件，从而保证.ssh目录和密钥文件的安全性。\n当然，你可以使用如下命令批量化的处理.ssh权限问题：\n1 chmod 600 ~/.ssh/* \u0026amp;\u0026amp; chmod 644 ~/.ssh/*.pub \u0026amp;\u0026amp; chmod 700 ~/.ssh 参考链接 SSH文件权限设置 | chmod 600 ~/.ssh/* \u0026amp;\u0026amp; chmod 644 ~/.ssh/*.pub \u0026amp;\u0026amp; chmod 700 ~/.ssh\nSSH 连接失败: no matching host key type found. Their offer: ssh-rs 1 2 $ ssh root@192.168.1.10 Unable to negotiate with 192.168.1.10 port 22: no matching host key type found. Their offer: ssh-rsa 这个问题经常出现在ssh 服务端版本和客户端版本不匹配。 要解决问题，需要在命令加上一个选项： -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedAlgorithms=+ssh-rsa 比如:\n1 ssh -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedAlgorithms=+ssh-rsa root@192.168.1.10 如果是sftp连接的话，只需要将ssh换成sftp即可，比如：\n1 sftp -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedAlgorithms=+ssh-rsa root@192.168.1.10 也可以加参数加到 ssh config file, /etc/ssh/ssh_config\n1 2 HostKeyAlgorithms = +ssh-rsa PubkeyAcceptedAlgorithms = +ssh-rsa 或者追加到~//.ssh/config文件中也是可以的，如：\n1 2 HostKeyAlgorithms = +ssh-rsa PubkeyAcceptedAlgorithms = +ssh-rsa 另一个选择是在创建密钥对时使用不同的算法。\n要查看 Linux 系统上 SSH 命令支持的算法，可以使用 ssh -Q 命令。具体来说，可以使用以下命令来查看支持的加密算法、散列算法和公钥算法：\n1 2 3 ssh -Q cipher # 查看支持的加密算法 ssh -Q mac # 查看支持的散列算法 ssh -Q key # 查看支持的公钥算法 sshd: no hostkeys available – exiting. 生成 SSH 主机密钥\n1 2 3 4 5 6 7 8 # 生成 RSA 密钥 ssh-keygen -t rsa -f $PREFIX/etc/ssh/ssh_host_rsa_key -N \u0026#34;\u0026#34; # 生成 ECDSA 密钥 ssh-keygen -t ecdsa -f $PREFIX/etc/ssh/ssh_host_ecdsa_key -N \u0026#34;\u0026#34; # 生成 ED25519 密钥 ssh-keygen -t ed25519 -f $PREFIX/etc/ssh/ssh_host_ed25519_key -N \u0026#34;\u0026#34; ubuntu自动配置sshd_config 操作步骤 1 ./sshd_config.sh /etc/ssh/sshd_config 脚本内容-sshd_config.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 # 通过输入sshd_config文件绝对路径来运行该脚本，脚本在运行前会先进行针对sshd_config进行备份，然后再配置 apt install -y openssh-server if [ -f ${1} ]; then cp $1 $1_backup\telse echo \u0026#34;$1 not exists!\u0026#34; fi #删除带有指定关键字的行 delete_line_with_special_word () { if [[ $# -lt 2 ]]; then return fi FILE=$1 WORD=$2 sed -i \u0026#34;/${WORD}/d\u0026#34; ${FILE} } #文件内容追加 append_line_into_file () { if [[ $# -lt 2 ]]; then return fi FILE=$1 LINE=$2 echo do echo $LINE \u0026gt;\u0026gt; $FILE } CONFIG=\u0026#34;/etc/ssh/sshd_config\u0026#34; # CONFIG=\u0026#34;./sshd_config\u0026#34; cp $CONFIG $CONFIG.old string_1=\u0026#34;Port 22\u0026#34; string_2=\u0026#34;PermitRootLogin\u0026#34; string_3=\u0026#34;PubkeyAuthentication\u0026#34; string_4=\u0026#34;AuthorizedKeysFile\u0026#34; string_5=\u0026#34;PasswordAuthentication yes\u0026#34; string_6=\u0026#34;Port 22\u0026#34; string_7=\u0026#34;PermitRootLogin yes\u0026#34; string_8=\u0026#34;PubkeyAuthentication yes\u0026#34; string_9=\u0026#34;AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\u0026#34; string_10=\u0026#34;PasswordAuthentication yes\u0026#34; ## 配置过程 delete_line_with_special_word $CONFIG \u0026#34;$string_1\u0026#34; append_line_into_file $CONFIG \u0026#34;$string_1\u0026#34; delete_line_with_special_word $CONFIG \u0026#34;$string_2\u0026#34; append_line_into_file $CONFIG \u0026#34;$string_7\u0026#34; delete_line_with_special_word $CONFIG \u0026#34;$string_3\u0026#34; append_line_into_file $CONFIG \u0026#34;$string_8\u0026#34; delete_line_with_special_word $CONFIG \u0026#34;$string_4\u0026#34; append_line_into_file $CONFIG \u0026#34;$string_9\u0026#34; delete_line_with_special_word $CONFIG \u0026#34;$string_5\u0026#34; append_line_into_file $CONFIG \u0026#34;$string_10\u0026#34; 客户端.ssh目录下config文件基本配置 .ssh/config\n1 2 3 4 5 6 7 8 9 Host * ServerAliveInterval 60 ServerAliveCountMax 120 Host HostName User Port IdentityFile 这个配置是一个 SSH 配置文件（通常是 ~/.ssh/config）。在这个配置中，ServerAliveInterval 和 ServerAliveCountMax 是全局参数，会应用到所有的主机连接上，而其他的部分是针对特定主机的配置。\nServerAliveInterval 设置为 60 秒表示，无论连接的是哪个主机，客户端都会每隔 60 秒发送一个空闲检查以确认服务器是否活动。 ServerAliveCountMax 设置为 120 表示，无论连接的是哪个主机，客户端都会允许服务器连续未响应 120 次空闲检查，然后才会断开连接。 其他部分（Host、HostName、User、Port、IdentityFile）是用于指定特定主机连接的配置，其中：\nHost 是用于指定主机别名的标识符。 HostName 是指定主机的域名或 IP 地址。 User 是指定连接主机时要使用的用户名。 Port 是指定连接主机时要使用的端口号。 IdentityFile 是指定用于身份验证的私钥文件路径。 如果你想为特定主机设置这些参数，你可以在 Host 后面指定主机别名，然后在其后设置相应的参数。例如：\n1 2 3 4 5 6 Host example.com ServerAliveInterval 60 ServerAliveCountMax 120 User username Port 22 IdentityFile ~/.ssh/id_rsa 这样的话，上述的 ServerAliveInterval 和 ServerAliveCountMax 参数将只会应用到 example.com 主机的连接上，而其他主机的连接则不受影响。\n如何不让ssh连接断开 客户端设置可以确保客户端定期向服务器发送空闲检查，以确保服务器仍然活跃。如果服务器在一段时间内没有响应，客户端可以主动断开连接，避免连接僵死。 服务端设置可以确保服务器定期向客户端发送空闲检查，以确保客户端仍然活跃。如果客户端在一段时间内没有响应，服务器可以主动断开连接，释放资源并提高安全性。 总结：如果客户端和服务端都设置保活选项，就可以确保连接的双向活跃性和稳定性。这样的设置可以在两个方向上都进行检查，以确保连接始终保持活跃，并及时处理失活的连接。\n可以只设置客户端或只设置服务端，这取决于你想要达到的目的，也可以通过同时设置客户端和服务端，可以确保连接的稳定性和可靠性，从而更好地管理连接并提高系统的安全性和稳定性。\n只在客户端设置 SSH 保活选项 您可以在 SSH 客户端的配置文件中设置保活选项，以防止连接因为长时间无活动而断开。这通常在客户端的 ~/.ssh/config 文件中设置：\n1 2 3 Host * ServerAliveInterval 60 ServerAliveCountMax 120 ServerAliveInterval：指定客户端向服务器发送空闲包的时间间隔（秒）。例如，60 表示每 60 秒发送一次。 ServerAliveCountMax：在没有收到任何服务器响应的情况下，客户端发送保活包的最大次数。120 意味着在没有响应的情况下最多发送 120 次。\n优点：客户端可以定期向服务器发送空闲检查，以确保服务器仍然活跃。如果服务器在一段时间内没有响应，客户端可以主动断开连接，这有助于防止连接僵死。 缺点：如果客户端没有设置超时检测（例如服务器端没有响应客户端的空闲检查），可能导致服务器一直保持连接，造成资源浪费。 只在服务器端设置 SSH 保活选项 同样，您也可以在 SSH 服务器端设置保活选项，来防止客户端连接由于超时而断开。在服务器的 SSH 配置文件 /etc/ssh/sshd_config 中设置：\n1 2 ClientAliveInterval 60 ClientAliveCountMax 120 ClientAliveInterval：服务器向客户端发送请求的时间间隔（秒），用于检查客户端是否仍然连接。 ClientAliveCountMax：在没有收到客户端响应的情况下，服务器尝试发送请求的最大次数。\n1 sudo systemctl restart sshd 优点：服务端可以定期向客户端发送空闲检查，以确保客户端仍然活跃。如果客户端在一段时间内没有响应，服务端可以主动断开连接，这有助于释放资源并提高安全性。 缺点：如果服务端没有设置超时检测（例如客户端无法及时响应服务端的空闲检查），可能导致服务端一直保持连接，造成资源浪费。 总结：单独设置客户端或服务端的一个方面可以达到一定的活跃性和稳定性，但是为了最佳效果，建议同时设置客户端和服务端。这可以确保连接在双向上都得到监视和保持活跃，从而更好地管理连接和资源。\nssh连接，如果超过3秒没有连上则断开 要在 SSH 连接时设置超时时间，可以在命令行中直接指定 -o 选项来设置 ConnectTimeout。以下是一个示例：\n1 ssh -o ConnectTimeout=3 user@hostname 在这个命令中，-o ConnectTimeout=3 表示设置连接超时时间为 3 秒。你可以将 user@hostname 替换为实际的用户名和主机名。\n这样，在执行以上命令时，如果连接未能在指定的时间内建立，则会自动断开连接。\n使用 tmux 或 screen 会话 termux教程：https://ynhugo.github.io/p/tmux%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/\nscreen教程：https://ynhugo.github.io/p/screen%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/\n使用 tmux 或 screen 可以在连接断开后保持您的工作会话。即使 SSH 连接断开，您也可以重新连接到同一个 tmux 或 screen 会话，继续之前的工作。\n安装 tmux 或 screen（取决于您的系统）\n1 2 sudo apt install tmux screen -y # 对于 Ubuntu/Debian sudo yum install tmux screen -y # 对于 CentOS/RHEL 开始一个新会话：\n1 tmux 如果连接断开，您可以重新连接：\n1 tmux attach 查看 ssh 版本 1 ssh -V 处理 ssh 版本信息 ssh -V 命令输出的版本信息是直接打印在标准错误输出（stderr）中，而不是标准输出（stdout）。因此需要使用重定向来处理。\n以下是一个示例来提取 OpenSSH 的版本号：\n1 ssh -V 2\u0026gt;\u0026amp;1 | awk \u0026#39;{print $1}\u0026#39; 这个命令将会执行 ssh -V 命令，并将标准错误输出（stderr）转发到标准输出（stdout），然后使用 awk 命令提取第一 个字段，即版本号。\n对于 OpenSSH 版本信息的输出，它通常类似于 \u0026#34;OpenSSH_x.x\u0026#34; 的格式，通过使用 $1 来提取第一个字段，可以获取到版本号。\n判断 ssh 版本 1 2 3 4 5 6 7 8 9 10 11 12 ssh_version=$(ssh -V 2\u0026gt;\u0026amp;1 | awk \u0026#39;{print $1}\u0026#39; | tr \u0026#39;_\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39; | awk -F \u0026#39;p\u0026#39; \u0026#39;{print $1}\u0026#39;) echo \u0026#34;ssh_version: ${ssh_version}\u0026#34; # 将版本号以小数点分隔，并提取整数部分 major_version=$(echo \u0026#34;${ssh_version}\u0026#34; | cut -d \u0026#39;.\u0026#39; -f 1) minor_version=$(echo \u0026#34;${ssh_version}\u0026#34; | cut -d \u0026#39;.\u0026#39; -f 2) if [[ ${major_version} -lt 7 || (${major_version} -eq 7 \u0026amp;\u0026amp; ${minor_version} -lt 8) ]]; then echo \u0026#34;debug_1\u0026#34; else echo \u0026#34;debug_2\u0026#34; fi 注意事项 长时间保持 SSH 连接可能会有安全风险，特别是在公共或不受信任的网络中。 确保您有足够的权限来修改 SSH 配置文件。 在修改服务器配置时，谨慎操作，错误的配置可能会导致无法通过 SSH 连接到服务器。 通过上述方法，您可以有效地防止 SSH 连接因为长时间无活动而断开，提高远程工作的连续性和便捷性。\n参考链接 如何不让ssh连接断开\nssh公钥登录远程服务器配置 每次通过ssh登陆远程服务器都要输入用户名和密码，很麻烦，比如：\n1 ssh 用户名@192.168.xxx.xxx 我们可以通过公钥的方式，无密码登陆远程服务器。\n第一步，ssh-keygen命令生成公钥私钥 全过程有三步，第一步是输入公钥私钥的保存路径，第二步和第三步是设置私钥密码和确认密码。\n1 ssh-keygen 如果是第一次生成公钥，则直接一路回车确认就行。公钥和私钥会自动生成到/Users/[用户名]/.ssh路径下。默认公钥文件名为id_rsa.pub，私钥文件名为id_rsa。如果不想覆盖之前已有的公钥，那在第一步指定一个保存路径即可。\n第二步，使用ssh-copy-id命令将公钥复制到远程服务器 在用户路径下，执行命令：\n1 ssh-copy-id -i .ssh/id_rsa.pub 用户名@192.168.xxx.xxx 注意：\n如果上一步你自己指定了单独的公钥路径，请在-i后面输入指定的公钥路径 这里是将你的公钥同步到远程服务器上你要登录的用户名，所以只会对该用户登录时有效。 本质上，这一步的操作，是将你的公钥追加到服务器/home/[用户名]/.ssh/authorized_keys文件后面。如果你手动复制进去，也可以，但是麻烦哦。\n第三步，检查服务端.ssh/的权限 以上配置之后，就可以无需密码直接登陆了，命令：\n1 ssh 用户名@192.168.xxx.xxx 如果无效，则需要检查服务器.ssh/文件的权限。如果用户组权限有写权限，则用公钥ssh登录是不生效的。需要去除掉用户组的写权限，使用命令：\n1 chmod g-w ./.ssh/ 为什么有这个限制呢？其实思考一下就能理解。因为你想通过公钥快捷登录A用户。而实现方式是将自己的公钥追加到A用户目录下的authorized_keys。这种情况下，如果同用户组的B用户，也有对.ssh/路径下的写权限，那么其他人就可以通过登录B用户，修改A用户下的authorized_keys，将自己的公钥追加进去，这样就可以直接用A用户登录了。所以这会出现漏洞。\n第四步，配置快捷命令 目前为止，登录还需要输入用户名和ip，依旧比较麻烦。我们可以在本地的.ssh/config文件中，配置快捷登录命令。\n将以下格式的信息追加到config文件后面：\n1 2 3 4 Host [你能记住的名字] Hostname [ip] Port [端口] User [登录用户名] 比如：\n默认端口为22，termux的端口为8022，下边这个例子是针对termux的，如果非termux的话将8022改成22即可\n1 2 3 4 Host vipad Hostname 192.168.xx.xx Port 8022 User u0_a77 之后使用命令：\n1 ssh vipad 就可以直接登录了。\n参考链接 快速实战派：ssh公钥登录远程服务器配置\n","date":"2025-03-11T20:46:24+08:00","permalink":"https://ynhugo.github.io/p/ssh%E9%85%8D%E7%BD%AE/","title":"SSH配置"},{"content":" 参考链接 Linux的SOCKET编程详解\nLinux网络通信—-htonl()、htons()、ntohl()、ntohs()四个函数\n实例 server.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /* File Name: server.c ,*/ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;errno.h\u0026gt; #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;netinet/in.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #define DEFAULT_PORT 8000 #define MAXLINE 4096 int main(int argc, char** argv) { int socket_fd, connect_fd; struct sockaddr_in servaddr; char buff[4096]; int n; //初始化Socket if( (socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ) { printf(\u0026#34;create socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } //初始化 memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。 servaddr.sin_port = htons(DEFAULT_PORT);//设置的端口为DEFAULT_PORT //将本地地址绑定到所创建的套接字上 if( bind(socket_fd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) == -1) { printf(\u0026#34;bind socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } //开始监听是否有客户端连接 if( listen(socket_fd, 10) == -1) { printf(\u0026#34;listen socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } printf(\u0026#34;======waiting for client\u0026#39;s request======\\n\u0026#34;); while(1) { //阻塞直到有客户端连接，不然多浪费CPU资源。 if( (connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL)) == -1) { printf(\u0026#34;accept socket error: %s(errno: %d)\u0026#34;,strerror(errno),errno); continue; } //接受客户端传过来的数据 n = recv(connect_fd, buff, MAXLINE, 0); //向客户端发送回应数据 if(!fork()) { //子进程 if(send(connect_fd, \u0026#34;Hello,you are connected!\\n\u0026#34;, 26,0) == -1) perror(\u0026#34;send error\u0026#34;); close(connect_fd); exit(0); } buff[n] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;recv msg from client: %s\\n\u0026#34;, buff); close(connect_fd); } close(socket_fd); } client.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* File Name: client.c ,*/ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;errno.h\u0026gt; #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;netinet/in.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #define MAXLINE 4096 int main(int argc, char** argv) { int sockfd, n,rec_len; char recvline[4096], sendline[4096]; char buf[MAXLINE]; struct sockaddr_in servaddr; if( argc != 2) { printf(\u0026#34;usage: ./client \u0026lt;ipaddress\u0026gt;\\n\u0026#34;); exit(0); } if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { printf(\u0026#34;create socket error: %s(errno: %d)\\n\u0026#34;, strerror(errno),errno); exit(0); } memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(8000); if( inet_pton(AF_INET, argv[1], \u0026amp;servaddr.sin_addr) \u0026lt;= 0) { printf(\u0026#34;inet_pton error for %s\\n\u0026#34;,argv[1]); exit(0); } if( connect(sockfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) \u0026lt; 0) { printf(\u0026#34;connect error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } printf(\u0026#34;send msg to server: \\n\u0026#34;); fgets(sendline, 4096, stdin); if( send(sockfd, sendline, strlen(sendline), 0) \u0026lt; 0) { printf(\u0026#34;send msg error: %s(errno: %d)\\n\u0026#34;, strerror(errno), errno); exit(0); } if((rec_len = recv(sockfd, buf, MAXLINE,0)) == -1) { perror(\u0026#34;recv error\u0026#34;); exit(1); } buf[rec_len] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;Received : %s \u0026#34;,buf); close(sockfd); exit(0); } 编译过程 1 2 make server make client 运行方式 server端 1 ./server 显示结果并等待客户端连接\n1 ======waiting for client\u0026#39;s request====== client端 运行客户端并等待输入消息\n1 2 $ while true; do ./client 127.0.0.1; done send msg to server: 发送一条消息，输入\u0026#34;testSocket\u0026#34;，此时服务器端看到客户端发送过来的消息\n1 2 3 $ ./server ======waiting for client\u0026#39;s request====== recv msg from client: testSocket ","date":"2025-03-06T13:36:20+08:00","permalink":"https://ynhugo.github.io/p/socket%E5%9F%BA%E4%BA%8Etcp%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B/","title":"socket基于tcp通信实例"},{"content":" shc使用 下面是shc比较常用的参数说明，更多参数说明请参考man手册或官方文档。\n参数 参数说明 -h 显示帮助信息并退出 -f 指定需要加密的shell脚本 -v 参数-v表示verbose模式，输出更详细的编译日志 -r 可以在相同操作系统的不同系统中执行，也就是放宽安全限制，生成可再分发的二进制文件 -o 输出文件名，也可以不指定 -f 指定shell脚本名称 -e 指定过期日期 -m 指定过期后的提示信息 -U 使二进制无法被追踪，默认不开启 -H 强化：额外的安全保护,默认不开启,它需要shell不支持参数 shc的离线安装 1 2 3 4 5 wget http://www.datsi.fi.upm.es/~frosal/sources/shc-3.8.9b.tgz tar zxf shc-3.8.9b.tgz cd shc-3.8.9b gcc shc-3.8.9b.c -o shc mv shc /bin/ 参考链接 shc加密shell脚本总结\n","date":"2025-02-27T17:25:50.92+08:00","permalink":"https://ynhugo.github.io/p/shc%E4%BD%BF%E7%94%A8/","title":"shc使用"},{"content":" 十二星座最羡慕哪个星座，太准了！ 十二星座就像是十二种不同的调味品。有的甜美如糖，有的辣得刺激，每一个星座都独具特色，无法替代。我们一出生就被贴上了某个星座的标签，就如同生下来就携带了某种独特的“味道”。然而你是否发现，我们总是倾向于觉得隔壁的菜更香，别人的月亮更圆。你是否也曾好奇，自己最羡慕的是哪个星座呢?\n白羊座 白羊座天生充满冲劲，总是情不自禁表达自己的看法。他们遇到想要做的事情时，几乎是第一时间就会积极行动。每一次的压力和困境对他们来说都是一种推动力，一场战斗。白羊座身上那份坚持和不屈不挠，或许也存在于其他星座中，但当他们看向狮子座时，仿佛狮子座是一位闪耀的英雄。狮子座站在风口浪尖时，散发出的王者气质和雄伟风度，足以令白羊座折服。尽管白羊座勇敢、果断、冲动，但面对狮子座，他们似乎总觉得自己缺少某种元素。狮子座天生的辉煌气质和高贵风范，似乎在白羊面前如此耀眼，令他们产生一种追随的欲望。\n金牛座 金牛座的淡定从容总能给人以深刻印象，他们从容不迫，宛如夏日阳台上的冰凉饮品，慢慢融化，不急不躁。金牛座在理财方面的技巧简直可媲美“财神爷”，这得益于他们精准的逻辑思维。坚持、耐心和恒心，再加上永不言败的信念，对于金牛座来说，一旦决定的事情就如同树根深深扎根，风雨不惧。然而，有时他们也会变得过于执着，陷入孜孜不倦的困境，就像是一个小孩子执意要抓住牛角尖。在这种时候，他们是否也羡慕能够像处女座那样明智地选择放手呢?处女座虽然追求完美，但他们懂得“知足常乐”的道理。在金牛座的内心深处，或许渴望能够像处女座一样，对待不完美的事物时轻松一笑，从容地放下。\n双子座 双子座的人就像童年时玩的拨浪鼓，时而东摇西晃，今天喜欢这个，明天又对另一个感兴趣。问他们原因，他们自己可能也答不上来，似乎只是随风而动。这种三分钟热度的生活态度，有时能逗乐周围的朋友，但也常常让人摸不着头脑。面对天秤座，双子座便自愧不如。为什么呢?因为天秤座总是泰然自若，深谙替他人着想，擅长平衡人际关系。他们就像生活中的小艺术家，对每一个细节都充满审美。双子座心生羡慕，如果能拥有天秤座的淡定和审美，再加上他们自己的反应迅速，岂不是能够无往不利?或许，这便是一个富有创意的完美主义者的理想状态。\n巨蟹座 巨蟹座总是将自己的母性气质表露无遗。他们慷慨大方，心中充满爱意，总是愿意付出一切。然而，这也使他们陷入一个困境：过于容易为爱所困，却时常忘记了自己也需要被爱。相反地，天蝎座在爱情之路上犹如老练的司机，精通何时加速，何时刹车，总能保持合适的距离。他们的爱充满浓烈，却始终保持原则，绝不让自己落入“单相思”的陷阱。面对天蝎座这种既深情又懂得自我保护的方式，巨蟹座内心既羡慕又嫉妒，就好像看到别人品尝着冰淇淋，而自己只能咬一口冰棍。好吧，巨蟹座，也许是时候学习如何给予爱，但同时也别忘了保护好自己。\n狮子座 狮子座，这个星座如同一位昂扬的王者，站在生活的舞台上，那尊贵的姿态不是做作出来的，而是与生俱来的。然而，这样高贵的一位，内心也许隐藏着一丝小小的矫情。在职场上，他们如日中天，但在爱情方面，就像个永远找不到遥控器的人，稍微调整一下频道可能就错过了最佳的一刻。狮子们或许会思考：“我为什么不能更轻松一些，随遇而安呢?”这时，他们眼中或许会闪现双子座的身影。双子座，这位情商高超的老司机，面对爱情的纷扰，如同应对一场午后的茶话会，左一个话题，右一个主题，总能将不愉快转化为趣味盎然的对话。狮子座或许会羡慕这种“口才巧”的缓解和自如。所以，狮子啊，有时也可以尝试放下那王者的光环，与双子一同品味生活中的点点滴滴和趣味之处。\n处女座 处女座，有时候真的过于拘谨。他们就像是寻找世界上最佳红酒的酿酒师，却因为完美主义倾向，纠结于杯子上是否有水渍，而错过了那美妙的味道。内心深处的一点点不自信，导致他们常常担心自己的行为是否得当，选择是否正确，几乎就像是受困于“选择恐惧症”。然而，就在这时，白羊座像是轰隆隆驾驶卡丁车冲入，告诉处女座：生活，就该如此玩耍!白羊的那种“我做了，所以我自豪”的态度，真的能照亮处女座的视野。可否有白羊的那份随性，毫不在乎他人眼光的自信呢?因此，亲爱的处女座，有时放下挑剔的眼光，释放自我，向白羊学习如何欣赏生活中的每个瞬间吧。\n天秤座 天秤座，这一群生来就带有内置平衡仪的人，始终在不断地作出抉择。有时是选择咖啡还是茶，有时则是为了生活中的大事而忧心忡忡。他们散发出温和如微风的气质，每次的犹豫都是为了找到生活中的最佳平衡点。然而，有时平衡是否就意味着束缚呢?尤其当他们望向那群自由自在的射手座时。射手座以行云流水的性格，毫不拘束的个性，以及那种在眨眼间决定要背起行囊环游世界的勇气，实在令天秤座望而生羡。\n天蝎座 天蝎座的人，总是深陷于爱情，同时也能毫不犹豫地表达自己的厌恶之情。一旦遇到心仪的对象，他们会像追踪模式启动般，锁定那颗熠熠生辉的星，然后毫不动摇地勇往直前。然而，这种深情的特质有时也成了他们的负担，因为天蝎座难以轻描淡写地对待情感。在这种时候，柔情似水的双鱼座便显得如此引人羡慕。双鱼座仿佛生活在一个梦幻世界，无论是欢乐还是伤痛，都能在梦境中找到片刻解脱。当双鱼面临分手，他们往往能将其视为人生旅途中的一段插曲，心怀下一个故事而非沉湎于上一个故事。这种心态，着实令天蝎座艳羡不已。若是天蝎能像双鱼一样洒脱，那岂不更为丰富多彩?\n射手座 射手座一直以来都是那个为生活注入欢声笑语的人，如同夏日微风，轻盈自由，毫无拘束。然而，即使微风中偶有尘埃，射手座内心有时也会感到困惑，因其过于专注于当下，往往忽略了长远规划和目标。而摩羯座则像坚实的大山，沉稳地踏着每一步，始终保持自己的方向。他们从容不迫，按部就班，从不动摇的初衷令射手座心生羡慕。试想一下，假如射手座能像摩羯座一样，既能享受当下的愉悦，又能不失对未来的远见，那该有多美好!\n摩羯座 摩羯座，那些一板一眼、稳健可靠的人，似乎天生拥有一份“安全感”。他们就像那些经验丰富的驾驶员，纵使路上风景再美，也不会因为诱人景色而放慢车速，内心深处总怀揣着“目标至上”的信念。然而，世界千变万化，不是每个人都钟情于按部就班的方式。水瓶座，这群伙伴，仿佛是生活中的“弹跳鞋”。在各种情况下，他们能迅速调整态度，应对复杂局面。面对机遇，他们始终灵活应对，仿佛能提前预见一切，知道何时抓住机会。而摩羯座呢，在一旁静观其变，或许心中暗想：“这群水瓶们怎么能如此迅速地调整方向，找到更短、更直接的路线呢?”\n水瓶座 水瓶座，实在是宇宙中的未来主义者，他们天生就带着一种前瞻性，若将世界比喻成一台舞台，水瓶座定是在领奖台上为明日做预演的那位。他们的思维充盈于理想、科学和一份特殊的自我热爱。有时候，我差点怀疑他们是否源自未来。然而，尽管如此与众不同，却还是存在一些微小的遗憾。他们常常为那些闪闪发光的点子所迷，以至于偶尔会忽略最基本的努力。金牛座便如勤奋的耕耘者，安静地耕耘，踏实前行，这让水瓶座不禁怀念起。\n双鱼座 嗯，双鱼座，实在是让人又爱又恨。他们那浓烈如美酒的情感，时常让人陶醉，但也不时让人为之烦心。就像是街头巷尾那些民谣歌手，轻弹吉他，歌声中流露出无尽的情感和摇摆。与此同时，坐在角落里的巨蟹座，犹如老式酒馆中的陈年老酒，稳重、沉淀，不会轻易受到世界的动摇。每当双鱼因风摇摆不定时，总是忍不住想，要是自己也能像巨蟹那样坚持和果断，那该多好啊!生活，总是两面的，一面是飘忽的诗意，另一面则是坚定的现实。双鱼啊，也许你们真的能从巨蟹身上学到，如何在这纷繁的世界里，守护那颗只为真爱跳跃的心。\n参考链接 十二星座最羡慕哪个星座，太准了！\n","date":"2025-02-04T05:10:45.66+08:00","permalink":"https://ynhugo.github.io/p/%E5%8D%81%E4%BA%8C%E6%98%9F%E5%BA%A7%E6%9C%80%E7%BE%A1%E6%85%95%E5%93%AA%E4%B8%AA%E6%98%9F%E5%BA%A7-%E5%A4%AA%E5%87%86%E4%BA%86/","title":"十二星座最羡慕哪个星座-太准了"},{"content":" 适合十二星座的脱单约会地点 十二星座的个性不同，自己的喜好也就不一样。当你和意中人约会时，当然是选在自己熟悉的地方，有利于散发自己的魅力，让脱单更近一步。看看你的脱单约会地点在哪里，下一次约会get!\n白羊座 活泼无厘头的白羊，适合去清吧、夜店这种热闹能带动氛围的地方，白羊活泼开朗的一面能让人放下防备，主动表示好感。\n金牛座 素有小资情怀的金牛，对于一切提高生活品质的地方都有了解，当去到咖啡厅、小资格调的场所，能展现金牛生活美学的一面。\n双子座 善变的双子可以选择的约会地点可以是密室馆、剧本杀、邮轮这类的地方，你能借此环境达到目的，也能激发对方的保护欲。\n巨蟹座 巨蟹其实会很在意对方感受，想要散发自己的魅力，其实就是让对方感觉到自己需要你，而事事总能想周全的地方，可以选择郊游、度假、爬山这类的地方。\n狮子座 狮子座的人向来热情，无论选择哪里，其实都没有太大差别，不过太清冷的地方就不适合狮子发挥了，要选择同样热闹的地方，比如火锅店、步行街、美食街这种地方。\n处女座 处女座比较喜欢吹毛求疵，所以只要是对方选的地方，自己一定会挑这挑那。与其败坏好感，不如让自己舒服点，普通约会场所，如：电影院看一场好评的电影，观后提一些影评建议，能够对印象加分哦!\n天秤座 天秤偶尔在充满艺术氛围的地方，有助于提升天秤的艺文气质。而完美主义的天秤，想要给对方留下好印象，这是个不错的选择。\n天蝎座 霸道的天蝎在选择夜景美，或者是地段高风景好的地方，能激发天蝎的贵气，在这样星河灿烂的夜色下，天蝎的孤傲、忧郁的魅力更能显现出来。\n射手座 选择带有异国风情的小镇、街区，会让射手散发出别样的魅力，而这样的地方往往场景都十分美好。\n魔羯座 摩羯的日常生活会比较单一，在一些养生方面，摩羯会有不少经历分享，在放松的SPA馆/养生馆，轻松的氛围下，沉闷的摩羯反而能自在一些。\n水瓶座 露营类的场所是水瓶约会首选，天时、地利、人和，在这里很容易就能凑成，并且水瓶的人很会找契机，想要脱单，露营地有无限可能噢!\n双鱼座 双鱼在游乐场这种场合里，能发散自己的浪漫天性，对于同行人而言，双鱼就是移动的粉色泡泡发射器，所到之处总能散发爱意。\n参考链接 适合十二星座的脱单约会地点\n","date":"2025-02-04T05:06:21.31+08:00","permalink":"https://ynhugo.github.io/p/%E9%80%82%E5%90%88%E5%8D%81%E4%BA%8C%E6%98%9F%E5%BA%A7%E7%9A%84%E8%84%B1%E5%8D%95%E7%BA%A6%E4%BC%9A%E5%9C%B0%E7%82%B9/","title":"适合十二星座的脱单约会地点"},{"content":" 四象星座的特点与四象星座的关系 我们都知道，十二星座被分为四象星座，分别由风土水火这四个元素组成，风象如风自由自在，火象如火热情灼烧，水象如水温柔流淌，土象如土坚毅顽强，那么你知道四象星座的特点是什么吗?这四象星座恰好对应了中国的五行之说的金木水火土中的三种，以基本的元素来划分，金木水火土之间相生相克，那么四象星座的关系又是怎样呢，小编就在这里，为各位朋友们介绍四象星座的关系，快来看看吧，不容错过的精彩内容!\n【四象星座的特点】 1、风象星座 风象星座对世界充满好奇心，喜欢研究新事物，他们有幽默感，也很会说话，是四象星座中最善于交谈的人。他们喜欢外出交际，认识很多人，这种能力又在众人围绕中增长。风象星座往往能与别人结成很亲密的关系，所以人缘都很不错，还能交到很多一辈子的朋友。\n2、火象星座 火象星座是四象星座中最冲动、任性、热情的。他们极富创造力，喜欢新鲜事物，而且是天生的行动派，乐于助人，喜欢成为众人瞩目的焦点。可以说，他们是天生的领队者，当然了他们也很自我和骄傲，自尊心极强。当火象星座与别人交换观点的时候，精力就会特别充沛，因为火是需要空间来通风的。火象星座也是一个燃烧的星座，一方面他们如同火焰般热情奔放、爆发力十足。另一方面他们又如火般，性急且脾气经常一触即发。\n3、水象星座 水温柔缓和，是大自然所有元素中最稳定的，也是形状最为多变的。这也影响着水象星座，使得他们的性格尤为敏感，容易多愁善感。而且水象星座的人对于感情相对较真，他们浪漫多情，依赖性强，又外刚内柔，总是别扭着不愿意表达自己的想法，又别扭的希望对方能读懂自己的内心。巨蟹座、天蝎座、双鱼座这三个星座又都是绝对的爱情星座，容易在爱情里迷失了自己。\n4、土象星座 土象星座属土，所以他们总是喜欢注重感官的变化，善于用理性的感官来感知周围的世界。土象星座知道什么是适可而止、什么是团结合作、什么是未雨绸缪，他们是优秀的制作者和实施者，他们一般都是一些兢兢业业的，并总能收获想要的回报。土象星座充满雄心壮志和坚定的梦想，并知道要以什么方式去努力实现它们。\n四象星座代表什么?\n风象星座包括天秤座、水瓶座、双子座，风象星座的特点掌管思维和想法，代表着思维、逻辑与反应能力，较多理性色彩，热爱自由，稍显淡漠，是四象星座中最善于交谈的人。\n火象星座包括白羊座、狮子座、射手座。火象星座的性格都是较为活泼开朗，像火一样生机勃勃。而且他们的性格都比较急，做事的风格都较为雷厉风行。\n水象星座包括巨蟹座、天蝎座、双鱼座。比起其他星座，水象星座的特点感性、温和、流动、较为敏感、有依赖性、富有包容性。四象星座中水相星座更加情绪化和直觉化，常常显示出一些超自然的能力。\n土象星座是由金牛座、处女座、摩羯座构成。土象星座充满雄心壮志和坚定的梦想，并知道要以什么方式去努力实现它们。\n【四象星座的关系】 1、火象+火象 爱情：两个火象星座的人的爱情，来得快去得快，两个人都不用担心对方太被动，可是维持下去却有一定难度。\n友谊：两个好朋友都是火象星座的话，自然很合得来;火象星座最讨厌婆婆妈妈的人，可对方恰巧也是雷厉风行，很容易有同样的想法，或者同样的决定。\n2、火象+土象 爱情：这样的组合，通常是火象的一方主动;土象星座是非常腼腆的，也许开始时他们是被动的，可是到了后来往往是他们付出更多。\n友谊：火象和土象的朋友组合，有点秀才遇上兵的感觉;不过火象的行动力和土象的耐性互补，有的时候也可以帮对方一把。\n3、火象+风象 爱情：听说过风助火势吗?圆滑的风象星座，可是在土象喜欢发疯的时候陪着他疯，也可以在他们冲动的时候充当安慰他的智者。\n友谊：风象星座朋友最多，或许火象的朋友不太能为他们分忧，不过他们大概和火象的朋友在一起的时候才能真正的尽兴。\n4、火象+水象 爱情：人都说水火不容，不过也不一定;火象偶尔喜欢发发脾气，不过水象一贯的低调方式真的像水一样可以把火浇灭。\n友谊：水象和火象的朋友组合，在众人面前两人往往是孑然不同的形象;大概只有私下聊天他们才比较可以发觉彼此的共性。\n5、土象+土象 爱情：双方都是痴情的土象星座，多半可以维持比较长久，他们都不要什么冠冕堂皇的东西。\n友谊：两个人都比较严肃，他们之间也许没什么幽默感，但是有绝对的默契，可以在对方最需要的时候伸出援手。\n6、土象+风象 爱情：土象受不了风象穿花蝴蝶的个性;风象星座扑簌迷离的个性，有时会让稳妥的土象星座干着急，或猜疑过多。\n友谊：土象星座的朴素，风象星座永远走在流行的尖端，往往让两位好朋友有些貌离神合;风象星座虽穿梭在人群之中，土象星座却可以当他们最忠实的朋友。\n7、土象+水象 爱情：土象星座过于现实，而水象却过于浪漫幻想，他们的爱情中多半少不了猜疑;但由于双方脾气都不大，倒是并不容易吵起来。\n友谊：敏感的水象星座总是感触比较多，他们总是有太多需要发泄的;而一个土象星0座的朋友则是他们的听众。\n8、风象+风象 爱情：风象和风象的情侣组合，很多都是从朋友开始;所以就算成为情侣，他们之间还是难免会有朋友的影子，有时也喜欢拉着一大堆电灯泡一起玩玩。\n友谊：这样的朋友组合大概是所有组合中话最多的了，他们总是有同样的兴趣爱好;两个爱聊天的风象星座凑到一起就很难叫他们停下来了。\n9、风象+水象 爱情：水象星座什么都喜欢放在心里不说，风象星座总是一副不在意的样子，他们之间大概有太多事情是心照不宣的吧。\n友谊：风象和水象的朋友之间，找话题的多半都是风象的一位，不过易被影响的水象星座，后来也可能会被风象带领得滔滔不绝。\n10、水象+水象 爱情：双方都是浪漫多情的水象，这必定是最浪漫的一对情侣;不过另一面，他们也会因过于的憧憬或幻想而变得不设防。\n友谊：分享心事的最佳朋友组合，别人或许认为水象的他们太敏感，想太多，但是另一位水象星座的朋友或许可以理解他们的心情。\n参考链接 四象星座的特点 四象星座的关系\n","date":"2025-02-04T05:01:17.61+08:00","permalink":"https://ynhugo.github.io/p/%E5%9B%9B%E8%B1%A1%E6%98%9F%E5%BA%A7%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E5%9B%9B%E8%B1%A1%E6%98%9F%E5%BA%A7%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"四象星座的特点与四象星座的关系"},{"content":" 示例 示例1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #!/usr/bin/expect set timeout 5 spawn ssh thc_2 expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\r\u0026#34; exp_continue } } while {1} { expect { \u0026#34;Press\u0026#34; { send \u0026#34;\\n\u0026#34; exp_continue } \u0026#34;y/N\u0026#34; { send \u0026#34;\\n\u0026#34; exp_continue } \u0026#34;root\u0026#34; { break; } }\t} interact 使用示例 1 expect expect-ssh.sh thc_2 示例2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/usr/bin/expect # 检查参数数量 if {$argc \u0026lt; 1} { puts \u0026#34;Usage: $argv0 \u0026lt;target_host\u0026gt;\u0026#34; exit 1 } set target_host [lindex $argv 0] spawn ssh \u0026#34;$target_host\u0026#34; expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\r\u0026#34; exp_continue } } while {1} { expect { \u0026#34;Press\u0026#34; { send \u0026#34;\\n\u0026#34; exp_continue } \u0026#34;y/N\u0026#34; { send \u0026#34;\\n\u0026#34; exp_continue } \u0026#34;root\u0026#34; { break; } }\t} interact 使用方法 1 expect expect-ssh.sh thc_2 参考链接 在 Windows 中使用 Expect\n","date":"2024-12-27T15:49:25.11+08:00","permalink":"https://ynhugo.github.io/p/cygwin%E4%B8%8B%E4%BD%BF%E7%94%A8expect%E6%89%A7%E8%A1%8Cssh%E7%99%BB%E5%BD%95%E7%A4%BA%E4%BE%8B/","title":"cygwin下使用expect执行ssh登录示例"},{"content":" 1 ffmpeg -i black.png -s 400x400 -filter_complex \u0026#34;scale=sws_flags=lanczos\u0026#34; -update 1 -y black.jpg -i black.png -i 选项后跟的是输入文件，在这里是 black.png。它告诉 ffmpeg 要读取的源文件是一个 PNG 图像。\n-s 400x400 -s 选项用于设置输出文件的分辨率。在这里，它将输出图像的尺寸设置为 400x400 像素。即使输入图像的尺寸不是 400x400，ffmpeg 会将其缩放到指定的大小。\n-filter_complex \u0026#34;scale=sws_flags=lanczos\u0026#34; -filter_complex 选项用于指定复杂的过滤器链。在这个命令中，scale=sws_flags=lanczos 是一个图像缩放操作，具体含义如下：\nscale：这是一个 ffmpeg 内置的缩放滤镜，用于调整图像的分辨率。 sws_flags=lanczos：这是 scale 滤镜的参数，sws_flags 选项指定了图像缩放时使用的算法。lanczos 是一种高质量的缩放算法，特别适合用于图像的下采样或上采样，它通常能保持较好的图像质量，减少锯齿现象。 lanczos 算法 lanczos 是一种高质量的滤波算法，使用了三次插值，通常用于图像缩放时提供较好的锐度和较少的失真。它特别适合于需要保持图像细节和质量的情况下进行缩放。\n-update 1 -update 1 选项指示 ffmpeg 使用单个文件输出。每次执行时，它会更新并覆盖目标文件，而不是生成多个文件。适用于输出序列更新，尤其在使用 GIF 或某些类型的图像时有用。\n在这个命令中，-update 1 表示将输入文件处理后，生成并覆盖目标文件 black.jpg。\n","date":"2024-12-27T14:45:14.81+08:00","permalink":"https://ynhugo.github.io/p/ffmpeg%E5%B0%86png%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BAjpg%E5%9B%BE%E7%89%87/","title":"ffmpeg将png图片转换为jpg图片"},{"content":" FFmpeg 将图片转成icon 1 ffmpeg -i black.png -s 48x48 -filter_complex \u0026#34;scale=sws_flags=lanczos\u0026#34; -y test.ico 参数解析 -i black.png：\n这是输入文件参数，指定了要转换的源文件是 black.png。该图片会被读取并作为输入进行处理。 -s 48x48：\n-s 参数指定输出视频/图像的尺寸为 48x48 像素。这个参数会缩放图像到给定的目标尺寸。在这里，输出的图像会被缩放到 48x48 像素。 -filter_complex \u0026#34;scale=sws_flags=lanczos\u0026#34;：\n这是一个复杂滤镜的参数，表示使用 scale 滤镜来对图像进行缩放处理，并设置 sws_flags=lanczos 来指定缩放时使用的算法。\nscale：该滤镜用于对图像进行缩放。在这个命令中，它会对输入的 black.png 图片进行缩放操作，最终将其尺寸调整为 48x48（通过 -s 48x48 参数）。 sws_flags=lanczos：指定在缩放图像时使用 Lanczos 算法。Lanczos 算法是一种高质量的插值算法，常用于图像缩放，特别是在需要高保真度时。相比其他简单的算法（如最近邻插值或双线性插值），Lanczos 能更好地保留细节并减少缩小过程中产生的锯齿状边缘。 -y：\n这个参数表示 FFmpeg 在输出文件时自动覆盖目标文件（如果该文件已存在）。它不需要用户确认即可覆盖文件。 test.ico：\n这是输出文件的名称和格式。在这里，输出的文件名是 test.ico，并且格式为 .ico。FFmpeg 将生成一个包含 48x48 图像的 .ico 文件。 参考链接 【FFmpeg 将图片转成icon】\n","date":"2024-12-27T13:51:00.51+08:00","permalink":"https://ynhugo.github.io/p/ffmpeg-%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%88%90icon/","title":"FFmpeg 将图片转成icon"},{"content":" 从源码构建emacs 获取版本信息 curl http://mirrors.ustc.edu.cn/gnu/emacs/ | grep emacs\n下载最新版本 wget http://mirrors.ustc.edu.cn/gnu/emacs/最新版本emacs.tar.xz\n解压 tar -xf 最新版本emacs.tar.xz\n编译安装emacs 进入目录后执行下面的命令\n1 ./configure --without-x --with-gnutls=no \u0026amp;\u0026amp; chmod +x ./* \u0026amp;\u0026amp; sudo make \u0026amp;\u0026amp; sudo make install 非源码安装 emacs-snapshot 1 2 3 4 5 $sudo add-apt-repository ppa:ubuntu-elisp/ppa $sudo apt update $sudo apt install emacs-snapshot emacs-snapshot-el $emacs-snapshot --version #查看emacs版本 ","date":"2024-12-27T09:22:14.89+08:00","permalink":"https://ynhugo.github.io/p/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAemacs/","title":"从源码构建emacs"},{"content":" IDM 6.38安装与配置 IDM Internet Download Manager 6.38是官方免费版本，为方便下载，专门保存到了百度网盘。\n下载文件 下载链接：IDM 6.38 Build 16 完整版.zip 提取码: u42m 配置UA 1 LogStatistic 直接指定为本机的配置\n参考链接 提速下载：IDM UA配置\n","date":"2024-12-26T19:11:36.64+08:00","permalink":"https://ynhugo.github.io/p/idm_638%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"IDM_638安装与配置"},{"content":" 通过CMD或bat批处理启用或禁用设备 在闲鱼买了一个二手的GPD Win Max2，用了几天后发现触摸屏有一些问题，于是写了一个禁用/启用设备的脚本。\n在设备管理器中查看目标设备的属性-\u0026gt;事件_已配置设备的信息下紧跟着\u0026#34;已配置设备\u0026#34;的字符串，然后通过bat脚本禁用/启用目标设备。\n禁用触摸屏设备驱动 1 pnputil /disable-device \u0026#34;HID\\GXTP7385\u0026amp;Col01\\4\u0026amp;36625b9a\u0026amp;0\u0026amp;0000\u0026#34; 启用触摸屏设备驱动 1 pnputil /enable-device \u0026#34;HID\\GXTP7385\u0026amp;Col01\\4\u0026amp;36625b9a\u0026amp;0\u0026amp;0000\u0026#34; 参考链接 通过CMD或bat批处理启用/禁用设备\n","date":"2024-12-25T23:26:30.4+08:00","permalink":"https://ynhugo.github.io/p/%E9%80%9A%E8%BF%87cmd%E6%88%96bat%E6%89%B9%E5%A4%84%E7%90%86%E5%90%AF%E7%94%A8%E6%88%96%E7%A6%81%E7%94%A8%E8%AE%BE%E5%A4%87/","title":"通过CMD或bat批处理启用或禁用设备"},{"content":" 项目概述 RtspServer 是由 PHZ76 开发的高效、可定制的实时流媒体服务器解决方案。它基于作者编写的网络基础库 xop，允许开发者轻松处理和分发实时音视频流。项目提供了一个名为 DesktopSharing 的示例应用，可以捕获桌面和麦克风声音，并在编码后通过 RTSP 协议进行转发和推流。该项目支持Windows 和 Linux 平台，代码量少，相比于 live555 等经典的流媒体库，RtspServer 更加轻量级，易于集成和二次开发。\n技术分析 支持的编码格式 RtspServer 支持多种音视频编码格式，涵盖了广泛的应用场景：\n视频编码：H.264、H.265 音频编码：G.711A、AAC 传输方式 单播 (Unicast)： RTP_OVER_UDP：通过 UDP 协议传输 RTP 数据，延迟低，但在网络不稳定时可能会丢包。 RTP_OVER_RTSP (TCP)：通过 RTSP 协议在 TCP 连接上传输 RTP 数据，可靠性高，适用于防火墙或 NAT 环境。\n组播 (Multicast)： 适用于需要将同一流媒体数据发送给多个客户端的场景，节省网络带宽。\n心跳检测机制 针对单播传输，RtspServer 内置了心跳检测机制，可以及时发现和处理连接异常，确保数据传输的稳定性。\nRTSP 推流 RtspServer 支持 RTSP 推流功能，使用 TCP 协议进行数据传输，保证了数据的可靠传输，适用于对传输可靠性要求较高的应用场景。\n安全性 RtspServer 内置了摘要认证（Digest Authentication），为服务提供了安全保障，防止未经授权的访问。\n架构分析 RtspServer 的架构主要包括以下组件：\nRTSP Server：处理客户端的 RTSP 请求，包括 SETUP、PLAY、PAUSE、TEARDOWN 等指令，管理会话和媒体流。 Media Session：表示一个媒体会话，包含媒体流的相关信息，如流名称、媒体类型、编码格式等。 Media Source：媒体源，负责提供音视频帧数据，可以来自文件、摄像头、麦克风或其他实时数据源。 RTP Connection：负责通过 RTP 协议发送音视频数据，支持单播和组播传输。 流程分析 客户端连接和会话建立 客户端通过 RTSP 协议发送连接请求到服务器。 RTSP Server 接收到请求后，解析并创建一个新的 Media Session。 为每个媒体流（音频或视频）创建对应的 Media Source。\n媒体数据传输 Media Source 获取音视频数据帧（可能来自编码器或实时采集设备）。 RTP Connection 负责将媒体数据打包成 RTP 包，通过网络传输给客户端。 支持的传输方式包括 RTP_OVER_UDP、RTP_OVER_RTSP 和组播。\n心跳检测和连接维护 为了保持连接的稳定性，服务器会定期发送心跳检测，确认客户端的在线状态。 如果检测到连接异常，服务器会及时释放资源，防止资源泄漏。\nxop 基础库 项目介绍 xop 是 RtspServer 的基础网络库，参考了 muduo 和 live555 的设计，封装了一个简单高效的网络框架，提供了构建高性能网络应用的基础组件。\n功能特性 跨平台支持：兼容 Windows 和 Linux 操作系统。\nWindows 下：使用 select 实现事件循环。 Linux 下：使用 epoll 实现高效的事件通知机制。 事件驱动模型：基于 Reactor 模式，实现非阻塞 IO 和事件驱动。 定时器：提供高精度的定时任务调度。 内存管理：实现了环形缓冲区和内存池，提升内存分配和释放的效率。 日志系统：内置简洁的日志功能，方便调试和运行监控。 EventLoop：事件循环，核心组件，负责监听和分发 IO 事件、定时器事件等。 Channel：通道，封装了文件描述符及其感兴趣的事件类型，如可读、可写等。 TimerQueue：定时器队列，管理所有的定时任务。 Buffer：缓冲区，提供高效的数据读写接口。 Acceptor：监听器，负责接受新的客户端连接。 编译与运行 1 2 3 4 5 git clone https://github.com/PHZ76/RtspServer.git cd RtspServer find ./ -name \u0026#34;*.cpp\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs sed -i s/554/8554/g # 因为手机上面低的端口有安全限制，所以这里将默认的554端口更改为8554，如果是ubuntu的话可以省略该命令 make sudo ./rtsp_h264_file test.h264 测试 客户端使用VLC，选择打开网络串流，在URL栏中填写：\n1 rtsp://192.168.3.33:8554/live 也可以使用ffplay命令播放，播放方式：\n1 2 3 ffplay rtsp://192.168.3.33:8554/live 或 ffplay -x 1920 -y 1080 rtsp://192.168.3.33:8554/live 参考链接 RtspServer:轻量级RTSP服务器和推流器\n","date":"2024-12-24T21:01:00.64+08:00","permalink":"https://ynhugo.github.io/p/termux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7rtsp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E6%8E%A8%E6%B5%81%E5%99%A8rtspserver%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/","title":"termux下实现轻量级RTSP服务器和推流器RtspServer的编译与运行"},{"content":" 项目概述 RtspServer 是由 PHZ76 开发的高效、可定制的实时流媒体服务器解决方案。它基于作者编写的网络基础库 xop，允许开发者轻松处理和分发实时音视频流。项目提供了一个名为 DesktopSharing 的示例应用，可以捕获桌面和麦克风声音，并在编码后通过 RTSP 协议进行转发和推流。该项目支持Windows 和 Linux 平台，代码量少，相比于 live555 等经典的流媒体库，RtspServer 更加轻量级，易于集成和二次开发。\n技术分析 支持的编码格式 RtspServer 支持多种音视频编码格式，涵盖了广泛的应用场景：\n视频编码：H.264、H.265 音频编码：G.711A、AAC 传输方式 单播 (Unicast)： RTP_OVER_UDP：通过 UDP 协议传输 RTP 数据，延迟低，但在网络不稳定时可能会丢包。 RTP_OVER_RTSP (TCP)：通过 RTSP 协议在 TCP 连接上传输 RTP 数据，可靠性高，适用于防火墙或 NAT 环境。\n组播 (Multicast)： 适用于需要将同一流媒体数据发送给多个客户端的场景，节省网络带宽。\n心跳检测机制 针对单播传输，RtspServer 内置了心跳检测机制，可以及时发现和处理连接异常，确保数据传输的稳定性。\nRTSP 推流 RtspServer 支持 RTSP 推流功能，使用 TCP 协议进行数据传输，保证了数据的可靠传输，适用于对传输可靠性要求较高的应用场景。\n安全性 RtspServer 内置了摘要认证（Digest Authentication），为服务提供了安全保障，防止未经授权的访问。\n架构分析 RtspServer 的架构主要包括以下组件：\nRTSP Server：处理客户端的 RTSP 请求，包括 SETUP、PLAY、PAUSE、TEARDOWN 等指令，管理会话和媒体流。 Media Session：表示一个媒体会话，包含媒体流的相关信息，如流名称、媒体类型、编码格式等。 Media Source：媒体源，负责提供音视频帧数据，可以来自文件、摄像头、麦克风或其他实时数据源。 RTP Connection：负责通过 RTP 协议发送音视频数据，支持单播和组播传输。 流程分析 客户端连接和会话建立 客户端通过 RTSP 协议发送连接请求到服务器。 RTSP Server 接收到请求后，解析并创建一个新的 Media Session。 为每个媒体流（音频或视频）创建对应的 Media Source。\n媒体数据传输 Media Source 获取音视频数据帧（可能来自编码器或实时采集设备）。 RTP Connection 负责将媒体数据打包成 RTP 包，通过网络传输给客户端。 支持的传输方式包括 RTP_OVER_UDP、RTP_OVER_RTSP 和组播。\n心跳检测和连接维护 为了保持连接的稳定性，服务器会定期发送心跳检测，确认客户端的在线状态。 如果检测到连接异常，服务器会及时释放资源，防止资源泄漏。\nxop 基础库 项目介绍 xop 是 RtspServer 的基础网络库，参考了 muduo 和 live555 的设计，封装了一个简单高效的网络框架，提供了构建高性能网络应用的基础组件。\n功能特性 跨平台支持：兼容 Windows 和 Linux 操作系统。\nWindows 下：使用 select 实现事件循环。 Linux 下：使用 epoll 实现高效的事件通知机制。 事件驱动模型：基于 Reactor 模式，实现非阻塞 IO 和事件驱动。 定时器：提供高精度的定时任务调度。 内存管理：实现了环形缓冲区和内存池，提升内存分配和释放的效率。 日志系统：内置简洁的日志功能，方便调试和运行监控。 EventLoop：事件循环，核心组件，负责监听和分发 IO 事件、定时器事件等。 Channel：通道，封装了文件描述符及其感兴趣的事件类型，如可读、可写等。 TimerQueue：定时器队列，管理所有的定时任务。 Buffer：缓冲区，提供高效的数据读写接口。 Acceptor：监听器，负责接受新的客户端连接。 编译与运行 1 2 3 4 git clone https://github.com/PHZ76/RtspServer.git cd RtspServer make sudo ./rtsp_h264_file test.h264 测试 客户端使用VLC，选择打开网络串流，在URL栏中填写：\n1 rtsp://192.168.3.33:8554/live 也可以使用ffplay命令播放，播放方式：\n1 2 3 ffplay rtsp://192.168.3.33:8554/live 或 ffplay -x 1920 -y 1080 rtsp://192.168.3.33:8554/live 参考链接 RtspServer:轻量级RTSP服务器和推流器\n","date":"2024-12-24T21:01:00.64+08:00","permalink":"https://ynhugo.github.io/p/ubuntu_20_04%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7rtsp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E6%8E%A8%E6%B5%81%E5%99%A8rtspserver%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/","title":"ubuntu_20_04下实现轻量级RTSP服务器和推流器RtspServer的编译与运行"},{"content":" 无线调试ADB使用配对码链接Android 先决条件 Android 手机需要是 Android 11 以上系统； 电脑上的 Android SDK 工具需要 ≥ 30.0.0 版本，确认方式是：adb –version\n1 2 3 4 5 $ adb --version Android Debug Bridge version 1.0.41 Version 35.0.0-11411520 Installed as D:\\Program Files (x86)\\scrcpy-win64-v2.5\\adb.exe Running on Windows 10.0.19045 Android 手机和电脑需连接在同一 WiFi 网络下；\n配对步骤 当你确认这些条件都具备，那么就可以愉快的开始 Android 11 的无线调试开启步骤了：\n在手机上启用开发者模式 \u0026amp; USB 调试（一般是关于手机 –\u0026gt; 连续点击版本号，直到提示你已进入开发者模式）； 启用无线调试选项； 在询问 要在此网络上允许无线调试吗? 的对话框中，点击允许。 经过第三步的操作，已经成功在手机上开启无线调试服务，点击无线调试 –\u0026gt; 点击使用配对码配对设备 可以看到配对码、ip 和端口号（每次点击都会生成新的）\n在电脑上的终端终端运行 adb pair ipaddr:port, 如下:\n1 2 3 4 5 // ip 和 port 点击无线调试 --\u0026gt; 点击使用配对码配对设备即可获取（每次点击都会生成新的） ~ » adb pair 192.168.3.161:37933 // 当系统提示，输入在 4 中获取到的配对码 Enter pairing code: 662287 Successfully paired to 192.168.3.161:37933 [guid=adb-05KAY1XPBC-hyXNZI] 输入 adb devices -l 即可看到通过无线连接成功的设备，如下：\n1 2 3 ~ » adb devices -l List of devices attached adb-05KAY1XPBC-hyXNZI._adb-tls-connect._tcp. device product:sargo model:Pixel_3a device:sargo transport_id:2 完成这些步骤，接下来我们就可以愉快的写 BUG 去了，更爽的是这些操作是带记忆存储的，也就是说已经成功配对的两个设备（手机和电脑）每次连接到同一个 WiFi 时会自动完成匹配，无需人工干预，简直爆赞！！！\n参考链接 无线调试 ADB 使用配对码链接Android\n","date":"2024-12-13T10:52:52.53+08:00","permalink":"https://ynhugo.github.io/p/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95adb%E4%BD%BF%E7%94%A8%E9%85%8D%E5%AF%B9%E7%A0%81%E9%93%BE%E6%8E%A5android/","title":"无线调试ADB使用配对码链接Android"},{"content":" git使用代理clone 我使用的是ss代理,我在网上也看到了很多的关于设置代理的方案,但是都得不到解决。\n设置全局Config代理。 1 2 git config --global http.proxy http://127.0.0.1:1080 git config --global https.proxy http://127.0.0.1:1080 去除代理设置 1 2 git config --global --unset http.proxy git config --global --unset https.proxy 在我使用过程中一直都没得到解决。\n我在clone的时候直接设置代理克隆，这样快的时候能达到3M/S，简直爽歪歪！\n1 git clone -c http.proxy=\u0026#34;127.0.0.1:1081\u0026#34; https://github.com/syl20bnr/spacemacs 参考链接 git使用代理clone\n","date":"2024-12-08T02:23:37.72+08:00","permalink":"https://ynhugo.github.io/p/git%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86clone/","title":"git使用代理clone"},{"content":" Emacs使用本地elpa镜像 搭建本地镜像源 可以将国内的elpa镜像同步到本地作为自己的镜像源，以清华elpa镜像源为例。\n同步镜像源 国内的elpa镜像源都有同步地址，如清华镜像同步地址为rsync://mirrors.tuna.tsinghua.edu.cn/elpa/,使用 rsync 命令进行同步。\n1 2 3 4 // 查看同步内容 rsync rsync://mirrors.tuna.tsinghua.edu.cn/elpa/ // 将镜像内容同步到本机 ~/elpa 目录下 rsync -avz rsync://mirrors.tuna.tsinghua.edu.cn/elpa/ ~/elpa 等待一段时间即可同步完成。注意同步时要仔细阅读同步要求，尽量不要对镜像服务器造成流量压力。\nemacs 中使用本地镜像 1 2 3 4 5 6 7 ;; emacs 初始化文件中添加以下代码 (setq package-archives \u0026#39;((\u0026#34;gnu\u0026#34; . \u0026#34;~/elpa/gnu/\u0026#34;) (\u0026#34;melpa\u0026#34; . \u0026#34;~/elpa/melpa/\u0026#34;) (\u0026#34;nongnu\u0026#34; . \u0026#34;~/elpa/nongnu/\u0026#34;) (\u0026#34;org\u0026#34; . \u0026#34;~/elpa/org/\u0026#34;) (\u0026#34;melpa-stable\u0026#34; . \u0026#34;~/elpa/stable-melpa/\u0026#34;))) (package-initialize) 添加完成后保存重启emacs，然后使用 M-x package-list-packages 命令既可以查看本地melpa等镜像中的包，而且如果电脑处于断网离线状态，依然可以安装本地镜像中存在的包。\n参考链接 1. Emacs使用本地elpa镜像\n","date":"2024-12-07T23:34:29.36+08:00","permalink":"https://ynhugo.github.io/p/emacs%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0elpa%E9%95%9C%E5%83%8F/","title":"Emacs使用本地elpa镜像"},{"content":" termux下的proot-distro安装的Linux路径 1 2 3 /data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs/ 即 $PREFIX/var/lib/proot-distro/installed-rootfs/ 使用proot-distro安装linux系统时可以看到这个路径，验证完proot-distro安装linux路径位置后，如果不需要linux可以到linux系统路径下将对应的linux系统删除即可。\nproot-distro使用教程 获取linux系统列表 1 proot-distro list 安装linux系统 例如安装ubuntu或debian\n1 2 3 proot-distro install ubuntu 或 proot-distro install debian 删除linux系统 例如安装ubuntu或debian\n1 2 3 proot-distro remove ubuntu 或 proot-distro remove debian ","date":"2024-12-06T20:52:12.52+08:00","permalink":"https://ynhugo.github.io/p/termux%E4%B8%8B%E7%9A%84proot-distro%E5%AE%89%E8%A3%85%E7%9A%84linux%E8%B7%AF%E5%BE%84/","title":"termux下的proot-distro安装的Linux路径"},{"content":" 使用Termux在安卓手机上搭建本地Git服务器 在局域网使用，需要连接Wifi或开热点\n手机正式创建Git的服务仓库 1 git init --bare test.git –bare：表示创建的是裸仓库，我将该裸仓库创建在家目录下了，对应路径为 ~/test.git\n如何使用创建的Git服务仓库 首先，获取Termux的用户名和IP地址，IP地址是IPV4格式的\n获取用户名\n1 whoami\t# 执行该命令后会看到用户名被打印出来 获取ip地址\n1 ifconfig\t# 执行该命令后可以看到IP地址 然后就是使用Git服务仓库了\n例如在Termux中通过 proot-distro 安装的Linux系统，可以进入Termux安装的Linux系统中后可以按照下面的命令格式clone仓库\n1 git clone ssh://username@ipv4:8022/路径 例如\n1 git clone ssh://u0_a223@192.168.3.39:8022/~/test.git 也可以在PC端上按照这个命令格式clone仓库\n注意事项 Git服务仓库本身是不能执行push或pull操作的，需要另外建立一个空目录clone Git服务仓库，然后在clone下的仓库中执行操作后再进行push或pull操作。\n参考链接 使用Termux在安卓手机上搭建本地Git服务器\n","date":"2024-12-06T20:08:21.48+08:00","permalink":"https://ynhugo.github.io/p/%E4%BD%BF%E7%94%A8termux%E5%9C%A8%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0git%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"使用Termux在安卓手机上搭建本地Git服务器"},{"content":" 管理多套Emacs配置 3.1 安装chemacs2 3.1.1 第一步：将当前emacs配置目录改名 如果你是按照本系列教程来进行配置管理的话，你的配置文件目录为： ~/.emacs.d ，那我们需要将这个目录改一下名字，假设我们修改之后的目录为： ~/.emacs.d.default:\n1 mv ~/.emacs.d ~/.emacs.d.default 3.1.2 第二步：克隆此项目 1 git clone https://github.com/plexus/chemacs2.git ~/.emacs.d 然后修改项目中的 chemacs2.el 文件，将 chemacs-profiles-paths 变量中的出现的路径 ~/.emacs-profiles.el 替换成 ~/.emacs.d/.emacs-profiles.el，接着将 chemacs-default-profile-paths 变量中的出现的 ~/.emacs-profile 替换成 ~/.emacs.d/.emacs-profile\n3.1.3 第三步：创建 ~/.emacs-profiles.el 创建 ~/.emacs.d/.emacs-profiles.el 文本文件并填入如下内容，这段内容可以简单理解为：\ndefault: 是这个配置的名称 后面这个是 default 这个配置所在的目录\n1 ((\u0026#34;default\u0026#34; . ((user-emacs-directory . \u0026#34;~/.emacs.d/.emacs.default\u0026#34;)))) 3.1.4 第四步：启动 我们通过以下命令启动 default 这个配置的 Emacs：\n1 emacs --with-profile default 3.2 新增新的环境 3.2.1 第一步：新建新环境所在的目录 假设我们需要新建一个环境 scratch ，第一步就是新建一个目录来装这个环境的相关配置文件，假设我们的文件夹是 ~/.emacs.d.scratch:\n1 mkdir ~/.emacs.d/.emacs.d.scratch 3.2.2 第二步：编辑 ~/.emacs-profiles.el 文件 我们在 ~/.emacs.d/.emacs-profiles.el 文件里添加 scratch 环境的配置：\n1 2 3 ((\u0026#34;default\u0026#34; . ((user-emacs-directory . \u0026#34;~/.emacs.d/.emacs.d.default\u0026#34;))) (\u0026#34;scratch\u0026#34; . ((user-emacs-directory . \u0026#34;~/.emacs.d/.emacs.d.scratch\u0026#34;))) ) 3.2.3 第三步：配置 scratch 环境 我们在 ~/.emacs.d/.emacs.d.scratch 文件夹下，具体配置 scratch 这个环境，这个过程跟你单独配置一个全新的 Emacs 类似。拿我的目录为例，结构大概如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /Users/test/.emacs.d/.emacs.d.scratch ├── README.org ├── config-mirror ├── early-init.el ├── elpa ├── emacs-config.org ├── etc ├── init.el ├── lisp ├── quelpa ├── reveal.js └── var 8 directories, 4 files 你可以在这个目录下写 scratch 这个环境的配置，它不会影响你的 default 以及其他的环境。\n3.2.4 第四步：启动 scratch 环境 我们通过下面的命令来启动 scratch 环境的 Emacs：\n1 emacs --with-profile scratch 然后 Emacs 会以 ~/.emacs.d/.emacs.d.scratch 目录下的配置来启动 Emacs，安装相应的插件。你相当于拥有了一个区别于 default 的一个单独的环境。\n3.3 删除环境 删除环境就更加简单了，直接删除相应环境的配置目录以及在 ~/.emacs.d/.emacs-profiles.el 里的配置行即可。\n参考链接 面向产品经理的Emacs教程：26. 管理多套Emacs配置\nchemacs2\n","date":"2024-12-06T00:11:59.09+08:00","permalink":"https://ynhugo.github.io/p/%E7%AE%A1%E7%90%86%E5%A4%9A%E5%A5%97emacs%E9%85%8D%E7%BD%AE/","title":"管理多套Emacs配置"},{"content":" 命令行操作 1 http_proxy=your-proxy-server-ip:port 前缀. 例如\n1 2 3 http_proxy=http://127.0.0.1:10809 emacs 或在命令行中启动Emacs时加上 -nw http_proxy=http://127.0.0.1:10809 emacs -nw 看是在什么环境下运行Emacs了，有些环境不需要加-nw，例如Cygwin。\n配置文件中操作 1 2 3 (setq url-proxy-services \u0026#39;( (\u0026#34;http\u0026#34; . \u0026#34;127.0.0.1:10809\u0026#34;) )) 参考链接 有些网站 Emacs 访问不了\nemacs启动时设置代理\nemacs使用代理教程\nEmacs 怎么使用代理\n专业 Emacs 入门（四）：基本配置\n","date":"2024-12-03T23:10:28.46+08:00","permalink":"https://ynhugo.github.io/p/%E6%9C%89%E4%BA%9B%E7%BD%91%E7%AB%99emacs%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86/","title":"有些网站Emacs访问不了"},{"content":" 什么是GTD工作法？ GTD是Get Things Done的缩写。\n相关方法的英文网站是：https://gettingthingsdone.com。 这个网站的最后一句话是：\nYour mind is for having ideas, not holding them.®\n所以，很多人描述GTD的思路大致就是，每当你想到一件你无法在接下来的两分钟内把它处理干净的事情，就先把它找固定的地方记录下来，不要用脑子去惦记着。养成了这个习惯，就做到了GTD方法的一大部分（如果你不想更细节地了解GTD，就记一句古话，好记性不如烂笔头）。\nGTD的剩余部分就是一些如何把已经记录下来的事情做好的一些简单有效的好步骤好习惯。如果你还有兴趣看，分五个步骤：\n1）Capture 领悟自己要干啥\n2）Clarify 简单写处理思路，你自己做还是交给别人做，放弃还是暂时搁置还是删除它 （可以用紧急重要四象限法则）\n3）Organize (要点！)整理上述梳理结果，并确保你真的会被提醒到这些事情，所以，用软件记录也许是个好方法\n4）Reflect 没事常看看列表，好知道当下该干点啥，并保持列表更新\n5）Engage 投入注意力，干活 （可以用番茄工作法）\n划重点 GTD工作法能不能用活用好，最关键的是哪一点呢？整理。这步搞定，满盘皆活。整理任务一旦成了习惯，那前面的Clarify，后面的Reflect，都是自然而然的事情。心理压力自然而然就没有了，脑子可以松下来去解决问题了！\n参考链接 什么是GTD工作法？\n","date":"2024-12-01T13:55:39.56+08:00","permalink":"https://ynhugo.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AFgtd%E5%B7%A5%E4%BD%9C%E6%B3%95/","title":"什么是GTD工作法"},{"content":" windows下nginx教程 windows安装nginx 下载对应windows版本的nginx最新版本\n下载链接：https://nginx.org/en/download.html\n运行nginx 下载下来的是一个压缩包，进入解压出来的nginx目录内，然后在当前目录运行cmd，运行方法是在当前的目录的地址栏将路径删掉，然后输入cmd并回车\n修改nginx配置文件 在修改nginx配置文件之前，先前nginx配置文件拷贝一份，这样如果nginx没有配置好还可以用原来的nginx配置文件恢复\nnginx的配置文件在nginx解压目录的conf目录，文件名是 nginx.conf\n打开配置文件查看内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; # \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; # \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } 准备工作 需要做的准备工作，在nginx的解压目录下新建一个myTest目录，再在myTest目录里建images子目录，然后存入图片，将图片命名为test2.png，也可以是其他命名，待会儿在链接里要访问的是test2.png\n修改nginx配置文件内容 修改nginx配置文件内容如下\n监听 8911 端口，通过 localhost 访问，将 / 映射到 myTest/images 下\n此配置是nginx比较精简的配置，events相关的内容必须要有，否则重新加载nginx会报错，http块中的server块则是配置访问的资源了\n1 2 3 4 5 6 7 8 9 10 11 12 13 events { worker_connections 1024; } http { server { listen 8911; server_name localhost; autoindex on; location / { root myTest/images; } } } 然后在cmd窗口重新加载nginx\n打开浏览器访问 localhost:8911/test2.png\nwindows配置其他目录 windows默认nginx运行程序所在目录为根目录，如果要配置其他路径的目录，需要配置绝对路径，并且对于windows的路径中的反斜杠要经过转义处理才能使得访问成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 events { worker_connections 1024; } http { server { listen 8911; server_name localhost;\tlocation / { autoindex on; root d:\\\\share\\\\nginx\\\\yenao_test\\\\images; } } } 配置多个端口显示不同的内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 events { worker_connections 1024; } http { server { listen 8911; server_name localhost;\tlocation / { autoindex on; root d:\\\\share\\\\nginx\\\\yenao_test\\\\images; } } server { listen 8910; server_name localhost;\tlocation / { autoindex on; root myTest/images; } } } 给nginx网页设置密码 设置密码需要 htpasswd，该工具依赖 apache2，因此需要下载 apache2\n下载apache2 官网链接：https://httpd.apache.org/\n下载链接：https://www.apachelounge.com/download/\n下载解压 apache2 的压缩包，在 apache2 的 bin 目录可以看到 htpasswd 程序\n给网页设置密码 在cmd窗口执行行命令，会在nginx目录下生成一个password文件，这行命令最后是设定的用户名叫 yenao，输入这行命令后回车，终端会提示创建并确认密码\n1 htpasswd -c d:/share/nginx/nginx-1.25.3/password yenao 查看生成密码的过程和生成的用户名和密码\n修改或删除密码 删除用户和密码 -D 删除指定的用户\n1 2 htpasswd -D /usr/local/nginx/password username # -D 删除指定的用户 修改用户和密码 1 2 3 4 5 htpasswd -D /usr/local/nginx/password username htpasswd -b /usr/local/nginx/password username passwd # -D 删除指定的用户 # -b htpassswd命令行中一并输入用户名和密码而不是根据提示输入密码 # -p htpassswd命令不对密码进行进行加密，即明文密码 在nginx的配置文件加入关于密码的配置\n需要添加提示输入密码的信息和提供密码文件的路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 events { worker_connections 1024; } http { server { listen 8911; server_name localhost; auth_basic \u0026#34;请输入用户名和密码\u0026#34;; auth_basic_user_file d:\\\\share\\\\nginx\\\\nginx-1.25.3\\\\password; location / { autoindex on; root d:\\\\share\\\\nginx\\\\yenao_test\\\\images; } } server { listen 8910; server_name localhost; location / { autoindex on; root myTest/images; } } } 效果 给整个网站添加密码 给整个网站，跟添加网页密码的操作类似，只是需要将密码相关的配置放在http块下，而不是放在server块下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 events { worker_connections 1024; } http { auth_basic \u0026#34;请输入用户名和密码\u0026#34;; auth_basic_user_file d:\\\\share\\\\nginx\\\\nginx-1.25.3\\\\password; server { listen 8911; server_name localhost; location / { autoindex on; root d:\\\\share\\\\nginx\\\\yenao_test\\\\images; } } server { listen 8910; server_name localhost; location / { autoindex on; root myTest/images; } } } 最终配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 events { worker_connections 1024; } http { charset utf-8; autoindex_exact_size off; autoindex_localtime on; auth_basic \u0026#34;请输入用户和密码\u0026#34;; auth_basic_user_file d:\\\\share\\\\nginx\\\\nginx-1.25.3\\\\password; server { listen 8911; server_name localhost; location / { autoindex on; root d:\\\\share\\\\nginx\\\\yenao_test\\\\images; } } server { listen 8910; server_name localhost; location / { autoindex on; root myTest/images; } } } linux下nginx教程 linux安装nginx 1 apt install nginx -y 运行nginx 1 nginx nginx修改配置后重新加载配置 1 nginx -s reload 配置方式跟配置方法参考上边windows的内容 注意事项 配置完后重新加载失败，需要注意有没有端口占用，最简单粗暴的方式就是将所有的nginx的进程给kill掉 1 ps aux | grep \u0026#34;nginx\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 参考链接 Nginx配置密码访问-访问网页需输入用户名密码\nnginx访问页面 中文乱码 解决方案 server层添加如下配置：\n1 charset utf-8; 也有人说server层和访问路径都要配置一下，可以自己尝试看看效果。\n参考链接 nginx访问页面 中文乱码 解决方案\n","date":"2024-11-29T19:33:34+08:00","permalink":"https://ynhugo.github.io/p/nginx%E7%AC%94%E8%AE%B0/","title":"nginx笔记"},{"content":" PowerShell如何运行脚本 简短说明 介绍如何在 PowerShell 中运行和编写脚本。具体可以查看参考链接。\n长说明 脚本是包含一个或多个 PowerShell 命令的纯文本文件。 PowerShell 脚本具有 .ps1 文件扩展名。\n运行脚本与运行 cmdlet 非常类似。 键入脚本的路径和文件名，然后使用参数提交数据和设置选项。 可以在你的计算机上运行脚本，也可以在另一台计算机上的远程会话中运行脚本。\n编写脚本可以保存命令以供以后使用，并且可以轻松与他人共享。 最重要的是，只需输入脚本路径和文件名即可运行命令。 脚本可以像文件中的单个命令一样简单，也可以像复杂的程序一样广泛。\n脚本具有附加功能，例如 #Requires 特殊注释、参数的使用、对数据部分的支持以及用于安全的数字签名。 还可以为脚本以及脚本中的任何函数编写帮助主题。\n如何运行脚本 在 Windows 上运行脚本之前，需要更改默认的 PowerShell 执行策略。 执行策略不适用于在非 Windows 平台上运行的 PowerShell。\n默认执行策略 Restricted会阻止所有脚本运行，包括在本地计算机上编写的脚本。 有关更多信息，请参阅 about_Execution_Policies。\n执行策略保存在注册表中，因此只需在每台计算机上更改一次。\n若要更改执行策略，请遵循以下过程。\n以管理员身份打开PowerSehll，在命令提示符处，键入：\n1 Set-ExecutionPolicy AllSigned 执行后根据提示输入 A 并回车 、\n1 Set-ExecutionPolicy RemoteSigned 执行后根据提示输入 A 并回车\n更改立即生效。\n参考链接 about_Scripts\n","date":"2024-11-27T00:27:35.06+08:00","permalink":"https://ynhugo.github.io/p/powershell%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","title":"PowerShell如何运行脚本"},{"content":" Emacs的org-mode归档 如果你用org-mode来做TODO管理，那么无法避免的是，随着时间的流逝，被DONE的事件会越来越多，那么TODO被会被夹杂在DONE之间，难以查找。同时，由于后期回顾的需要，你也不想简单地将DONE事件删除掉。这个时候，你就需要归档命令了。归档，就是把你不想天天看到的东西，放到你看不到了，或者不怎么影响你的注意力的地方去。org-mode提供了两种归档方式。\n内部归档 内部归档是在本文件内部给特定子树打上ACHIVED标签或者移动到名为achived的子树中去并打上标签。\n这个被认为是ACIVED的子树，会被移动了本级子树的最末端。 例如有这么一个子树，由三个TODO项目组成。\n1 2 3 4 * blog ** TODO 匈牙利命名法 ** TODO org-mode 归档 ** TODO BillG审查 C-c C-x a 将某一个节点打上ARCHIVE标签。\n1 2 3 4 * blog ** TODO 匈牙利命名法 ** TODO org-mode 归档\t:ARCHIVE: ** TODO BillG审查 C-c C-x A 将当前节点归入一个名为Archive的子树中，并且这个子树是位于当前级别子树的最下方。\n1 2 3 4 5 6 7 8 * blog ** TODO org-mode 归档\t:ARCHIVE: ** TODO BillG审查 ** Archive\t:ARCHIVE: *** TODO 匈牙利命名法 :PROPERTIES: :ARCHIVE_TIME: 2010-01-02 六 18:14 :END: 外部归档 外部归档是指把子树移动到另一个org文件中去。文件名可以自定义。默认情况下，归档的子树会被移动到名为“当年文件名_archived”的文件中去。\nC-c C-x C-s是把当前的节点移到archived文件中去。\n我个人还是更喜欢在文件内部做归档。因为它兼具归档的好处和查找的方便。\n在任何一个树的子树中，只有一个archive子树，只占文档的一行，当你居然查看以前存档的事件时，只能在这个节点上使用\u0026#34;C-TAB\u0026#34;命令即可打开。\n参考链接 Emacs的orgmode [归档］\n","date":"2024-11-26T03:14:07.26+08:00","permalink":"https://ynhugo.github.io/p/emacs%E7%9A%84org-mode%E5%BD%92%E6%A1%A3/","title":"Emacs的org-mode归档"},{"content":" Emacs 使用org-agenda 管理日程 如何使用org设置日程上篇已经介绍完，那现在的重点就是如何查看日程，并且真正将org运用到日常工作中来。之前学习org跨越了很长时间，但一直没有落实到日常应用，所以过一阵子就会忘记，得来的教训就是学习任何语言，工具一定要落实在使用中，纸上谈兵要不得。让我们一起开始使用org-agenda查看，管理及运用设置好的日程。\n纸上得来终觉浅,绝知此事要躬行.\n日程 Agenda 定义完ToDo之后，使用M-x org-agenda 打开日程buffer，可看到当前排的所有日程，并可以直接进行优先级等操作。那如何归纳整理自己的日程表呢，通常我使用多个文件来代表不同的类型。\n日程文件 可以针对不同的任务类型，定义多个日程或任务文件，然后将文件加入全局的日程文件列表，统一纳入org的管理。\n以下来举例： 使用C-h v 查看变量org-agenda-flies，当前有一个文件，现在我们再加入另一个\n打开org文件，使用org-agenda-file-to-front或者快捷键C-c [ 将当前文件加入到全局列表。这样一来，我们定义的日程就会加入到全局列表，使用emacs统一进行管理了。也可以通过emacs配置文件加入。\n然后就可以使用M-x org-agenda a 打开agenda界面了。\n快捷键 功能 C-c [ 将当前文件加入全局列表 C-c ] 将当前文件移除全局列表 C-c C-x \u0026lt; 锁定当前文件即在org agenda的buffer中只显示当前文件的日程（org-agenda-set-restriction-lock） C-c C-x \u0026gt; 解锁(org-agenda-remove-restriction-lock) 可以打开speedbar ，在文件上使用\u0026lt; 和\u0026gt; 来锁定和解锁。\n日程操作 前一章已经介绍过，使用org-agenda打开日程buffer，此时可以选择多种视图方式，以便更加方便的查看日程。\nEmacs 内置了多种视图，下面会一一介绍，首先来看都有哪些操作。\n视图中的操作 其他快捷键及功能：\n快捷键 功能 b daily视图 w weekly视图 n/p 上/下移动光标 N/P 上/下按日程移动光标 SPC 在另一缓冲区显示任务在org文件中的定义的位置 TAB 在另一缓冲区显示任务在org文件中的定义的位置，并且光标跳转至此 L 显示任务在文件中位置并且光标居中 RET 在当前buffer打开文件并跳转 F 打开跟踪模式，即移动光标时，另一buffer显示当前任务的定义处 C-c C-x b 显示任务及子树，并可以设置层数 C-c C-o 打开链接 o 关闭另一个buffer A 打开另一种视图并嵌入到当前视图中 v 弹出多个命令进行选择 f/b 下一天 . 跳转至当天 j 选择日期并跳转 D 包含日记 r 刷新agenda buffer / 通过tag过滤 \u0026lt; 通过类型过滤 ^ 通过 top headline 过滤 = 通过模式匹配过滤 丨 去除所有过滤 t 改变状态 C-S-Left/C-S-Right 改变状态 C-k 删除 C-w 重新归档某项日程 $ 归档，通常是另一个文件 T 显示所有tag : 设置tag , 设置优先级 +/- 或者 S-up/down 设置优先级 z 添加note C-c C-a 附件 C-c C-s 安排日程 C-c C-d 设置deadline S-Left/Right 改变日期 \u0026gt; 改变日期 I 插入clock O 停止上一个clock X 取消当前clock J 跳转之clock处 M-Up/Down 拖拽一个日程 m mark当前日程 * mark所有日程为重点 u 取消mark当前日程 U 取消mark所有日程 M-m 设置/取消当前mark M-× 设置/取消所有mark B bulk action C-x C-w 导出。可以为.html .pdf .ps .org q 退出 x 退出，包括所有相关打开的buffer 太多了，大家通过帮助自己尝试吧。\nWeekly/daily 视图 输入M-x org-agenda 时， 选择a 进入此视图。\n在此视图中，操作在上一节介绍过。大家实践一下，通常使用的也就几个功能，碰到需要用的其他，再来查询具体快捷键。\ntodo 视图 输入M-x org-agenda 时， 选择t/T 进入此视图。 t， 列出所有的todo T，可以选择特殊的key来进行过滤。\nTag和属性过滤视图 输入M-x org-agenda 时， 选择m/M 进入此视图。 m， 根据tag进行过滤\n语法：\n1 2 3 4 5 ‘work’： 选择tag ‘:work:’. ‘work\u0026amp;boss’： 选择tag ‘:work:’ 和 ‘:boss:’. ‘+work-boss’： 选择tag ‘:work:’, 忽略 tag ‘:boss:’. ‘work|laptop’： 选择tag ‘:work:’ 或 ‘:laptop:’. ‘work|laptop+night’：选择有laptop 并且有night的tag 除了tag，还可以使用正则表达式，例如： ‘work+{^boss.*}’ ，选择带有work的tag并且以boss开头\n更多的语法及表达式就不介绍了，有需要时，查文档获取。\nsearch 视图 输入M-x org-agnda 时， 选择s 进入此视图。 根据关键字查找或者正则。\nstuck project视图 输入M-x org-agnda 时， 选择# 进入此视图。 参考了David Allen的GTD方法，一个stuck的project是没有定义下一步action的日程，不会在todo显示\n分类 每个org todo文件都有一个分类，默认就是文件名。\n可以在文件开头加入：\n1 #+CATEGORY: xxx 可以在某项日程中加入属性：\n1 :CATEGORY: xxx 之后在检索过滤时，可以根据分类来进行u过滤\nColumn 视图 列模式在上篇文章已经介绍过。 使用C-c C-x C-c 进入列模式。 此处不介绍了。\n格式 导出时，Html等格式可以定义更多的格式，所以Emacs 可以定义更多的格式。\n例如：\n1 *bold*, /italic/, underlined, =verbatim= and code, 参考链接 Emacs 使用org-agenda 管理日程\n","date":"2024-11-26T02:12:09.84+08:00","permalink":"https://ynhugo.github.io/p/emacs%E4%BD%BF%E7%94%A8org-agenda%E7%AE%A1%E7%90%86%E6%97%A5%E7%A8%8B/","title":"Emacs使用org-agenda管理日程"},{"content":" org-mode任务管理 大多数内容看参考链接内容即可，本文章只列出一些简单的配置，并补充一些内容\n某org文件标题被标记了状态如 TODO、DONE，然后打开该文件执行快捷键 C-c [ 将文件添加入 org-agenda追踪列表，然后执行 org-agenda，在 org-agenda 的窗口中按字母 a 显示本周任务，如果要将追踪的文件移出去，可以执行快捷键 C-c ]。\n任务管理方案 直接插入文件头的任务管理配置 只需要任意一个任务状态设置快捷键即可，其他会默认以任务状态开头字母小写形式表现出来\n1 2 #+SEQ_TODO: REPORT(@/!) BUG(@/!) KNOWNCAUSE(@/!) | FIXED(!) #+SEQ_TODO: TODO(t!) | DONE(!) CANCELED(@/!) 将光标放在这些内容上，输入 C-c C-c 可以直接生效。然后再在用 C-c C-t 即可设置任务状态了。\n任务管理配置文件 只需要任意一个任务状态设置快捷键即可，其他会默认以任务状态开头字母小写形式表现出来\n1 2 3 4 5 6 7 8 (setq org-todo-keywords \u0026#39;((sequence \u0026#34;REPORT(@/!)\u0026#34; \u0026#34;BUG(@/!)\u0026#34; \u0026#34;KNOWNCAUSE(@/!)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;FIXED(!)\u0026#34;) (sequence \u0026#34;TODO(t!)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;CANCELED(@/!)\u0026#34;) )) (global-set-key \u0026#34;\\C-cl\u0026#34; \u0026#39;org-store-link) (global-set-key \u0026#34;\\C-cc\u0026#34; \u0026#39;org-capture) (global-set-key \u0026#34;\\C-ca\u0026#34; \u0026#39;org-agenda) 设置任务等级的方式 在Org-mode中，还针对任务设定了A，B，C三种优先级，在安排日程的时候可以按照优先级进行排序。为任务设定优先级是通过快捷键 S-UP/DOWN 。\n除了 S-UP/DOWN 外，还可以通过快捷键 C-c,C-, 来设置任务优先级\norg-store-link org-store-link 是 Org Mode 中的一个命令，用于将当前缓冲区（比如文件、网页或其他内容）的链接保存到 Org Mode 的链接列表中。这对于创建和管理任务和笔记时非常有用，尤其是当你希望在 Org 文件中引用外部资源时。\n示例 假设你正在浏览一个网页，并希望将其链接保存在 Org 文件中：\n打开网页或文档，按 C-c l （或 M-x org-store-link）。 Org Mode 会将该网页的链接（或者文件名）存储在链接列表中。 接下来，回到你的 Org 文件，按 C-c C-l 来插入这个链接。 org-capture org-capture 是 Org Mode 中的一个命令，允许你快速创建和捕捉新的条目到指定的 Org 文件。通常用于快速记录任务、笔记或者其他相关信息。\norg-agenda org-agenda 是 Org Mode 中的命令，用于显示日程、任务列表以及其他时间表相关的视图。它可以帮助你查看和管理任务的安排。\n快速插入时间戳 C-c ! 直播插入时间戳，只包含年月日，不包含小时和分钟。\nC-c . 可以自定义时间戳，默认是插入年月日，手动输入小时和分钟即可，后边还可以添加定期提醒的选项，这方面我还不太熟练。\n计划时间和截止时间 设置计划时间和截止时间，同样默认是插入年月日，可以自定义时间戳，手动输入小时和分钟即可。\n参考链接 org-mode，最强的任务管理利器，没有之一\n","date":"2024-11-25T03:12:37.76+08:00","permalink":"https://ynhugo.github.io/p/org-mode%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"org-mode任务管理"},{"content":" TPM安装 按照官网的做法，很简单就安装上了，输入下面命令：\ntmux基本配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 把管理器文件安装到`~/.tmux/plugins/tpm`之下 此前这些目录是不存在的 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm # 新建配置文件 vim ~/.tmux.conf # 将下面内容复制到`~/.tmux.conf` # List of plugins set -g @plugin \u0026#39;tmux-plugins/tpm\u0026#39; set -g @plugin \u0026#39;tmux-plugins/tmux-sensible\u0026#39; # Other examples: # set -g @plugin \u0026#39;github_username/plugin_name\u0026#39; # set -g @plugin \u0026#39;git@github.com/user/plugin\u0026#39; # set -g @plugin \u0026#39;git@bitbucket.com/user/plugin\u0026#39; # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run \u0026#39;~/.tmux/plugins/tpm/tpm\u0026#39;\t# 记住，这个必须放在.tumx.conf的底部 使tmux配置生效 1 2 #使其生效 tmux source-file ~/.tmux.conf 快捷键管理插件（可忽略） 安装插件 添加新的插件 ~/.tmux.conf 与 set -g @plugin \u0026#39;...\u0026#39; 按 prefix + I（大写字母i，如我 nstall）来获取插件。 你很好！该插件已克隆到 ~/.tmux/plugins/dir 并已获得。\n卸载插件 从列表中删除（或注释掉）插件。 按 prefix + alt+ u（小写ü在ü n安装）删除插件。 所有插件均已安装到， ~/.tmux/plugins/ 因此您也可以在此处找到插件目录并将其删除。\n键绑定 prefix + I\n从GitHub或任何其他git存储库安装新插件 刷新TMUX环境 prefix + U\n更新插件 prefix + alt+u\n删除/卸载不在插件列表中的插件 命令管理插件 安装插件 像往常一样，需要在中指定插件 .tmux.conf 。运行以下命令以安装插件：\n1 ~/.tmux/plugins/tpm/bin/install_plugins 更新插件 要更新所有已安装的插件：\n1 ~/.tmux/plugins/tpm/bin/update_plugins all 或更新单个插件：\n1 ~/.tmux/plugins/tpm/bin/update_plugins tmux-sensible 删除插件 要删除不在插件列表中的插件：\n1 ~/.tmux/plugins/tpm/bin/clean_plugins tmux复制粘贴插件 使用 tmux-yank 插件改善复制粘贴体验\n直接在 .tmux.conf 中的 List of plugins 下新增插件即可\n1 set -g @plugin \u0026#39;tmux-plugins/tmux-yank\u0026#39; 安装完成后默认使用鼠标选中后,松开鼠标右键即为复制\ntmux永久保存插件(手动) 将插件添加到TPM插件列表中 .tmux.conf ：\n1 set -g @plugin \u0026#39;tmux-plugins/tmux-resurrect\u0026#39; 要保存 Tmux 会话 ， 我们只要按 前缀键 + Ctrl-s 就可以了 。 此时 ，Tmux 状态栏会显示 “Saving …” 字样 ， 完毕后会提示 Tmux 环境已保存 。\nTmux Resurrect 会将 Tmux 会话的详细信息以文本文件形式保存到 ~/.tmux/resurrect 目录 。\n还原则按 前缀键 + Ctrl-r 即可 。\n默认情况下，仅还原保守的程序列表\n1 vi vim nvim emacs man less more tail top htop irssi weechat mutt 我们可能还需要保存当前每个窗格运行的程序。类似 vim, less, man 这些程序 tmux-resurrect 会自动恢复，其他的则需要配置：\n1 set -g @resurrect-processes \u0026#39;ssh mysql redis-server npm\u0026#39; 这个插件可以保存和恢复tmux窗格的内容。\n可以通过添加以下行来启用此功能 .tmux.conf ：\n1 set -g @resurrect-capture-pane-contents \u0026#39;on\u0026#39; tmux永久保存插件(自动) 可能你嫌手动保存和恢复太过麻烦，别担心，这不是问题。Tmux Continuum 在 Tmux Resurrec的基础上更进一步，现在保存和恢复全部自动化了，如你所愿，可以无感使用tmux，不用再担心备份问题。\nTmux Continuum依赖Tmux Resurrect，请保证已安装Tmux Resurrect插件\nTmux Continuum默认每隔15mins备份一次，我设置的是一天一次：\n1 set -g @continuum-save-interval \u0026#39;1440\u0026#39; 关闭自动备份 ，只需设置时间间隔为 0 即可：\n1 set -g @continuum-save-interval \u0026#39;0\u0026#39; 想要在 tmux启动时就恢复最后一次保存的会话环境 ，需增加如下配置：\n1 set -g @continuum-restore \u0026#39;on\u0026#39; # 启用自动恢复 如果不想要启动时自动恢复的功能了，直接移除上面这行就行。想要绝对确定自动恢复不会发生，就在用户根目录下创建一个 tmux_no_auto_restore 空文件（创建命令： touch ~/tmux_no_auto_restore ），该文件存在时，自动恢复将不触发。\n对于tmux高级用户（可能就是你）而言，同时运行多个tmux服务器也是有可能的。你可能并不希望后面启用的几个tmux服务器自动恢复或者自动保存会话。因此Tmux Continuum会优先在第一个启用的tmux服务器中生效，随后启用的tmux服务器不再享受自动恢复或自动保存会话的待遇。\n实际上，不管Tmux Continuum功能有没有启用，或者多久保存一次，我们都有办法从状态栏知晓。Tmux Continuum提供了一个查看运行状态的插值 #{continuum_status} ，它支持 status-right 和 status-left 两种状态栏设置，如下所示：\n1 set -g status-right \u0026#39;Continuum status: #{continuum_status}\u0026#39; tmux运行时， #{continuum_status} 将显示保存的时间间隔（单位为分钟），此时状态栏会显示：\n1 Continuum status: 1440 如果其自动保存功能关闭了，那么状态栏会显示：\n1 Continuum status: off tmux日志 1 set -g @plugin \u0026#39;tmux-plugins/tmux-logging\u0026#39; 记录日志： 在当前窗格中切换（开始/停止）日志记录。\n按键绑定： prefix + shift + p 文件名格式： tmux-#{session_name}-#{window_index}-#{pane_index}-%Y%m%dT%H%M%S.log 文件路径：( 1 $HOME 用户主目录)\n示例文件： ~/tmux-my-session-0-1-20140527T165614.log 截取屏幕日志： 在当前窗格中保存可见文本。等效于“文本截图”。\n按键绑定： prefix + alt + p 文件名格式： tmux-screen-capture-#{session_name}-#{window_index}-#{pane_index}-%Y%m%dT%H%M%S.log 文件路径：（$HOME 用户主目录） 示例文件： tmux-screen-capture-my-session-0-1-20140527T165614.log\n保存完整的历史记录 将完整的窗格历史记录保存到文件。如果您回想起来很方便，则需要记录/保存所有工作。\n按键绑定： prefix + alt + shift + p 文件名格式： tmux-history-#{session_name}-#{window_index}-#{pane_index}-%Y%m%dT%H%M%S.log 文件路径：（$HOME用户主目录）\n示例文件： tmux-history-my-session-0-1-20140527T165614.log 注意 ：此功能取决于 history-limit- 值Tmux在回滚缓冲区中保留的行数。Tmux保留的内容也只会保存到文件中。\nset -g history-limit 50000 在.tmux.conf中使用，对于现代计算机，可以将此选项设置为高数字。\n清除窗格历史记录 按键绑定： prefix + alt + c\n这只是一个便捷键绑定。\n我的配置文件 1 2 3 4 5 6 7 8 9 10 set -g @plugin \u0026#39;tmux-plugins/tpm\u0026#39; set -g @plugin \u0026#39;tmux-plugins/tmux-sensible\u0026#39; # set -g @plugin \u0026#39;tmux-plugins/tmux-yank\u0026#39; # tmux复制粘贴插件 set -g @plugin \u0026#39;tmux-plugins/tmux-resurrect\u0026#39; # tmux永久保存插件(手动) set -g @continuum-save-interval \u0026#39;15\u0026#39; # tmux永久保存插件(自动)，每隔15分钟自动保存一次 # set -g @continuum-save-interval \u0026#39;0\u0026#39; # 关闭自动备份 set -g @continuum-restore \u0026#39;on\u0026#39; # 启用自动恢复，tmux启动时就恢复最后一次保存的会话环境 set -g status-right \u0026#39;Continuum status: #{continuum_status}\u0026#39; # 此时状态栏会显示保存的时间间隔（单位为分钟） set -g @plugin \u0026#39;tmux-plugins/tmux-logging\u0026#39; # tmux日志 set -g history-limit 50000 参考链接 Tmux Plugin Manager使用及具体插件\n","date":"2024-11-24T11:40:45.03+08:00","permalink":"https://ynhugo.github.io/p/tmux-plugin-manager%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B7%E4%BD%93%E6%8F%92%E4%BB%B6/","title":"Tmux Plugin Manager使用及具体插件"},{"content":" Android Studio安装教程 只需要安装 Android Studio 就可以了，也不需要添加环境变量什么的，至少我目前的版本是这样的\n关于我安装的 Android Studio，包含 Android Studio 版本和汉化插件版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Android Studio Ladybug | 2024.2.1 Patch 2 Build #AI-242.23339.11.2421.12550806, built on October 25, 2024 Runtime version: 21.0.3+-12282718-b509.11 amd64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o. Toolkit: sun.awt.windows.WToolkit Windows 11.0 GC: G1 Young Generation, G1 Concurrent GC, G1 Old Generation Memory: 2048M Cores: 16 Registry: ide.experimental.ui=true i18n.locale= Non-Bundled Plugins: com.intellij.zh (242.91) 参考链接 Android Studio开发环境搭建（图文教程）\ngradle–groovy-dsl和kotlin-dsl对比\nAndroid Studio 4以上版本设置成中文\n","date":"2024-11-22T23:26:46.56+08:00","permalink":"https://ynhugo.github.io/p/android_studio%E5%AE%89%E8%A3%85/","title":"Android_Studio安装"},{"content":" 前排提示 如果你准备将公司内网的信息暴露到公网，请在操作之前自行确认是否有信息泄露及安全风险，本文不承担由此带来的任何后果。\n有的时候我们有一些运行在内网的服务，没有公网IP，需要临时暴露在公网供自己或其他人访问，本文探讨了几种可以达到的方法。\n使用比如 ngrok, cloudflared 等等的软件 这种方法应该来说是最简单便捷的，只需要下载安装对应的软件，启动服务即可。这里有一个前提是服务器能连接外网。这里提到的这两个软件都不需要太多配置，可能需要登陆一个账号就可以使用了。目前这两种只支持 http/https 协议，对其他协议还不支持\n通过 iptables 设置 DNAT 来完成 如果你有一台具有公网IP的服务器，可以是在云服务商购买的，且你想暴露的内网服务器和这台服务器在一个局域网内，那么可以使用 iptables 来实现。\n在具有公网IP的服务器上执行下面的命令\n1 iptables -t nat -A PREROUTING -dport 9999 -DNAT 192.168.1.1:9998 即可将对公网IP服务器的 9999 端口的访问转发到 192.168.1.1 的 9998 端口。注意，这里还需要打开 Linux 的转发功能。\n通过 SSH 端口转发来实现内网暴露在公网 这里需要一个具有公网IP的服务器，具体的操作方法有两种\n本地端口转发 1 ssh -L 8080:192.168.1.1:9999 root@10.0.0.3 这个命令的作用如下：通过ssh登陆到 10.0.0.3，然后将对本机 8080 的访问流量通过 10.0.0.3 转发到内部的 192.168.1.1:9999。这样，同事通过访问你的机器，就能访问到对应的服务了。\n远端端口转发 1 ssh -R 9999:192.168.1.1:3456 root@10.0.0.3 这个命令的作用如下：通过ssh登陆到 10.0.0.3，然后将对远端 9999 的访问流量通过本机转发到内部的 192.168.1.1:3456。这样，同事通过访问 10.0.0.3，就能访问到你内网对应的服务 192.168.1.1:3456 了。\n路由器的DMZ及端口转发 这个需要登陆路由器后台，一般来说路由器都是支持这两个功能的，这个适用于路由器拨号就有公网IP的幸运儿。\n通过 VPN 访问 在一台具有公网IP的服务器上部署 VPN 服务，如 openvpn, wireguard。然后通过 peer to peer 的访问来达到\n将服务通过云服务商的负载均衡或者NAT网关暴露 这个也是个办法，具体的操作需要查看每个云的文档\n参考链接 内网服务暴露在公网的几种方式\n","date":"2024-11-20T22:25:09.03+08:00","permalink":"https://ynhugo.github.io/p/%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%9C%A8%E5%85%AC%E7%BD%91%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","title":"内网服务暴露在公网的几种方式"},{"content":" 网页留言板源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, user-scalable=0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;网页留言板\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body { height: 100%; margin: 0; padding: 5px; box-sizing: border-box; } textarea { background-color: #333; border-radius: 10px; width: 80%; height: 80%; display: block; margin: 0 auto; color: #fff; padding: 20px; font-size: 16px; box-sizing: border-box; } textarea::-webkit-input-placeholder { color: #eee; } .action { width: 80%; margin: 10px auto; text-align: right; } .btn { padding: 0 10px; height: 38px; line-height: 38px; min-width: 100px; text-align: center; border: none; border-radius: 4px; user-select: none; -webkit-user-select:none; -moz-user-select:none; -o-user-select:none; } .btn-save { background-color: #409eff; color: #fff; } .btn-del { background-color: #f56c6c; color: #fff; } .btn-copy { background-color: #409eff; color: #fff; height: 20px; line-height: 20px; width: 50px; font-size: 12px; margin-left: 5px; } .copy-box { display: flex; margin-top: 5px; } .copy-input { flex: 1; border: none; padding: 0 10px; border: 1px solid #ddd; } .operation-btn { display: flex; align-items: center; margin-top: 20px; justify-content: space-between; } .time-select { flex: 1; height: 38px; margin-right: 5px; max-width: 220px; } .message-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%); background-color: #fff; padding: 5px; max-width: 250px; border-radius: 4px; z-index: 9999; display: none; } @media (max-width: 900px) { textarea { width: 95%; } .action { width: 95%; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;textarea id=\u0026#34;text-box\u0026#34; class=\u0026#34;\u0026#34; placeholder=\u0026#34;请留言\u0026#34;\u0026gt; \u0026lt;/textarea\u0026gt; \u0026lt;div class=\u0026#34;action copy-box\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;copy-input\u0026#34; readonly value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;button class=\u0026#34;btn btn-copy\u0026#34;\u0026gt;分享留言\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;action operation-btn\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;time-select\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;5分钟销毁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;15分钟销毁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;1小时销毁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;4\u0026#34;\u0026gt;24小时销毁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;5\u0026#34;\u0026gt;7天后销毁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;6\u0026#34;\u0026gt;30天后销毁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;7\u0026#34;\u0026gt;一年后销毁\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;div onselectstart=\u0026#34;return false;\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-del\u0026#34;\u0026gt;清空/删除\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-save\u0026#34;\u0026gt;留言\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 错误信息 --\u0026gt; \u0026lt;div class=\u0026#34;message-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;/clipboard.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const baseUrl = window.location.origin let btnSave = document.querySelector(\u0026#39;.btn-save\u0026#39;) let btnDel = document.querySelector(\u0026#39;.btn-del\u0026#39;) let textBox = document.querySelector(\u0026#39;#text-box\u0026#39;) let timeSelect = document.querySelector(\u0026#39;.time-select\u0026#39;) let copyInput = document.querySelector(\u0026#39;.copy-input\u0026#39;) let btnCopy = document.querySelector(\u0026#39;.btn-copy\u0026#39;) let messageBox = document.querySelector(\u0026#39;.message-box\u0026#39;) let timerid = null let needCopy = false function showMessage(text, time = 1500) { if(timerid){ clearTimeout(timerid) timerid = null } messageBox.innerHTML = text messageBox.style.display = \u0026#39;block\u0026#39; timerid = setTimeout(() =\u0026gt; { messageBox.style.display = \u0026#39;none\u0026#39; }, time) } function getValue(reload=false) { let key = this.getQueryByKey(window.location.href, \u0026#39;k\u0026#39;) if (!key) { key = getQueryByKey(window.location.href, \u0026#39;key\u0026#39;) } if(!key){ textBox.value = \u0026#34;\u0026#34; return } fetch(baseUrl + \u0026#39;/get?k=\u0026#39; + encodeURIComponent(key), { method: \u0026#39;GET\u0026#39;, }).then(function (res) { return res.text() }).then((val) =\u0026gt; { // 赋值 if(!val){ if(!reload){ getValue(true) }else{ textBox.value = val // history.replaceState(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, baseUrl) } return } textBox.value = val // 赋值内容 let shareUrl = baseUrl + \u0026#39;/?k=\u0026#39; + encodeURIComponent(key) let is_block_key = getQueryByKey(window.location.href, \u0026#39;block\u0026#39;) if (!is_block_key){ is_block_key = getQueryByKey(window.location.href, \u0026#39;b\u0026#39;) if (is_block_key){ shareUrl = shareUrl + \u0026#34;\u0026amp;b=\u0026#34; + is_block_key } } copyInput.value = shareUrl // 读取消息有效时间 fetch(baseUrl + \u0026#39;/get?k=time_index_\u0026#39; + encodeURIComponent(key), { method: \u0026#39;GET\u0026#39;, }).then(function (res) { return res.text() }).then((val) =\u0026gt; { if(val){ timeSelect.selectedIndex = val } }) }) } function getQueryByKey(url, name) { if(!url){ return \u0026#34;\u0026#34; } var paths=url.split(\u0026#39;?\u0026#39;) if(paths.length \u0026lt; 2){ return \u0026#34;\u0026#34; } var str = paths[1] var keys = str.split(\u0026#39;\u0026amp;\u0026#39;) var obj = {} keys.forEach((item, idx, data) =\u0026gt; { var arr = item.split(\u0026#39;=\u0026#39;) obj[arr[0]] = decodeURI(arr[1]) }) return obj[name] } function getTime() { var index = timeSelect.selectedIndex let time = timeSelect.options[index].value switch (time) { case \u0026#39;1\u0026#39;: return 5 * 60 case \u0026#39;2\u0026#39;: return 15 * 60 case \u0026#39;3\u0026#39;: return 1 * 60 * 60 case \u0026#39;4\u0026#39;: return 24 * 60 * 60 case \u0026#39;5\u0026#39;: return 7 * 24 * 60 * 60 case \u0026#39;6\u0026#39;: return 30 * 24 * 60 * 60 case \u0026#39;7\u0026#39;: return 12 * 30 * 24 * 60 * 60 default: return 60 * 60 } } function getRandom(m) { // 随机数字 // m = m \u0026gt; 16 ? 16 : m; // var num = Math.random().toString(); // return num.substring(num.length - m); // 随机数字+小写字母 // let letter = [\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;G\u0026#34;,\u0026#34;H\u0026#34;,\u0026#34;I\u0026#34;,\u0026#34;J\u0026#34;,\u0026#34;K\u0026#34;,\u0026#34;L\u0026#34;,\u0026#34;M\u0026#34;,\u0026#34;N\u0026#34;,\u0026#34;O\u0026#34;,\u0026#34;P\u0026#34;,\u0026#34;Q\u0026#34;,\u0026#34;R\u0026#34;,\u0026#34;S\u0026#34;,\u0026#34;T\u0026#34;,\u0026#34;U\u0026#34;,\u0026#34;V\u0026#34;,\u0026#34;W\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;Y\u0026#34;,\u0026#34;Z\u0026#34;] var data = [ \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;, ] m = m \u0026gt; 16 ? 16 : m var str = \u0026#39;\u0026#39; let endnum = data.length - 1 let startnum = 0 for (var i = 0; i \u0026lt; m; i++) { var ram = Math.floor( Math.random() * (endnum - startnum + 1 + startnum) ) str += data[ram] } return str.toUpperCase() } btnSave.addEventListener(\u0026#39;click\u0026#39;, function () { let text = textBox.value let is_block_key = getQueryByKey(window.location.href, \u0026#39;block\u0026#39;) if (!is_block_key) { is_block_key = getQueryByKey(window.location.href, \u0026#39;b\u0026#39;) } let key; if (is_block_key == \u0026#39;true\u0026#39;){ key = getQueryByKey(window.location.href, \u0026#39;key\u0026#39;) if (!key){ key = getQueryByKey(window.location.href, \u0026#39;k\u0026#39;) } } if (!key){ key = getRandom(8) } let shareUrl = baseUrl + \u0026#39;/?k=\u0026#39; + encodeURIComponent(key) if (is_block_key){ shareUrl = shareUrl + \u0026#39;\u0026amp;b=\u0026#39; + encodeURIComponent(is_block_key) } copyInput.value = shareUrl history.replaceState(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, shareUrl) fetch(baseUrl + \u0026#39;/set\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;}, body: JSON.stringify({ \u0026#39;t\u0026#39;: getTime(), \u0026#39;k\u0026#39;: key, \u0026#39;v\u0026#39;: text }) }).then(function () { needCopy = true showMessage(\u0026#39;留言成功，请分享链接\u0026#39;) }) fetch(baseUrl + \u0026#39;/set\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;}, body: JSON.stringify({ \u0026#39;t\u0026#39;: getTime(), \u0026#39;k\u0026#39;: \u0026#39;time_index_\u0026#39;+key, \u0026#39;v\u0026#39;: \u0026#39;\u0026#39;+timeSelect.selectedIndex })}) }); // var saveClipboard = new ClipboardJS(\u0026#39;.btn-save\u0026#39;, { // text: function() { // return shareUrl; // } // }); btnDel.addEventListener(\u0026#39;click\u0026#39;, function () { textBox.value = \u0026#39;\u0026#39; showMessage(\u0026#39;清空成功，长按可删除\u0026#39;) }) var copyClipboard = new ClipboardJS(\u0026#39;.btn-copy\u0026#39;, { text: function() { return copyInput.value; } }); copyClipboard.on(\u0026#39;success\u0026#39;, function(e) { showMessage(\u0026#39;复制成功，请分享链接\u0026#39;) }); timeSelect.addEventListener(\u0026#39;change\u0026#39;, function () { localStorage.setItem(\u0026#39;timeselection\u0026#39;, timeSelect.selectedIndex) }) var lastTouchEnd=0; var btntouchtime=0; function touchstart(){ if(event.touches.length\u0026gt;1){ event.preventDefault(); } } function touchend(){ var now=(new Date()).getTime(); if(now-lastTouchEnd\u0026lt;=300){ event.preventDefault(); } lastTouchEnd=now; } function btntouchstart(){ var now=(new Date()).getTime(); if(event.touches.length\u0026gt;1){ event.preventDefault(); } if(now-btntouchtime\u0026lt;=300){ event.preventDefault(); } btntouchtime = now } //function btntouchend(e){ // var now=(new Date()).getTime(); // if(now-btntouchtime\u0026lt;=300){ // event.preventDefault(); // } //} var timer=null; var touchtime=null; var touchx=0; var touchy=0; var touchstartHander=function(event){ // event.preventDefault(); var now=(new Date()).getTime(); touchtime = now timer=setTimeout(LongPress,500); touchx=0; touchy=0; } var touchmoveHander=function(event){ if(touchx!=0 \u0026amp;\u0026amp; touchy!=0){ event.preventDefault(); clearTimeout(timer); timer=null; } touchx = event.changedTouches[0].pageX; touchy = event.changedTouches[0].pageY; } var touchendHander=function(event){ var now=(new Date()).getTime(); clearTimeout(timer); timer=null; if(now-touchtime\u0026gt;=500){ event.preventDefault(); event.target.disabled = true; setTimeout(function(){ event.target.disabled = false; },100); } return false; } function LongPress(){ let key = getQueryByKey(copyInput.value, \u0026#39;k\u0026#39;) if (!key) { key = getQueryByKey(copyInput.value, \u0026#39;key\u0026#39;) } var supportsVibrate = \u0026#34;vibrate\u0026#34; in window.navigator; if (supportsVibrate) { window.navigator.vibrate(100); } fetch(baseUrl + \u0026#39;/del?k=\u0026#39; + encodeURIComponent(key), { method: \u0026#39;GET\u0026#39;, }).then(function () { copyInput.value = \u0026#39;\u0026#39; textBox.value = \u0026#39;\u0026#39; showMessage(\u0026#39;删除成功\u0026#39;) }) } window.onload = function () { getValue() timeSelect.selectedIndex = localStorage.getItem(\u0026#39;timeselection\u0026#39;) || 6 // 其他功能 document.addEventListener(\u0026#39;touchstart\u0026#39;,touchstart); document.addEventListener(\u0026#39;touchend\u0026#39;,touchend,false); btnCopy.addEventListener(\u0026#39;touchstart\u0026#39;,btntouchstart); // btnCopy.addEventListener(\u0026#39;touchend\u0026#39;,btntouchend,false); btnDel.addEventListener(\u0026#39;touchstart\u0026#39;,btntouchstart); // btnDel.addEventListener(\u0026#39;touchend\u0026#39;,btntouchend,false); btnSave.addEventListener(\u0026#39;touchstart\u0026#39;,btntouchstart); // btnSave.addEventListener(\u0026#39;touchend\u0026#39;,btntouchend,false); // 长按删除 btnDel.addEventListener(\u0026#34;touchstart\u0026#34;,touchstartHander,false); btnDel.addEventListener(\u0026#34;touchmove\u0026#34;,touchmoveHander,false); btnDel.addEventListener(\u0026#34;touchend\u0026#34;,touchendHander,false); btnDel.addEventListener(\u0026#34;mousedown\u0026#34;,touchstartHander,false); btnDel.addEventListener(\u0026#34;mousemove\u0026#34;,touchmoveHander,false); btnDel.addEventListener(\u0026#34;mouseup\u0026#34;,touchendHander,false); document.addEventListener(\u0026#39;gesturestart\u0026#39;, function (event) { event.preventDefault(); }); } function copyText() { if(needCopy){ needCopy = false if (navigator.clipboard) { navigator.clipboard.writeText(copyInput.value) } else { // 选中 copyInput.select() // 复制 document.execCommand(\u0026#39;copy\u0026#39;, true) } } } // document.body.addEventListener(\u0026#39;mouseup\u0026#39;,copyText, true); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考链接 网页在线留言板-工具分享\n","date":"2024-11-20T18:31:12.08+08:00","permalink":"https://ynhugo.github.io/p/%E7%BD%91%E9%A1%B5%E7%95%99%E8%A8%80%E6%9D%BF%E6%BA%90%E7%A0%81/","title":"网页留言板源码"},{"content":" git 本地代码版本与远程仓库版本不一致 push冲突问题 问题一：别人先提交了自己的工作代码到远程仓库，导致自己提交时时，由于自己当前版本落后远程最新版本，导致提交失败。 解决：当前分支落后了远程仓库的分支，推送不进去如何解决呢！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 1. 使用git stash save \u0026#34;暂存\u0026#34; 将自己修改的代码，进行一个本地仓库的临时缓存。 $ git stash save \u0026#34;暂存\u0026#34; Saved working directory and index state On master: 暂存 2. 使用git stash list 查看缓存代码片段。 $ git stash list stash@{0}: On master: 暂存 4. 执行pull命令 将远程仓库更新到本地。 $ git pull origin master 5. 将我们的修改合并到更新后的代码中，stash@{0} 就是我们自己暂存的标记 $ git stash pop stash@{0} 6. 回到自己代码中，合并或删除不需要的代码。 7. git status 查看文件修改状态 8. git checkout 文件名称 （各个文件名之间用空格 隔开） 撤销不需要的提交文件 9. git add 提交文件名称 (各个文件名之间用空格 隔开) 需要提交的文件。不建议直接使用git add . 10. git commit –m” 修改记录说明” 提交到本地仓库 11. git push origin master 是推到远程master库 问题二：在使用git协同开发时，难免会出现不同的人员，同时修改某个文件导致代码冲突的问题。 这时候我们提交代码前，应该首先获取远程最新版本，与本地版本合并。回到代码中解决冲突，再做提交。\n1 2 3 4 5 6 7 8 9 10 11 //查询当前远程的版本 $ git remote -v //获取最新代码到本地(本地当前分支为[master]，获取的远端的分支为[origin/master]) $ git fetch origin master [示例1：获取远端的origin/master分支] $ git fetch origin pin[示例2：获取远端的origin/pin分支] //查看版本差异 $ git log -p master..origin/master [示例1：查看本地master与远端origin/master的版本差异] $ git log -p dev..origin/pin[示例2：查看本地dev与远端origin/dev的版本差异] //合并最新代码到本地分支 $ git merge origin/master [示例1：合并远端分支origin/master到当前分支] $ git merge origin/pin[示例2：合并远端分支origin/dev到当前分支] 问题三：有时候，我们用Git的时候有可能commit提交代码后，发现这一次commit的内容是有错误的 1 2 3 4 那么有两种处理方法： 1、修改错误内容，再次commit一次 2、使用git reset 命令撤销这一次错误的commit https://www.jianshu.com/p/c2ec5f06cf1a 1 git reset --soft HEAD^ 撤销这一次错误的commit 参考链接 git 本地代码版本与远程仓库版本不一致 push冲突问题\n","date":"2024-11-20T10:12:41.29+08:00","permalink":"https://ynhugo.github.io/p/git-%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E8%87%B4-push%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","title":"git 本地代码版本与远程仓库版本不一致 push冲突问题"},{"content":" Git：强制拉取以覆盖本地修改 在本文中，我们将介绍如何使用Git强制拉取以覆盖本地修改。Git是一种分布式版本控制系统，它允许多个开发者在同一时间协同工作，并轻松管理代码的变更。有时候，当我们在本地进行修改后，想要从远程仓库拉取最新的代码时，可能会遇到冲突问题，这时就需要强制拉取以覆盖本地修改。\nGit Pull Git Pull命令用于从远程仓库获取最新的代码并合并到当前分支中。默认情况下，当我们执行Git Pull时，如果存在本地未提交的修改，Git会尝试自动合并远程代码和本地代码。然而，在某些情况下，自动合并可能会导致冲突，这时就需要进行手动干预。\n强制拉取指令 如果我们确定无论如何都要覆盖本地修改，并使用远程仓库最新的代码，就需要使用强制拉取指令。在Git中，有两种方法可以实现强制拉取，一种是使用 git fetch 命令结合 git reset 命令，另一种是使用 git pull 命令的 –force 选项。\n方法一：使用git fetch和git reset命令 步骤如下：\n1.首先，使用git fetch命令获取远程仓库最新的代码，但是不进行合并。\n1 git fetch origin 2.然后，使用git reset命令将当前分支的HEAD指向远程分支的最新commit。\n1 git reset --hard origin/master 这里的origin/master表示远程仓库的主分支。\n3.最后，使用git pull命令进行合并。\n1 git pull origin master 参考链接 Git：强制拉取以覆盖本地修改\n","date":"2024-11-20T10:10:00+08:00","permalink":"https://ynhugo.github.io/p/git%E5%BC%BA%E5%88%B6%E6%8B%89%E5%8F%96%E4%BB%A5%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9/","title":"Git：强制拉取以覆盖本地修改"},{"content":" scrcpy 是一款通过adb远程控制手机的软件，官方有 windows 版本，也有第三方的 mac版。\n软件利用 adb 技术，启动一个服务端，实时获取手机画面并通过网络转发到客户端，也就是 windows 或者mac上，目前没有特别实用的 Android 版。\n如果有旧手机，那么可以通过内网穿透，将 adb 默认的接入端口 5555 映射到公网，即可将旧手机打造成云手机，随时挂机、操作等。\n即便是打开 adb 端口 5555 ，一般情况下，也只能在局域网内使用 ip 访问，如果具备 nas 、或者frp、内网穿透等经验，则可以将手机的调试端口映射到外网，只要映射到外网，则可以随时远程控制\n如果家庭网络有 ipv6、或者运营商提供 ipv4，则只需要在路由器打开网络防火墙，供外部访问即可直接远程控制\n点击下载 Scrcpy For Android\n百度网盘链接：https://pan.baidu.com/s/1vDozKDXevaavt0NM3aHtKg?pwd=turc\n参考链接 Android远程控制手机，scrcpy手机版\nScrcpy for Android\nAndroid远程控制手机，scrcpy手机版\n开机自动执行 shell 的 apk\n","date":"2024-11-18T22:14:38.62+08:00","permalink":"https://ynhugo.github.io/p/android%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%9C%BA-scrcpy%E6%89%8B%E6%9C%BA%E7%89%88/","title":"Android远程控制手机-scrcpy手机版"},{"content":" 内网穿透方法 当本地服务运行时，它会通过端口转发将内容暴露出去，而 frp 的配置文件会将本地端口暴露到外部网络。因此，在修改 frp 配置文件后，相关的本地服务也需要重新启动。例如，如果配置的是 SSH 穿透，在修改 frp 配置后，本地需要重新启动 sshd 服务。类似地，对于 nginx 服务，修改 frp 配置后，也需要执行 nginx -s reload 来重新加载配置。\nssh连接-termux 服务器布置 一、 下载frp arm64！！\n1 2 # 网络好的话 wget https://github.com/fatedier/frp/releases/download/v0.61.0/frp_0.61.0_linux_arm64.tar.gz 二、复制到服务器中解压\n1 2 tar zxvf frp_0.37.0_linux_arm64.tar.gz cd frp_0.37.0_linux_arm64 三、下载 screen 并使用它创建frp服务器端\n可以根据需要修改端口，我这里选择使用默认的，后期根据需要再去修改\n1 2 3 4 pkg install -y screen screen -S frps ./frps -c frps.ini # 退出该screen：Ctrl + a，Ctrl + d frps.ini 1 2 [common] bind_port = 7000 客户端布置 frps与frpc的运行都在同一个设备上的termux中，通过screen创建多个实例来运行frps与fprc\n1 2 3 4 5 screen -S frpc vim frpc.ini\t# 将该配置文件的ssh配置下的默认22端口修改成8022，因为手机上面低的端口有安全限制，所以这里 openssh 默认的 sshd 默认的服务端口号为 8022 ./frpc -c frpc.ini # 退出该screen：Ctrl + a，Ctrl + d sshd\t# 退出screen实例后运行 sshd 命令，使 6000 端口配置生效 fprc.ini 1 2 3 4 5 6 7 8 9 [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = x.x.x.x local_port = 8022 remote_port = 6000 测试frp内网穿透 1 ssh username@x.x.x.x -p 6000 参考链接 【简单易学】frp + tmux 实现内网穿透\nweb访问-nginx 在配置 frp 与 nginx 时，选择使用 TCP 协议而不是 HTTP 协议，是因为 HTTP 协议涉及的配置项较多且相对复杂，尤其是大多数示例都基于域名来进行配置。尽管我拥有域名，但考虑到不想花费过多时间在复杂的配置上，同时也只是想进行简单的验证，因此我选择了使用 TCP 协议。\n服务器布置 一、 下载frp arm64！！\n1 2 # 网络好的话 wget https://github.com/fatedier/frp/releases/download/v0.61.0/frp_0.61.0_linux_arm64.tar.gz 二、复制到服务器中解压\n1 2 tar zxvf frp_0.37.0_linux_arm64.tar.gz cd frp_0.37.0_linux_arm64 三、下载 screen 并使用它创建frp服务器端\n可以根据需要修改端口，我这里选择使用默认的，后期根据需要再去修改\n1 2 3 4 pkg install -y screen screen -S frps ./frps -c frps.ini # 退出该screen：Ctrl + a，Ctrl + d frps.ini 1 2 [common] bind_port = 7000 客户端布置 frps与frpc的运行都在同一个设备上的termux中，通过screen创建多个实例来运行frps与fprc\n1 2 3 4 5 screen -S frpc vim frpc.ini\t./frpc -c frpc.ini # 退出该screen：Ctrl + a，Ctrl + d sshd\t# 退出screen实例后运行 sshd 命令，使 9000 端口配置生效 fprc.ini 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = x.x.x.x local_port = 8022 remote_port = 6000 [nginx] type = tcp local_ip = x.x.x.x local_port = 8080 remote_port = 9000 测试frp内网穿透 浏览器访问\n1 x.x.x.x:9000 参考链接 安卓手机使用Termux搭建web服务器（含frp内网穿透、wake on lan远程唤醒）\n","date":"2024-11-17T18:57:10.9413186+08:00","permalink":"https://ynhugo.github.io/p/termux--frp--screen-%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"termux + frp + screen 实现内网穿透"},{"content":" Ledger进行复式记账-ChatGPT 使用 Ledger 进行复式记账（double-entry bookkeeping）时，可以根据你的消费方式（花呗、借呗、工资银行卡）和消费类别（吃饭、交通费、生活费）设计一个合理的账户结构。Ledger 是一个基于文本的财务管理工具，它通过清晰的借贷记账规则帮助你记录和追踪财务状况。\n以下是一个基本的示例，帮助你将消费、收入以及不同账户之间的交易整理成复式记账的形式。\n账户结构设计 资产账户：\nAssets:Bank:Salary —— 工资银行卡 Assets:PayLater:Huabei —— 花呗 Assets:PayLater:Jiebei —— 借呗 费用账户：\nExpenses:Food —— 吃饭 Expenses:Transportation —— 交通费 Expenses:Living —— 生活费 收入账户：\nIncome:Salary —— 工资收入 示例交易记录 1. 工资收入到账 当你工资收入到账时，使用工资银行卡支付，所以我们会记录从工资账户（Assets:Bank:Salary）到银行账户的转账。\n1 2 3 2024/11/01 工资收入 Assets:Bank:Salary 5000 CNY Income:Salary -5000 CNY 2. 吃饭消费（使用花呗支付） 假设你在餐馆消费了 100 元，使用花呗支付。\n1 2 3 2024/11/02 吃饭 Expenses:Food 100 CNY Assets:PayLater:Huabei -100 CNY 3. 交通费消费（使用借呗支付） 假设你乘坐公交车花费了 20 元，使用借呗支付。\n1 2 3 2024/11/03 交通费 Expenses:Transportation 20 CNY Assets:PayLater:Jiebei -20 CNY 4. 生活费消费（使用工资银行卡支付） 假设你购买日常生活用品花费了 200 元，从工资银行卡支付。\n1 2 3 2024/11/04 生活费 Expenses:Living 200 CNY Assets:Bank:Salary -200 CNY 5. 还花呗账单 假设你还了 100 元花呗账单。\n1 2 3 2024/11/05 还花呗 Assets:Bank:Salary 100 CNY Assets:PayLater:Huabei 100 CNY 6. 还借呗账单 假设你还了 20 元借呗账单。\n1 2 3 2024/11/06 还借呗 Assets:Bank:Salary 20 CNY Assets:PayLater:Jiebei 20 CNY 账户结余 使用 Ledger，你可以通过命令 ledger register 或 ledger balance 来查看各个账户的余额。例如：\n1 ledger register Assets 这会显示各个资产账户的余额，包括工资银行卡、花呗和借呗的余额。\n总结 资产账户 用来记录你的银行卡、花呗和借呗等账户的余额。 费用账户 用来记录不同类别的消费（如吃饭、交通费、生活费）。 每一笔消费都需要有两个条目：一条是从支付方式账户（如银行卡、花呗、借呗）减少钱款，另一条是将金额记录到相应的费用账户中。 你可以根据自己的实际情况进一步扩展和调整这些账户分类和交易记录，使得 Ledger 更符合你的需求。\nledger记账工具导出文件 导出表格 1 2 3 ledger bal -f ledger.ledger -o test.csv 或 ledger reg -f ledger.ledger -o test.csv 导出其他文件 1 2 3 ledger bal -f ledger.ledger -o test.txt 或 ledger reg -f ledger.ledger -o test.txt 也可以导出为.md文件或.org文件，只需要更改后缀即可。\nledger记账工具查看指定时间范围的记账情况 1 ledger -f ledger_1.ledger bal --begin 12/13 --end 12/14 参考链接 Ledger \u0026amp; ledger-mode 学习知识点总结\n","date":"2024-11-11T04:57:15.7129566+08:00","permalink":"https://ynhugo.github.io/p/ledger%E8%BF%9B%E8%A1%8C%E5%A4%8D%E5%BC%8F%E8%AE%B0%E8%B4%A6/","title":"Ledger进行复式记账"},{"content":" 操作步骤 在org文件开头添加以下内容：\n然后输入自定义的 insert-timestamp-entry 插入记账模板\n然后在第一行按\\C-c\\C-x\\C-c统计记账，按\\C-c\\C-c取消统计\norg-mode记账模板-配置代码-ChatGPT 1 2 3 4 5 6 (defun insert-timestamp-entry () \u0026#34;Insert a new entry with Money empty and Date set to current date with time (including seconds).\u0026#34; (interactive) (let ((current-date (format-time-string \u0026#34;%Y/%m/%d %H:%M:%S\u0026#34;))) ;; 获取当前日期和时间（包括秒） (insert (format \u0026#34;** \\n :PROPERTIES:\\n :Money: \\n :Date: %s\\n :END:\\n\u0026#34; current-date)))) 代码解析 让我们逐行解析这段 Emacs 配置文件中的 Emacs Lisp 代码：\n1. defun insert-timestamp-entry () 这是定义一个新的 Emacs Lisp 函数。defun 用来定义一个函数，insert-timestamp-entry 是函数的名称。这个函数没有参数，因此括号中是空的。\n2. \u0026#34;Insert a new entry with Money empty and Date set to current date with time (including seconds).\u0026#34; 这是函数的文档字符串（docstring），用来简短描述这个函数的功能。Emacs 会在 M-x 命令提示时显示这个字符串，帮助用户了解该函数的作用。这里的描述说明了这个函数的功能：插入一个条目，包含一个空的 Money 字段和一个当前日期和时间（包括秒）的 Date 字段。\n3. (interactive) (interactive) 是一个特殊的表单，它使得这个函数可以在 Emacs 中交互式调用。换句话说，通过 M-x 或绑定到键盘快捷键，用户可以直接执行这个函数。\n4. (let ((current-date (format-time-string \u0026#34;%Y/%m/%d %H:%M:%S\u0026#34;))) 这一行创建了一个局部变量 current-date，并通过 let 绑定其值。current-date 变量存储了当前的日期和时间，格式为：%Y/%m/%d %H:%M:%S。具体解释：\n%Y：四位年份（例如：2024） %m：两位月份（例如：11） %d：两位日期（例如：10） %H：小时，24小时制（例如：14） %M：分钟（例如：30） %S：秒（例如：45） 使用 format-time-string 函数，Emacs 将返回当前的时间，格式是 YYYY/MM/DD HH:MM:SS，例如 2024/11/10 14:32:45。\n5. insert (format \u0026#34; \\n :PROPERTIES:\\n :Money: \\n :Date: %s\\n :END:\\n\u0026#34; current-date) 这行代码会在当前缓冲区插入一个字符串。具体来说，insert 函数用来在光标位置插入文本。format 函数用于格式化文本，其中：\n\u0026#34; \\n :PROPERTIES:\\n :Money: \\n :Date: %s\\n :END:\\n\u0026#34; 是插入的模板字符串，格式为一个 Org Mode 栏目（如 ），包含 :PROPERTIES: 块，空的 :Money: 字段和 :Date: 字段（%s 将被替换为当前日期时间）。 %s 是 format 函数的占位符，表示将 current-date 的值插入到此位置。current-date 的值是当前的日期和时间。 这个条目插入到 Org Mode 文件中，表示一个带有时间戳的条目。\n总结： 这个函数的作用是插入一个带有当前日期和时间的条目。 日期和时间格式为 YYYY/MM/DD HH:MM:SS，包括秒。 Money 字段为空，Date 字段会填充为当前的时间戳。 此函数适用于需要记录时间、费用等信息的场景，特别是在 Org Mode 中。\n参考链接 如何用 Org-mode 理财？\n","date":"2024-11-11T03:52:07.92+08:00","permalink":"https://ynhugo.github.io/p/org-mode%E8%AE%B0%E8%B4%A6%E6%A8%A1%E6%9D%BF/","title":"org-mode记账模板"},{"content":" 安装 Termux 和必要工具 只是创建、编译、运行项目，没有打包生成apk的内容，不过将在网上找到的链接添加到参考链接中了，感兴趣可以看一看。\n安装 Termux 如果还没有安装 Termux，可以从 F-Droid 或 Google Play 商店安装。\n更新和安装必需的软件 打开 Termux，执行以下命令以更新包管理器和安装 Java 和 Gradle：\n1 2 3 pkg update \u0026amp;\u0026amp; pkg upgrade pkg install openjdk-17 pkg install gradle 创建一个简单的 Gradle 项目 实现过程 除了java版本需要指定一下，其他全部默认即可。\n查看java版本 1 2 3 4 ~/ts/MyApplication $ java -version openjdk version \u0026#34;17-internal\u0026#34; 2021-09-14 OpenJDK Runtime Environment (build 17-internal+0-adhoc..src) OpenJDK 64-Bit Server VM (build 17-internal+0-adhoc..src, mixed mode) 创建项目目录 1 2 mkdir MyGradleApp cd MyGradleApp 初始化 Gradle 项目 使用 Gradle 初始化项目\n1 2 3 gradle init # 或 gradle init --type java-application 查看项目树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ~/ts/MyApplication $ tree . ├── app │ ├── build.gradle.kts │ └── src │ ├── main │ │ ├── java │ │ │ └── org │ │ │ └── example │ │ │ └── App.java │ │ └── resources │ └── test │ ├── java │ │ └── org │ │ └── example │ │ └── AppTest.java │ └── resources ├── gradle │ ├── libs.versions.toml │ └── wrapper │ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── gradlew ├── gradlew.bat └── settings.gradle.kts 15 directories, 9 files 构建项目 在项目根目录下运行以下命令以构建项目\n1 gradle build 运行项目 构建成功后，可以运行你的应用\n1 gradle run 完整执行过程 先确认 java 版本，然后执行 gradle init ，过程中一路回车，直到需要输入 java 版本时根据之前查看的版本进行输入，然后接着一路回车到底，最后执行 gradle build 进行编译，再执行 gradle run 运行程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 ~/ts/MyApplication $ java -version openjdk version \u0026#34;17-internal\u0026#34; 2021-09-14 OpenJDK Runtime Environment (build 17-internal+0-adhoc..src) OpenJDK 64-Bit Server VM (build 17-internal+0-adhoc..src, mixed mode) ~/ts/MyApplication $ gradle init Select type of build to generate: 1: Application 2: Library 3: Gradle plugin 4: Basic (build structure only) Enter selection (default: Application) [1..4] Select implementation language: 1: Java 2: Kotlin 3: Groovy 4: Scala 5: C++ 6: Swift Enter selection (default: Java) [1..6] Enter target Java version (min: 7, default: 21): 17 Project name (default: MyApplication): Select application structure: 1: Single application project 2: Application and library project Enter selection (default: Single application project) [1..2] Select build script DSL: 1: Kotlin 2: Groovy Enter selection (default: Kotlin) [1..2] Select test framework: 1: JUnit 4 2: TestNG 3: Spock 4: JUnit Jupiter Enter selection (default: JUnit Jupiter) [1..4] Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no] \u0026gt; Task :init Learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.10.2/samples/sample_building_java_applications.html BUILD SUCCESSFUL in 17s 1 actionable task: 1 executed ~/ts/MyApplication $ tree . ├── app │ ├── build.gradle.kts │ └── src │ ├── main │ │ ├── java │ │ │ └── org │ │ │ └── example │ │ │ └── App.java │ │ └── resources │ └── test │ ├── java │ │ └── org │ │ └── example │ │ └── AppTest.java │ └── resources ├── gradle │ ├── libs.versions.toml │ └── wrapper │ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── gradlew ├── gradlew.bat └── settings.gradle.kts 15 directories, 9 files ~/ts/MyApplication $ gradle build \u0026gt; Task :app:compileJava \u0026gt; Task :app:processResources NO-SOURCE \u0026gt; Task :app:classes \u0026gt; Task :app:jar \u0026gt; Task :app:startScripts \u0026gt; Task :app:distTar \u0026gt; Task :app:distZip \u0026gt; Task :app:assemble \u0026gt; Task :app:compileTestJava \u0026gt; Task :app:processTestResources NO-SOURCE \u0026gt; Task :app:testClasses \u0026gt; Task :app:test \u0026gt; Task :app:check \u0026gt; Task :app:build BUILD SUCCESSFUL in 2s 7 actionable tasks: 7 executed ~/ts/MyApplication $ gradle run \u0026gt; Task :app:compileJava UP-TO-DATE \u0026gt; Task :app:processResources NO-SOURCE \u0026gt; Task :app:classes UP-TO-DATE \u0026gt; Task :app:run Hello World! BUILD SUCCESSFUL in 1s 2 actionable tasks: 1 executed, 1 up-to-date 参考链接 第 1 部分：初始化项目\ngradle 打包命令 Android gradle命令行打包生成apk\n","date":"2024-11-01T03:14:40.18+08:00","permalink":"https://ynhugo.github.io/p/termux-gradle%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"termux-gradle使用教程"},{"content":" 解决办法 首先主机断电，然后将主板小电池抠下来，等待5分钟后重新安装上小电池，恢复主机供电，再次尝试开机，会发现系统可以正常开机了\n","date":"2024-10-29T10:21:58.77+08:00","permalink":"https://ynhugo.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1blinitializelibrary%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","title":"记录一次BlinitializeLibrary解决方法"},{"content":" mininet环境配置 操作步骤 1 2 3 4 5 6 7 sudo cp /usr/bin/python /usr/bin/python_bak sudo rm -rf /usr/bin/python sudo ln -s /usr/bin/python3 /usr/bin/python sudo apt install -y git python3-pip pip3 install scapy git clone https://gitee.com/derekwin/mininet.git ./mininet/util/install.sh -a 操作链接 记录一次ubuntu16.04安装mininet+ryu的记录\nUbuntu16.04安装Mininet\n在执行 pip install 时遇到错误： ERROR: Complete output from command python setup.py egg_info:\nPython3+Scapy安装使用教程\nUbuntu安装Mininet\n","date":"2024-10-29T02:18:53.97+08:00","permalink":"https://ynhugo.github.io/p/linux%E5%AE%89%E8%A3%85mininet/","title":"linux安装mininet"},{"content":" 安装live555 termux安装live555，目前已知最新版本的live555源码编译会报错，因此下载旧版本进行编译安装\n操作步骤 live555归档链接：https://download.videolan.org/pub/contrib/live555/\n1 2 3 4 5 6 7 8 9 10 11 12 13 wget https://download.videolan.org/pub/contrib/live555/live.2020.12.23.tar.gz tar zxvf live.2020.12.23.tar.gz export live=$(readlink -f live) cd $live sed -i \u0026#39;97,98{s/^/\\/\\//}\u0026#39; liveMedia/ByteStreamFileSource.cpp ./genMakefiles linux-64bit make cd $live/mediaServer mkdir -p video wget https://images.videolan.org/images/vlc-player.mp4 mv vlc-player.mp4 video ffmpeg -i video/vlc-player.mp4 -vcodec h264 -s 352*278 -y video/vlc-player.264 ./live555MediaServer video/vlc-player.mp4 运行打印信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 LIVE555 Media Server version 1.04 (LIVE555 Streaming Media library version 2020.12.23). Play streams from this server using the URL rtsp://192.168.3.33/\u0026lt;filename\u0026gt; where \u0026lt;filename\u0026gt; is a file present in the current directory. Each file\u0026#39;s type is inferred from its name suffix: \u0026#34;.264\u0026#34; =\u0026gt; a H.264 Video Elementary Stream file \u0026#34;.265\u0026#34; =\u0026gt; a H.265 Video Elementary Stream file \u0026#34;.aac\u0026#34; =\u0026gt; an AAC Audio (ADTS format) file \u0026#34;.ac3\u0026#34; =\u0026gt; an AC-3 Audio file \u0026#34;.amr\u0026#34; =\u0026gt; an AMR Audio file \u0026#34;.dv\u0026#34; =\u0026gt; a DV Video file \u0026#34;.m4e\u0026#34; =\u0026gt; a MPEG-4 Video Elementary Stream file \u0026#34;.mkv\u0026#34; =\u0026gt; a Matroska audio+video+(optional)subtitles file \u0026#34;.mp3\u0026#34; =\u0026gt; a MPEG-1 or 2 Audio file \u0026#34;.mpg\u0026#34; =\u0026gt; a MPEG-1 or 2 Program Stream (audio+video) file \u0026#34;.ogg\u0026#34; or \u0026#34;.ogv\u0026#34; or \u0026#34;.opus\u0026#34; =\u0026gt; an Ogg audio and/or video file \u0026#34;.ts\u0026#34; =\u0026gt; a MPEG Transport Stream file (a \u0026#34;.tsx\u0026#34; index file - if present - provides server \u0026#39;trick play\u0026#39; support) \u0026#34;.vob\u0026#34; =\u0026gt; a VOB (MPEG-2 video with AC-3 audio) file \u0026#34;.wav\u0026#34; =\u0026gt; a WAV Audio file \u0026#34;.webm\u0026#34; =\u0026gt; a WebM audio(Vorbis)+video(VP8) file See http://www.live555.com/mediaServer/ for additional documentation. (We use port 80 for optional RTSP-over-HTTP tunneling, or for HTTP live streaming (for indexed Transport Stream files only).) 测试 1 2 3 4 5 6 mkdir -p $live/mediaServer/video cd $live/mediaServer/video wget https://images.videolan.org/images/vlc-player.mp4 ffmpeg -i vlc-player.mp4 -vcodec h264 -s 352*278 -y vlc-player.264 cd $live/mediaServer ./live555MediaServer video/vlc-player.mp4 客户端使用VLC，选择打开网络串流，在URL栏中填写：\n1 2 3 rtsp://192.168.3.33/video/vlc-player.264 或者 rtsp://192.168.3.33:8554/video/vlc-player.264 也可以使用ffplay命令播放，播放方式\n1 2 3 4 5 ffplay rtsp://192.168.3.33/video/vlc-player.264 或者 ffplay rtsp://192.168.3.33:8554/video/vlc-player.264 如果要设置分辨率，比如1920x1080，使用-x和-y选项即可，例如： ffplay -x 1920 -y 1080 rtsp://192.168.3.102:8554/video/vlc-player.264 参考链接 live555-archive\nUbuntu下使用Live555搭建流媒体服务器\nAndroid 编译live555\n1. 视频循环推流\n","date":"2024-10-28T14:07:19.21+08:00","permalink":"https://ynhugo.github.io/p/termux%E4%BD%BF%E7%94%A8live555%E6%90%AD%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"termux使用live555搭建流媒体服务器"},{"content":" 安装live555 ubuntu20.04安装live555，目前已知最新版本的live555源码编译会报错，因此下载旧版本进行编译安装\n操作步骤 live555归档链接：https://download.videolan.org/pub/contrib/live555/\n1 2 3 4 5 6 7 8 9 10 11 12 13 wget https://download.videolan.org/pub/contrib/live555/live.2020.12.23.tar.gz tar zxvf live.2020.12.23.tar.gz export live=$(readlink -f live) cd $live sed -i \u0026#39;97,98{s/^/\\/\\//}\u0026#39; liveMedia/ByteStreamFileSource.cpp ./genMakefiles linux-64bit make cd $live/mediaServer mkdir -p video wget https://images.videolan.org/images/vlc-player.mp4 mv vlc-player.mp4 video ffmpeg -i video/vlc-player.mp4 -vcodec h264 -s 352*278 -y video/vlc-player.264 ./live555MediaServer video/vlc-player.mp4 运行打印信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 LIVE555 Media Server version 1.04 (LIVE555 Streaming Media library version 2020.12.23). Play streams from this server using the URL rtsp://192.168.3.33/\u0026lt;filename\u0026gt; where \u0026lt;filename\u0026gt; is a file present in the current directory. Each file\u0026#39;s type is inferred from its name suffix: \u0026#34;.264\u0026#34; =\u0026gt; a H.264 Video Elementary Stream file \u0026#34;.265\u0026#34; =\u0026gt; a H.265 Video Elementary Stream file \u0026#34;.aac\u0026#34; =\u0026gt; an AAC Audio (ADTS format) file \u0026#34;.ac3\u0026#34; =\u0026gt; an AC-3 Audio file \u0026#34;.amr\u0026#34; =\u0026gt; an AMR Audio file \u0026#34;.dv\u0026#34; =\u0026gt; a DV Video file \u0026#34;.m4e\u0026#34; =\u0026gt; a MPEG-4 Video Elementary Stream file \u0026#34;.mkv\u0026#34; =\u0026gt; a Matroska audio+video+(optional)subtitles file \u0026#34;.mp3\u0026#34; =\u0026gt; a MPEG-1 or 2 Audio file \u0026#34;.mpg\u0026#34; =\u0026gt; a MPEG-1 or 2 Program Stream (audio+video) file \u0026#34;.ogg\u0026#34; or \u0026#34;.ogv\u0026#34; or \u0026#34;.opus\u0026#34; =\u0026gt; an Ogg audio and/or video file \u0026#34;.ts\u0026#34; =\u0026gt; a MPEG Transport Stream file (a \u0026#34;.tsx\u0026#34; index file - if present - provides server \u0026#39;trick play\u0026#39; support) \u0026#34;.vob\u0026#34; =\u0026gt; a VOB (MPEG-2 video with AC-3 audio) file \u0026#34;.wav\u0026#34; =\u0026gt; a WAV Audio file \u0026#34;.webm\u0026#34; =\u0026gt; a WebM audio(Vorbis)+video(VP8) file See http://www.live555.com/mediaServer/ for additional documentation. (We use port 80 for optional RTSP-over-HTTP tunneling, or for HTTP live streaming (for indexed Transport Stream files only).) 测试 1 2 3 4 5 6 mkdir -p $live/mediaServer/video cd $live/mediaServer/video wget https://images.videolan.org/images/vlc-player.mp4 ffmpeg -i vlc-player.mp4 -vcodec h264 -s 352*278 -y vlc-player.264 cd $live/mediaServer ./live555MediaServer video/vlc-player.mp4 客户端使用VLC，选择打开网络串流，在URL栏中填写：\n1 2 3 rtsp://192.168.3.33/video/vlc-player.264 或者 rtsp://192.168.3.33:8554/video/vlc-player.264 也可以使用ffplay命令播放，播放方式\n1 2 3 4 5 ffplay rtsp://192.168.3.33/video/vlc-player.264 或者 ffplay rtsp://192.168.3.33:8554/video/vlc-player.264 如果要设置分辨率，比如1920x1080，使用-x和-y选项即可，例如： ffplay -x 1920 -y 1080 rtsp://192.168.3.102:8554/video/vlc-player.264 参考链接 live555-archive\nUbuntu下使用Live555搭建流媒体服务器\nAndroid 编译live555\n1. 视频循环推流\n","date":"2024-10-28T14:07:19.21+08:00","permalink":"https://ynhugo.github.io/p/ubuntu20_04%E4%BD%BF%E7%94%A8live555%E6%90%AD%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"ubuntu20_04使用live555搭建流媒体服务器"},{"content":" org-mode链接内部标题 在标题的下一行输入M-x命令，可以创建包含ID的属性，查看ID值后，在其他位置以引用链接的形式链接标题，如我创建的包含ID的属性为\n1 2 3 :PROPERTIES: :ID: 4aed9d50-f5a4-42f1-8252-ee27d5842124 :END: 可以看到ID为 4aed9d50-f5a4-42f1-8252-ee27d5842124\n那么我要链接的标题便是\n1 [[#4aed9d50-f5a4-42f1-8252-ee27d5842124][org-mode链接内部标题]] 参考链接 在 org-mode 中快速插入交叉引用\n","date":"2024-09-24T14:59:31.71+08:00","permalink":"https://ynhugo.github.io/p/org-mode%E9%93%BE%E6%8E%A5%E5%86%85%E9%83%A8%E6%A0%87%E9%A2%98/","title":"org-mode链接内部标题"},{"content":" 注意：该博客在hugo博客框架下，该文章内org-mode下的公式在hugo博客中不能正常显示html效果的公式，如果想要感受公式效果，可以下载该文章页面，然后在html文件中插入以下代码，再从新加载html文件就可以看到公式效果了\n1 2 3 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 添加该代码的作用是启动MathJax，MathJax 是一个 JavaScript 库，可以让你使用 LaTeX 风格的语法，在网页的 HTML （或者 Markdown）的源码中显示数学表达式。因为它是一个纯 Javascript 的库，在 Hugo 中是可以直接使用的。\norg mode 使用latex org mode写技术文章，经常需要编写数学公式和希腊字母。下面介绍如何使用.\n拉丁、希腊字母 可以使用转义符\n1 Angles are written as Greek letters \\alpha, \\beta and \\gamma. 获得的结果是：\n1 Angles are written as Greek letters α, β and γ. 输入M-x命令，可以查看完整的entities\n1 org-entities-help 在letters里面可以看到拉丁和希腊字符。\n使用转义字符的公式\n1 a\\sup2 + b\\sup2 = c\\sup2 导出html查看效果\n1 a² + b² = c² 使用转义字符的公式导出html的效果可以将公式视作普通文本复制下来，如果是使用latex公式，导出的html效果中公式不能被复制下来，但是可以在电脑端浏览器网页中设置公式的样式和效果\norg-mode行内公式 使用org-mode输入\n1 $a^2 + b^2 = c^2$ 导出html查看效果\n$a^2 + b^2 = c^2$\nLaTex关于数学公式的使用（10）—求和，求积 关于求和符号和求积符号的创建(结合3学习) 1、求和符号及其范围的创建，两种方式\n基本的求和 1 2 3 \\begin{equation} \\sum_{0 \\lt i \\lt m \\ 0 \\lt j \\lt n}x_{ij} \\end{equation} \\begin{equation} \\sum_{0 \\lt i \\lt m \\ 0 \\lt j \\lt n}x_{ij} \\end{equation} 将范围表示叠层处理 1 2 3 \\begin{equation} \\sum_{0 \\lt i \\lt m \\\\ 0 \\lt j \\lt n}x_{ij} \\end{equation} \\begin{equation} \\sum_{0 \\lt i \\lt m \\\\ 0 \\lt j \\lt n}x_{ij} \\end{equation} 2、两种和2）同样功能的实现方式\n1 2 3 4 5 6 7 \\begin{equation} \\sum_{\\begin{subarray}{l}0 \\lt i \\lt m\\\\0 \\lt j \\lt n\\end{subarray}}x_{ij} \\end{equation} \\begin{equation} \\sum_{\\begin{subarray}{c}i\\\\0 \\lt j \\lt n\\end{subarray}} x_{ij} \\end{equation} \\begin{equation} \\sum_{\\begin{subarray}{l}0 \\lt i \\lt m\\\\0 \\lt j \\lt n\\end{subarray}}x_{ij} \\end{equation} \\begin{equation} \\sum_{\\begin{subarray}{c}i\\\\0 \\lt j \\lt n\\end{subarray}} x_{ij} \\end{equation} 3、累积符号的创建\n1 2 3 4 5 6 7 \\begin{equation} \\sideset{_a^b}{_x^d}\\prod_i^N x_i \\end{equation} \\begin{equation} \\sideset{_a^b}{_c\u0026#39;}\\prod_i^N x_i \\end{equation} \\begin{equation} \\sideset{_a^b}{_x^d}\\prod_i^N x_i \\end{equation} \\begin{equation} \\sideset{_a^b}{_c\u0026#39;}\\prod_i^N x_i \\end{equation} 4、关于求和的另外表示方式\n1 2 3 4 5 6 7 8 9 10 11 \\begin{equation} \\sum\\thinspace\u0026#39;x_i\\hspace{1cm}\\sum{\u0026#39;}x_i %第一行图 \\end{equation} \\begin{equation} \\sum\\nolimits \u0026#39;x_i %第二行图 \\end{equation} \\begin{equation} \\sideset{}{\u0026#39;}\\sum_i x_i %第二行图 \\end{equation} \\begin{equation} \\sum\\thinspace\u0026#39;x_i\\hspace{1cm}\\sum{\u0026#39;}x_i %第一行图 \\end{equation} \\begin{equation} \\sum\\nolimits \u0026#39;x_i %第二行图 \\end{equation} \\begin{equation} \\sideset{}{\u0026#39;}\\sum_i x_i %第二行图 \\end{equation} 参考链接 org mode 使用latex\norg mode 使用 latex\norg-mode下如何输入数学公式和特殊符号并且在导出了html中可以正常显示？\nLaTex关于数学公式的使用（10）—求和，求积\nMathJax Support\n","date":"2024-09-24T10:00:05.55+08:00","permalink":"https://ynhugo.github.io/p/org-mode%E4%BD%BF%E7%94%A8latex/","title":"org-mode使用latex"},{"content":" 设置用户有效期 为保证用户的安全性，应设置用户的有效期，使用系统命令chage来设置用户的有效期。\n命令为：\n1 chage [-m mindays] [-M maxdays] [-d lastday] [-I inactive] [-E expiredate] [-W warndays] user 相关参数见下表\n参数 参数说明 -m 密码可更改的最小天数。设置为“0”表示任何时候都可以更改密码。 -M 密码保持有效的最大天数。设置为“-1”表示可删除这项密码的检测，用户密码则不会超期，存在安全风险，请谨慎使用。 -d 上一次更改密码的日期。 -I 停滞时期。过期指定天数后，设定密码为失效状态。 -E 用户到期的日期。超过该日期，此用户将不可用。 -W 密码到期前，提前收到警告信息的天数。 - 列出用户以及密码的有效期。由非特权用户来确定用户或密码何时过期。 说明 表格只列举出常用的参数，用户可通过chage –help命令查询详细的参数说明。 日期格式为YYYY-MM-DD，如chage -E 2019-12-01 test表示用户test的用户在2019年12月1日过期。 User如果不填写，默认为root用户。 例如：修改用户test的有效期为2019年12月31日。可执行如下命令：\n1 chage -E 2019-12-31 test ","date":"2024-09-23T17:06:01.68+08:00","permalink":"https://ynhugo.github.io/p/linux%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E6%9C%89%E6%95%88%E6%9C%9F/","title":"linux设置用户有效期"},{"content":" makefile 怎么传递参数 在 Makefile 中，你可以通过在命令行中传递参数来进行参数的传递。传递参数的常用方式有两种：\n使用变量：在 Makefile 中定义变量，然后通过命令行传递参数给这些变量。例如，假设你想传递一个名为 TARGET 的参数，可以在 Makefile 中这样定义： 1 2 3 4 TARGET := $(value TARGET) all: @echo \u0026#34;Target: $(TARGET)\u0026#34; 然后，在命令行中使用 make 命令时，可以通过 -e 参数来传递参数值：\n1 make -e TARGET=my_target 这样，TARGET 变量的值就会被设置为 my_target。\n使用命令行变量：在命令行中直接传递参数给 Makefile 中的命令。例如，假设你有一个名为 run 的目标，需要传递一个名为 arg 的参数给它，可以这样定义： 1 2 run: @echo \u0026#34;Argument: $(arg)\u0026#34; 然后，在命令行中使用 make 命令时，直接在目标后面使用 arg=value 的形式传递参数：\n1 make arg=my_argument 这样，arg 参数的值就会被设置为 my_argument。\n通过以上两种方式，你可以在 Makefile 中灵活地传递参数并使用它们。\n相关问题 Makefile 传递参数 Makefile 是一种在 Unix 系统中常用的构建工具，它通过简单的文本文件来描述软件项目如何从源码编译、链接成最终可执行程序的过程。\n在 Makefile 中，你可以使用变量来接收并传递参数，通常用于定制编译过程。\n当你想要传递参数给 Makefile 的规则时，可以在命令行中指定这些参数，然后在 Makefile 中通过 $ 符号引用它们。例如：\n1 make target=debug 在这个例子中，target 是一个自定义的参数，debug 是它的值。在 Makefile 中，可以这样获取这个值：\n1 2 3 4 5 6 7 8 all: $(target) debug: ; @echo \u0026#34;Building for debug mode\u0026#34; release: ; @echo \u0026#34;Building for release mode\u0026#34; $(target): # 编译代码的命令会使用 $target 变量来指定模式 make -f sub_makefile $(target) 在这个 Makefile 中，$(target) 在 $(target): 行被引用，表示根据传递的不同参数（如 debug 或 release），执行不同的编译指令。\n如何向makefile传递参数 可以通过在命令行中使用变量来向 Makefile 传递参数。Makefile 可以使用这些变量来执行不同的操作。以下是一些可能的方法：\n通过在命令行中设置变量，例如： 1 make VAR=value 在 Makefile 中，可以通过 $(VAR) 引用该变量。\n通过在 Makefile 中定义变量来设置默认值，例如： 1 VAR ?= default_value 如果没有在命令行中设置变量，则使用默认值。\n通过在 Makefile 中定义目标来设置变量，例如： 1 2 target: @echo $(VAR) 在命令行中运行 make target VAR=value 时，将输出 value。\n通过在 Makefile 中定义函数来处理变量，例如： 1 2 3 4 5 6 define my_function @echo $(1) endef target: $(call my_function,$(VAR)) 在命令行中运行 make target VAR=value 时，将输出 value。\n这些方法可以根据具体情况进行组合使用。\n参考链接 Makefile传入参数\nmakefile 怎么传递参数\n","date":"2024-09-19T14:43:41.76+08:00","permalink":"https://ynhugo.github.io/p/makefile-%E6%80%8E%E4%B9%88%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/","title":"makefile 怎么传递参数"},{"content":" emacs多种配置共存的思路 将配置放在early-init.el文件中，可以不需要init.el文件，将其他用户或其他独立的配置的init.el文件改成对应用户或独立的的配置后在early-init.el中加载即可\n如果你希望增加通用性，可以让配置更加灵活，以便将来可以轻松切换或添加其他配置文件。以下是一个示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 (defun load-emacs-config (config-name) \u0026#34;Load a specific Emacs configuration based on CONFIG-NAME.\u0026#34; (let ((config-path (expand-file-name (concat config-name \u0026#34;.el\u0026#34;) \u0026#34;~/.emacs.d/\u0026#34;))) (if (file-exists-p config-path) (load config-path) (message \u0026#34;Config file not found: %s\u0026#34; config-path)))) ;; 加载 remacs 配置 (load-emacs-config \u0026#34;remacs\u0026#34;) ;; 以后可以通过更改参数来加载不同的配置 ;; (load-emacs-config \u0026#34;spacemacs\u0026#34;) ;; (load-emacs-config \u0026#34;prelude\u0026#34;) 这样，你可以通过调用 `load-emacs-config` 函数并传入配置文件名来加载不同的配置。\n","date":"2024-09-18T11:26:55.66+08:00","permalink":"https://ynhugo.github.io/p/emacs%E5%A4%9A%E7%A7%8D%E9%85%8D%E7%BD%AE%E5%85%B1%E5%AD%98%E7%9A%84%E6%80%9D%E8%B7%AF/","title":"emacs多种配置共存的思路"},{"content":" ffmpeg使用教程 安装 ffmpeg windows 安装 ffmpeg 下载页面：https://ffmpeg.org/download.html\n查看设备列表 Windows查看设备列表 1 ffmpeg -list_devices true -f dshow -i dummy 查看设备列表结果 像我的主机上只有audio相关设备，没有video相关设备\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ ffmpeg -list_devices true -f dshow -i dummy ffmpeg version N-112134-g9ef20920ab-20230920 Copyright (c) 2000-2023 the FFmpeg developers built with gcc 13.1.0 (crosstool-NG 1.25.0.196_227d99d) configuration: --prefix=/ffbuild/prefix --pkg-config-flags=--static --pkg-config=pkg-config --cross-prefix=x86_64-w64-mingw32- --arch=x86_64 --target-os=mingw32 --enable-gpl --enable-version3 --disable-debug --disable-w32threads --enable-pthreads --enable-iconv --enable-libxml2 --enable-zlib --enable-libfreetype --enable-libfribidi --enable-gmp --enable-lzma --enable-fontconfig --enable-libharfbuzz --enable-libvorbis --enable-opencl --disable-libpulse --enable-libvmaf --disable-libxcb --disable-xlib --enable-amf --enable-libaom --enable-libaribb24 --enable-avisynth --enable-chromaprint --enable-libdav1d --enable-libdavs2 --disable-libfdk-aac --enable-ffnvcodec --enable-cuda-llvm --enable-frei0r --enable-libgme --enable-libkvazaar --enable-libass --enable-libbluray --enable-libjxl --enable-libmp3lame --enable-libopus --enable-librist --enable-libssh --enable-libtheora --enable-libvpx --enable-libwebp --enable-lv2 --enable-libvpl --enable-openal --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenh264 --enable-libopenjpeg --enable-libopenmpt --enable-librav1e --enable-librubberband --enable-schannel --enable-sdl2 --enable-libsoxr --enable-libsrt --enable-libsvtav1 --enable-libtwolame --enable-libuavs3d --disable-libdrm --enable-vaapi --enable-libvidstab --enable-vulkan --enable-libshaderc --enable-libplacebo --enable-libx264 --enable-libx265 --enable-libxavs2 --enable-libxvid --enable-libzimg --enable-libzvbi --extra-cflags=-DLIBTWOLAME_STATIC --extra-cxxflags= --extra-ldflags=-pthread --extra-ldexeflags= --extra-libs=-lgomp --extra-version=20230920 libavutil 58. 25.100 / 58. 25.100 libavcodec 60. 26.100 / 60. 26.100 libavformat 60. 13.100 / 60. 13.100 libavdevice 60. 2.101 / 60. 2.101 libavfilter 9. 11.100 / 9. 11.100 libswscale 7. 3.100 / 7. 3.100 libswresample 4. 11.100 / 4. 11.100 libpostproc 57. 2.100 / 57. 2.100 [dshow @ 0000025ec2e24e80] \u0026#34;OBS Virtual Camera\u0026#34; (video) [dshow @ 0000025ec2e24e80] Alternative name \u0026#34;@device_sw_{860BB310-5D01-11D0-BD3B-00A0C911CE86}\\{A3FCE0F5-3493-419F-958A-ABA1250EC20B}\u0026#34; [dshow @ 0000025ec2e24e80] \u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; (audio) [dshow @ 0000025ec2e24e80] Alternative name \u0026#34;@device_cm_{33D9A762-90C8-11D0-BD43-00A0C911CE86}\\wave_{8E507121-E2A9-415D-9EC9-B975D91463F7}\u0026#34; [dshow @ 0000025ec2e24e80] \u0026#34;立体声混音 (Realtek(R) Audio)\u0026#34; (audio) [dshow @ 0000025ec2e24e80] Alternative name \u0026#34;@device_cm_{33D9A762-90C8-11D0-BD43-00A0C911CE86}\\wave_{56D3F882-71A2-4A0B-BF2A-404379259FF8}\u0026#34; [in#0 @ 0000025ec2e1f4c0] Error opening input: Immediate exit requested Error opening input file dummy. 查看视频录制的可选参数 1 ffmpeg -f dshow -list_options true -i video=\u0026#34;OBS Virtual Camera\u0026#34; 查看视频录制的可选参数结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ ffmpeg -f dshow -list_options true -i video=\u0026#34;OBS Virtual Camera\u0026#34; ffmpeg version N-112134-g9ef20920ab-20230920 Copyright (c) 2000-2023 the FFmpeg developers built with gcc 13.1.0 (crosstool-NG 1.25.0.196_227d99d) configuration: --prefix=/ffbuild/prefix --pkg-config-flags=--static --pkg-config=pkg-config --cross-prefix=x86_64-w64-mingw32- --arch=x86_64 --target-os=mingw32 --enable-gpl --enable-version3 --disable-debug --disable-w32threads --enable-pthreads --enable-iconv --enable-libxml2 --enable-zlib --enable-libfreetype --enable-libfribidi --enable-gmp --enable-lzma --enable-fontconfig --enable-libharfbuzz --enable-libvorbis --enable-opencl --disable-libpulse --enable-libvmaf --disable-libxcb --disable-xlib --enable-amf --enable-libaom --enable-libaribb24 --enable-avisynth --enable-chromaprint --enable-libdav1d --enable-libdavs2 --disable-libfdk-aac --enable-ffnvcodec --enable-cuda-llvm --enable-frei0r --enable-libgme --enable-libkvazaar --enable-libass --enable-libbluray --enable-libjxl --enable-libmp3lame --enable-libopus --enable-librist --enable-libssh --enable-libtheora --enable-libvpx --enable-libwebp --enable-lv2 --enable-libvpl --enable-openal --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenh264 --enable-libopenjpeg --enable-libopenmpt --enable-librav1e --enable-librubberband --enable-schannel --enable-sdl2 --enable-libsoxr --enable-libsrt --enable-libsvtav1 --enable-libtwolame --enable-libuavs3d --disable-libdrm --enable-vaapi --enable-libvidstab --enable-vulkan --enable-libshaderc --enable-libplacebo --enable-libx264 --enable-libx265 --enable-libxavs2 --enable-libxvid --enable-libzimg --enable-libzvbi --extra-cflags=-DLIBTWOLAME_STATIC --extra-cxxflags= --extra-ldflags=-pthread --extra-ldexeflags= --extra-libs=-lgomp --extra-version=20230920 libavutil 58. 25.100 / 58. 25.100 libavcodec 60. 26.100 / 60. 26.100 libavformat 60. 13.100 / 60. 13.100 libavdevice 60. 2.101 / 60. 2.101 libavfilter 9. 11.100 / 9. 11.100 libswscale 7. 3.100 / 7. 3.100 libswresample 4. 11.100 / 4. 11.100 libpostproc 57. 2.100 / 57. 2.100 [dshow @ 000002a9577d4180] DirectShow video device options (from video devices) [dshow @ 000002a9577d4180] Pin \u0026#34;Video Output\u0026#34; (alternative pin name \u0026#34;Output Pin\u0026#34;) [dshow @ 000002a9577d4180] pixel_format=nv12 min s=1920x1080 fps=30 max s=1920x1080 fps=30 [dshow @ 000002a9577d4180] pixel_format=yuv420p min s=1920x1080 fps=30 max s=1920x1080 fps=30 [dshow @ 000002a9577d4180] pixel_format=yuyv422 min s=1920x1080 fps=30 max s=1920x1080 fps=30 [in#0 @ 000002a9577ce5c0] Error opening input: Immediate exit requested Error opening input file video=OBS Virtual Camera. 查看音频录制的可选参数 1 ffmpeg -f dshow -list_options true -i audio=\u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; 查看音频录制的可选参数结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 $ ffmpeg -f dshow -list_options true -i audio=\u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; ffmpeg version N-112134-g9ef20920ab-20230920 Copyright (c) 2000-2023 the FFmpeg developers built with gcc 13.1.0 (crosstool-NG 1.25.0.196_227d99d) configuration: --prefix=/ffbuild/prefix --pkg-config-flags=--static --pkg-config=pkg-config --cross-prefix=x86_64-w64-mingw32- --arch=x86_64 --target-os=mingw32 --enable-gpl --enable-version3 --disable-debug --disable-w32threads --enable-pthreads --enable-iconv --enable-libxml2 --enable-zlib --enable-libfreetype --enable-libfribidi --enable-gmp --enable-lzma --enable-fontconfig --enable-libharfbuzz --enable-libvorbis --enable-opencl --disable-libpulse --enable-libvmaf --disable-libxcb --disable-xlib --enable-amf --enable-libaom --enable-libaribb24 --enable-avisynth --enable-chromaprint --enable-libdav1d --enable-libdavs2 --disable-libfdk-aac --enable-ffnvcodec --enable-cuda-llvm --enable-frei0r --enable-libgme --enable-libkvazaar --enable-libass --enable-libbluray --enable-libjxl --enable-libmp3lame --enable-libopus --enable-librist --enable-libssh --enable-libtheora --enable-libvpx --enable-libwebp --enable-lv2 --enable-libvpl --enable-openal --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenh264 --enable-libopenjpeg --enable-libopenmpt --enable-librav1e --enable-librubberband --enable-schannel --enable-sdl2 --enable-libsoxr --enable-libsrt --enable-libsvtav1 --enable-libtwolame --enable-libuavs3d --disable-libdrm --enable-vaapi --enable-libvidstab --enable-vulkan --enable-libshaderc --enable-libplacebo --enable-libx264 --enable-libx265 --enable-libxavs2 --enable-libxvid --enable-libzimg --enable-libzvbi --extra-cflags=-DLIBTWOLAME_STATIC --extra-cxxflags= --extra-ldflags=-pthread --extra-ldexeflags= --extra-libs=-lgomp --extra-version=20230920 libavutil 58. 25.100 / 58. 25.100 libavcodec 60. 26.100 / 60. 26.100 libavformat 60. 13.100 / 60. 13.100 libavdevice 60. 2.101 / 60. 2.101 libavfilter 9. 11.100 / 9. 11.100 libswscale 7. 3.100 / 7. 3.100 libswresample 4. 11.100 / 4. 11.100 libpostproc 57. 2.100 / 57. 2.100 [dshow @ 000001a1c5a65e00] DirectShow audio only device options (from audio devices) [dshow @ 000001a1c5a65e00] Pin \u0026#34;Capture\u0026#34; (alternative pin name \u0026#34;Capture\u0026#34;) [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 44100 Last message repeated 1 times [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 44100 [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 32000 [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 32000 [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 22050 [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 22050 [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 11025 [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 11025 [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 8000 [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 8000 [dshow @ 000001a1c5a65e00] ch= 2, bits= 8, rate= 44100 [dshow @ 000001a1c5a65e00] ch= 1, bits= 8, rate= 44100 [dshow @ 000001a1c5a65e00] ch= 2, bits= 8, rate= 22050 [dshow @ 000001a1c5a65e00] ch= 1, bits= 8, rate= 22050 [dshow @ 000001a1c5a65e00] ch= 2, bits= 8, rate= 11025 [dshow @ 000001a1c5a65e00] ch= 1, bits= 8, rate= 11025 [dshow @ 000001a1c5a65e00] ch= 2, bits= 8, rate= 8000 [dshow @ 000001a1c5a65e00] ch= 1, bits= 8, rate= 8000 [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 48000 [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 48000 [dshow @ 000001a1c5a65e00] ch= 2, bits=16, rate= 96000 [dshow @ 000001a1c5a65e00] ch= 1, bits=16, rate= 96000 [in#0 @ 000001a1c5a5bd00] Error opening input: Immediate exit requested Error opening input file audio=麦克风 (Realtek(R) Audio). Linux查看设备列表 1 ffmpeg -devices true -f dshow -i dummy 查看设备列表结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ubt@ubt:~/ts/debug$ ffmpeg -devices true -f dshow -i dummy ffmpeg version 4.3.1 Copyright (c) 2000-2020 the FFmpeg developers built with gcc 9 (Ubuntu 9.4.0-1ubuntu1~20.04.2) configuration: --enable-gpl --enable-libass --enable-libfdk-aac --enable-libfreetype --enable-libopus --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-nonfree libavutil 56. 51.100 / 56. 51.100 libavcodec 58. 91.100 / 58. 91.100 libavformat 58. 45.100 / 58. 45.100 libavdevice 58. 10.100 / 58. 10.100 libavfilter 7. 85.100 / 7. 85.100 libswscale 5. 7.100 / 5. 7.100 libswresample 3. 7.100 / 3. 7.100 libpostproc 55. 7.100 / 55. 7.100 Devices: D. = Demuxing supported .E = Muxing supported -- DE alsa ALSA audio output DE fbdev Linux framebuffer D lavfi Libavfilter virtual input device DE oss OSS (Open Sound System) playback E sdl,sdl2 SDL2 output device DE sndio sndio audio playback DE video4linux2,v4l2 Video4Linux2 output device D x11grab X11 screen capture, using XCB E xv XV (XVideo) output device 屏幕录制 Windows下操作 只录制画面，没有声音 1 ffmpeg -f gdigrab -i desktop -f mp4 out.mp4 播放视频 1 ffplay out.mp4 只录制声音，没有画面 1 ffmpeg -f dshow -i audio=\u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; -f mp3 out.mp3 -y 播放音频 1 ffplay out.mp3 同时录制声音和画面-1 1 ffmpeg -f dshow -i audio=\u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; -f gdigrab -i desktop -f mp4 -y out.mp4 以下是录制命令的说明： -f gdigrab 使用 FFmpeg 内置的 Windows 屏幕录制命令gdigrab，录制对象可为全屏、指定范围和指定程序。MacOS 录屏方法为AVFoundation，Linux 录屏方法为x11grab。\n同时录制声音和画面-2 1 ffmpeg -f dshow -i audio=\u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; -f dshow -i video=\u0026#34;OBS Virtual Camera\u0026#34; -f mp4 -y out.mp4 以下是录制命令的说明： \u0026#34;OBS Virtual Camera\u0026#34; 是电脑安装了OBS，然后将OBS的虚拟摄像机打开并设置输出类型为\u0026#34;来源\u0026#34;，输出选择为\u0026#34;显示器采集\u0026#34;，打开了虚拟摄像机后可以再次使用命令查看设备列表可以看到多出一个OBS的虚拟摄像机\n播放视频 1 ffplay out.mp4 多参数录屏示例 1 ffmpeg -f gdigrab -t 30 -framerate 15 -i desktop -f dshow -i audio=\u0026#34;麦克风 (Realtek(R) Audio)\u0026#34; -b:v 3M -pixel_format yuv420p -vcodec libx264 -s 1366x768 -y test.flv 命令详解 -f 指定采集数据方式，一般为dshow 或 gdigrab。gdigrab为系统自带，只能录屏幕，没声音；dshow需装directX，优点是可以指定多个输入，比如下载安装screen capture recorder后，可将其作为dshow模式下的视频输入，可将virtual-audio-capturer作为dshow模式下的音频输入，实现录屏的同时录音。 -i 指定输入，desktop表示gdigrab采集模式输入全部桌面。dshow模式下自己指定，如：-i video=\u0026#34;screen-capture-recorder\u0026#34; -i audio=\u0026#34;virtual-audio-capturer\u0026#34; -t 表示录屏时间，缺省则没有录屏时间限制，会一直录，录到手动停止或强制关闭 -framerate 表示帧率。对屏幕录制来说，一般15帧就够了，太大的话会很占资源，cpu占用率、内存、存储空间占用等都会很高。\ns 表示分辨率 -b:v 表示码率，如：-b:v 3M。大一点清楚，但是占资源，自己权衡吧。 -pixel_format 表示像素格式，如yuv420p等，注意选择不同的像素格式会影响资源占用率和视频质量，自己研究吧。 -vcodec 表示编码方式。libx264表示软编码，编码器的库为x264。你可以选择其他的，不同的编码方式也会影响资源占用率和视频质量，自己研究吧。此外可以用硬件加速，硬编解码有3种常见的方式，例如：-vcodec h264_qsv，即使用集显加速；例如： -vcodec h264_nvenc，即使用N卡加速；例如： -vcodec h264_amf，即使用A卡加速。开启硬件加速的情况下可大大降低CPU的占用率 -y 表示覆盖同名文件 test.flv为输出文件名，格式虽然mp4较为常见，但我建议用flv格式，因为如果中间有录制损坏，mp4整个就播放不了了，但flv能。\n播放视频 1 ffplay test.flv ffmpeg对桌面或指定窗口录制视频gdigrab ffmpeg录屏命令gdigrab 基于Win32屏幕捕捉设备，支持对显示器指定区域进行录屏。\n可选2种捕捉方式：\n-i desktop -i title=window_title 方式1 捕捉整个桌面或者桌面的某个区域。 方式2 捕捉指定窗口，由窗口标题栏指定窗口。 实际上，由于窗口标题可能重名，导致录屏窗口不对。\n录制窗口 1 ffmpeg -f gdigrab -t 3 -i title=企业微信 -y out.mp4 整个桌面 6帧/秒 1 ffmpeg -f gdigrab -framerate 6 -i desktop out.mp4 桌面指定区域 左上角(10,20) 尺寸(640x480) 1 ffmpeg -f gdigrab -framerate 6 -offset_x 10 -offset_y 20 -video_size vga -i desktop out.mp4 录制左半边屏幕 录制时长为3秒\n1 ffmpeg -f gdigrab -show_region 1 -t 3 -offset_x 0 -offset_y 0 -video_size 960x1080 -i desktop -y out.mp4 录制右半边屏幕 1 ffmpeg -f gdigrab -show_region 1 -t 3 -offset_x 960 -offset_y 0 -video_size 960x1080 -i desktop -y out.mp4 录制左上角占屏幕四分之一的区域 1 ffmpeg -f gdigrab -show_region 1 -t 3 -offset_x 0 -offset_y 0 -video_size 960x540 -i desktop -y out.mp4 录制左下角占屏幕四分之一的区域 1 ffmpeg -f gdigrab -show_region 1 -t 3 -offset_x 0 -offset_y 540 -video_size 960x540 -i desktop -y out.mp4 录制右上角占屏幕四分之一的区域 1 ffmpeg -f gdigrab -show_region 1 -t 3 -offset_x 960 -offset_y 0 -video_size 960x540 -i desktop -y out.mp4 录制右下角占屏幕四分之一的区域 1 ffmpeg -f gdigrab -show_region 1 -t 3 -offset_x 960 -offset_y 540 -video_size 960x540 -i desktop -y out.mp4 窗口标题为\u0026#34;Calculator\u0026#34;的窗口 也可设置offset_x/y和video_size 1 ffmpeg -f gdigrab -framerate 6 -i title=Calculator out.mp4 显示边界框 只是提示作用不会保存进视频中 1 ffmpeg -f gdigrab -show_region 1 -framerate 6 -video_size cif -offset_x 10 -offset_y 20 -i desktop out.mp4 参数详解 framerate 录屏帧率。默认值ntsc, 一般是30000/1001. 除了ffmpeg设置默认参数之外，gdigrab可设置下列参数项：\nshow_region 录屏时是否在屏幕上显示边界框。用于检查录屏区域，防止区域错误。 1显示，0不显示。 draw_mouse 是否包含鼠标。0=不包含，1=包含。默认值1，视频含有鼠标。 video_size 视频尺寸，默认整个桌面或整个窗口。 自定义尺寸，如1280x720。或者，下面的列表之一。 offset_x 和video_size一起使用，指定左上角位置。 原点为桌面或指定窗口的左上角。 offset_y 同上。 不使用video_size/offset_x/offset_y，则对整个桌面或程序窗口录屏，使用则只对桌面或窗口的部分区域进行录屏。\nvideo_size可选视频尺寸 ntsc 720x480 pal 720x576 qntsc 352x240 qpal 352x288 sntsc 640x480 spal 768x576 film 352x240 ntsc-film 352x240 sqcif 128x96 qcif 176x144 cif 352x288 4cif 704x576 16cif 1408x1152 qqvga 160x120 qvga 320x240 vga 640x480 svga 800x600 xga 1024x768 uxga 1600x1200 qxga 2048x1536 sxga 1280x1024 qsxga 2560x2048 hsxga 5120x4096 wvga 852x480 wxga 1366x768 wsxga 1600x1024 wuxga 1920x1200 woxga 2560x1600 wqsxga 3200x2048 wquxga 3840x2400 whsxga 6400x4096 whuxga 7680x4800 cga 320x200 ega 640x350 hd480 852x480 hd720 1280x720 hd1080 1920x1080 2k 2048x1080 2kflat 1998x1080 2kscope 2048x858 4k 4096x2160 4kflat 3996x2160 4kscope 4096x1716 nhd 640x360 hqvga 240x160 wqvga 400x240 fwqvga 432x240 hvga 480x320 qhd 960x540 2kdci 2048x1080 4kdci 4096x2160 uhd2160 3840x2160 uhd4320 7680x4320 参考链接 FFmpeg屏幕录制\n15-ffmpeg常用 命令视频录制\n3 分钟入门 FFmpeg，抛弃又贵又难用的录屏软件\nffmpeg对桌面或指定窗口录制视频gdigrab\nffmpeg时间有关的操作\nLinux下操作 录制全屏视频 1 ffmpeg -f x11grab -r 25 -s $(xwininfo -root | grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;) -i :0.0 -t 3 -vcodec libx264 -preset ultrafast -y output.mp4 参数详解 这条 ffmpeg 命令用于从 X11 屏幕录制视频，并将结果保存为 output.mp4。以下是对每个参数的详细解释：\nffmpeg: 调用 FFmpeg 工具进行视频和音频处理。 -f x11grab: 指定输入格式为 X11 屏幕捕捉（x11grab）。这表示要录制 X11 显示器上的屏幕内容。 -r 25: 设置视频的帧率为 25 帧每秒（fps）。这决定了录制视频的流畅度。 -s $(xwininfo -root | grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;): 设置输出视频的分辨率为当前屏幕的分辨率。\nxwininfo -root: 获取根窗口（即整个屏幕）的信息。 grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;: 使用正则表达式从 xwininfo 的输出中提取屏幕分辨率，格式为 宽度x高度。[0-9]{3,5} 匹配 3 到 5 位的数字，x 是分隔符，后面的 [0-9]{3,5} 匹配高度部分。 -i :0.0: 指定 X11 屏幕的显示和显示编号为 :0.0。通常表示第一个显示器的第一个屏幕。 -t 3: 设置录制时长为 3 秒。-t 指定录制的时间长度。 -vcodec libx264: 指定视频编码器为 libx264，即使用 H.264 编码。H.264 是一种高效的视频编码格式。 -preset ultrafast: 设置编码预设为 ultrafast，优先考虑编码速度，而非压缩效率。这将生成较大的文件，但编码速度最快。 -y: 自动确认覆盖输出文件。如果 output.mp4 已经存在，FFmpeg 会自动覆盖它，而不会提示用户确认。 output.mp4: 指定输出文件名为 output.mp4。mp4 是一种广泛使用的视频文件格式，能够容纳视频和音频流。 总的来说，这条命令从 X11 屏幕录制 3 秒钟的视频，使用 H.264 编码，保存为 output.mp4。\n录制指定区域视频 1 ffmpeg -f x11grab -r 25 -s 800x600 -i :0.0+100,200 -vcodec libx264 -y output.mp4 参数详解 这条 ffmpeg 命令用于从 X11 屏幕录制指定区域的视频，并将结果保存为 output.mp4。下面是对每个参数的解释：\nffmpeg: 调用 FFmpeg 工具进行视频处理。 -f x11grab: 指定输入格式为 X11 屏幕捕捉，表示要录制 X11 显示器上的屏幕内容。 -r 25: 设置视频的帧率为 25 帧每秒（fps），决定了录制视频的流畅度。 -s 800x600: 设置录制视频的分辨率为 800x600 像素。这里是指定的区域大小。 -i :0.0+100,200: 指定录制的输入源为 X11 屏幕 :0.0，并且设置录制区域的起始位置为屏幕上的 (100, 200) 像素点。这意味着视频录制将从屏幕的 (100, 200) 位置开始，覆盖 800x600 像素的区域。 -vcodec libx264: 指定视频编码器为 libx264，即使用 H.264 编码。这种编码格式在压缩效率和视频质量之间提供了很好的平衡。 output.mp4: 指定输出文件名为 output.mp4。这是最终保存录制内容的视频文件名。 总的来说，这条命令从 X11 屏幕的 (100, 200) 位置开始录制一个 800x600 像素的区域，录制的帧率为 25 fps，使用 H.264 编码，保存为 `output.mp4`。\n指定录屏时间长度为30秒 1 ffmpeg -f x11grab -r 25 -s $(xwininfo -root | grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;) -i :0.0 -t 30 -preset ultrafast -y output.mp4 参数详解 这条 `ffmpeg` 命令用于从 X11 屏幕录制指定时长的视频，并将结果保存为 `output.mp4`。下面是对每个参数的详细解释：\nffmpeg: 调用 FFmpeg 工具来处理视频和音频。 -f x11grab: 指定输入格式为 X11 屏幕捕捉，表示要录制 X11 显示器上的屏幕内容。 -r 25: 设置视频的帧率为 25 帧每秒（fps），决定了录制视频的流畅度。 -s $(xwininfo -root | grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;): 设置录制视频的分辨率为当前屏幕的分辨率。\nxwininfo -root: 获取根窗口（即整个屏幕）的信息。 grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;: 从 xwininfo 输出中提取屏幕的分辨率，格式为 宽度x高度。正则表达式 [0-9]{3,5} 匹配 3 到 5 位的数字，x 作为分隔符，后面 [0-9]{3,5} 匹配高度部分。这样做可以确保 FFmpeg 使用当前屏幕的完整分辨率进行录制。 -i :0.0: 指定 X11 屏幕的显示和显示编号为 :0.0。通常表示第一个显示器的第一个屏幕。 -t 30: 设置录制时长为 30 秒。-t 用来指定录制的时间长度。 -preset ultrafast: 设置视频编码的预设为 ultrafast。这会使编码过程尽可能快，但会生成较大的文件，因为编码压缩率较低。 -y: 自动确认覆盖输出文件。如果 output.mp4 已经存在，FFmpeg 会自动覆盖它，而不需要用户确认。 output.mp4: 指定输出文件名为 output.mp4。这是录制的视频将被保存的文件名。 总的来说，这条命令从 X11 屏幕录制 30 秒钟的视频，使用当前屏幕的完整分辨率，帧率为 25 fps，使用 H.264 编码，并将结果保存为 `output.mp4`。编码设置为 `ultrafast`，优先考虑编码速度。\n使用alsa录制系统音频 1 ffmpeg -f alsa -i default -f x11grab -r 25 -s $(xdpyinfo | grep \u0026#39;dimensions:\u0026#39;|awk \u0026#39;{print $2;}\u0026#39;) -i :0.0 -c:v libx264 -preset ultrafast -c:a aac -tune fastdecode -y output.mkv 参数详解 这条 `ffmpeg` 命令用于同时录制音频和视频，并将结果保存为 `output.mkv`。以下是对每个参数的详细解释：\nffmpeg: 调用 FFmpeg 工具来处理视频和音频。 -f alsa -i default: 指定音频输入格式为 ALSA（Advanced Linux Sound Architecture），并选择默认音频设备作为输入。-f alsa 指定了音频输入格式为 ALSA，-i default 表示使用系统默认的音频输入设备。 -f x11grab -r 25 -s $(xdpyinfo | grep \u0026#39;dimensions:\u0026#39; | awk \u0026#39;{print $2;}\u0026#39;) -i :0.0: 指定视频输入格式为 X11 屏幕捕捉。\n-f x11grab: 指定视频输入格式为 X11 屏幕捕捉。 -r 25: 设置视频的帧率为 25 帧每秒（fps）。 -s $(xdpyinfo | grep \u0026#39;dimensions:\u0026#39; | awk \u0026#39;{print $2;}\u0026#39;): 设置录制视频的分辨率。xdpyinfo 是一个 X11 工具，用于获取 X11 显示的相关信息。grep \u0026#39;dimensions:\u0026#39; 提取包含屏幕分辨率的行，awk \u0026#39;{print $2;}\u0026#39; 从这一行中提取分辨率信息（如 1920x1080）。 -i :0.0: 指定 X11 屏幕的显示和显示编号为 :0.0，通常表示第一个显示器的第一个屏幕。 -c:v libx264: 指定视频编码器为 libx264，这是用于 H.264 视频编码的 FFmpeg 编码器。 -preset ultrafast: 设置视频编码的预设为 ultrafast，使编码过程尽可能快，但会生成较大的文件，因为编码压缩率较低。 -c:a aac: 指定音频编码器为 aac，用于音频压缩和编码，常用于高效的音频压缩。 -tune fastdecode: 指定编码器的调整参数为 fastdecode，优化编码设置以加快解码速度。这通常有助于提高播放设备或软件的解码效率。 output.mkv: 指定输出文件名为 output.mkv。这是录制的音视频将被保存的文件名，使用 MKV 格式。 总结来说，这条命令将从默认的音频设备和 X11 屏幕录制视频和音频。视频将以 25 fps 录制，使用 `libx264` 编码器和 `ultrafast` 预设，音频将使用 `aac` 编码器，并且优化了解码速度。录制的结果将保存为 `output.mkv` 文件。\n这些命令可以根据需要进行修改，例如更改输出文件名或调整录屏分辨率和帧速率。\n参考链接 linux ffmpeg录屏命令实例\n编辑字幕 硬字幕和软字幕的简介 硬字幕 将字幕渲染到视频的纹理上，然后将其编码成独立于视频格式的一个完整的视频。硬字幕不能更改或删除，因为它们与视频（通道）是一个整体。\n软字幕 在播放视频时实时渲染和读取。软字幕可以在播放过程中随时添加或删除。软字幕比硬字幕更加灵活，因为它们可以随时进行修改，但它们也需要高性能的播放器支持。\n字幕单独生成一个字幕通道，与视频、音频一样，如以下Stream #0:2：\n1 2 3 4 5 6 7 8 9 10 11 Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 852x480, 397 kb/s, 25 fps, 25 tbr, 12800 tbn (default) Metadata: handler_name : VideoHandler vendor_id : [0][0][0][0] Stream #0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 127 kb/s (default) Metadata: handler_name : SoundHandler vendor_id : [0][0][0][0] Stream #0:2[0x3](eng): Subtitle: mov_text (tx3g / 0x67337874), 0 kb/s (default) Metadata: handler_name : SubtitleHandler SRT和ASS字幕格式的简介 SRT（SubRip Subtitle） 是一种简单的字幕格式，主要由时间戳和文本组成。它通常用于简单的字幕文件，如电影聚会之类。SRT字幕格式的参数如下：\n标题的计数器/索引 START和END：字幕开始和字幕结束的时间戳，格式为 “小时：分钟：毫秒”。 TEXT：在此时间戳范围内显示的字幕文本 一行空白表示一个结束 1 2 3 4 5 6 7 8 9 10 11 1 00:00:0,000 --\u0026gt; 00:00:2,000 这是0到2秒显示的字幕 2 00:00:2,000 --\u0026gt; 00:00:4,000 这是2到4秒显示的字幕 3 00:00:4,000 --\u0026gt; 00:00:7,000 这是4到7秒显示的字幕 ASS（Advanced SubStation Alpha） 是一个高级的字幕格式，它可以支持更多的样式和控制，比如，更改颜色、字体和大小，还可以通过几何变换来控制字幕的位置。ASS字幕格式包含以下参数：\n样式 1 2 Style: 序号, 字体名称, 字号, 颜色, 阴影, 边框, 描边, 阴影, 抗锯齿, 倾斜度, weight, underline 例子：Style: Top, Microsoft YaHei,40,\u0026amp;H00F5FF\u0026amp;,-1,2,0,0,1,0,0 对齐 1 Dialogue: 0,0:00:03.42,0:00:04.91,Top,,0,0,0,,{\\an6}本字幕居右上 触发器 1 Dialogue: 0,0:00:03.42,0:00:04.91,Top,,0,0,0,,{\\t(0,300,\\fade(400,400))}三秒内渐入渐出 动画 1 Dialogue: 0,0:00:03.42,0:00:04.91,Top,,0,0,0,,{\\move(0,0,100,100)}右下角移动 特殊效果 1 Dialogue: 0,0:00:03.42,0:00:05.62,Top,,0,0,0,,{\\fad(500,500)\\blur3}左右淡入淡出，模糊度3 合的ASS字幕案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [Script Info] ; Script generated by FFmpeg/Lavc59.18.100 Title: 某电影 Original Script: 某人 ScriptType: v4.00+ WrapStyle: 0 Collisions: Normal PlayResX: 1920 PlayResY: 1080 Timer: 100.0000 [V4 Styles] Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding Style: Default,Arial,30,\u0026amp;Hffffff,\u0026amp;Hffffff,\u0026amp;H0,\u0026amp;H0,0,0,0,0,100,100,0,0,1,1,0,2,10,10,50,0 [Events] Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text Dialogue: 0,0:00:00.00,0:00:02.00,Default,,0,0,0,,这是0到2秒显示的{\\b1}{\\i1}字幕{\\i0}{\\b0} Dialogue: 0,0:00:02.00,0:00:04.00,Default,,0,0,0,,这是2到4秒显示的字幕 Dialogue: 0,0:00:04.00,0:00:07.00,Default,,0,0,0,,这是4到7秒显示的字幕 Dialogue: 0,0:00:07.00,0:00:10.00,Default,,0,0,0,,这是7到10秒显示的字幕 Dialogue: 0,0:00:10.00,0:00:30.00,Default,,0,0,0,,这是10到30秒显示的字幕{\\an5\\move(960,700,960,900)\\t(\\fscx200\\fscy200\\frx360\\fry360\\fad(200,200))\\fs60\\p5\\t(\\fscx100\\fscy100\\frx0\\fry0\\fad(200,200))\\c\u0026amp;HFFFFFF\u0026amp;\\3c\u0026amp;HA000\u0026amp;}高级操作. 生成字幕的命令 SRT硬字幕命令 1 ffmpeg -i input.mp4 -vf subtitles=subtitle.srt output_srt.mp4 命令参数详解 -vf 是 ffmpeg 的视频滤镜选项，subtitles=subtitle.srt 表示使用字幕滤镜将 subtitle.srt 文件中的字幕嵌入到视频中。这个选项会将 subtitle.srt 文件中的字幕渲染到视频流上。\nASS硬字幕命令 1 ffmpeg -i input.mp4 -vf ass=subtitle.ass output_ass.mp4 SRT和ASS软字幕命令 1 2 3 ffmpeg -i input.mp4 -i subtitle.srt -c copy -c:s mov_text -metadata:s:s:0 language=chi ouptut_chi.mp4 or ffmpeg -i input.mp4 -i subtitle.ass -c copy -c:s mov_text -metadata:s:s:0 language=chi ouptut_chi.mp4 SRT可以转ASS命令 1 ffmpeg -i subtitle.srt subtitle.ass 多通道(软)字幕命令 准备字幕文件：假设有中文字幕文件为ch.srt，英文字幕文件为en.srt。 中文字幕文件：ch.srt 1 2 3 4 5 6 7 1 00:00:0,000 --\u0026gt; 00:00:5,000 这里是视频的标题 1 2 00:00:5,000 --\u0026gt; 00:00:10,000 这里是视频的标题 2 英文字幕文件：en.srt 1 2 3 4 5 6 7 1 00:00:0,000 --\u0026gt; 00:00:5,000 Here\u0026#39;s the video\u0026#39;s title 1 2 00:00:5,000 --\u0026gt; 00:00:10,000 Here\u0026#39;s the video\u0026#39;s title 2 命令 1 ffmpeg -i input.mp4 -i ch.srt -i en.srt -map 0 -map 1 -map 2 -c copy -c:s mov_text -metadata:s:s:0 language=chi -metadata:s:s:1 language=eng output_chi_eng.mp4 注意：ass格式同样的操作\n1 ffmpeg -i input.mp4 -i ch.ass -i en.ass -map 0 -map 1 -map 2 -c copy -c:s mov_text -metadata:s:s:0 language=chi -metadata:s:s:1 language=eng output_chi_eng_ass.mp4 参数详解 这个 ffmpeg 命令的作用是将 input.mp4 视频与两个字幕文件 ch.srt（中文）和 en.srt（英文）合并成一个包含两种语言字幕的输出视频文件 output_chi_eng.mp4。以下是各个参数的详细解释：\nffmpeg: 调用 FFmpeg 工具。 -i input.mp4: 指定第一个输入文件，input.mp4 是要处理的视频文件。 -i ch.srt: 指定第二个输入文件，ch.srt 是中文字幕文件。 -i en.srt: 指定第三个输入文件，en.srt 是英文字幕文件。 -map 0: 包含第一个输入文件（input.mp4）的所有流（视频、音频、字幕）。 -map 1: 包含第二个输入文件（ch.srt）的所有流（中文字幕）。 -map 2: 包含第三个输入文件（en.srt）的所有流（英文字幕）。 -c copy: 对视频和音频流使用直接复制方式，不进行重新编码。 -c:s mov_text: 对字幕流使用 mov_text 编解码器，这种编码适用于 MP4 容器。 -metadata:s:s:0 language=chi: 为第一个字幕流（中文字幕）设置语言元数据为 chi。 -metadata:s:s:1 language=eng: 为第二个字幕流（英文字幕）设置语言元数据为 eng。 output_chi_eng.mp4: 指定输出文件名，output_chi_eng.mp4 是最终生成的包含中英文字幕的视频文件。 多通道(软)字幕，中英字幕实现 准备字幕文件：假设有中英文字幕文件为ch_en.srt，英文字幕文件为en.srt。 中文字幕文件：ch_en.srt 1 2 3 4 5 6 7 8 9 1 00:00:0,000 --\u0026gt; 00:00:5,000 这里是视频的标题 1 Here\u0026#39;s the video\u0026#39;s title 1 2 00:00:5,000 --\u0026gt; 00:00:10,000 这里是视频的标题 2 Here\u0026#39;s the video\u0026#39;s title 2 英文字幕文件：en.srt 1 2 3 4 5 6 7 1 00:00:0,000 --\u0026gt; 00:00:5,000 Here\u0026#39;s the video\u0026#39;s title 1 2 00:00:5,000 --\u0026gt; 00:00:10,000 Here\u0026#39;s the video\u0026#39;s title 2 命令 1 ffmpeg -i input.mp4 -i ch_en.srt -i en.srt -map 0 -map 1 -map 2 -c copy -c:s mov_text -metadata:s:s:0 language=chi_eng -metadata:s:s:1 language=eng output_chi_eng_eng.mp4 最后使用ffprobe查看一下生成文件的内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Input #0, mov,mp4,m4a,3gp,3g2,mj2, from \u0026#39;output_chi_eng_eng.mp4\u0026#39;: Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf60.3.100 description : Bilibili VXCode Swarm Transcoder v0.6.11 Duration: 00:05:24.20, start: 0.000000, bitrate: 531 kb/s Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 852x480, 397 kb/s, 25 fps, 25 tbr, 12800 tbn (default) Metadata: handler_name : VideoHandler vendor_id : [0][0][0][0] Stream #0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 127 kb/s (default) Metadata: handler_name : SoundHandler vendor_id : [0][0][0][0] Stream #0:2[0x3](chi): Subtitle: mov_text (tx3g / 0x67337874), 0 kb/s (default) Metadata: handler_name : SubtitleHandler Stream #0:3[0x4](eng): Subtitle: mov_text (tx3g / 0x67337874), 0 kb/s Metadata: handler_name : SubtitleHandler ffmpeg给视频添加字幕(软字幕和硬字幕) 软字幕(外挂字幕) 先获取视频元数据 1 ffmpeg -i 1.mp4 -hide_banner 获取视频元数据结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ ffmpeg -i 1.mp4 -hide_banner Input #0, mov,mp4,m4a,3gp,3g2,mj2, from \u0026#39;1.mp4\u0026#39;: Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf60.13.100 Duration: 00:00:05.01, start: 0.000000, bitrate: 1320 kb/s Stream #0:0[0x1](und): Video: h264 (High 4:4:4 Predictive) (avc1 / 0x31637661), yuv444p(progressive), 3840x1080, 1285 kb/s, 29.97 fps, 29.97 tbr, 30k tbn (default) Metadata: handler_name : VideoHandler vendor_id : [0][0][0][0] encoder : Lavc60.26.100 libx264 Stream #0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 127 kb/s (default) Metadata: handler_name : SoundHandler vendor_id : [0][0][0][0] At least one output file must be specified 假设有一个视频轨(#0:0), 一个音频轨(#0:1), 两个字幕轨(#0:2和#0:3)，现在我要添加第三个字幕, 可以如下操作\n1 ffmpeg -i 4.mp4 -i ch_en.srt -map 0:v:0 -map 0:a:0 -map 0:s:0 -map 0:s:1 -c:v copy -c:a copy -c:s copy -map 1 -c:s:2 mov_text -metadata:s:s:2 language=chi_eng -y 6.mp4 参数解释 第一个输入流(视频.mp4)对应map 0, 第二个输入流(字幕.srt)对应map 1 metadata:s:s:2 指向第三个字幕流元数据 c:v 视频编解码方式 c:a 音频编解码方式 c:s 字幕编解码方式 c:s:2 mov_text: 对字幕流使用 mov_text 编解码器，这种编码适用于 MP4 容器。 给无字幕的视频添加软字幕 视频已经有video和audio，接下来要做是添加Subtitle\n1 ffmpeg -i input.mp4 -i input.srt -c:v copy -c:a copy -c:s mov_text -y output.mp4 参数详解 -i input.mp4：-i 选项指定输入文件。这里 input.mp4 是你要处理的视频文件。 -i input.srt：第二个 -i 选项指定字幕文件 input.srt。ffmpeg 会将这个字幕文件合并到视频中。 -c:v copy：-c:v 用于指定视频编解码器。copy 表示直接拷贝视频流，不进行任何编码或重新压缩，从而保留原始视频质量。 -c:a copy：-c:a 用于指定音频编解码器。copy 表示直接拷贝音频流，不进行重新编码，保持原始音频质量。 -c:s mov_text：-c:s 用于指定字幕编解码器。mov_text 是将字幕编码为适用于 MP4 文件的文本轨道格式。这种格式允许播放器选择显示或隐藏字幕。 -y：-y 选项表示在输出文件 output.mp4 已存在时自动覆盖该文件，而不会询问确认。这对于脚本或批处理操作非常有用。 output.mp4：这是输出文件的名称。合并后的文件将保存为 output.mp4。 硬字幕(将字幕烧录到视频上) 将外部字幕烧录到视频中(例如第二个字幕轨) 1 ffmpeg -i 1.mp4 -map 0:v:0 -map 0:a:0 -vf subtitles=ch.srt -y 7.mp4 使用mkv容器中的某一个字幕轨烧录到视频上 1 ffmpeg -i 1.mp4 -map 0:v:0 -map 0:a:0 -vf subtitles=4.mp4:si=1 8.mp4 参数解释 :si=1 代表指定选择第 1 个字幕轨道，字幕轨道从 0 开始算起，因此 si=1 对应第 2 个字幕轨道。si 是 subtitles 过滤器的一个选项，用于指定字幕流的索引。这里的 si 代表 \u0026#34;subtitle index\u0026#34;，即字幕流的索引。它必须用 si 而不是 s 是因为 s 是用来指定其它过滤器选项的缩写，例如 scale 或 setpts，而 si 特指字幕流的索引选择。\n使用 FFmpeg 将 MKV 内封字幕压制为内嵌硬字幕 1 ffmpeg -i output_chi_eng_eng.mp4 -vf \u0026#34;subtitles=output_chi_eng_eng.mp4:si=0\u0026#34; -crf:18 -o result.mp4 命令参数详解 -i output_chi_eng_eng.mp4 为你的输入视频文件\n-vf \u0026#34;subtitles=output_chi_eng_eng.mp4:si=0\u0026#34; 代表了要选用的滤镜，请注意，这里 -vf 后面的参数是双引号之间的内容\nsubtitles=output_chi_eng_eng.mp4 这里是字幕的来源，可以填写 mp4 文件\n:si=0 代表指定选择第 0 个字幕轨道。实际上此参数可以不加，FFmepg 将选择默认的字幕轨道。关于字幕轨道的编号可以通过播放器或 mediainfo 来查看，在 ffmpeg 中。si 是 subtitles 过滤器的一个选项，用于指定字幕流的索引。这里的 si 代表 \u0026#34;subtitle index\u0026#34;，即字幕流的索引。它必须用 si 而不是 s 是因为 s 是用来指定其它过滤器选项的缩写，例如 scale 或 setpts，而 si 特指字幕流的索引选择。\n-crf:18 这里简单指定了压制的质量，18 已经是画质较佳的选项。一般动画压制的范围在 16-23，可查找其他教程\n-o result.mp4 这里指定了输出文件名，mp4 的后缀将会自动将视频压制为 H.264 / AVC 编码。若需要使用其他封装格式请手动指定编码器为 libx264\nffmpeg将带字幕轨道的视频分离成无字幕视频，同时提取字幕文件及替换视频音轨 查看视频信息 命令 1 ffmpeg -i output_chi.mp4 查看视频信息结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $ ffmpeg -i output_chi.mp4 ffmpeg version N-112134-g9ef20920ab-20230920 Copyright (c) 2000-2023 the FFmpeg developers built with gcc 13.1.0 (crosstool-NG 1.25.0.196_227d99d) configuration: --prefix=/ffbuild/prefix --pkg-config-flags=--static --pkg-config=pkg-config --cross-prefix=x86_64-w64-mingw32- --arch=x86_64 --target-os=mingw32 --enable-gpl --enable-version3 --disable-debug --disable-w32threads --enable-pthreads --enable-iconv --enable-libxml2 --enable-zlib --enable-libfreetype --enable-libfribidi --enable-gmp --enable-lzma --enable-fontconfig --enable-libharfbuzz --enable-libvorbis --enable-opencl --disable-libpulse --enable-libvmaf --disable-libxcb --disable-xlib --enable-amf --enable-libaom --enable-libaribb24 --enable-avisynth --enable-chromaprint --enable-libdav1d --enable-libdavs2 --disable-libfdk-aac --enable-ffnvcodec --enable-cuda-llvm --enable-frei0r --enable-libgme --enable-libkvazaar --enable-libass --enable-libbluray --enable-libjxl --enable-libmp3lame --enable-libopus --enable-librist --enable-libssh --enable-libtheora --enable-libvpx --enable-libwebp --enable-lv2 --enable-libvpl --enable-openal --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenh264 --enable-libopenjpeg --enable-libopenmpt --enable-librav1e --enable-librubberband --enable-schannel --enable-sdl2 --enable-libsoxr --enable-libsrt --enable-libsvtav1 --enable-libtwolame --enable-libuavs3d --disable-libdrm --enable-vaapi --enable-libvidstab --enable-vulkan --enable-libshaderc --enable-libplacebo --enable-libx264 --enable-libx265 --enable-libxavs2 --enable-libxvid --enable-libzimg --enable-libzvbi --extra-cflags=-DLIBTWOLAME_STATIC --extra-cxxflags= --extra-ldflags=-pthread --extra-ldexeflags= --extra-libs=-lgomp --extra-version=20230920 libavutil 58. 25.100 / 58. 25.100 libavcodec 60. 26.100 / 60. 26.100 libavformat 60. 13.100 / 60. 13.100 libavdevice 60. 2.101 / 60. 2.101 libavfilter 9. 11.100 / 9. 11.100 libswscale 7. 3.100 / 7. 3.100 libswresample 4. 11.100 / 4. 11.100 libpostproc 57. 2.100 / 57. 2.100 Input #0, mov,mp4,m4a,3gp,3g2,mj2, from \u0026#39;output_chi.mp4\u0026#39;: Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf60.13.100 Duration: 00:00:07.00, start: 0.000000, bitrate: 1287 kb/s Stream #0:0[0x1](und): Video: h264 (High 4:4:4 Predictive) (avc1 / 0x31637661), yuv444p(progressive), 3840x1080, 1457 kb/s, 29.97 fps, 29.97 tbr, 30k tbn (default) Metadata: handler_name : VideoHandler vendor_id : [0][0][0][0] encoder : Lavc60.26.100 libx264 Stream #0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 127 kb/s (default) Metadata: handler_name : SoundHandler vendor_id : [0][0][0][0] Stream #0:2[0x3](chi): Subtitle: mov_text (tx3g / 0x67337874), 0 kb/s (default) Metadata: handler_name : SubtitleHandler At least one output file must be specified 可以看到第一个轨道是视频，第二个轨道是音频，第三个轨道是字幕\n提取字幕文件 1 2 3 4 #将第三个轨道subrip字幕轨道提取成srt文件 ffmpeg -i output_chi.mp4 -map \u0026#34;0:2\u0026#34; test.srt #将第三个轨道subrip字幕轨道提取成ass文件 ffmpeg -i output_chi.mp4 -map \u0026#34;0:2\u0026#34; test.ass 提取无字幕的视频文件 1 ffmpeg -i output_chi.mp4 -map \u0026#34;0:0\u0026#34; test.srt 或\n1 2 # 将第一轨道的视频和第二轨道的音频重新生成新的视频文件 ffmpeg -i .\\33死者们的侵略.mp4 -map 0:0 -map 0:1 -vcodec copy -acodec copy 33死者们的侵略（无字幕）.mp4 命令参数详解 -i: 输入文件 -map 0:0: 第1个输入文件的第一个流，也就是主要的视频流。 -map 0:1: 第1个输入文件的第二个流，是视频的声音。 -vcodec copy: 拷贝选择的视频流。 -acodec copy: 拷贝选择的声音流。 提取音频文件 1 ffmpeg -i output_chi.mp4 -map \u0026#34;0:1\u0026#34; test.mp3 或\n1 ffmpeg -i 1.mp4 -c:a mp3 -map 0:a:0 targetAudio.mp3 命令参数详解 -i 1.mp4 指定输入的视频文件名称和路径 -c:a mp3 指定输出的音频编码采用mp3编码器 -map 0:a:0 指定输入输出的映射 targetAudio.mp3 指定输出的音频文件名称和路径 使用ffmpeg替换视频音轨 1 ffmpeg -i 1.mp4 -i 2.mp3 -c:v copy -c:a alac -map 0:v:0 -map 1:a:0 3.mp4 命令参数详解 -i sourceVideo.mp4 指定输入的视频文件名称和路径 -i sourceAudio.flac 指定输入的音频文件名称和路径，这里是一个无损格式的flac音频文件 -c:v copy 指定输出的视频编码，copy指直接拷贝源文件的内容，不就行二次编码 -c:a alac 指定输出的音频编码采用alac编码器 -map 0:v:0 指定第一个输入映射到输出的视频 -map 1:a:0 指定第二个输入映射到输出的音频 targetVideo.mp4 指定输出的视频文件名称和路径 参考链接 FFmpeg添加字幕的详细操作\n使用 FFmpeg 将 MKV 内封字幕压制为内嵌硬字幕\nffmpeg 视频音轨的提取及替换\nffmpeg给视频添加文字 1 ffmpeg -i 1.mp4 -vf drawtext=fontcolor=red:fontsize=50:text=\u0026#39;Hello World!\u0026#39;:x=0:y=100 -y 5.mp4 上面简单命令的相关参数 输入文件 1.mp4 fontcolor 文字颜色 为黑色red fontsize 文字大小 为50 text 文本内容 “Hello Word” 文本所处的位置 x=0,y=100 输出文件 5.mp4 相关命令参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 between(x, min, max) Return 1 if x is greater than or equal to min and lesser than or equal to max, 0 otherwise. ... gt(x, y) Return 1 if x is greater than y, 0 otherwise. gte(x, y) Return 1 if x is greater than or equal to y, 0 otherwise. ... if(x, y) Evaluate x, and if the result is non-zero return the result of the evaluation of y, return 0 otherwise. if(x, y, z) Evaluate x, and if the result is non-zero return the evaluation result of y, otherwise the evaluation result of z. ... lt(x, y) Return 1 if x is lesser than y, 0 otherwise. lte(x, y) Return 1 if x is lesser than or equal to y, 0 otherwise. ... mod(x, y) Compute the remainder of division of x by y. 前5秒加文字 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=40:text=\u0026#39;test\u0026#39;:x=50:y=50:enable=\u0026#39;lte(t\\,5)\u0026#39; -y 9.mp4 5秒后加文字 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=40:text=\u0026#39;test\u0026#39;:x=50:y=50:enable=\u0026#39;gte(t\\,5)\u0026#39; -y 10.mp4 第2秒到第5加文字 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=40:text=\u0026#39;test\u0026#39;:x=50:y=50:enable=\u0026#39;between(t\\,2\\,5)\u0026#39; -y 11.mp4 参数详解 between(t\\,start\\,end)：这个条件判断 t 是否在 start 和 end 之间。例如，between(t\\,2\\,5) 会在视频播放时间从第 10 秒到第 15 秒之间为 true，即在这段时间内显示文本。\n每隔3秒周期显示1秒文字 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=40:text=\u0026#39;test\u0026#39;:x=50:y=50:enable=\u0026#39;lte(mod(t\\,3)\\,1)\u0026#39; -y 12.mp4 间隔1秒依次显示hello和world 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=40:text=\u0026#39;hello\u0026#39;:x=50:y=50:enable=\u0026#39;lte(mod(t\\,2)\\,1)\u0026#39;,drawtext=fontcolor=red:fontsize=40:text=\u0026#39;world\u0026#39;:x=50:y=50:enable=\u0026#39;gte(mod(t\\,2)\\,1)\u0026#39; -y 13.mp4 文字从左向右移动 每帧移动50个像素 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=60:text=\u0026#39;test\u0026#39;:x=50+50*t:y=50 -y 14.mp4 参数解释 x=50+50*t：文本的水平位置随着时间变化。50+50*t 意味着文本的水平位置会随着视频播放时间 t 增加，每秒移动 50 像素。\n从下往上移动，每次移动100像素 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=50:text=\u0026#39;Hello World!\u0026#39;:y=h-100*t -y 15.mp4 打印real time 1 ffmpeg -i input.mp4 -vf drawtext=fontcolor=red:fontsize=40:text=\u0026#39;%{localtime}\u0026#39;:x=200:y=200 -y 16.mp4 将每帧的时间戳以 hh:mm:ss 格式叠加到视频上 1 ffmpeg -i input.mp4 -vf \u0026#34;drawtext=fontcolor=red:fontsize=40:text=\u0026#39;%{pts\\:hms}\u0026#39;:x=10:y=10\u0026#34; -y 17.mp4 参考链接 ffmpeg给视频添加文字\n水印的添加与去除 ffmpeg添加水印 基本命令 ffmpeg添加水印主要通过overlay滤镜实现。以下是一个基本示例，展示了如何在视频中添加静态水印：\n1 ffmpeg -i input.mp4 -i yenao.png -filter_complex \u0026#34;overlay=400:50\u0026#34; -y 6.mp4 在这个命令中，-i input.mp4指定了输入视频文件，-i logo.png指定了水印图片文件，overlay=10:10表示将水印放置在视频的左上角（距离左边和上边各10像素的位置），output.mp4是输出视频文件。\n自定义水印位置 1 ffmpeg -i input.mp4 -i yenao.png -filter_complex \u0026#34;overlay=main_w-overlay_w-100:main_h-overlay_h-100\u0026#34; -y 6.mp4 其中，main_w和main_h分别代表主视频的宽度和高度，overlay_w和overlay_h分别代表水印的宽度和高度。通过计算，可以将水印放置在指定位置。\n透明水印 如果水印图片包含透明通道（如PNG图片），则可以直接使用ffmpeg添加透明水印。不需要额外的设置，ffmpeg会自动处理透明通道。\nfmpeg去除水印 delogo是ffmpeg中用于去除视频中固定位置标志或水印的滤镜。基本语法如下：\n1 ffmpeg -i input.mp4 -vf \u0026#34;delogo=x:y:w:h[:band[:show]]\u0026#34; output.mp4 其中，x和y是水印左上角的坐标，w和h是水印的宽度和高度，band是可选的边缘模糊宽度（默认值为4），show是可选的，如果设置为1，将显示一个矩形表示删除的区域（默认值为0）。\n示例 1 ffmpeg -i 6.mp4 -vf delogo=x=400:y=50:w=70:h=30 -y 8.mp4 遮盖水印 如果delogo滤镜的效果不理想，可以尝试使用drawbox滤镜来遮盖水印。基本语法如下：\n1 ffmpeg -i input.mp4 -vf \u0026#34;drawbox=x:y:w:h:color[:t]\u0026#34; output.mp4 其中，x、y、w、h分别代表矩形的位置和大小，color是矩形的颜色（可以是颜色名称或十六进制代码），t是矩形的厚度（t=fill表示填充整个区域）。\n示例 1 ffmpeg -i 6.mp4 -vf drawbox=x=400:y=50:w=70:h=30:color=red:t=fill -y 7.mp4 参考链接 ffmpeg实战：水印的添加与去除\n如何使用 ffmpeg 剪切和裁剪视频 如何使用ffmpeg剪切视频 使用 ffmpeg 剪切视频是一项非常简单、快速且资源消耗低的任务。您只需要定义开始或结束时间，或两者（如果需要）和输出文件。\n下面的命令使用 ffmpeg 从标志 -ss 指定的 00:00:05 处开始剪切视频；这是定义新视频起点的标志，以防您想剪切开头的一部分。如果您只想剪切视频末尾的一部分，则不需要使用此标志。如您所见，计时格式必须为 HH:MM:SS（小时、分钟、秒）。例如，对于 2 分 3 秒的计时，您应该键入 00:02:03。\n-i 标志用于指定要编辑的文件；\n选项-t用于指定新文件的结尾；在这种情况下，视频将在 00:00:05 结束。与 -ss 类似，如果您不想剪切视频结尾的部分，而只想剪切开头的部分，则不需要应用此标志。\n在这种情况下，-c copy 标志用于定义输出文件；\n从 -ss 00:00:05 处开始，剪辑了 -t 00:00:05 这么长时间，共5秒\n1 ffmpeg -ss 00:00:05 -i input.mp4 -t 00:00:05 -c copy -y 1.mp4 整个操作只需几秒钟，不消耗计算机资源。\n下一个示例演示如何仅剪切视频的结尾部分。因此，我省略了选项 -ss，因为我想保留起点，并通过实施 -t 标志在 00:00:05 剪切视频。\n1 ffmpeg -i input.mp4 -t 00:00:05 -c copy -y 3.mp4 与前面的示例相反，下面的命令仅使用 -ss 标志来剪切视频开头的部分。在这种情况下，新输出将从 00:00:05 开始。\n1 ffmpeg -ss 00:00:05 -i input.mp4 -c copy -y 4.mp4 如您所见，使用 ffmpeg 剪切视频是一个简单而快速的过程。\n使用 ffmpeg 裁剪黑色边框 本教程的这一部分介绍如何使用 ffmpeg 裁剪视频。\n您可以使用 ffmpeg 尝试自动检测如何裁剪视频以去除黑色边框。\n下面的命令将尝试检测正确的尺寸和位置以正确裁剪视频。\n1 timeout 3s ffmpeg -i input.mp4 -vf cropdetect -f null - 2\u0026gt;\u0026amp;1 | awk \u0026#39;/crop/ {print $NF}\u0026#39; | head -n 1 如您所见，ffmpeg 返回正确的宽度 (320)、高度 (208)、X 和 Y 位置以正确裁剪视频。\nX 位置：X 位置定义从左边距开始的水平裁剪起点，其中左边距为 0。\nY 位置：Y 是垂直裁剪起始点，上边距为 0。\n视频下面的示例将被裁剪；您可以看到 -filter:v 标志。\n-filter 标志实现一个过滤器图，该过滤器图划分输入流，裁剪它，并将其与其他流叠加。如您所见，下面的命令中定义的尺寸和位置是由上一个命令提供的。\n另外，您可以看到省略了标志“-c copy”，并且输出文件名写在作物标志之后。\n1 ffmpeg -i 1.mp4 -filter:v \u0026#34;crop=1920:1072:0:4\u0026#34; -y 5.mp4 参数解释 timeout 3s：timeout 命令会在指定时间（如 3 秒）后强制终止 ffmpeg 命令。你可以根据需要调整时间长度。 ffmpeg -i input.mp4 -vf cropdetect -f null - 2\u0026gt;\u0026amp;1：执行视频裁剪检测，将输出重定向到标准输出。 awk \u0026#39;crop {print $NF}\u0026#39;：过滤包含 “crop” 的行，并打印最后一个字段。 head -n 1：只取 awk 输出的第一行。\n说明 timeout 命令会在指定时间后终止 ffmpeg 进程。如果 ffmpeg 在超时时间内找到了裁剪建议并打印出来，head -n 1 将确保你只得到第一行输出。 timeout 的时间需要根据你的视频长度和处理速度进行调整，以确保它足够长以捕捉到裁剪建议，但又不会长到影响效率。\n关于使用 ffmpeg 裁剪视频： 您可以使用以前的技术裁剪视频的任何部分，而不仅仅是黑色边框。\n下面的命令将裁剪上一个视频，返回 200×200 的图像，从左侧开始 200 像素，从上边距开始 0 像素。\n1 ffmpeg -i 5.mp4 -filter:v \u0026#34;crop=200:200:200:0\u0026#34; 6.mp4 如果不指定位置，ffmpeg会自动裁剪视频的中心。因此，在下面的示例中，仅定义了视频的高度和宽度，但没有定义位置，ffmpeg 将裁剪视频并返回视频中心的 500×500 裁剪输出。\n1 ffmpeg -i 5.mp4 -filter:v \u0026#34;crop=200:200\u0026#34; 7.mp4 如果需要，可以使用ffmpeg命令结合grep来了解原始视频分辨率，如下所示。\n1 ffmpeg -i 5.mp4 2\u0026gt;\u0026amp;1 | grep \u0026#34;Video:\u0026#34; | grep -Po \u0026#39;\\d{3,5}x\\d{3,5}\u0026#39; FFmpeg如何将一个gif嵌入视频指定位置并指定显示时间 1 ffmpeg -i test.mp4 -stream_loop -1 -i test.gif -filter_complex \u0026#34;[0:v][1:v] overlay=10:10:enable=\u0026#39;between(t,3,4)\u0026#39;:shortest=1\u0026#34; -y output.mp4 或\n1 ffmpeg -i test.mp4 -stream_loop -1 -i test.gif -filter_complex \u0026#34;overlay=10:10:enable=\u0026#39;between(t,3,4)\u0026#39;:shortest=1\u0026#34; -y output.mp4 参数详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ffmpeg: 调用 FFmpeg 工具。 -i test.mp4: 指定输入视频文件 test.mp4。 -stream_loop -1 -i test.gif: 指定输入动图 test.gif 并使其无限循环（-1 表示无限循环）。 -filter_complex: 应用复杂的滤镜链，允许同时处理多个输入流。 \u0026#34;[0:v][1:v] overlay=10:10:enable=\u0026#39;between(t,3,4)\u0026#39;:shortest=1\u0026#34;: [0:v]: 第一个输入的第一个视频流（即 test.mp4）。 [1:v]: 第二个输入的第一个视频流（即 test.gif）。 overlay=10:10: 在 test.mp4 上覆盖 test.gif，并将 test.gif 放置在视频的 (10,10) 位置。 enable=\u0026#39;between(t,3,4)\u0026#39;: 仅在 test.mp4 的时间从第3秒到第4秒之间显示覆盖。 shortest=1: 确保输出视频长度与最短输入视频流长度一致。 -y: 自动覆盖输出文件 output.mp4（如果存在）。 output.mp4: 指定输出文件名。 参考链接 FFmpeg如何将一个gif嵌入视频指定位置并指定显示时间\n视频转换成帧图片再转换成视频，如何考虑速率问题 将视频转换为帧图片，再将这些帧图片重新转换为视频时，考虑到速率（即帧率）的问题是关键。以下是处理这一过程的步骤和相关说明：\n脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 vcodec_1=\u0026#34;libx264\u0026#34;\t# 视频编码格式 crf_1=\u0026#34;25\u0026#34;\t# 画质 fps=$(ffprobe \u0026#34;$1\u0026#34; 2\u0026gt;\u0026amp;1 | grep -Eo \u0026#34;[0-9]{2,5} fps\u0026#34; | awk \u0026#39;{print $1}\u0026#39;) # 获取帧率 s=$(ffprobe \u0026#34;$1\u0026#34; 2\u0026gt;\u0026amp;1 | grep \u0026#34;Video\u0026#34; | grep -Eo \u0026#34;[0-9]{3,5}x[0-9]{3,5}\u0026#34;)\t# 获取分辨率 b=$(ffprobe \u0026#34;$1\u0026#34; 2\u0026gt;\u0026amp;1 | grep \u0026#34;bitrate\u0026#34; | grep -Eo \u0026#34;[0-9]{4,6} kb/s\u0026#34; | awk \u0026#39;{print $1}\u0026#39;) pix_fmt=$(ffprobe \u0026#34;$1\u0026#34; 2\u0026gt;\u0026amp;1 | grep -Eo \u0026#34;, .*(.*progressive)\u0026#34; | awk -F \u0026#39;(\u0026#39; \u0026#39;{print $1}\u0026#39; | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; | sed \u0026#39;s/ //g\u0026#39;) # 获取像素格式 # echo \u0026#34;fps: ${fps}\u0026#34; # echo \u0026#34;s: ${s}\u0026#34; # echo \u0026#34;pix_fmt: ${pix_fmt}\u0026#34; case $2 in R) dir=$(echo \u0026#34;$1\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;) mkdir -p \u0026#34;${dir}\u0026#34; ffmpeg -i \u0026#34;$1\u0026#34; -vf \u0026#34;fps=${fps}\u0026#34; -y \u0026#34;${dir}\u0026#34;/%d.png cd \u0026#34;${dir}\u0026#34; mapfile -t files \u0026lt; \u0026lt;(ls *.png | sort -nr); for i in \u0026#34;${files[@]}\u0026#34;; do echo \u0026#34;file \u0026#39;${i}\u0026#39;\u0026#34;; done | cat \u0026gt; pngRlist.txt # 生成帧图片的文件列表 ffmpeg -f concat -safe 0 -i pngRlist.txt -vf palettegen -y palette.png # 生成调色板 case $3 in mp4) ffmpeg -r \u0026#34;${fps}\u0026#34; -f image2 -f concat -safe 0 -i pngRlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -vcodec \u0026#34;${vcodec_1}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y routput.mp4 # 将视频转换为倒放 rm *.png rm *.txt ;; gif) ffmpeg -r \u0026#34;${fps}\u0026#34; -f concat -safe 0 -i pngRlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y routput.gif # 将视频转换为倒放的gif rm *.png rm *.txt ;; rgif) ffmpeg -r \u0026#34;${fps}\u0026#34; -f concat -safe 0 -i pngRlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y routput.gif # 将视频转换为gif ffmpeg -i routput.gif -vf \u0026#34;scale=${4}:-2\u0026#34; -y rsoutput.gif # 缩放gif文件 rm *.png rm *.txt ;; all) ffmpeg -r \u0026#34;${fps}\u0026#34; -f image2 -f concat -safe 0 -i pngRlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -vcodec \u0026#34;${vcodec_1}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y routput.mp4 # 将视频转换为倒放 ffmpeg -r \u0026#34;${fps}\u0026#34; -f concat -safe 0 -i pngRlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y routput.gif # 将视频转换为倒放的gif\tffmpeg -i routput.gif -vf \u0026#34;scale=${4}:-2\u0026#34; -y rsoutput.gif # 缩放gif文件 rm *.png rm *.txt\tesac ;; N) dir=$(echo \u0026#34;$1\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;) mkdir -p \u0026#34;${dir}\u0026#34; ffmpeg -i \u0026#34;$1\u0026#34; -vf \u0026#34;fps=${fps}\u0026#34; -y \u0026#34;${dir}\u0026#34;/%d.png cd \u0026#34;${dir}\u0026#34; mapfile -t files \u0026lt; \u0026lt;(ls *.png | sort -n); for i in \u0026#34;${files[@]}\u0026#34;; do echo \u0026#34;file \u0026#39;${i}\u0026#39;\u0026#34;; done | cat \u0026gt; pngNlist.txt # 生成帧图片的文件列表 ffmpeg -f concat -safe 0 -i pngNlist.txt -vf palettegen -y palette.png # 生成调色板\tcase $3 in gif) ffmpeg -r \u0026#34;${fps}\u0026#34; -f concat -safe 0 -i pngNlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y noutput.gif # 将视频转换为gif\trm *.png rm *.txt ;; sgif) ffmpeg -r \u0026#34;${fps}\u0026#34; -f concat -safe 0 -i pngNlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y noutput.gif # 将视频转换为gif ffmpeg -i noutput.gif -vf \u0026#34;scale=${4}:-2\u0026#34; -y nsoutput.gif # 缩放gif文件 rm *.png rm *.txt ;; all) ffmpeg -r \u0026#34;${fps}\u0026#34; -f concat -safe 0 -i pngNlist.txt -i palette.png -pix_fmt \u0026#34;${pix_fmt}\u0026#34; -crf \u0026#34;${crf_1}\u0026#34; -lavfi paletteuse -s \u0026#34;${s}\u0026#34; -y noutput.gif # 将视频转换为gif ffmpeg -i noutput.gif -vf \u0026#34;scale=${4}:-2\u0026#34; -y nsoutput.gif # 缩放gif文件 rm *.png rm *.txt esac ;; s)\tffmpeg -i \u0026#34;$1\u0026#34; -vf \u0026#34;scale=${3}:-2\u0026#34; -y soutput.gif ;; c) ffmpeg -i \u0026#34;$1\u0026#34; -y coutput.gif ;; cs) ffmpeg -i \u0026#34;$1\u0026#34; -y coutput.gif ffmpeg -i \u0026#34;$1\u0026#34; -vf \u0026#34;scale=${3}:-2\u0026#34; -y csoutput.gif ;; esac 参考链接 FFmpeg将有序帧（图片）转换成视频（解决了生成视频后播放闪烁的问题）\n【ffmpeg命令入门】重新编码媒体流、设置码率、设置帧速率\n1. 将视频转换为帧图片 首先，你需要确定你想从视频中提取的帧率（fps）。可以使用 ffmpeg 提取帧图片，并指定 fps 参数：\n1 ffmpeg -i input.mp4 -vf fps=25 frame_%04d.png 这里 fps=25 表示你从视频中每秒提取 25 帧。frame_%04d.png 是帧图片的命名格式，其中 %04d 是一个四位数的递增编号（如 0001, 0002, 等等）。\n2. 将帧图片重新转换为视频 当你把这些帧图片转换回视频时，你需要指定与提取时相同的帧率。这样可以确保视频播放的速率与原始视频一致：\n1 ffmpeg -framerate 25 -i frame_%04d.png -c:v libx264 -r 25 output.mp4 -framerate 25 表示输入的帧图片的帧率。 -i frame_%04d.png 是输入的帧图片文件名格式。 -c:v libx264 表示使用 libx264 编码器来编码视频。 -r 25 是输出视频的帧率，与输入帧图片的帧率保持一致。 注意事项 帧率一致性：确保提取帧时和重建视频时的帧率一致，以避免视频播放速度的变化。 文件命名：帧图片的命名格式应保持一致，以便 ffmpeg 能正确读取所有帧。 编码设置：选择合适的视频编码器和参数，以确保输出视频的质量和压缩效果。 通过正确设置这些参数，你可以在帧图片和视频之间进行转换，而不会影响最终视频的播放速率。\n把视频拆帧的方法 1 ffmpeg -i 3.mp4 -vf fps=20 %d.png 这个 ffmpeg 命令将 3.mp4 视频按每秒 20 帧的速度提取为一系列 PNG 图片。每张图片将按递增的数字命名（如 1.png, 2.png）。确保 ffmpeg 已安装并在你的 PATH 中。如果有问题，可以检查文件路径或命名格式是否正确。\n参考链接 把视频拆帧的方法 ffmpeg\n用ffmpeg从多张图片生成动图 在做笔记、写博客或者制作梗图时，我们有时需要将多张图片合成为动图。这里介绍一种使用 ffmpeg 从多张图片生成动图的方法。\n通过 ffmpeg -h encoder=gif 可以得知 ffmpeg 支持的 GIF 编码器仅支持 rgb8 bgr8 rgb4_byte bgr4_byte gray pal8 7 种 pixel format，不支持输入文件使用的 rg24。在 ffmpeg 将其强制转换为 rgb8 时，颜色出现偏差。\n使用调色板解决颜色偏差问题 首先用以下命令生成调色板 1 ffmpeg -i %d.png -vf palettegen palette.png -i %d.png：指定输入文件。%d.png 表示输入文件是以 1.png, 2.png, 3.png 等格式命名的一系列图像。%d 是一个格式说明符，表示这是一个数字序列。\n如果不是以数字进行命名排列的，可以使用文件列表的方式进行操作 将文件添加到列表 1 mapfile -t files \u0026lt; \u0026lt;(ls | sort); for i in \u0026#34;${files[@]}\u0026#34;; do echo \u0026#34;file \u0026#39;${i}\u0026#39;\u0026#34;; done | cat \u0026gt; test.txt 生成调色板 1 ffmpeg -f concat -safe 0 -i test.txt -vf palettegen -y test.png 然后在生成动图时使用调色板 1 ffmpeg -framerate 1 -i %d.png -i palette.png -lavfi paletteuse out.gif -framerate 1 是用来设置帧速率为间隔1秒\n如果是文件列表方式生成的可以按照如下命令操作 1 ffmpeg -r 1 -f concat -safe 0 -i test.txt -i test.png -lavfi paletteuse -y test.gif -r 是用来设置帧速率为间隔1秒 参考链接 用ffmpeg从多张图片生成动图\nFFmpeg 视频旋转处理命令 ffmpeg -vf -vf指令是一些简单的视频过滤器。\n顺时针旋转90° 1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=1\u0026#34; -y output.mp4 逆时针旋转90° 1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=2\u0026#34; -y output.mp4 水平翻转 1 ffmpeg -i input.mp4 -vf hflip -y output.mp4 水平翻转 1 ffmpeg -i input.mp4 -vf vflip -y output.mp4 逆时针旋转90°后再水平翻转 也可以理解为水平翻转后逆时针旋转90°。\n1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=3\u0026#34; -y output.mp4 等效于\n1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=2,hflip\u0026#34; -y output.mp4 顺时针旋转90°后再水平翻转 也可以理解为水平翻转后逆时针旋转90°\n1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=0\u0026#34; -y output.mp4 等效于\n1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=1,hflip\u0026#34; -y output.mp4 旋转180° 1 ffmpeg -i input.mp4 -vf \u0026#34;transpose=1,transpose=1\u0026#34; -y output.mp4 顺时针旋转45° 1 ffmpeg -i input.mp4 -vf \u0026#34;rotate=PI/4\u0026#34; -y output.mp4 兀等于180度，可以计算不同的值进行旋转\n参考链接 FFmpeg 视频旋转处理命令\nffmpeg 中打印实时信息 要在 ffmpeg 中打印实时信息，你可以使用 -loglevel 参数来调整日志详细程度。在命令中添加 -loglevel debug 将显示更详细的调试信息，包括时间戳和实时数据。示例如下：\n1 ffmpeg -loglevel debug -i input.mp4 -vf \u0026#34;drawtext=fontcolor=red:fontsize=40:text=\u0026#39;%{pts\\:hms}\u0026#39;:x=10:y=10\u0026#34; -y 17.mp4 ffplay常用参数总结 通过ffplay播放视频时，窗口的大小规则是如何呢？\n答：如果拉取视频流的分辨率大于屏幕分辨率，那么ffplay播放时会将视频画面缩放至屏幕大小；如果拉取视频流的分辨率大小小于屏幕分辨率，那么ffplay播放时会按照视频分辨率的大小调整窗口大小。\n调整播放窗口大小\n答：通过-x xx -y xx的方式来调整播放窗口的大小\n调整播放窗口的位置\n答：通过-left xxx -top xxx的方式来调整播放窗口的位置，例如-left 0 -top 0来指出播放窗口在屏幕的左上角。\n设置播放窗口标题\n答：通过-window_title xxxxx 来设置窗口标题，注意不需要双引号\n设置播放窗口没有标题栏\n答：通过-noborder来取消播放窗口的标题栏，设置该选项后，播放窗口则不存在标题栏\n指定播放窗口位置和窗口大小 首先录制一个时长为3秒，分辨率为960x540的视频 1 ffmpeg -t 3 -f gdigrab -offset_x 0 -offset_y 0 -video_size 960x540 -i desktop -y out.mp4 指定窗口播放位置，根据分辨率长和高的数值进行位置数值的调整 1 ffplay -window_title test -left 960 -top 540 out.mp4 指定播放窗口的大小 1 ffplay -window_title test -x 1000 -y 1000 out.mp4 最好是跟分辨率对应着进行设置，例如视频的分辨率也是960x540\n1 ffplay -window_title test -x 960 -y 540 out.mp4 将指定位置和指定大小的选项结合起来用 视频在屏幕右上角播放\n1 ffplay -window_title test -left 960 -top 0 -x 960 -y 540 out.mp4 参考链接 ffplay常用参数总结\n播放 yuv 格式的视频 将yuv文件转换为mp4文件 1 ffmpeg -s:v 640x480 -pix_fmt yuv420p -i input.yuv output.mp4 直接播放yuv文件 1 ffplay -video_size 640x480 -i video.yuv 使用 ffplay 一帧一帧地播放视频 要使用 ffplay 一帧一帧地播放视频，您可以通过在命令行中逐帧显示视频帧的方式来实现。以下是一种常见的方法：\n1 ffplay -vf \u0026#34;select=\u0026#39;eq(n\\,FRAME_NUMBER)\u0026#39;\u0026#34; input.mp4 在这个命令中，将 `FRAME_NUMBER` 替换为您想要查看的帧数（从0开始），`input.mp4` 是您的视频文件名。\n通过这个命令，ffplay 将加载视频并显示指定帧的内容。您可以通过不断更改 `FRAME_NUMBER` 的值来逐帧显示视频内容，从而实现一帧一帧地播放视频。\n需要注意的是，ffplay 是一个简单的用于播放视频和音频的工具，如果您需要更多交互性或者更复杂的播放控制，可能需要借助其他工具或编程语言来实现。\n循环播放视频 1 ffplay -loop 0 output_ass.mp4 命令说明 -loop number 循环播放影片 \u0026lt;number\u0026gt; 次。0表示永远。\nffplay倍速播放 音频变速播放 1 ffplay -i test.mp4 -af atempo=2 视频变速播放 1 ffplay -i test.mp4 -vf setpts=PTS/2 音视频同时变速 1 ffplay -i test.mp4 -vf setpts =PTS/2 -af atempo =2 参考链接 FFplay命令 —- 播放与参数选项\n参考链接 ffmpeg安装教程（windows版）\nffplay 文档\n视频裁剪与拼接命令 ( 裁剪视频命令 | h264 编码的 SPS 和 PPS 数据 | 拼接视频 - 相同编码和相同容器格式的拼接 | 拼接视频 - 不同编码和容器格式的拼接测试 拼接视频 - 相同编码和相同容器格式的拼接测试 拼接视频命令 - mp4 格式 方法一，使用concat demuxer进行视频文件的合并 将视频添加到文件列表 1 mapfile -t files \u0026lt; \u0026lt;(ls | sort); for i in \u0026#34;${files[@]}\u0026#34;; do echo \u0026#34;file \u0026#39;${i}\u0026#39;\u0026#34;; done | cat \u0026gt; test.txt 合并视频 这种合并方式的适用场景是：当容器格式不支持文件层次的合并，而又不想（不需要）进行再编码的操作的时候。这种方式对源视频同样有同格式同性质的要求。其详细语法参见 这里 。典型的命令示例如下：\n1 ffmpeg -f concat -i test.txt -c copy -y test.mp4 指定文件列表拼接 mp4 视频 - 拼接成功但是播放不正常\n拼接视频命令 - ts 格式 将mp4转换为ts 1 mapfile -t files \u0026lt; \u0026lt;(ls *.mp4 | sort); for i in \u0026#34;${files[@]}\u0026#34;; do ffmpeg -i \u0026#34;${i}\u0026#34; -vcodec libx264 \u0026#34;${i}.ts\u0026#34;; done 将ts文件添加为文件列表 1 mapfile -t files \u0026lt; \u0026lt;(ls *.ts | sort); for i in \u0026#34;${files[@]}\u0026#34;; do echo \u0026#34;file \u0026#39;${i}\u0026#39;\u0026#34;; done | cat \u0026gt; ts.txt 将ts文件进行拼接 1 ffmpeg -f concat -i ts.txt -c copy output.ts 拼接视频命令 - flv 格式 将mp4转换为flv 1 mapfile -t files \u0026lt; \u0026lt;(ls *.mp4 | sort); for i in \u0026#34;${files[@]}\u0026#34;; do ffmpeg -i \u0026#34;${i}\u0026#34; -vcodec libx264 \u0026#34;${i}.flv\u0026#34;; done 将flv文件添加为文件列表 1 mapfile -t files \u0026lt; \u0026lt;(ls *.flv | sort); for i in \u0026#34;${files[@]}\u0026#34;; do echo \u0026#34;file \u0026#39;${i}\u0026#39;\u0026#34;; done | cat \u0026gt; flv.txt 将flv文件进行拼接 1 ffmpeg -f concat -i flv.txt -c copy output.flv 参考链接 【FFmpeg】视频裁剪与拼接命令 ( 裁剪视频命令 | h264 编码的 SPS 和 PPS 数据 | 拼接视频 - 相同编码和相同容器格式的拼接 | 拼接视频 - 不同编码和容器格式的拼接测试 )\n如何使用 ffmpeg 剪切和裁剪视频\n手把手教你用ffmpeg制作表情包 准备视频素材 裁剪视频 找到要裁剪的时间段：00:00:02，裁剪时长3秒，进行裁剪：\n1 ffmpeg -ss 00:00:02 -i 7.mp4 -t 00:00:03 gif.mp4 添加文字 ffmpeg中可以用drawtext filter为视频添加水印或添加文字，需要编译ffmpeg添加支持：\n使用drawtext，编译时需要加上–enable-libfreetype 要使用多种字体，需要加上–enable-libfontconfig 需要字体变形，需要加上–enable-libfribidi 1 ffmpeg -i gif.mp4 -vf \u0026#34;drawtext=yellow:fontsize=40:text=\u0026#39;Gif测试\u0026#39;:x=(w-text_w)/2:y=h-th-20\u0026#34; -y gif_3s.mp4 设置文字位置： 顶端左侧: x=0:y=0 (边缘留白10像素： x=10:y=10) 顶端居中: x=(w-text_w)/2:y=0 (边缘留白10像素： x=(w-text_w)/2:y=10) 顶端右侧: x=w-tw:y=0 (边缘留白10像素: x=w-tw-10:y=10) 画面中心: x=(w-text_w)/2:y=(h-text_h)/2 底端左侧: x=0:y=h-th (边缘留白10像素: x=10:y=h-th-10) 底端居中: x=(w-text_w)/2:y=h-th (边缘留白10像素: x=(w-text_w)/2:y=h-th-10) 底端右侧: x=w-tw:y=h-th (边缘留白10像素: x=w-tw-10:y=h-th-10) 如果有多句话，可以指定时间段进行添加 1 ffmpeg -i gif.mp4 -vf \u0026#34;drawtext=enable=\u0026#39;between(t,0,1)\u0026#39;:fontcolor=yellow:fontsize=40:text=\u0026#39;hello\u0026#39;:x=(w-text_w)/2:y=h-th-20\u0026#34;,\u0026#34;drawtext=enable=\u0026#39;between(t,1,2)\u0026#39;:fontcolor=yellow:fontsize=40:text=\u0026#39;world\u0026#39;:x=(w-text_w)/2:y=h-th-20\u0026#34; -y out_3s.mp4 enable=\u0026#39;between(t,0,1)\u0026#39; 指定的是在0s-1s之间添加文字。 enable=\u0026#39;between(t,1,2)\u0026#39; 指定的是在1s-2s之间添加文字。 缩放视频尺寸 裁剪好后的源视频是1920x1080 1080格式的，做成gif可能有点大，需要先进行缩放：\n1 ffmpeg -i gif_3s.mp4 -vf \u0026#34;scale=360:-2\u0026#34; -y small_3s.mp4 注意 sacle 值必须是偶数，这里的 -2 表示要求压缩出来的视频尺寸长宽都保持为偶数.如果需要保持长宽比，根据宽度值自适应高度，可以使用 -1。\n我这里只进行缩小就可以了，你也可能有加速播放和慢速播放的需要，也可以用实现。\n加倍速播放视频 1 ffmpeg -i small_3s.mp4 -filter:v \u0026#34;setpts=0.5*PTS\u0026#34; out_speedup.mp4 定义帧率 16fps 1 ffmpeg -i small_3s.mp4 -r 16 -an -y out_16_fps.mp4 -an 选项表示“去除音频”。在你的命令中，-an 会移除视频文件 out_3s.mp4 的音频流，只保留视频流。\n慢倍速播放视频 1 ffmpeg -i gif_3s.mp4 -filter:v \u0026#34;setpts=2.0*PTS\u0026#34; out_slowdown.mp4 将视频 MP4 转化为 GIF 经过以上步骤，已经有了我们处理完成的视频文件，只需要转换成gif即可\n1 ffmpeg -i small_3s.mp4 small.gif 转化成gif默认转换是中等质量的，压缩的比较厉害，可以修改比特率提高gif质量：\n1 ffmpeg -i small_3s.mp4 -b 2048k -y small_3s.gif 统过以上步骤就完成了我们要制作的gif，ffmpeg的生态比较丰富，目前很多在线制作表情包的网站和一些Telegram上的bot，就是通过ffmpeg进行制作。也可以找其它的视频进行制作，比如，张学友：食屎啦你、有钱真的可以为所欲为、王镜泽： 真香 等等。\nmp4转gif 转换命令 1 ffmpeg -i test.mp4 -y test.gif 参考链接 利用 FFmpeg 将视频转换为 GIF 操作指北\n手把手教你用ffmpeg制作表情包\n使用ffplay拉流RSTP-海康威视摄像机 1 ffplay rtsp://admin:qingyikeji1@192.168.0.64:554/h264/ch1/main/av_stream windows环境下实现ffmpeg本地视频进行rtsp推流 摘要：有时候服务端（如linux）或者边缘端（jetson盒子）需要接受摄像头的视频流输入，而摄像头的输入视频流一般为rtsp，测试时需要搭建摄像头环境，很不方便，因此需要对本地视频进行rtsp推流，模拟摄像头的rtsp输入。\n环境搭建 系统环境 本地使用windows11 64位\n下载rtsp rtsp下载地址\n下载ffmpeg ffmpeg下载地址\n把rtsp和ffmpeg解压到同一个文件夹 把上面下载的两个压缩包解压到同一个文件夹，视频也放到该文件夹目录下，如下图所示：\nffmpeg对本地视频进行rtsp推流 启动rtsp 双击点开mediamtx.exe，得到如下图画面：\nffpmeg推流本地视频 打开cmd终端(win+r，输入cmd, 回车)，进入到ffmpeg.exe所在路径，使用以下命令：\n1 ffmpeg -re -stream_loop -1 -i normal_78.mp4 -c copy -f rtsp rtsp://127.0.0.1:8554/video 注意：这里ip为本地环境IP，可以在cmd终端输入ipconfig查看。\nffpmeg常用参数 -re 以流的方式读取 -i 输入视频 -f 格式化输出到哪里 -stream_loop 循环读取视频源的次数，-l为无线循环 -c 指定编码器 -c copy 直接复制，不经过重新编码（较快） -c:v 指定视频编码器 -c:a 指定音频编码器 -vn 去除视频流 -an 去除音频流 使用vlc验证是否推流成功 下载vlc软件并安装: 打开vlc，点击媒体-\u0026gt;打开网络串流-\u0026gt;输入网路url：rtsp://127.0.0.1:8554/video 如果能正常播放视频，证明推流成功，服务端或者边缘端可以使用ur进行rtsp来推流。\n参考链接 windows环境下实现ffmpeg本地视频进行rtsp推流\n在Windows操作系统上使用mediamtx和ffmpeg推送录屏视频流 搭建启动rtsp server 从https://github.com/bluenviron/mediamtx/releases/latest下载Windows版本的编译结果。\n解压，然后启动该程序\n推送录屏视频流 下载FFmpeg\n从https://github.com/BtbN/FFmpeg-Builds/releases/latest下载Windows版本的编译结果。\n解压后，通过cmd进入FFmpeg所在的目录，执行下面的命令（其中rtsp://localhost:8554/mystream是上一步生成的地址）。\n1 ffmpeg -f gdigrab -framerate 10 -i desktop -f rtsp -g 5 -an rtsp://localhost:8554/mystream 我们可以看到console会出现下面的变化。\nrstp simple server的窗口会发生下面的变化。\n检验 获取本机IP 在cmd中使用ipconfig获取本机IP\n检测 可以使用VLC播放器测试流地址是否有效。\n填入rtsp://127.0.0.1:8554/mystream。注意此处不能再使用localhost了，而是要用本机的IP。\n在VCL中能看到屏幕就代表我们方案是通过的。\n参考链接 在Windows操作系统上使用mediamtx和ffmpeg推送录屏视频流\nRTSP 和 RTMP原理 \u0026amp; 通过ffmpeg实现将本地摄像头推流到RTSP服务器 流媒体：RTSP 和 RTMP 参考资料 秒懂流媒体协议 RTMP 与 RTSP\n什么是RTMP 和 RTSP？它们之间有什么区别？\nRTSP和RTMP的区别是什么？\nRTSP 和 RTMP的工作原理 RTSP工作原理 用户设备向视频流平台发送 RTSP 请求 视频流平台返回可以操作的请求列表，比如播放、暂停等 用户设备向视频流平台发送具体的请求，比如播放 视频流平台解析请求并调用指定机制启动视频流处理 由于 RTSP 依赖于专用服务器，并且依赖于 RTP（底层用到了UDP），因此该协议不支持加密视频内容或重传丢失的数据包。 这里解释一下RTSP中是如何用到UDP和TCP的： RTP协议，英文全称：Real-time Transport Protocol，中文就是实时传输协议，它的底层其实就是UDP，这样一来就可以实现低延迟。 除了RTP协议，为确保流畅和一致的流传输，RTSP 还使用另外两种网络通信协议：\nTCP 收发控制命令（例如播放或停止请求）：TCP可靠传输，比如用户按下播放或者停止播放的时候，这个是个准确的请求，这个需要保证可靠性，这个时候TCP作用就体现了。 UDP传送音频、视频和数据：UDP是低延迟的协议，那么用于传送音频、视频和数据可以达到非常高效的效果。 这里可以通过开源的rtsp服务器可以简单理解：TCP监听端口为8554，UDP监听端口为8000\nRTMP工作原理 摄像头捕获视频 通过编码器将视频流传输到视频平台服务器 视频平台处理视频流 通过CDN分发到离用户最近的服务器上 最后视频流就能成功的到达用户设备 在视频从摄像头到服务器的过程中，RTMP将大量数据分割成小块并跨多个虚拟通道传输（内容分发网络CDN），在视频源和 RTMP 服务器之间提供了稳定和流畅的视频流。\nRTSP 和 RTMP的优缺点 RTSP的优缺点 RTSP的优点：\n轻松自定义流：可以通过结合不同的协议来开发自己的视频流解决方案。 分段流式传输：RTSP 流使观看者能够在下载完成之前访问的视频内容，而不必下载完整的视频以流式传输内容。 RTSP的缺点：\n与 HTTP不兼容：没有简单的解决方案可以在 Web 浏览器中播放 RTSP流，因为 RTSP 旨在通过私有网络流式传输视频，必须借用额外软件。 使用率低：由于视频播放器和流媒体服务并未广泛支持 RTSP 流媒体，因为使用率比较低。 RTMP的优缺点 RTMP的优点： 低延迟：RTMP使用独占的 1935 端口，无需缓冲，可以实现低延迟。 适应性强：所有 RTMP 服务器都可以录制直播媒体流，同时还允许观众跳过部分广播并在直播开始后加入直播流。 灵活性：RTMP 支持整合文本、视频和音频，支持 MP3 和 AAC 音频流，也支持MP4、FLV 和 F4V 视频。 RTMP的缺点： HTML5 不支持：标准HTML5 播放器不支持 RTMP 流。 容易受到带宽问题的影响：RTMP 流经常会出现低带宽问题，造成视频中断。 HTTP 不兼容：无法通过 HTTP 流式传输 RTMP，必须需要实现一个特殊的服务器，并使用第三方内容交付网络或使用流媒体视频平台。 RTSP和RTMP的比较 RTMP 和 RTSP协议 都是流媒体协议：\nRTMP（Real Time Message Protocol 实时消息传递协议） 有 Adobe 公司提出，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题，优势在于低延迟，稳定性高，支持所有摄像头格式，浏览器加载 flash插件就可以直接播放。 RTSP （Real-Time Stream Protocol 实时流协议）由Real Networks 和 Netscape共同提出的，基于文本的多媒体播放控制协议。RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。 RTMP 和 RTSP协议 的区别： RTSP虽然实时性最好，但是实现复杂，适合视频聊天和视频监控；\nRTMP强在浏览器支持好，加载flash插件后就能直接播放，所以非常火，相反在浏览器里播放rtsp就很困难了。\nRTSP和RTMP如何选择 IP 摄像机选择RTSP：几乎所有 IP 摄像机都支持 RTSP，这是因为 IP 摄像机早在 RTMP 协议创建之前就已经存在，与 RTSP 和 IP 摄像机结合使用时，IP 摄像机本身充当 RTSP 服务器，这意味着要将摄像机连接到 IP 摄像机服务器并广播视频。 物联网设备选择RTSP：RTSP 通常内置在无人机或物联网软件中，从而可以访问视频源，它的好处之一是低延迟，确保视频中没有延迟，这对于无人机来说至关重要。 流媒体应用程序选择RTMP：比如各种短视频软件、视频直播软件等都内置了RTMP，RTMP 是为满足现代流媒体需求而设计的。 如何在浏览器上播放RTSP 直播的协议有：rtmp, http, rtsp等等。最常用的有二种：http, rtmp，当使用http协议的时候视频格式需要是m3u8或flv，下面作详细说明各种环境的优缺点。首先，rtsp不能使用于网页环境（包含PC端和移动端），那么直播只能选择rtmp或http。 rtmp协议只支持flashplayer，也就是只能在PC端（或安卓环境中安装了flashplayer组件，这种环境比较少）安装了flashplayer的情况下使用。按现在的趋势，flashplayer是要逐渐被淘汰掉的。当然，在中国还会存在相对长时间。 http协议的直播分二种格式，m3u8和flv。flv是一种即将被淘汰的直播格式。用来做直播已显的力不从心了。所以综合考虑，m3u8相对的比较好点，优点是支持移动端，并且支持PC端上安装了flashplayer的环境。缺点就如同rtmp一样。flashplayer并不是未来的发展趋势。另外一个缺点就是m3u8是有延迟的。并不能实时，实时传输方面不如rtmp协议。因为 m3u8的直播原理是将直播源不停的压缩成指定时长的ts文件（比如9秒，10秒一个ts文件）并同时实时更新m3u8文件里的列表以达到直播的效果。这样就会有一个至少9,10秒的时间延迟。如果压缩的过小，可能导致客户端网络原因致视频变卡。 实现rtsp转http并使用m3u8格式进行直播 可以参考RTSP Webcam to HLS Live Streaming using FFMPEG and XAMPP | PART 1 具体过程：外接支持rtsp的webcam；使用ffplay命令来播放rtsp流，可以根据参数将实时视频写入到指定文件夹中（分段写入）；xampp开启apache（开启80端口），可以让页面通过保存的m3u8文件实时访问webcam的监控界面。\nffmpeg将本地摄像头推流到RTSP服务器 ffmpeg参考资料 FFmpeg Protocols Documentation\nFFmpeg中文文档\nFFmpeg流媒体处理-收流与推流\nFFmpeg发送流媒体的命令（UDP，RTP，RTMP）\nffmpeg将本地摄像头推流到RTSP服务器 ffmpeg–使用命令+EasyDarwin推流笔记本摄像头\nwindows环境下，搭建RTSP视频推流服务器\nwindows环境下python使用ffmpeg rtsp推流\n一个RtspServer的设计与实现和RTSP2.0简介\nRTSP Webcam to HLS Live Streaming using FFMPEG and XAMPP | PART 1\nNote：ffmpeg将本地摄像头推流到rtsp的8554端口上（rtsp-simple-server在处理rtsp时，监听的是8554端口，指定其他端口ffmpeg推流会失败)\n安装ffmpeg和rtsp-simple-server 大致实现过程：使用rtsp-simple-server作为中转服务器，用于ffmpeg（写客户端）推流，后台服务（读客户端）拉流\nwindows安装rtsp-simple-server和ffmpeg 参考windows环境下，搭建RTSP视频推流服务器即可（记得修改rtsp-simple-server.yml配置文件中的ip地址）\nlinux安装rtsp-simple-server和ffmpeg 安装rtsp-simple-server_v0.20.2_linux_amd64.tar.gz（这里以x86 CPU为例），解压后修改rtsp-simple-server.yml配置文件中的ip地址（vim替换命令为%s:/127.0.0.1/192.168.132.100/g），执行./rtsp-simple-server即可启动rtsp服务器。\n如果要想在后台启动rtsp服务器，执行如下命令\n1 nohup ./rtsp-simple-server \u0026gt;\u0026gt; rtsp_server.log 2\u0026gt;\u0026amp;1 \u0026amp; #非挂起启动命令 tail rtsp_server.log #查看rtsp-simple-server启动日志文件\n1 2 ps -aux | grep rtsp_simple_server #查看rtsp-simple-server进程 dpf 2116 0.0 0.0 13140 1016 pts/0 S+ 04:54 0:00 grep --color=auto rtsp_simple_server ffmpeg安装地址如下https://johnvansickle.com/ffmpeg/，解压后执行./ffmpeg即可使用ffmpeg，参考在linux下使用ffmpeg方法\nNote：在linux中关于tar.gz，xz，tar的解压操作请自行上网查阅。\n将本地摄像头推流到RTSP服务器 大致实现过程：使用rtsp-simple-server作为中转服务器，用于ffmpeg（写客户端）推流，后台服务（读客户端）拉流\n这里以windows系统作为演示，先解压rtsp-simple-server_v0.19.1_windows_amd64.zip，打开rtsp-simple-server.exe监听RTSP下TCP的8554端口，然后通过ffmpeg将指定摄像头采集到的图像帧向该端口进行推流（即多个客户端与服务器端的socket通信）\n写客户端：ffmpeg ffmpeg推流视频文件到指定ip + 端口上（-stream_loop -1）：\n1 ffmpeg -re -stream_loop -1 -i 你视频的文件名 -c copy -f rtsp rtsp://127.0.0.1:8554/videoFile_test ffmpeg将本地摄像头的视频流推送到指定ip + 端口上，则需要\n1 2 3 4 5 6 7 //获取本地摄像头名称 ffmpeg -list_devices true -f dshow -i dummy //ffmpeg向指定端口推流（我的是Integrated Camera） ffmpeg -f dshow -i video=\u0026#34;自己的摄像头驱动名称\u0026#34; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -rtsp_transport tcp -f rtsp rtsp://127.0.0.1:8554/camera_test //libx264编码 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -rtsp_transport tcp -f rtsp rtsp://127.0.0.1:8554/camera_test 服务器端：RTSP服务器 初启动效果如下：\n开启两个ffmpeg模拟两个写客户端，完成摄像头采集视频帧的推流和本地视频文件的推流\n该过程会出现两个createby和publishing，在不同文件路径下写入图像帧，可以通过指定进程（ip+端口）来处理（这里新创建了56725和56732两个进程来处理），而RTSP的监听端口仍然是8554，这样可以实现非阻塞通信。\n读客户端：读客户端可以通过两种方式来实现 安装VLC，选择流数据播放模式，输入rtsp://127.0.0.1:8554/camera_test，rtsp://127.0.0.1:8554/videoFile_test即可播放；\n通过OBS的虚拟摄像头，将终端打印信息接入到虚拟摄像头中，再通过ffmpeg将虚拟摄像头中的内容推流出来，最后通过VLC拉流查看效果\n亦或者使用如下python代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import cv2 def capture_video(rtsp_path): name = rtsp_path.split(\u0026#34;/\u0026#34;)[-1] capture = cv2.VideoCapture(rtsp_path) while capture.isOpened(): ret, frame = capture.read() if not ret: break cv2.imshow(name, frame) if cv2.waitKey(50) == 27: break if __name__ == \u0026#39;__main__\u0026#39;: # rtsp_paths = [\u0026#39;rtsp://127.0.0.1:8554/videoFile_test\u0026#39;,\u0026#39;rtsp://127.0.0.1:8554/camera_test\u0026#39;] rtsp_paths = [\u0026#39;rtsp://127.0.0.1:8554/videoFile_test\u0026#39;] for rtsp_path in rtsp_paths: capture_video(rtsp_path) cv2.waitKey(0) cv2.destroyAllWindows() 此时会出现两个createby和reading，即开启两个进程进行视频流的读取\n存在问题：视频读取时延大 基于tcp和RTP的rtsp直播延迟很高，一开始延迟只有7s，由于TCP的拥塞控制，导致随着时间推移，延迟越来越高，有14s之多。\n可能原因1：视频编码导致延迟高（亲测效果不明显） 参考ffmpeg直播解决延时的关键方法，主要原因是使用libx264或者h264对视频进行编码的问题。\n解决方法参考ffmpeg–使用命令+EasyDarwin推流笔记本摄像头\n//h264_qsv编码（比libx264编码快点）\n1 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; -vcodec h264_qsv -tune:v zerolatency -rtsp_transport tcp -f rtsp rtsp://127.0.0.1:8554/camera_test //不使用编码器，直接推送（但是很模糊）\n1 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; -rtsp_transport tcp -f rtsp rtsp://127.0.0.1:8554/camera_test 可能原因2：设置ffmpeg参数（亲测效果不明显） 参考解决ffmpeg的播放摄像头的延时优化问题(项目案例使用有效)\n原参数：\n1 2 3 -vcodec libx264, -r 25, -video_size 1280x720, 优化参数1：\n-tune zerolatency /设置零延时 -preset ultrafast /–preset的参数主要调节编码速度和质量的平衡，有ultrafast（转码速度最快，视频往往也最模糊）、superfast、veryfast、faster、fast、medium、slow、slower、veryslow、placebo这10个选项，从快到慢\n优化参数2：\n1 2 3 4 5 6 7 8 9 -threads 4, -c:a copy, -fflags nobuffer, -max_delay 1, -vprofile baseline, -rtsp_transport tcp, -crf 30, -vsync 2, -f flv ffmpeg完整命令如下：\n1 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; -vcodec libx264 -r 25 -video_size 640x480 -tune:v zerolatency -preset:v ultrafast -threads 4 -c:a copy -fflags nobuffer -max_delay 1 -rtsp_transport tcp -crf 30 -vsync 2 -f flv -f rtsp rtsp://127.0.0.1:8554/camera_test 可能原因3：tcp连接导致延迟高 参考RTSP end to end latency will be increasing when use tcp #902\nffmpeg在通过rtsp实现推流时默认是遵循tcp协议的，目的是为了保证消息可靠传输。对于实时音视频通信，如果要想实现低延迟，要么增加带宽，要么使用UDP进行传输。\n原因4：逐帧读取时需要逐帧解码，导致输入和输出速率不匹配导致延迟高（有效 - 抽帧读取） 解决方法：对于读客户端，采用抽帧读取的方法来解决。如果采用逐帧读取并完成解码的方式，会让写客户端不停地推流，而读客户端来不及解码导致缓存区拥塞。\n参考Opencv—视频跳帧处理，OpenCV笔记：cv2.VideoCapture 完成视频的跳帧输出操作\nffmpeg写客户端命令无需修改：\n//获取本地摄像头名称\n1 ffmpeg -list_devices true -f dshow -i dummy 1 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; -vcodec libx264 -r 25 -video_size 640x480 -tune:v zerolatency -preset:v ultrafast -threads 4 -c:a copy -fflags nobuffer -max_delay 1 -rtsp_transport tcp -crf 30 -vsync 2 -f flv -f rtsp rtsp://127.0.0.1:8554/camera_test python读客户端代码修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def capture_video(rtsp_path): name = rtsp_path.split(\u0026#34;/\u0026#34;)[-1] capture = cv2.VideoCapture(rtsp_path) #不用带cv2.CAP_DSHOW now_fps = 0 while capture.isOpened(): # 设置每 10 帧输出一次 if (now_fps == 3): now_fps = 0 ret, frame = capture.read() if not ret: break cv2.imshow(name, frame) if cv2.waitKey(50) == 27: break else: # 跳帧，仅获取帧但不做解码处理 ret = capture.grab() now_fps += 1 参考链接 RTSP 和 RTMP原理 \u0026amp; 通过ffmpeg实现将本地摄像头推流到RTSP服务器\nFFMpeg 实现视频编码、解码\n","date":"2024-09-14T15:18:12+08:00","permalink":"https://ynhugo.github.io/p/ffmpeg-%E6%95%99%E7%A8%8B/","title":"ffmpeg 教程"},{"content":" Linux下基于ffmpeg音视频解码 FFmpeg开发环境配置参考：Ubuntu 20.04LTS FFmpeg 环境配置\n工程示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026lt;libswresample/swresample.h\u0026gt; #include \u0026lt;libavutil/mathematics.h\u0026gt; #include \u0026lt;libavutil/timestamp.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;linux/fb.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;poll.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;wchar.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;SDL.h\u0026gt; #define FILE_NAME \u0026#34;123.flv\u0026#34; typedef unsigned char u8; typedef unsigned short u16; typedef unsigned int u32; typedef enum { false, true, }bool; uint8_t *out_buffer; #define MAX_AUDIO_FRAME_SIZE 1024*100 static Uint8* audio_chunk; static unsigned int audio_len=0; static unsigned char *audio_pos; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//互斥锁 //保存音频数据链表 struct AUDIO_DATA { unsigned char* audio_buffer; int audio_size; struct AUDIO_DATA *next; }; //定义一个链表头 struct AUDIO_DATA *list_head=NULL; struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head);//创建链表头 void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size);//添加节点 void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer);//删除节点 int List_GetNodeCnt(struct AUDIO_DATA *head);//遍历 int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size); int file_stat=1; void AudioCallback(void *userdata, Uint8 * stream,int len) { SDL_memset(stream, 0,len); if(audio_len\u0026lt;=0) { return ; } len=(len\u0026gt;audio_len?audio_len:len); SDL_MixAudio(stream,audio_pos,len,SDL_MIX_MAXVOLUME); audio_pos+=len; audio_len-=len; //printf(\u0026#34;len=%d\\n\u0026#34;,len); } void *Audio_decode(void *arg) { int res; int audio_size; char audio_buff[4096*3]; while(1) { res=List_GetNode(list_head,audio_buff,\u0026amp;audio_size); if(res==0) { audio_chunk = audio_buff; //指向音频数据 (PCM data) while(audio_len\u0026gt;0){}//等待数据处理完 audio_len =audio_size;//音频长度 audio_pos = audio_buff;//当前播放位置 } } } int main(int argc,char *argv[]) { if(argc!=2) { printf(\u0026#34;格式:./app 文件名\\n\u0026#34;); return 0; } char *file_name=argv[1]; /*SDL初始化*/ SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_TIMER); printf(\u0026#34;pth:%s\\n\u0026#34;,avcodec_configuration());/*获取ffmpeg配置信息*/ /*初始化所有组件*/ //av_register_all(); /*打开文件*/ AVCodecContext *pCodecCtx;//解码器上下文 AVFormatContext *ps=NULL;//音视频封装格式结构体信息 printf(\u0026#34;name:%s\\n\u0026#34;,file_name); int res=avformat_open_input(\u0026amp;ps,file_name,NULL,NULL); if(res!=0) { printf(\u0026#34;open err: %d\\n\u0026#34;,res); return 0; } /*寻找解码信息*/ avformat_find_stream_info(ps,NULL); int64_t time=ps-\u0026gt;duration; printf(\u0026#34;time:%ld s\\n\u0026#34;,time/1000000); /*打印有关输入或输出格式的详细信息*/ av_dump_format(ps,0,file_name,0); /*寻找视频流信息*/ int videostream=-1; int audiostream=-1; AVCodec *vcodec; videostream=av_find_best_stream(ps,AVMEDIA_TYPE_VIDEO,-1,-1,NULL, 0); printf(\u0026#34;video=%d\\n\u0026#34;,videostream); /*寻找音频流信息*/ audiostream=av_find_best_stream(ps,AVMEDIA_TYPE_AUDIO,-1,-1,NULL, 0); printf(\u0026#34;audio=%d\\n\u0026#34;,audiostream); AVStream *stream; int frame_rate; if(videostream!=-1)//判断是否找到视频流数据 { /*寻找视频解码器*/ AVStream *stream = ps-\u0026gt;streams[videostream]; vcodec=avcodec_find_decoder(stream-\u0026gt;codecpar-\u0026gt;codec_id); if(!vcodec) { printf(\u0026#34;未找到视频解码器\\n\u0026#34;); return -1; }/*申请AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ res=avcodec_open2(stream-\u0026gt;codec,vcodec,NULL); if(res) { printf(\u0026#34;打开解码器失败\\n\u0026#34;); return -1; } frame_rate=stream-\u0026gt;avg_frame_rate.num/stream-\u0026gt;avg_frame_rate.den;//每秒多少帧 printf(\u0026#34;fps=%d\\n\u0026#34;,frame_rate); printf(\u0026#34;视频流ID=%#x\\n\u0026#34;,vcodec-\u0026gt;id);//音频流 } /*音频流数据处理*/ AVCodec *audcodec; AVStream *audstream; SwrContext *swrCtx;//保存重采样数据，即解码的信息 uint64_t out_channel_layout;//声道 int out_sample_fmt;//采样格式 int out_sample_rate;//采样率 int out_nb_samples;//样本数量 int out_channels;//通道数量 uint64_t in_channel_layout;//输入音频声道 SDL_AudioSpec desired;//SDL音频格式信息 AVFrame *audioframe;//保存音频数据 int out_buffer_size;//音频缓冲区大小 if(audiostream\u0026gt;=0)//判断是否有音频流 { /*寻找音频解码器*/ audstream = ps-\u0026gt;streams[audiostream]; audcodec=avcodec_find_decoder(audstream-\u0026gt;codecpar-\u0026gt;codec_id); if(!audcodec) { printf(\u0026#34;audcodec failed\\n\u0026#34;); return -1; } /*申请音频AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ pCodecCtx=audstream-\u0026gt;codec;//解码器上下文 res=avcodec_open2(audstream-\u0026gt;codec,audcodec,NULL); if(res) { printf(\u0026#34;未找到音频解码器\\n\u0026#34;); return -1; } printf(\u0026#34;音频流ID=%#x\\n\u0026#34;,audcodec-\u0026gt;id);//音频流 printf(\u0026#34;配置音频参数\\n\u0026#34;); //输出音频参数 out_channel_layout = AV_CH_LAYOUT_STEREO; //声道格式 out_sample_fmt=AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S32;//;//采样格式 printf(\u0026#34;pCodecCtx-\u0026gt;sample_rate=%d\\n\u0026#34;,pCodecCtx-\u0026gt;sample_rate); out_sample_rate =pCodecCtx-\u0026gt;sample_rate;//采样率，多为44100 /*样本数量*/ printf(\u0026#34;frame_size=%d\\n\u0026#34;,pCodecCtx-\u0026gt;frame_size); if(pCodecCtx-\u0026gt;frame_size\u0026gt;0)out_nb_samples=pCodecCtx-\u0026gt;frame_size; else if(audcodec-\u0026gt;id == AV_CODEC_ID_AAC) out_nb_samples=1024;/*样本数量nb_samples: AAC-1024 MP3-1152 格式大小 */ else if(audcodec-\u0026gt;id == AV_CODEC_ID_MP3)out_nb_samples=1152; else out_nb_samples=1024; out_channels=av_get_channel_layout_nb_channels(out_channel_layout);//通道个数 out_buffer_size=av_samples_get_buffer_size(NULL,out_channels,out_nb_samples,out_sample_fmt,1);//获取缓冲区大小 out_buffer=(uint8_t*)av_malloc(MAX_AUDIO_FRAME_SIZE); memset(out_buffer,0,out_buffer_size); printf(\u0026#34;声道格式:%d\\n\u0026#34;,out_channel_layout); printf(\u0026#34;采样格式:%d\\n\u0026#34;,out_sample_fmt);\tprintf(\u0026#34;样本数量:%d\\n\u0026#34;,out_nb_samples);\tprintf(\u0026#34;采样率:%d\\n\u0026#34;,out_sample_rate); printf(\u0026#34;通道个数:%d\\n\u0026#34;,out_channels); printf(\u0026#34;缓冲区大小:%d\\n\u0026#34;,out_buffer_size); //输入音频参数 in_channel_layout=av_get_default_channel_layout(pCodecCtx-\u0026gt;channels);//输入声道格式 swrCtx = swr_alloc(); /*对解码数据进行重采样*/ swrCtx=swr_alloc_set_opts(swrCtx,out_channel_layout,out_sample_fmt,out_sample_rate,/*输入音频格式*/ in_channel_layout,pCodecCtx-\u0026gt;sample_fmt,pCodecCtx-\u0026gt;sample_rate,/*输出音频格式*/ 0,NULL);\tswr_init(swrCtx);//初始化swrCtx printf(\u0026#34;输入音频格式:%d\\n\u0026#34;,in_channel_layout); printf(\u0026#34;输入采样格式:%d\\n\u0026#34;,pCodecCtx-\u0026gt;sample_fmt); printf(\u0026#34;输入采样率:%d\\n\u0026#34;,pCodecCtx-\u0026gt;sample_rate); /*设置音频数据格式*/ desired.freq=out_sample_rate;/*采样率*/ desired.format=AUDIO_S16SYS;/*无符号16位*/ desired.channels=out_channels;/*声道*/ desired.samples=out_nb_samples;/*样本数1024*/ desired.silence=0;/*静音值*/ desired.callback=AudioCallback; SDL_OpenAudio(\u0026amp;desired,NULL); SDL_PauseAudio(0);/*开始播放音频，1为播放静音值*/ //分配内存 audioframe=av_frame_alloc();/*分配音频帧*/ printf(\u0026#34;音频数据初始化完成\u0026#34;); } //视频解码 AVFrame *frame=av_frame_alloc();/*分配视频帧*/ AVFrame *frameYUV=av_frame_alloc();/*申请yuv空间*/ /*分配空间，进行图像转换*/ int width=ps-\u0026gt;streams[videostream]-\u0026gt;codecpar-\u0026gt;width; int height=ps-\u0026gt;streams[videostream]-\u0026gt;codecpar-\u0026gt;height; int fmt=ps-\u0026gt;streams[videostream]-\u0026gt;codecpar-\u0026gt;format;/*流格式*/ printf(\u0026#34;fmt=%d\\n\u0026#34;,fmt); int size=avpicture_get_size(AV_PIX_FMT_RGB24, width,height); unsigned char *buff=NULL; printf(\u0026#34;w=%d,h=%d,size=%d\\n\u0026#34;,width,height,size); buff=av_malloc(size); /*计算一帧空间大小*/ avpicture_fill((AVPicture *)frameYUV,buff,AV_PIX_FMT_RGB24,width,height); /*转换上下文*/ struct SwsContext *swsctx=sws_getContext(width,height, fmt,width,height, AV_PIX_FMT_RGB24,SWS_BICUBIC,NULL,NULL,NULL); /*读帧*/ int go=0; int go_audio;\tlist_head=List_CreateHead(list_head);//创建链表头 /*创建音频处理线程*/ pthread_t pthid; pthread_create(\u0026amp;pthid,NULL,Audio_decode,(void *)ps); pthread_detach(pthid);//设置为分离属性 /*创建窗口*/ SDL_Window *window=SDL_CreateWindow(\u0026#34;SDL_VIDEO\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,1280,720,SDL_WINDOW_SHOWN); /*创建渲染器*/ SDL_Renderer *render=SDL_CreateRenderer(window,-1,SDL_RENDERER_ACCELERATED); /*清空渲染器*/ SDL_RenderClear(render);\t/*创建纹理*/ SDL_Texture *sdltext=SDL_CreateTexture(render,SDL_PIXELFORMAT_RGB24,SDL_TEXTUREACCESS_STREAMING,width,height);\tbool quit=true; SDL_Event event; printf(\u0026#34;read fream buff\\n\u0026#34;); //初始化转码器 AVPacket *packet=av_malloc(sizeof(AVPacket));/*分配包*/ av_init_packet(packet);//初始化 int i=0; int index=0; long video_pts_time=0; long audio_pts_time=0;//音频解码时间 time=(1000000/frame_rate-10000);//时间 printf(\u0026#34;time=%d\\n\u0026#34;,time); while((av_read_frame(ps,packet)\u0026gt;=0) \u0026amp;\u0026amp; (quit)) { SDL_PollEvent(\u0026amp;event); if(event.type==SDL_QUIT) { quit=false; continue; } if(packet-\u0026gt;stream_index == videostream)/*判断是否为视频*/ { res=avcodec_send_packet(ps-\u0026gt;streams[videostream]-\u0026gt;codec,packet); if(res) { av_packet_unref(packet);//释放这个pkt continue; } res=avcodec_receive_frame(ps-\u0026gt;streams[videostream]-\u0026gt;codec,frame); if(res) { av_packet_unref(packet);//释放这个pkt\tcontinue; } sws_scale(swsctx,(const uint8_t **)frame-\u0026gt;data,frame-\u0026gt;linesize,0,height,(const uint8_t **)frameYUV-\u0026gt;data,frameYUV-\u0026gt;linesize); video_pts_time=packet-\u0026gt;pts; //printf(\u0026#34;视频=%ld\\n\u0026#34;,video_pts_time); SDL_UpdateTexture(sdltext,NULL,buff, width*3); SDL_RenderCopy(render, sdltext, NULL, NULL); // 拷贝纹理到渲染器 SDL_RenderPresent(render); //渲染 usleep(time); } if(packet-\u0026gt;stream_index == audiostream) //如果为音频标志 { if(audiostream\u0026lt;0)continue; res=avcodec_send_packet(pCodecCtx,packet); if(res) { printf(\u0026#34;avcodec_send_packet failed,res=%d\\n\u0026#34;,res); av_packet_unref(packet);//释放这个pkt\tcontinue; } res=avcodec_receive_frame(pCodecCtx,audioframe); if(res) { printf(\u0026#34;avcodec_receive_frame failed,res=%d\\n\u0026#34;,res); av_packet_unref(packet);//释放这个pkt continue; } //数据格式转换 res=swr_convert(swrCtx,\u0026amp;out_buffer,out_buffer_size,/*重采样之后的数据*/ (const uint8_t **)audioframe-\u0026gt;data,audioframe-\u0026gt;nb_samples/*重采样之前数据*/ ); audio_pts_time=packet-\u0026gt;pts; //printf(\u0026#34;音频：%ld\\n\u0026#34;,audio_pts_time); if(res\u0026gt;0) { //audio_chunk =out_buffer; //指向音频数据 (PCM data) //while(audio_len\u0026gt;0){}//等待数据处理完 //audio_len =audioframe-\u0026gt;nb_samples;//out_buffer_size;//音频长度 //audio_pos =out_buffer;//当前播放位置 List_AddNode(list_head,out_buffer,out_buffer_size);//添加节点 } } //释放数据包 av_packet_unref(packet); } sws_freeContext(swsctx); av_frame_free(\u0026amp;frame); av_frame_free(\u0026amp;frameYUV); avformat_free_context(ps); return 0; } /*创建链表头*/ struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head) { if(head==NULL) { head=malloc(sizeof(struct AUDIO_DATA)); head-\u0026gt;next=NULL; } return head;\t} /*添加节点*/ void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *new_node; pthread_mutex_lock(\u0026amp;mutex); /*找到链表尾部*/ while(tmp-\u0026gt;next) { tmp=tmp-\u0026gt;next; } /*插入新的节点*/ new_node=malloc(sizeof(struct AUDIO_DATA)); new_node-\u0026gt;audio_size=audio_size; new_node-\u0026gt;audio_buffer=malloc(audio_size);//分配保存音频数据大小空间 memcpy(new_node-\u0026gt;audio_buffer,audio_buffer,audio_size); new_node-\u0026gt;next=NULL; /*将新节点接入到链表*/ tmp-\u0026gt;next=new_node;\tpthread_mutex_unlock(\u0026amp;mutex); } /* 函数功能:删除节点 */ void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *p; /*找到链表中要删除的节点*/ pthread_mutex_lock(\u0026amp;mutex); while(tmp-\u0026gt;next) { p=tmp; tmp=tmp-\u0026gt;next; if(tmp-\u0026gt;audio_buffer==audio_buffer) { p-\u0026gt;next=tmp-\u0026gt;next; free(tmp-\u0026gt;audio_buffer); free(tmp); break; } } pthread_mutex_unlock(\u0026amp;mutex); } /* 函数功能:遍历链表，得到节点总数量 */ int List_GetNodeCnt(struct AUDIO_DATA *head) { int cnt=0; struct AUDIO_DATA *tmp=head; pthread_mutex_lock(\u0026amp;mutex); while(tmp-\u0026gt;next) { tmp=tmp-\u0026gt;next; cnt++; } pthread_mutex_unlock(\u0026amp;mutex); return cnt; } /* 从链表头取数据 */ int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *ptemp=head; pthread_mutex_lock(\u0026amp;mutex); while(tmp-\u0026gt;next!=NULL) { ptemp=tmp; tmp=tmp-\u0026gt;next; if(tmp!=NULL) { *audio_size=tmp-\u0026gt;audio_size; memcpy(audio_buff,tmp-\u0026gt;audio_buffer,tmp-\u0026gt;audio_size); ptemp-\u0026gt;next=tmp-\u0026gt;next; free(tmp-\u0026gt;audio_buffer); free(tmp); pthread_mutex_unlock(\u0026amp;mutex); return 0; } } pthread_mutex_unlock(\u0026amp;mutex); return -1; } Makefile文件 注意Makefile文件中涉及到的路径要跟系统环境相匹配，如果路径不一致会编译报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 OBJ=main.o ffmpeg_dir=\u0026#34;${HOME}/ffmpeg/ffmpeg-4.3.1\u0026#34; sdl_dir=\u0026#34;/usr\u0026#34; CFLAGS=-I$(ffmpeg_dir)/_install/include -LI$(ffmpeg_dir)/_install/lib\\ -I$(sdl_dir)/include -I$(sdl_dir)/include/SDL2 -L$(sdl_dir)/lib \\ -lSDL2 -lpthread -lm -ldl -lavcodec -lavfilter -lavutil -lswresample -lavdevice -lavformat -lpostproc -lswscale -lpthread -lstdc++ -lm -lasound -lx264 app:$(OBJ) gcc -o $@ $^ $(CFLAGS) clean: rm -rf app main.o 运行程序 先准备一个视频 1 ffmpeg -f alsa -i default -f x11grab -r 25 -s $(xdpyinfo | grep \u0026#39;dimensions:\u0026#39;|awk \u0026#39;{print $2;}\u0026#39;) -i :0.0 -t 5 -c:v libx264 -preset ultrafast -c:a aac -tune fastdecode -y output.mp4 运行示例 1 ./app output.mp4 运行示例效果 运行示例会播放视频，并在终端打印视频相关参数信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 video=0 audio=1 fps=25 视频流ID=0x1b 音频流ID=0x15002 配置音频参数 pCodecCtx-\u0026gt;sample_rate=48000 frame_size=1024 声道格式:3 采样格式:1 样本数量:1024 采样率:48000 通道个数:2 缓冲区大小:4096 输入音频格式:3 输入采样格式:8 输入采样率:48000 音频数据初始化完成fmt=5 w=1918,h=926,size=5328204 read fream buff time=30000 ChatGPT分析代码 这个代码主要实现了通过FFmpeg和SDL库对FLV格式视频文件进行音频和视频的解码和播放，使用了线程和链表对音频数据进行处理。以下是对代码的详细分析：\n1. 头文件与库引入 1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026lt;libswresample/swresample.h\u0026gt; #include \u0026lt;libavutil/mathematics.h\u0026gt; #include \u0026lt;libavutil/timestamp.h\u0026gt; FFmpeg库：用于音视频的编解码处理，包括 avcodec、avformat、swscale、swresample 等库，分别处理编解码、封装格式、视频格式转换、音频重采样等。 SDL库：用于处理音频和视频的输出，负责创建窗口和播放音频。 2. 常量与全局变量 1 2 3 4 5 6 #define FILE_NAME \u0026#34;123.flv\u0026#34; #define MAX_AUDIO_FRAME_SIZE 1024*100 static Uint8* audio_chunk; static unsigned int audio_len=0; static unsigned char *audio_pos; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; FILE_NAME 是测试用的 FLV 文件名，实际运行时通过命令行参数指定文件。 audio_chunk 是用于存储音频数据的指针，audio_len 和 audio_pos 用于管理音频缓冲区的状态。 mutex 是一个互斥锁，用于音频数据链表的并发访问控制。 3. 音频数据链表 1 2 3 4 5 struct AUDIO_DATA { unsigned char* audio_buffer; int audio_size; struct AUDIO_DATA *next; }; 这段代码定义了一个用于存储音频数据的链表结构 AUDIO_DATA，每个节点包含音频数据的大小和指向下一节点的指针。 链表操作函数包括创建链表头 List_CreateHead，添加节点 List_AddNode，删除节点 List_DelNode，获取节点数量 List_GetNodeCnt 和从链表中获取数据 List_GetNode。 4. 音频回调函数 1 2 3 4 5 6 7 8 void AudioCallback(void *userdata, Uint8 *stream, int len) { SDL_memset(stream, 0, len); // 清零音频缓冲区 if (audio_len \u0026lt;= 0) return; len = (len \u0026gt; audio_len) ? audio_len : len; SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME); // 将音频数据混入播放缓冲区 audio_pos += len; audio_len -= len; } SDL 使用该回调函数在音频缓冲区为空时拉取数据，通过 SDL_MixAudio 函数混合音频数据。 当 audio_len 为 0 时，表示当前没有音频数据可播放。 5. 音频解码线程 1 2 3 4 5 6 7 8 9 10 11 12 13 void *Audio_decode(void *arg) { while (1) { int audio_size; char audio_buff[4096*3]; int res = List_GetNode(list_head, audio_buff, \u0026amp;audio_size); if (res == 0) { audio_chunk = audio_buff; while (audio_len \u0026gt; 0) {} // 等待数据被播放完毕 audio_len = audio_size; audio_pos = audio_buff; } } } 该函数为一个线程，用于持续从链表中取出音频数据，并在播放缓冲区为空时将新数据填入。 6. 主程序 main 初始化：\n1 SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER); 初始化 SDL，指定需要使用的视频、音频和定时器子系统。\n打开媒体文件：\n1 2 avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); avformat_find_stream_info(ps, NULL); 使用 FFmpeg 打开指定的视频文件，并解析其流信息。\n视频流和音频流解码器初始化：\n视频：找到视频流后，使用 avcodec_find_decoder 查找合适的解码器，并打开解码器上下文 avcodec_open2。 音频：找到音频流后，类似地初始化音频解码器上下文，并设置音频的重采样参数 SwrContext。 创建音频播放：\n1 2 3 4 SDL_AudioSpec desired; desired.callback = AudioCallback; SDL_OpenAudio(\u0026amp;desired, NULL); SDL_PauseAudio(0); 使用 SDL 创建音频播放，指定音频回调函数 AudioCallback，并启动音频播放。\n解码与播放循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 while (av_read_frame(ps, packet) \u0026gt;= 0) { if (packet-\u0026gt;stream_index == videostream) { // 视频解码 avcodec_send_packet(ps-\u0026gt;streams[videostream]-\u0026gt;codec, packet); avcodec_receive_frame(ps-\u0026gt;streams[videostream]-\u0026gt;codec, frame); // 视频缩放并更新纹理 sws_scale(swsctx, ...); SDL_UpdateTexture(sdltext, NULL, buff, width*3); SDL_RenderCopy(render, sdltext, NULL, NULL); SDL_RenderPresent(render); } if (packet-\u0026gt;stream_index == audiostream) { // 音频解码 avcodec_send_packet(pCodecCtx, packet); avcodec_receive_frame(pCodecCtx, audioframe); swr_convert(swrCtx, ...); List_AddNode(list_head, out_buffer, out_buffer_size); } av_packet_unref(packet); } 视频部分：读取视频帧，使用 sws_scale 进行图像格式转换，更新 SDL 纹理并显示。 音频部分：读取音频帧，重采样后将数据添加到链表，供回调函数消费。 7. 链表管理 音频数据使用链表存储，这样可以缓冲更多的数据，防止播放过程中音频数据不足造成的卡顿。\n在你提供的代码中，链表的类型是 单向链表。这是因为每个节点只包含一个指向下一个节点的指针，没有指向前一个节点的指针。\n链表的定义如下：\n1 2 3 4 5 struct AUDIO_DATA { unsigned char* audio_buffer; // 音频数据指针 int audio_size; // 音频数据大小 struct AUDIO_DATA *next; // 指向下一个节点的指针 }; 每个 AUDIO_DATA 结构体中包含三个成员：\naudio_buffer：指向保存音频数据的缓冲区。 audio_size：保存当前音频数据的大小。 next：指向下一个 AUDIO_DATA 节点。如果这是链表的最后一个节点，则 next 为 NULL。 这是一个典型的 单向链表，因为它的节点只通过 next 指针连接到下一个节点，而无法访问前一个节点。这种链表的操作（如添加、删除节点）只需处理单个方向的指针，不涉及双向连接。\n总结 该程序通过 FFmpeg 实现音频和视频的解码，通过 SDL 实现音视频的播放。 使用了链表和线程处理音频数据，保证了音频播放的连续性。 打开一个媒体文件并输出其格式信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;格式:./app 文件名\\n\u0026#34;); return 1; } const char *file_name = argv[1]; AVFormatContext *ps = NULL; int res = avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); if (res != 0) {\tprintf(\u0026#34;open err: %d\\n\u0026#34;, res); return 1; } av_dump_format(ps, 0, file_name, 0); av_dump_format(ps, 0, file_name, 0); avformat_close_input(\u0026amp;ps); return 0; } 示例说明 这段代码的功能是打开一个指定的视频或音频文件并打印其格式信息。具体步骤如下：\n检查命令行参数：确保提供了一个文件名作为参数。 打开文件：使用 avformat_open_input 打开指定的媒体文件，并将文件的格式信息存储在 AVFormatContext 结构体中。 打印格式信息：使用 av_dump_format 打印文件的详细格式信息。 关闭文件：调用 avformat_close_input 释放资源并关闭文件。 代码的最终目的是用来查看指定媒体文件的格式信息。\n参考链接 【FFmpeg】avformat_open_input函数\nffmpeg_av_dump_format\n查找视频和音频流示例-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage:./app filename\\n\u0026#34;); return 0; } const char *file_name = argv[1]; AVFormatContext *ps = NULL; int res = avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); if (res) { printf(\u0026#34;Open error:%d\\n\u0026#34;, res); return -1;\t} avformat_find_stream_info(ps, NULL); av_dump_format(ps, 0, file_name, 0); int videostream = -1, audiostream = -1; AVStream *stream = NULL, *audstream = NULL; AVCodec *vcodec = NULL, *audcodec = NULL; int frame_rate = 0; videostream = av_find_best_stream(ps, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); printf(\u0026#34;video = %d\\n\u0026#34;, videostream); audiostream = av_find_best_stream(ps, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); printf(\u0026#34;audio = %d\\n\u0026#34;, audiostream); if (videostream \u0026gt;= 0) { stream = ps-\u0026gt;streams[videostream]; vcodec = avcodec_find_decoder(stream-\u0026gt;codecpar-\u0026gt;codec_id); if (!vcodec) { printf(\u0026#34;Not find video decoder.\\n\u0026#34;); return -1; } res = avcodec_open2(stream-\u0026gt;codec, vcodec, NULL); if (res) { printf(\u0026#34;Open decoder failed.\\n\u0026#34;); return -1; } } printf(\u0026#34;Video Stream ID = %#X\\n\u0026#34;, vcodec-\u0026gt;id); frame_rate = stream-\u0026gt;avg_frame_rate.num / stream-\u0026gt;avg_frame_rate.den; printf(\u0026#34;FPS = %d\\n\u0026#34;, frame_rate); if (audiostream \u0026gt;= 0) { audstream = ps-\u0026gt;streams[audiostream]; audcodec = avcodec_find_decoder(audstream-\u0026gt;codecpar-\u0026gt;codec_id); if (!audcodec) { printf(\u0026#34;Not find audio deocder.\\n\u0026#34;); return -1; } res = avcodec_open2(audstream-\u0026gt;codec, audcodec, NULL); if (res) { printf(\u0026#34;Open decoder failed.\\n\u0026#34;); return -1; } } printf(\u0026#34;Audio Stream ID = %#X\\n\u0026#34;, audcodec-\u0026gt;id); avformat_close_input(\u0026amp;ps); return 0; } 示例说明 这段代码的功能是：\n初始化：使用 SDL 库进行视频、音频和计时器的初始化。 打开媒体文件：通过 FFmpeg 的 avformat_open_input 函数打开用户指定的媒体文件，并检查是否成功。 获取流信息：调用 avformat_find_stream_info 函数获取媒体文件中的流信息，并使用 av_dump_format 打印流的详细信息。 查找流：使用 av_find_best_stream 函数查找视频流和音频流的索引，并输出这些流的索引。 解码器处理：\n对视频流：查找并打开对应的视频解码器，计算帧率并打印。 对音频流：查找并打开对应的音频解码器，打印音频解码器的 ID。 清理：关闭媒体文件的输入流。 总体来说，这段代码的目的是初始化 SDL，打开并分析指定的媒体文件，查找视频和音频流，并尝试打开相应的解码器。\n查找视频和音频流示例-2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage:./app filename\\n\u0026#34;); return 0; } const char *file_name = argv[1]; AVFormatContext *ps = NULL; int res = avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); if (res) { printf(\u0026#34;Open error:%d\\n\u0026#34;, res); return -1; } avformat_find_stream_info(ps, NULL); av_dump_format(ps, 0, file_name, 0); for(int i=0; i\u0026lt;ps-\u0026gt;nb_streams; i++){ AVStream *stream = ps-\u0026gt;streams[i]; AVCodecParameters *codec_par = stream-\u0026gt;codecpar; av_log(NULL, AV_LOG_INFO, \u0026#34;find audio/video stream index=%d, type=%s, codec id=%#X\u0026#34;, i, av_get_media_type_string(codec_par-\u0026gt;codec_type), codec_par-\u0026gt;codec_id); printf(\u0026#34;\\n\u0026#34;); } avformat_close_input(\u0026amp;ps); return 0; } 参考链接 一步步进行ffmpeg的C语言音视频编程\n查看音视频流的格式，同时获得解码器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage:./app filename\\n\u0026#34;); return 0; } const char *file_name = argv[1]; AVFormatContext *ps = NULL; int res = avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); if (res) { printf(\u0026#34;Open error:%d\\n\u0026#34;, res); return -1; } avformat_find_stream_info(ps, NULL); av_dump_format(ps, 0, file_name, 0); AVStream *stream = NULL; AVCodecParameters *codec_par = NULL; AVCodec *decodec = NULL; for(int i = 0; i \u0026lt; ps-\u0026gt;nb_streams; i++){ stream = ps-\u0026gt;streams[i]; codec_par = stream-\u0026gt;codecpar; decodec = avcodec_find_decoder(codec_par-\u0026gt;codec_id); av_log(NULL, AV_LOG_INFO, \u0026#34;find audio/video stream index = %d, type = %s, codec id = %#X\\n\u0026#34;, i, av_get_media_type_string(codec_par-\u0026gt;codec_type), codec_par-\u0026gt;codec_id); av_log(NULL, AV_LOG_INFO, \u0026#34;find codec name = %s\\t%s\\n\u0026#34;, decodec-\u0026gt;name, decodec-\u0026gt;long_name); } avformat_close_input(\u0026amp;ps); return 0; } 参考链接 一步步进行ffmpeg的C语言音视频编程\n查看视频帧率 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage:./app filename\\n\u0026#34;); return 0; } const char *file_name = argv[1]; AVFormatContext *ps = NULL; AVRational framerate; int res = avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); if (res) { printf(\u0026#34;Open error:%d\\n\u0026#34;, res); return -1; } avformat_find_stream_info(ps, NULL); framerate = av_guess_frame_rate(ps, ps-\u0026gt;streams[0], NULL); av_log(NULL, AV_LOG_INFO, \u0026#34;video framerate=%d/%d\\n\u0026#34;, framerate.num, framerate.den); avformat_close_input(\u0026amp;ps); return 0; } 参考链接 一步步进行ffmpeg的C语言音视频编程\n正确获取和处理流索引、解码器、以及正确释放资源 - ChatGPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage: ./app filename\\n\u0026#34;); return 0; } const char *file_name = argv[1]; AVFormatContext *ps = NULL; int res = avformat_open_input(\u0026amp;ps, file_name, NULL, NULL); if (res) { printf(\u0026#34;Open error: %d\\n\u0026#34;, res); return -1; } avformat_find_stream_info(ps, NULL); av_dump_format(ps, 0, file_name, 0); AVStream *stream = NULL; AVCodecParameters *codec_par = NULL; AVCodec *codec = NULL; AVCodecContext *video_codec_ctx = NULL, *audio_codec_ctx = NULL; int video_stream_idx = -1, audio_stream_idx = -1; AVRational framerate; for (int i = 0; i \u0026lt; ps-\u0026gt;nb_streams; i++) { stream = ps-\u0026gt;streams[i]; codec_par = stream-\u0026gt;codecpar; codec = avcodec_find_decoder(codec_par-\u0026gt;codec_id); if (codec == NULL) { av_log(NULL, AV_LOG_WARNING, \u0026#34;Unsupported codec with id %d\\n\u0026#34;, codec_par-\u0026gt;codec_id); continue; } av_log(NULL, AV_LOG_INFO, \u0026#34;Stream index = %d, type = %s, codec id = %#X\\n\u0026#34;, i, av_get_media_type_string(codec_par-\u0026gt;codec_type), codec_par-\u0026gt;codec_id); av_log(NULL, AV_LOG_INFO, \u0026#34;Codec name = %s\\t%s\\n\u0026#34;, codec-\u0026gt;name, codec-\u0026gt;long_name); if (codec_par-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { video_stream_idx = i; video_codec_ctx = avcodec_alloc_context3(codec); avcodec_parameters_to_context(video_codec_ctx, codec_par); if (avcodec_open2(video_codec_ctx, codec, NULL) \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Failed to open video codec\\n\u0026#34;); return -1; } } else if (codec_par-\u0026gt;codec_type == AVMEDIA_TYPE_AUDIO) { audio_stream_idx = i; audio_codec_ctx = avcodec_alloc_context3(codec); avcodec_parameters_to_context(audio_codec_ctx, codec_par); if (avcodec_open2(audio_codec_ctx, codec, NULL) \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Failed to open audio codec\\n\u0026#34;); return -1; } } } if (video_stream_idx \u0026gt;= 0) { framerate = av_guess_frame_rate(ps, ps-\u0026gt;streams[video_stream_idx], NULL); av_log(NULL, AV_LOG_INFO, \u0026#34;Video framerate = %d/%d\\n\u0026#34;, framerate.num, framerate.den); } AVPacket *pkt = av_packet_alloc(); AVFrame *frame = av_frame_alloc(); while (av_read_frame(ps, pkt) \u0026gt;= 0) { if (pkt-\u0026gt;size) { if (pkt-\u0026gt;stream_index == video_stream_idx) { printf(\u0026#34;Video stream index = %d\\n\u0026#34;, video_stream_idx); avcodec_send_packet(video_codec_ctx, pkt); while (avcodec_receive_frame(video_codec_ctx, frame) == 0) { printf(\u0026#34;Decoded video frame\\n\u0026#34;); } } else if (pkt-\u0026gt;stream_index == audio_stream_idx) { printf(\u0026#34;Audio stream index = %d\\n\u0026#34;, audio_stream_idx); avcodec_send_packet(audio_codec_ctx, pkt); while (avcodec_receive_frame(audio_codec_ctx, frame) == 0) { printf(\u0026#34;Decoded audio frame\\n\u0026#34;); } } } av_packet_unref(pkt); av_frame_unref(frame); } avcodec_free_context(\u0026amp;video_codec_ctx); avcodec_free_context(\u0026amp;audio_codec_ctx); av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); avformat_close_input(\u0026amp;ps); return 0; } 打开一个多媒体文件，查找其中的视频和音频流，并打印每个流的相关信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Usage: ./app filename\\n\u0026#34;); return 0; } const char *file_name = argv[1]; AVFormatContext *fmt_ctx = NULL; int ret = avformat_open_input(\u0026amp;fmt_ctx, file_name, NULL, NULL); if (ret) { printf(\u0026#34;Open error: %d\\n\u0026#34;, ret); return -1; } avformat_find_stream_info(fmt_ctx, NULL); av_dump_format(fmt_ctx, 0, file_name, 0); // find codec int video_stream_idx = -1, audio_stream_idx = -1; AVStream *video_stream = NULL, *audio_stream = NULL; AVCodecContext *video_decodec_ctx=NULL, *audio_decodec_ctx=NULL; // AVFormatContext.nb_stream 记录了该 URL 中包含有几路流 for(int i=0; i\u0026lt;fmt_ctx-\u0026gt;nb_streams; i++){ AVStream *stream = fmt_ctx-\u0026gt;streams[i]; AVCodecParameters *codec_par = stream-\u0026gt;codecpar; AVCodec *decodec = NULL; AVCodecContext *decodec_ctx = NULL; av_log(NULL, AV_LOG_INFO, \u0026#34;find audio/video stream index=%d, type=%s, codec id=%#X\\n\u0026#34;, i, av_get_media_type_string(codec_par-\u0026gt;codec_type), codec_par-\u0026gt;codec_id); // 获得解码器 decodec = avcodec_find_decoder(codec_par-\u0026gt;codec_id); av_log(NULL, AV_LOG_INFO, \u0026#34;find codec name=%s\\t%s\\n\u0026#34;, decodec-\u0026gt;name, decodec-\u0026gt;long_name); // 分配解码器上下文句柄 decodec_ctx = avcodec_alloc_context3(decodec); if(!decodec_ctx){ av_log(NULL, AV_LOG_ERROR, \u0026#34;fail to allocate codec context\\n\u0026#34;); } // 复制流信息到解码器上下文 if(avcodec_parameters_to_context(decodec_ctx, codec_par) \u0026lt; 0){ av_log(NULL, AV_LOG_ERROR, \u0026#34;fail to copy codec parameters to decoder context\\n\u0026#34;); avcodec_free_context(\u0026amp;decodec_ctx); } // 初始化解码器 if ((ret = avcodec_open2(decodec_ctx, decodec, NULL)) \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Failed to open %s codec\\n\u0026#34;, decodec-\u0026gt;name); return ret; } if( stream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO){ // 视频的属性，帧率，这里 av_guess_frame_rate() 非必须，看业务是否需要使用帧率参数 decodec_ctx-\u0026gt;framerate = av_guess_frame_rate(fmt_ctx, stream, NULL); av_log(NULL, AV_LOG_INFO, \u0026#34;video framerate=%d/%d\\n\u0026#34;, decodec_ctx-\u0026gt;framerate.num, decodec_ctx-\u0026gt;framerate.den); video_stream_idx = i; video_stream = stream; video_decodec_ctx = decodec_ctx; } else if( stream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_AUDIO){ audio_stream_idx = i; audio_stream = stream; audio_decodec_ctx = decodec_ctx; } } avformat_close_input(\u0026amp;fmt_ctx); return 0; } 示例说明 这段代码的功能是打开一个多媒体文件，查找其中的视频和音频流，并打印每个流的相关信息。具体步骤如下：\n打开文件：通过 avformat_open_input 打开指定的多媒体文件。 获取流信息：调用 avformat_find_stream_info 获取流的详细信息，并用 av_dump_format 打印所有流的基本信息。 查找和初始化解码器：\n遍历文件中的所有流，识别音频和视频流。 为每个流找到对应的解码器，并为其分配和初始化解码器上下文。 打印每个流的类型、编解码器 ID 和名称。 处理视频流：对于视频流，尝试获取帧率信息并打印。 关闭文件：最后，关闭输入文件并释放相关资源。 总结：这段代码用于分析多媒体文件的流结构和编解码器信息。\n参考链接 一步步进行ffmpeg的C语言音视频编程\ndecode_video_mp4 - ChatGPT 解码视频\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #define INBUF_SIZE 4096 static void pgm_save(unsigned char *buf, int wrap, int xsize, int ysize, char *filename) { FILE *f; int i; f = fopen(filename, \u0026#34;wb\u0026#34;); fprintf(f, \u0026#34;P5\\n%d %d\\n%d\\n\u0026#34;, xsize, ysize, 255); for (i = 0; i \u0026lt; ysize; i++) fwrite(buf + i * wrap, 1, xsize, f); fclose(f); } static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt, const char *filename) { char buf[1024]; int ret; ret = avcodec_send_packet(dec_ctx, pkt); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error sending a packet for decoding\\n\u0026#34;); exit(1); } while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(dec_ctx, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error during decoding\\n\u0026#34;); exit(1); } printf(\u0026#34;saving frame %3\u0026#34;PRId64\u0026#34;\\n\u0026#34;, dec_ctx-\u0026gt;frame_number); fflush(stdout); snprintf(buf, sizeof(buf), \u0026#34;%s-%\u0026#34;PRId64, filename, dec_ctx-\u0026gt;frame_number); pgm_save(frame-\u0026gt;data[0], frame-\u0026gt;linesize[0], frame-\u0026gt;width, frame-\u0026gt;height, buf); } } int main(int argc, char **argv) { const char *filename, *outfilename; const AVCodec *codec; AVCodecContext *c = NULL; AVFormatContext *fmt_ctx = NULL; AVFrame *frame; AVPacket *pkt; int video_stream_index; if (argc \u0026lt;= 2) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;input file\u0026gt; \u0026lt;output file\u0026gt;\\n\u0026#34;, argv[0]); exit(0); } filename = argv[1]; outfilename = argv[2]; avformat_open_input(\u0026amp;fmt_ctx, filename, NULL, NULL); if (!fmt_ctx) { fprintf(stderr, \u0026#34;Could not open input file %s\\n\u0026#34;, filename); exit(1); } if (avformat_find_stream_info(fmt_ctx, NULL) \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to retrieve input stream information\\n\u0026#34;); exit(1); } video_stream_index = -1; for (int i = 0; i \u0026lt; fmt_ctx-\u0026gt;nb_streams; i++) { if (fmt_ctx-\u0026gt;streams[i]-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { video_stream_index = i; break; } } if (video_stream_index == -1) { fprintf(stderr, \u0026#34;No video stream found in input file\\n\u0026#34;); exit(1); } AVCodecParameters *codecpar = fmt_ctx-\u0026gt;streams[video_stream_index]-\u0026gt;codecpar; codec = avcodec_find_decoder(codecpar-\u0026gt;codec_id); if (!codec) { fprintf(stderr, \u0026#34;Codec not found\\n\u0026#34;); exit(1); } c = avcodec_alloc_context3(codec); if (!c) { fprintf(stderr, \u0026#34;Could not allocate video codec context\\n\u0026#34;); exit(1); } avcodec_parameters_to_context(c, codecpar); avcodec_open2(c, codec, NULL); frame = av_frame_alloc(); pkt = av_packet_alloc(); while (av_read_frame(fmt_ctx, pkt) \u0026gt;= 0) { if (pkt-\u0026gt;stream_index == video_stream_index) { decode(c, frame, pkt, outfilename); } av_packet_unref(pkt); } decode(c, frame, NULL, outfilename); av_packet_free(\u0026amp;pkt); avcodec_free_context(\u0026amp;c); avformat_close_input(\u0026amp;fmt_ctx); av_frame_free(\u0026amp;frame); return 0; } 参考链接 decode_video.c\nencode_video_mp4 - ChatGPT 多个视频帧通过编码恢复成视频\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libswscale/swscale.h\u0026gt; static void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVFormatContext *ofmt_ctx, AVStream *out_stream) { int ret; AVPacket *pkt = av_packet_alloc(); // Send frame to encoder ret = avcodec_send_frame(enc_ctx, frame); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error sending a frame for encoding\\n\u0026#34;); exit(1); } // Receive encoded packet while (ret \u0026gt;= 0) { ret = avcodec_receive_packet(enc_ctx, pkt); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error during encoding\\n\u0026#34;); exit(1); } // Rescale packet timestamp from codec to output stream timebase av_packet_rescale_ts(pkt, enc_ctx-\u0026gt;time_base, out_stream-\u0026gt;time_base); pkt-\u0026gt;stream_index = out_stream-\u0026gt;index; // Write packet to output ret = av_interleaved_write_frame(ofmt_ctx, pkt); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error writing frame\\n\u0026#34;); exit(1); } av_packet_unref(pkt); } av_packet_free(\u0026amp;pkt); } int main(int argc, char **argv) { const char *output_filename; const AVCodec *encoder; AVCodecContext *enc_ctx = NULL; AVFormatContext *ofmt_ctx = NULL; AVStream *out_stream; AVFrame *frame; int ret, frame_count; if (argc \u0026lt; 2) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;output file\u0026gt;\\n\u0026#34;, argv[0]); exit(1); } output_filename = argv[1]; // Initialize libavformat and register all formats and codecs av_register_all(); // Initialize output format context avformat_alloc_output_context2(\u0026amp;ofmt_ctx, NULL, NULL, output_filename); if (!ofmt_ctx) { fprintf(stderr, \u0026#34;Could not create output context\\n\u0026#34;); exit(1); } // Find H.264 encoder for output video stream encoder = avcodec_find_encoder(AV_CODEC_ID_H264); if (!encoder) { fprintf(stderr, \u0026#34;H.264 encoder not found\\n\u0026#34;); exit(1); } // Create new video stream for output out_stream = avformat_new_stream(ofmt_ctx, NULL); if (!out_stream) { fprintf(stderr, \u0026#34;Failed allocating output stream\\n\u0026#34;); exit(1); } // Initialize codec context for the encoder enc_ctx = avcodec_alloc_context3(encoder); enc_ctx-\u0026gt;bit_rate = 400000; enc_ctx-\u0026gt;width = 1280; // Frame width enc_ctx-\u0026gt;height = 720; // Frame height enc_ctx-\u0026gt;time_base = (AVRational){1, 25}; // Framerate: 25 fps enc_ctx-\u0026gt;framerate = (AVRational){25, 1}; enc_ctx-\u0026gt;gop_size = 10; enc_ctx-\u0026gt;max_b_frames = 1; enc_ctx-\u0026gt;pix_fmt = AV_PIX_FMT_YUV420P; // Open encoder if (avcodec_open2(enc_ctx, encoder, NULL) \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not open encoder\\n\u0026#34;); exit(1); } // Copy the codec parameters from the encoder context to the output stream ret = avcodec_parameters_from_context(out_stream-\u0026gt;codecpar, enc_ctx); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to copy encoder parameters to output stream\\n\u0026#34;); exit(1); } // Open output file if (!(ofmt_ctx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { if (avio_open(\u0026amp;ofmt_ctx-\u0026gt;pb, output_filename, AVIO_FLAG_WRITE) \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not open output file %s\\n\u0026#34;, output_filename); exit(1); } } // Write output file header if (avformat_write_header(ofmt_ctx, NULL) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error occurred when writing header to output file\\n\u0026#34;); exit(1); } // Allocate frame frame = av_frame_alloc(); if (!frame) { fprintf(stderr, \u0026#34;Could not allocate video frame\\n\u0026#34;); exit(1); } frame-\u0026gt;format = enc_ctx-\u0026gt;pix_fmt; frame-\u0026gt;width = enc_ctx-\u0026gt;width; frame-\u0026gt;height = enc_ctx-\u0026gt;height; // Allocate buffer for frame ret = av_frame_get_buffer(frame, 32); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not allocate the frame data\\n\u0026#34;); exit(1); } // Generate frames (this part is where you can insert your own frames) frame_count = 100; // Example: encoding 100 frames for (int i = 0; i \u0026lt; frame_count; i++) { // Make sure the frame is writable ret = av_frame_make_writable(frame); if (ret \u0026lt; 0) { exit(1); } // Fill the frame with your data (for demonstration purposes, here we\u0026#39;re setting all YUV planes to constant values) for (int y = 0; y \u0026lt; enc_ctx-\u0026gt;height; y++) { for (int x = 0; x \u0026lt; enc_ctx-\u0026gt;width; x++) { frame-\u0026gt;data[0][y * frame-\u0026gt;linesize[0] + x] = i + y + x; // Y plane } } for (int y = 0; y \u0026lt; enc_ctx-\u0026gt;height / 2; y++) { for (int x = 0; x \u0026lt; enc_ctx-\u0026gt;width / 2; x++) { frame-\u0026gt;data[1][y * frame-\u0026gt;linesize[1] + x] = 128; // U plane frame-\u0026gt;data[2][y * frame-\u0026gt;linesize[2] + x] = 128; // V plane } } frame-\u0026gt;pts = i; // Set the frame presentation timestamp // Encode the frame encode(enc_ctx, frame, ofmt_ctx, out_stream); } // Flush the encoder encode(enc_ctx, NULL, ofmt_ctx, out_stream); // Write trailer and clean up av_write_trailer(ofmt_ctx); av_frame_free(\u0026amp;frame); avcodec_free_context(\u0026amp;enc_ctx); if (!(ofmt_ctx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { avio_closep(\u0026amp;ofmt_ctx-\u0026gt;pb); } avformat_free_context(ofmt_ctx); return 0; } Linux下基于FFmpeg，通过C语言调用API函数解码mp4视频后再合并成一个新的视频，要求分辨率、颜色跟解码之前一样 - ChatGPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;libavformat/avformat.h\u0026#34; static void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVFormatContext *ofmt_ctx, AVStream *out_stream) { int ret; AVPacket *pkt = av_packet_alloc(); ret = avcodec_send_frame(enc_ctx, frame); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error sending frame to encoder\\n\u0026#34;); exit(1); } while (ret \u0026gt;= 0) { ret = avcodec_receive_packet(enc_ctx, pkt); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error during encoding\\n\u0026#34;); exit(1); } av_packet_rescale_ts(pkt, enc_ctx-\u0026gt;time_base, out_stream-\u0026gt;time_base); pkt-\u0026gt;stream_index = out_stream-\u0026gt;index; ret = av_interleaved_write_frame(ofmt_ctx, pkt); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error writing frame\\n\u0026#34;); exit(1); } av_packet_unref(pkt); } av_packet_free(\u0026amp;pkt); } int main(int argc, char **argv) { const char *input_filename, *output_filename = NULL; AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL; AVCodecContext *dec_ctx = NULL, *enc_ctx = NULL; AVStream *in_stream = NULL, *out_stream = NULL; const AVCodec *decoder, *encoder; AVFrame *frame = NULL; AVPacket pkt; int ret; if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;input.mp4\u0026gt; \u0026lt;output.mp4\u0026gt;\\n\u0026#34;, argv[0]); return -1; } input_filename = argv[1]; output_filename = argv[2]; av_register_all(); // 打开输入文件并获取格式上下文 if ((ret = avformat_open_input(\u0026amp;ifmt_ctx, input_filename, NULL, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not open input file \u0026#39;%s\u0026#39;\\n\u0026#34;, input_filename); return ret; } // 查找流信息 if ((ret = avformat_find_stream_info(ifmt_ctx, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to retrieve input stream information\\n\u0026#34;); return ret; } // 打开输出文件格式上下文 avformat_alloc_output_context2(\u0026amp;ofmt_ctx, NULL, NULL, output_filename); if (!ofmt_ctx) { fprintf(stderr, \u0026#34;Could not create output context\\n\u0026#34;); return AVERROR_UNKNOWN; } // 查找视频流 for (int i = 0; i \u0026lt; ifmt_ctx-\u0026gt;nb_streams; i++) { AVStream *stream = ifmt_ctx-\u0026gt;streams[i]; if (stream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { in_stream = stream; break; } } if (!in_stream) { fprintf(stderr, \u0026#34;Could not find video stream in input file\\n\u0026#34;); return -1; } // 查找解码器 decoder = avcodec_find_decoder(in_stream-\u0026gt;codecpar-\u0026gt;codec_id); if (!decoder) { fprintf(stderr, \u0026#34;Decoder not found\\n\u0026#34;); return AVERROR_DECODER_NOT_FOUND; } // 分配解码器上下文 dec_ctx = avcodec_alloc_context3(decoder); if (!dec_ctx) { fprintf(stderr, \u0026#34;Could not allocate decoder context\\n\u0026#34;); return AVERROR(ENOMEM); } // 初始化解码器上下文 if ((ret = avcodec_parameters_to_context(dec_ctx, in_stream-\u0026gt;codecpar)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to copy decoder parameters to input context\\n\u0026#34;); return ret; } // 打开解码器 if ((ret = avcodec_open2(dec_ctx, decoder, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open decoder\\n\u0026#34;); return ret; } // 为输出流添加一个视频流 out_stream = avformat_new_stream(ofmt_ctx, NULL); if (!out_stream) { fprintf(stderr, \u0026#34;Failed allocating output stream\\n\u0026#34;); return AVERROR_UNKNOWN; } // 查找编码器（使用与解码器相同的格式） encoder = avcodec_find_encoder(dec_ctx-\u0026gt;codec_id); if (!encoder) { fprintf(stderr, \u0026#34;Encoder not found\\n\u0026#34;); return AVERROR_ENCODER_NOT_FOUND; } // 分配编码器上下文 enc_ctx = avcodec_alloc_context3(encoder); if (!enc_ctx) { fprintf(stderr, \u0026#34;Could not allocate encoder context\\n\u0026#34;); return AVERROR(ENOMEM); } // 设置编码器上下文的属性 enc_ctx-\u0026gt;height = dec_ctx-\u0026gt;height; enc_ctx-\u0026gt;width = dec_ctx-\u0026gt;width; enc_ctx-\u0026gt;pix_fmt = dec_ctx-\u0026gt;pix_fmt; enc_ctx-\u0026gt;time_base = in_stream-\u0026gt;time_base; enc_ctx-\u0026gt;framerate = av_guess_frame_rate(ifmt_ctx, in_stream, NULL); // 打开编码器 if ((ret = avcodec_open2(enc_ctx, encoder, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not open encoder\\n\u0026#34;); return ret; } // 复制编码器参数到输出流 if ((ret = avcodec_parameters_from_context(out_stream-\u0026gt;codecpar, enc_ctx)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to copy encoder parameters to output stream\\n\u0026#34;); return ret; } out_stream-\u0026gt;time_base = enc_ctx-\u0026gt;time_base; // 打开输出文件 if (!(ofmt_ctx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { if ((ret = avio_open(\u0026amp;ofmt_ctx-\u0026gt;pb, output_filename, AVIO_FLAG_WRITE)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not open output file \u0026#39;%s\u0026#39;\\n\u0026#34;, output_filename); return ret; } } // 写文件头 if ((ret = avformat_write_header(ofmt_ctx, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Error occurred when opening output file\\n\u0026#34;); return ret; } // 解码并重新编码视频帧 frame = av_frame_alloc(); if (!frame) { fprintf(stderr, \u0026#34;Could not allocate video frame\\n\u0026#34;); return AVERROR(ENOMEM); } while (av_read_frame(ifmt_ctx, \u0026amp;pkt) \u0026gt;= 0) { if (pkt.stream_index == in_stream-\u0026gt;index) { ret = avcodec_send_packet(dec_ctx, \u0026amp;pkt); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error sending packet to decoder\\n\u0026#34;); break; } while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(dec_ctx, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error during decoding\\n\u0026#34;); return ret; } frame-\u0026gt;pts = frame-\u0026gt;best_effort_timestamp; encode(enc_ctx, frame, ofmt_ctx, out_stream); } } av_packet_unref(\u0026amp;pkt); } // Flush encoder encode(enc_ctx, NULL, ofmt_ctx, out_stream); // 写文件尾部 av_write_trailer(ofmt_ctx); // 释放资源 av_frame_free(\u0026amp;frame); avcodec_free_context(\u0026amp;dec_ctx); avcodec_free_context(\u0026amp;enc_ctx); avformat_close_input(\u0026amp;ifmt_ctx); if (!(ofmt_ctx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) avio_closep(\u0026amp;ofmt_ctx-\u0026gt;pb); avformat_free_context(ofmt_ctx); return 0; } 编码函数定义 1 static void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVFormatContext *ofmt_ctx, AVStream *out_stream) enc_ctx: 编码上下文，包含编码器的相关设置。 frame: 需要编码的输入帧。 ofmt_ctx: 输出格式上下文，表示输出文件的格式。 out_stream: 输出流，表示在输出文件中要写入的流。 内部变量 1 2 int ret = 0; AVPacket *pkt = av_packet_alloc(); ret: 用于存储函数调用的返回值。 pkt: 分配一个 AVPacket，用于存储编码后的数据。 发送帧进行编码 1 2 3 4 5 ret = avcodec_send_frame(enc_ctx, frame); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error sending frame to encoder\\n\u0026#34;); exit(1); } 调用 avcodec_send_frame 将帧发送到编码器。 如果返回值小于零，表示出错，打印错误信息并退出。 接收编码后数据 1 2 3 4 5 6 7 8 while (ret \u0026gt;= 0) { ret = avcodec_receive_packet(enc_ctx, pkt); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error during encoding\\n\u0026#34;); exit(1); } 通过 avcodec_receive_packet 接收编码后的数据包。 如果返回 EAGAIN 或 EOF，说明没有更多的数据可接收，直接返回。 如果返回值小于零，表示出错，打印错误信息并退出。 时间基准转换和写入帧 1 2 3 4 5 6 7 8 av_packet_rescale_ts(pkt, enc_ctx-\u0026gt;time_base, out_stream-\u0026gt;time_base); pkt-\u0026gt;stream_index = out_stream-\u0026gt;index; ret = av_interleaved_write_frame(ofmt_ctx, pkt); if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;Error writing frame\\n\u0026#34;); exit(1); } av_packet_rescale_ts: 将数据包的时间戳从编码上下文的时间基准转换为输出流的时间基准。 设置数据包的流索引。 使用 av_interleaved_write_frame 写入编码后的数据包到输出格式上下文中。 如果写入失败，打印错误信息并退出。 释放数据包 1 av_packet_unref(pkt); 释放 pkt，以准备下一次使用。 总结 整体上，这段代码实现了视频帧的编码并写入到文件的功能，通过调用 FFmpeg 提供的 API 处理编码和输出。每一步都包含错误检查，以确保程序在发生错误时能够及时反馈并退出。\n完整代码解析 让我们分解并逐步解释代码的各个部分，包括其功能、参数以及工作机制。该代码的主要目的是在 Linux 下基于 FFmpeg，通过 C 语言解码一个 MP4 视频文件，然后将解码后的帧重新编码为另一个 MP4 文件。\nencode 函数 1 2 3 static void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVFormatContext *ofmt_ctx, AVStream *out_stream) { int ret; AVPacket *pkt = av_packet_alloc(); // 分配一个新的 AVPacket 功能 encode 函数的作用是将视频帧通过编码器进行编码，并将编码后的数据写入输出文件。\n参数解释 AVCodecContext *enc_ctx: 编码器上下文，包含编码器的相关参数和状态。 AVFrame *frame: 待编码的帧。 AVFormatContext *ofmt_ctx: 输出格式上下文，管理输出文件的格式和流。 AVStream *out_stream: 输出流，代表输出文件中的单个流（视频流）。 过程解释 发送帧到编码器： 1 ret = avcodec_send_frame(enc_ctx, frame); 将 frame 发送到编码器。如果 frame 为 NULL，则意味着需要刷新编码器，处理剩余未编码的帧。\n从编码器接收已编码的包： 1 2 while (ret \u0026gt;= 0) { ret = avcodec_receive_packet(enc_ctx, pkt); 通过 avcodec_receive_packet 获取编码后的数据包 pkt。返回 EAGAIN 表示编码器还在等待输入帧；返回 AVERROR_EOF 表示编码器已完成。\n写入文件： 1 av_interleaved_write_frame(ofmt_ctx, pkt); 编码后的数据包 pkt 被写入输出文件。\n清理： 1 2 av_packet_unref(pkt); av_packet_free(\u0026amp;pkt); 使用 av_packet_unref 清理包内容并释放分配的 AVPacket。\nmain 函数 main 函数是程序的入口点，它负责打开输入文件、初始化解码器和编码器、逐帧解码并重新编码、最后将编码后的数据写入输出文件。\n1 2 3 4 5 6 7 8 9 int main(int argc, char argv) { const char *input_filename, *output_filename = NULL; AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL; AVCodecContext *dec_ctx = NULL, *enc_ctx = NULL; AVStream *in_stream = NULL, *out_stream = NULL; const AVCodec *decoder, *encoder; AVFrame *frame = NULL; AVPacket pkt; int ret; 参数解释 argc: 命令行参数的数量。 argv: 命令行参数数组，argv[1] 为输入视频文件路径，argv[2] 为输出视频文件路径。 核心步骤： 输入参数验证： 1 2 3 4 5 6 if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;input.mp4\u0026gt; \u0026lt;output.mp4\u0026gt;\\n\u0026#34;, argv[0]); return -1; } input_filename = argv[1]; output_filename = argv[2]; 检查命令行参数是否足够，确保用户提供了输入和输出文件路径。\n注册所有编解码器： 1 av_register_all(); FFmpeg 初始化函数，注册所有支持的编解码器、文件格式等。\n打开输入文件并获取格式上下文： 1 2 3 4 if ((ret = avformat_open_input(\u0026amp;ifmt_ctx, input_filename, NULL, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Could not open input file \u0026#39;%s\u0026#39;\\n\u0026#34;, input_filename); return ret; } 通过 avformat_open_input 打开输入文件，并填充 ifmt_ctx 结构体，其中包含输入文件的信息。\n查找输入文件流信息： 1 2 3 4 if ((ret = avformat_find_stream_info(ifmt_ctx, NULL)) \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to retrieve input stream information\\n\u0026#34;); return ret; } 使用 avformat_find_stream_info 获取输入文件的所有流信息（视频流、音频流等）。\n查找视频流： 1 2 3 4 5 6 7 for (int i = 0; i \u0026lt; ifmt_ctx-\u0026gt;nb_streams; i++) { AVStream *stream = ifmt_ctx-\u0026gt;streams[i]; if (stream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { in_stream = stream; break; } } 遍历所有流，找到类型为视频的流并赋值给 in_stream。\n查找解码器并初始化解码器上下文： 1 2 3 4 decoder = avcodec_find_decoder(in_stream-\u0026gt;codecpar-\u0026gt;codec_id); dec_ctx = avcodec_alloc_context3(decoder); avcodec_parameters_to_context(dec_ctx, in_stream-\u0026gt;codecpar); avcodec_open2(dec_ctx, decoder, NULL); 根据输入视频的编码格式查找相应的解码器，并初始化解码器上下文 dec_ctx。然后，打开解码器以准备解码。\n创建输出文件并初始化输出流： 1 2 3 4 5 avformat_alloc_output_context2(\u0026amp;ofmt_ctx, NULL, NULL, output_filename); out_stream = avformat_new_stream(ofmt_ctx, NULL); encoder = avcodec_find_encoder(dec_ctx-\u0026gt;codec_id); enc_ctx = avcodec_alloc_context3(encoder); avcodec_open2(enc_ctx, encoder, NULL); 为输出文件分配格式上下文，并创建一个新的视频流 out_stream。随后，查找对应的编码器并初始化编码器上下文 enc_ctx。\n逐帧解码和编码： 1 2 3 4 5 6 7 8 9 10 while (av_read_frame(ifmt_ctx, \u0026amp;pkt) \u0026gt;= 0) { if (pkt.stream_index == in_stream-\u0026gt;index) { ret = avcodec_send_packet(dec_ctx, \u0026amp;pkt); while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(dec_ctx, frame); encode(enc_ctx, frame, ofmt_ctx, out_stream); } } av_packet_unref(\u0026amp;pkt); } 通过 av_read_frame 读取视频帧数据包 pkt。 使用 avcodec_send_packet 发送数据包到解码器。 从解码器获取解码后的 frame，然后通过 encode 函数将其编码并写入输出文件。 写入文件尾并释放资源： 1 2 3 4 5 6 7 av_write_trailer(ofmt_ctx); av_frame_free(\u0026amp;frame); avcodec_free_context(\u0026amp;dec_ctx); avcodec_free_context(\u0026amp;enc_ctx); avformat_close_input(\u0026amp;ifmt_ctx); avio_closep(\u0026amp;ofmt_ctx-\u0026gt;pb); avformat_free_context(ofmt_ctx); 结论 该程序逐步完成视频的解码和编码，将输入 MP4 文件中的视频流解码为帧，然后将每一帧重新编码为新的 MP4 文件，确保解码后的视频重新编码为同样的格式。\n参考链接 Linux下基于ffmpeg音视频解码\n【FFmpeg】avformat_open_input函数\nffmpeg之avformat_find_stream_info函数详细解释\nFFmpeg源代码简单分析：常见结构体的初始化和销毁（AVFormatContext，AVFrame等）\n一步步进行ffmpeg的C语言音视频编程\n","date":"2024-09-09T17:14:47.09+08:00","permalink":"https://ynhugo.github.io/p/linux%E4%B8%8B%E5%9F%BA%E4%BA%8Effmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/","title":"Linux下基于ffmpeg音视频解码"},{"content":" 循环操作 循环打印数字 1 2 3 4 5 6 7 for (var i = 0; i \u0026lt; 5; i++) { (function(index) { setTimeout(function() { toast(index) }, index * 1000); })(i) } 循环点击指定坐标 1 2 3 for (var i = 0; i \u0026lt; 5; i++) { press(513, 743, 200); } 参考链接 【AutoJs】AutoJs实现手势模拟，点击，滑动操作\nFor 循环/While 循环\n起云脚本-autojs之for循环如何正确使用\nAutoJs6\n【免root脚本制作教程】代码循环运行(Auto.js使用教程-5)\ntimers - 定时器\n","date":"2024-09-09T13:42:41.62+08:00","permalink":"https://ynhugo.github.io/p/autojs/","title":"autojs"},{"content":" 详解 const uint8_t * const* 类型： const uint8_t * const* 是 C 语言中的一种复杂指针类型，用于指向指向常量的指针。让我们详细拆解这个类型：\n类型拆解 const uint8_t：\nuint8_t 是无符号的 8 位整数类型，通常用于表示一个字节。 const 关键字在 uint8_t 前面，表示这个 uint8_t 类型的数据是常量，即在指针指向的数据位置上的值不能被修改。 const uint8_t *：\n这是一个指向 const uint8_t 类型的指针。 它表示你可以通过这个指针访问 const uint8_t 类型的数据，但不能修改这些数据。 const uint8_t * const：\n这是一个指向 const uint8_t 的指针，但这个指针本身也是常量。 也就是说，你不能通过这个指针去修改指针的值（即你不能改变指针所指向的位置），但你依然可以读取它所指向的数据。 const uint8_t * const*：\n这是一个指向 const uint8_t * const 的指针，也就是一个指向常量指针的指针。 这意味着你有一个指针，它指向另一个指针，而这个被指向的指针是 const 的（即你不能修改它指向的位置），并且这个被指向的位置的数据也是 const 的（即你不能修改这些数据）。 用途和示例 这个类型经常用于表示一个指针数组，其中每个指针指向一个常量数据，并且这些指针本身也是不可修改的。它在处理图像数据时非常有用，因为图像数据通常是由多个平面组成的，每个平面的数据可能需要被读取但不应被修改。\n示例 假设我们有如下的数据：\n1 2 3 4 5 6 const uint8_t *plane1; // 指向第一个平面的数据，数据不能被修改 const uint8_t *plane2; // 指向第二个平面的数据，数据不能被修改 const uint8_t * const planes[] = { plane1, plane2 }; // 指针数组，数组中的每个指针都指向常量数据 const uint8_t * const * planes_ptr = planes; // 指向指针数组的指针，不能修改指针数组中的指针 在这个示例中：\nplanes 是一个指针数组，其中每个元素都是指向常量数据的指针。 planes_ptr 是一个指向这个指针数组的指针，你不能通过 planes_ptr 修改 planes 中的任何指针值，也不能通过这些指针修改数据本身。 具体应用 在 FFmpeg 的 sws_scale 函数中，const uint8_t * const* 用于指向图像的多个平面数据。每个平面都是不可修改的，这保证了图像数据在转换过程中不会被意外改变。同时，const uint8_t * const* 确保你不能改变指向这些平面的指针数组的结构。这种方式增加了代码的安全性和可维护性。\nC语言打印格式%x与%#x有什么区别 在 C 语言中，%x 和 %#x 是 printf 函数中的格式说明符，用于打印整数值的十六进制表示。它们之间的主要区别在于是否显示前缀：\n%x:\n打印整数的十六进制表示，不带任何前缀。 输出的是一个十六进制数，只使用小写字母（a 到 f）。 示例：\n1 2 int num = 255; printf(\u0026#34;%x\\n\u0026#34;, num); // 输出 \u0026#34;ff\u0026#34; %#x:\n在十六进制表示前加上 0x 前缀。 也输出小写字母（a 到 f）。 示例：\n1 2 int num = 255; printf(\u0026#34;%#x\\n\u0026#34;, num); // 输出 \u0026#34;0xff\u0026#34; 举例说明 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main() { int num = 255; // 使用 %x printf(\u0026#34;Using %%x: %x\\n\u0026#34;, num); // 输出: Using %x: ff // 使用 %#x printf(\u0026#34;Using %%#x: %#x\\n\u0026#34;, num); // 输出: Using %#x: 0xff return 0; } 总结 \u0026#34;%x\u0026#34; 输出的是纯十六进制数值，不带前缀。 \u0026#34;%#x\u0026#34; 在十六进制数值前加上 0x 前缀，标识这是一个十六进制数。 从终端输入字符串，提取字符串中的ASCII值 - ChatGPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { unsigned char *arr = NULL; // 初始化为 NULL unsigned int arr_num = 0; // 当前输入字符的数量 unsigned int capacity = 1; // 初始容量设置为 1 int ch; // 为 arr 分配初始内存 arr = (unsigned char *)malloc(capacity * sizeof(unsigned char)); printf(\u0026#34;请输入包含任意大小数字的任意长度的字符串 (按 Enter 键结束):\\n\u0026#34;); while ((ch = getchar()) != \u0026#39;\\n\u0026#39;) { // 检查是否需要扩展数组 if (arr_num \u0026gt;= capacity) { capacity *= 2; // 扩大容量为原来的两倍 unsigned char *temp = realloc(arr, capacity * sizeof(unsigned char)); arr = temp; // 更新 arr 指针 } arr[arr_num++] = (unsigned char)ch; // 将读取的字符存储到数组 } // 为字符串结束符增加空间 unsigned char *final_arr = realloc(arr, (arr_num + 1) * sizeof(unsigned char)); arr = final_arr; arr[arr_num] = \u0026#39;\\0\u0026#39;; // 添加字符串结束符 // 输出读取到的字符串 printf(\u0026#34;您输入的字符串是: %s\\n\u0026#34;, arr); // 打印每个字符及其 ASCII 值 for (unsigned int i = 0; i \u0026lt; arr_num; i++) { printf(\u0026#34;arr[%d] = %c\\n\u0026#34;, i, arr[i]); } free(arr); // 释放动态分配的内存 return 0; } 代码说明 动态内存分配: 使用 malloc 为 arr 分配初始内存，之后根据需要使用 realloc 扩展内存。\n字符读取: 使用 getchar() 从标准输入逐个读取字符，直到遇到换行符 \\n。\n容量管理: 每当字符数量达到当前容量时，容量翻倍，以合理利用内存。\n字符串结束符: 在读取完成后，为字符串添加结束符 \\0，确保可以正确作为字符串处理。\n内存释放: 程序结尾处释放分配的内存，以避免内存泄漏。\n使用说明 编译并运行程序，输入一段字符并按回车键结束。 程序会输出您输入的字符串和每个字符的 ASCII 值。\n提取字符串中的数字 - ChatGPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { const char *RecvBuf = \u0026#34;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256\u0026#34;; // 输入字符串 char **buf_test = NULL; // 指向字符串指针数组 int count = 0; // 计数器 // 创建一个临时字符串以避免修改原始字符串 char *temp = (char *)malloc(strlen(RecvBuf) + 1); strcpy(temp, RecvBuf); // 复制输入字符串到临时字符串 // 使用 strtok 提取每个数字 char *token = strtok(temp, \u0026#34; \u0026#34;); while (token != NULL) { // 动态增加指针数组大小 char **new_buf_test = (char **)realloc(buf_test, (count + 1) * sizeof(char *)); buf_test = new_buf_test; // 为当前数字分配内存并复制 buf_test[count] = (char *)malloc(strlen(token) + 1); strcpy(buf_test[count], token); // 复制字符串到新分配的内存 count++; token = strtok(NULL, \u0026#34; \u0026#34;); } // 输出提取的数字 for (int i = 0; i \u0026lt; count; i++) { printf(\u0026#34;buf_test[%d] = %s\\n\u0026#34;, i, buf_test[i]); free(buf_test[i]); // 释放每个字符串的内存 } free(buf_test); // 释放指针数组的内存 free(temp); // 释放临时字符串的内存 return 0; } 关键点 动态指针数组: 使用 char **buf_test 来存储提取的数字，每次提取后动态分配内存。 内存管理: 使用 malloc 和 realloc 进行动态内存分配，确保在失败时释放已分配的内存。 字符串操作: 使用 strtok 函数提取字符串，并用 strcpy 复制到新分配的内存中。\n提取字符串中的正数、浮点数 - ChatGPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; // 函数声明 void extractNumbers(const char *inputString); int main() { const char *inputString = \u0026#34;1 -2 3.5 -4.7 5 6 -0.1 7.0\u0026#34;; extractNumbers(inputString); return 0; } // 提取数字的函数 void extractNumbers(const char *inputString) { double num = 0.0; int foundNumber = 0; // 标志是否找到了数字 int isNegative = 0; // 标志是否为负数 int hasDecimal = 0; // 标志是否有小数部分 while (*inputString) { // 跳过空格 while (isspace(*inputString)) { inputString++; } // 检查正负号 if (*inputString == \u0026#39;-\u0026#39;) { isNegative = 1; inputString++; } else if (*inputString == \u0026#39;+\u0026#39;) { inputString++; // 忽略正号 } // 提取数字部分 num = 0.0; hasDecimal = 0; double decimalPlace = 1.0; while (isdigit(*inputString) || *inputString == \u0026#39;.\u0026#39;) { if (*inputString == \u0026#39;.\u0026#39;) { hasDecimal = 1; inputString++; continue; } if (hasDecimal) { decimalPlace *= 10.0; // 更新小数位 num = num + (*inputString - \u0026#39;0\u0026#39;) / decimalPlace; // 加入小数部分 } else { num = num * 10 + (*inputString - \u0026#39;0\u0026#39;); // 加入整数部分 } inputString++; } // 应用符号 if (isNegative) { num = -num; isNegative = 0; // 重置标志 } // 判断并打印结果 if (hasDecimal) { printf(\u0026#34;提取的浮点数是: %.2f\\n\u0026#34;, num); } else { printf(\u0026#34;提取的整数是: %d\\n\u0026#34;, (int)num); } foundNumber = 1; // 找到数字 // 重置状态 while (isspace(*inputString)) { inputString++; // 跳过空格 } } if (!foundNumber) { printf(\u0026#34;没有找到任何数字。\\n\u0026#34;); } } 代码说明 主函数： 定义了输入字符串 inputString，并调用 extractNumbers 函数。 extractNumbers 函数： 使用 double 类型来存储提取的数值，以便处理浮点数。 使用 isNegative 标志来判断数字是否为负数。 使用 hasDecimal 标志来判断是否有小数部分。 遍历字符串时，首先跳过空格，然后检查正负号。 提取数字部分，包括整数和小数：\n如果遇到小数点，更新 hasDecimal 标志，并在后续循环中处理小数部分。 输出提取的数字，区分整数和浮点数。 示例输出 运行上述代码时，输出将会显示提取的所有数字，包括整数和浮点数：\n1 2 3 4 5 6 7 8 提取的整数是: 1 提取的整数是: -2 提取的浮点数是: 3.50 提取的浮点数是: -4.70 提取的整数是: 5 提取的整数是: 6 提取的浮点数是: -0.10 提取的浮点数是: 7.00 这种实现能够有效提取出字符串中的所有整数和浮点数，并且考虑了正负号。\n提取指定大小字符串中的整数 - ChatGPT 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned int *buf1 = NULL; size_t buf1_len = 0; int convert_character(unsigned char *str1, size_t str1_len , unsigned int *str2); int main(int argc, char *aragv[]) { int i = 0; buf1 = malloc(15 * sizeof(unsigned int)); unsigned char *str = (unsigned char *)\u0026#34;1 2 3 4 5 6 7 8 9 10 11 12 13 14\u0026#34;; size_t str_len = strlen((char *)str); convert_character(str, str_len, buf1); /* 输出转换结果 */ for (i = 0; i \u0026lt; buf1_len; i++) { printf(\u0026#34;%d: buf1[%d] = %u\\n\u0026#34;, __LINE__, i, buf1[i]); } free(buf1); return 0; } int convert_character(unsigned char *str1, size_t str1_len , unsigned int *str2) { int i = 0, j = 0;\tfor (i = 0; i \u0026lt; str1_len; i++) { if (str1[i] == \u0026#39; \u0026#39;) continue; /* 跳过空格 */ int num = 0; while(i \u0026lt; str1_len \u0026amp;\u0026amp; str1[i] != \u0026#39; \u0026#39;) { num = num * 10 + (str1[i] - \u0026#39;0\u0026#39;); i++; } str2[j++] = num; } buf1_len = j; return 0; } 这段代码的主要功能是将一个包含空格分隔数字的字符串转换为无符号整数数组，并输出这些整数。下面是对代码功能和结构的详细分析：\n代码功能分析 全局变量：\nunsigned int *buf1：指向动态分配的无符号整数数组，用于保存转换后的结果。 size_t buf1_len：保存转换后数组的长度。 主函数 (main)：\n定义了一个指向 unsigned char 的字符串 str，其中包含空格分隔的数字。 使用 malloc 动态分配了一个大小为 15 的 unsigned int 数组，以便存储转换后的数字。 调用 convert_character 函数，将字符串 str 和它的长度 str_len 传递给该函数以进行转换。 遍历 buf1 数组并打印每个无符号整数及其索引。 最后释放动态分配的内存。 转换函数 (convert_character)：\n接受输入字符串 str1 和其长度 str1_len，以及用于存储输出结果的数组 str2。 在循环中，跳过空格并逐个字符读取数字：\n将字符转换为整数（通过将字符减去 \u0026#39;0\u0026#39;）并累加到 num 中。 当遇到空格或字符串结束时，将解析得到的整数存入 str2 数组。 更新全局变量 buf1_len，指示转换后的数字数量。 重要细节 内存分配：使用 malloc 为 buf1 分配内存，但没有检查分配结果是否成功，可能在内存不足时导致未定义行为。 全局变量的使用：buf1_len 更新在 convert_character 函数中，可能导致可读性降低，因为它在函数外部使用。 输出格式：在输出时使用 __LINE__，这会显示当前行号，有助于调试，但在实际应用中可能不需要。 错误处理：缺少对输入数据的有效性检查（例如，确保输入格式正确且不超过预期的数字数量）。 总结 总体而言，这段代码实现了从一个以空格分隔的数字字符串到无符号整数数组的简单转换功能，并打印出结果。但在实际应用中，应该加入更多的错误处理和边界检查，以提高健壮性和可读性。\n","date":"2024-09-06T18:49:18.86+08:00","permalink":"https://ynhugo.github.io/p/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/","title":"C语言相关"},{"content":" 16种MBTI性格分别代表什么意思？ 通常，人们在完成MBTI16型人格测试后问的第一个问题是：那些神秘的首字母缩写词：INFP-A、 INFJ-A、ENFP-T 或 INTP-A 等等，“这些字母是什么意思？”今天就跟你详细分析：它们分别从以下四个维度去分析你的人格类型。\n精力支配 （I）内向 \u0026amp; （E）外向这方面展示了我们如何与周围环境互动，也就是大家常说的“i人和e人”：\n（I）内向 ：内向的人（Introverted）喜欢单独活动，在社会交往中会感到疲惫。一般来说，他们对外界刺激(如声音、视觉或嗅觉)相当敏感。\n（E）外向 ： 外向的人（Extraverted）喜欢集体活动，通过社会互动获得活力。他们往往比内向的人更热情，更容易兴奋。\n认识世界 （S）实感 \u0026amp; （N）直觉\n第二个方面决定了我们如何看待世界和处理信息，也就是大家常说的“S人和N人”：\n（S）实感 ：实感型/观察型的人（Observant）是洞察力强的，高度务实、脚踏实地的。他们往往专注于正在发生或已经发生的事情。\n（N）直觉 ： 直觉型的人（Intuitive）非常有想象力、思想开放和好奇。他们更喜欢新奇而不是稳定性，并专注于隐藏的意义和未来的可能性。\n判断与决策 （T）思考 \u0026amp;（F）情感这个方面决定了我们如何做决定和处理情绪，也就是大家常说的“T人和F人”：\n（T）思考：思考型/逻辑型的人（Thinking）注重客观和理性，优先考虑逻辑而不是情感。他们倾向于隐藏自己的感受，认为效率比合作更重要。\n（F）情感：情感型/感受型的人（Feeling）是敏感的和情绪化的。与思维型相比，他们更有同理心，更少竞争，更注重社会和谐与合作。\n生活态度 （J）判断\u0026amp; （P）感知这方面反映了我们的工作、规划等生活态度，也就是大家常说的“J人和P人”：\n（J）判断：判断型/计划型的人（Judging）是果断的，彻底的和高度组织。他们重视清晰、可预测性和封闭性，更喜欢结构和计划而不是自发性\n（P）感知：感知型/展望型的人（Prospecting）非常擅长即兴创作和发现机会。他们往往是灵活的、放松的、不墨守成规的人，他们更喜欢保持开放的选择。\n最后：身份特性 身份方面是所有其他方面的基础，表明我们对自己的能力和决定有多么自信：\n自信（-A）：自信型/坚决型（Assertive）是自信的、平和的、能抵抗压力的。他们拒绝过分担心，在实现目标时也不会太勉强自己。\n谨慎（-T）：谨慎型/动荡型（Turbulent）有自我意识，对压力很敏感。他们可能会经历各种各样的情绪，并以成功为导向、完美主义和渴望改进。\n紫色组：理性的“分析家” 直觉和思考 [_NT_] 类型：\n分析家（Analysts）通常是理性和公正的，在智力辩论和科学或技术领域表现出色。他们非常独立，思想开放，意志坚强，富有想象力，从功利主义的角度处理许多事情。比起令每个人都满意的东西，对实在有效的东西更感兴趣。这些特质使分析师成为优秀的战略思想家，但在社交或浪漫追求方面也会造成困难。\nINTJ（建筑师）：富有想象力和战略性的思想家，保证一切在计划之中。 INTP（逻辑学家）：具有创造力的发明家，对知识有着止不住的渴望。 ENTJ（指挥官）：大胆、富有想象力且意志强大的领导者，总能找到或创造解决方法。 ENTP （辩论家）：聪明好奇的思想者，不会放弃任何智力上的挑战。 绿色组：想象力丰富的“外交家” 直觉和情感 [ NF ] 类型：\n外交家（Diplomats）注重同理心和合作，在外交和辅导方面熠熠生辉。属于这种类型的人是合作的和富有想象力的，经常在他们的工作场所或社交圈中扮演协调者的角色。这些特质使外交家成为热情、善解人意和有影响力的人，但当需要完全依靠冷静的理性或做出艰难决定时，也会引发问题。\nINFJ（提倡者）：安静而神秘，同时鼓舞人心的理想主义者。 INFP（调停者）： 诗意而善良的利他主义者，总是热情地为正义提供帮助。 ENFJ（主人公）：富有魅力且鼓舞人心的领导者，有着让听众着迷的能力。 ENFP（竞选者）：热情、有创造力、爱社交的自由自在的活动家，总能找到理由大笑。 蓝色组：踏实而稳定的“守护者” 实感和判断 [ _S_J ] 类型：\n守护者（Sentinels）具有合作精神和高度的实用性，无论他们走到哪里，都会拥抱并创造秩序、安全和稳定。属于这一类型的人往往工作努力、细致、传统，擅长后勤或行政领域，尤其是那些依赖于明确的等级制度和规则的领域。这些性格类型的人坚持他们的计划，不回避困难的任务——然而，他们也可能非常不灵活，不愿意接受不同的观点。\nISTJ（物流师）：实际且注重事实的，具有可靠的个性。 ISFJ（守护者）：非常专注和温暖的守护者，时刻准备着保护爱着的人。 ESTJ（总经理）：出色的管理者，在管理任何事方面有出色技能。 ESFJ（执政官）：富有爱心且受欢迎的大管家，总是热心提供帮助。 黄色组：自由探索的探险家 实感和知觉 [ _S_P ] 类型：\n探险家（Explorers）这些类型是所有类型中最自发的，他们也有一种与周围环境联系的能力，这是其他类型所无法达到的。探索者是实利主义的和实际的，在需要快速反应和思考能力的情况下闪闪发光。他们精通工具和技术，以多种不同方式使用它们——从掌握物理工具到说服他人。不出所料，这些性格类型在危机、手工艺和销售方面是不可替代的——然而，他们的特质也可能促使他们进行冒险的努力或只专注于感官享受。\nISTP（鉴赏家）：大胆而实际的探险家，擅长使用各种形式的工具。 ISFP（探险家）：灵活有魅力的艺术家，时刻准备着探索和体验新鲜事物。 ESTP（企业家）：聪明、精力充沛的领导者，享受行动的乐趣而不是坐以待毙。 ESFP（表演者）：享受自由安排、活力而热情的表演者，拥有永不无聊的快乐。 Dessertant • 提倡者 (INFJ-T)在西方社会，外向的人（e人）远远多于内向（i人）的人，因此大多数人认为每个人都应该努力变得外向、自信、拥有一个大的朋友圈等。这是一种误导性的信念，因为每种性格类型都是独特的，并且具有不同的性格特征。我们无需迫使自己变成一个“理想人格”，而是应该改变你不满意的性格方面——尽管你的显性性格不变，你可以增加更多面的隐性性格。\n相关文章 INFJ 女生：具有“提倡者”人格类型的女生具有什么特征？ ENFJ 女生：具有“主人公”人格类型的女生具有什么特征？ 为什么INFJ（提倡者）和INFP（调停者）人格喜欢暗恋？ 如何识别身边的 ISFP——「最具艺术感的人格类型」之一 为什么INTP（逻辑学家）和INTJ（建筑师）人格更可能是恋爱困难户？ 16型人格室友是什么样的 | NT组 参考链接 16种MBTI性格分别代表什么意思？\n","date":"2024-09-05T23:31:55.11+08:00","permalink":"https://ynhugo.github.io/p/16%E7%A7%8Dmbti%E6%80%A7%E6%A0%BC%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/","title":"16种MBTI性格分别代表什么意思"},{"content":" FFmpeg 编码实现 本例子实现的是将视频域 YUV 数据编码为压缩域的帧数据，编码格式包含了 H.264/H.265/MPEG1/MPEG2 四种 CODEC 类型。\n实现的过程，可以大致用如下图表示:\n从图中可以大致看出视频编码的流程:\n首先要有未压缩的 YUV 原始数据。 其次要根据想要编码的格式选择特定的编码器。 最后编码器的输出即为编码后的视频帧。 根据流程可以推倒出大致的代码实现：\n存放待压缩的 YUV 原始数据。此时可以利用 FFMpeg 提供的 AVFrame 结构体，并根据 YUV 数据来填充 AVFrame　结构的视频宽高、像素格式；根据视频宽高、像素格式可以分配存放数据的内存大小，以及字节对齐情况。 获取编码器。利用想要压缩的格式，比如　H.264/H.265/MPEG1/MPEG2 等，来获取注册的编解码器，编解码器在 FFMpeg 中用 AVCodec 结构体表示，对于编解码器，肯定要对其进行配置，包括待压缩视频的宽高、像素格式、比特率等等信息，这些信息，FFMpeg 提供了一个专门的结构体 AVCodecContext 结构体。 存放编码后压缩域的视频帧。FFMpeg 中用来存放压缩编码数据相关信息的结构体为 AVPacket。最后将 AVPacket 存储的压缩数据写入文件即可。 AVFrame 结构体的分配使用av_frame_alloc()函数，该函数会对 AVFrame 结构体的某些字段设置默认值，它会返回一个指向 AVFrame 的指针或 NULL指针(失败)。\nAVFrame 结构体的释放只能通过av_frame_free()来完成。\n注意，该函数只能分配 AVFrame 结构体本身，不能分配它的 data buffers 字段指向的内容，该字段的指向要根据视频的宽高、像素格式信息手动分配，本例使用的是av_image_alloc()函数。\n代码实现大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //allocate AVFrame struct AVFrame *frame = NULL; frame = av_frame_alloc(); if(!frame){ printf(\u0026#34;Alloc Frame Fail\\n\u0026#34;); return -1; } //fill AVFrame struct fields frame-\u0026gt;width = width; frame-\u0026gt;height = height; frame-\u0026gt;pix_fmt = AV_PIX_FMT_YUV420P; //allocate AVFrame data buffers field point ret = av_image_alloc(frame-\u0026gt;data, frame-\u0026gt;linesize, frame-\u0026gt;width, frame-\u0026gt;height, frame-\u0026gt;pix_fmt, 32); if(ret \u0026lt; 0){ printf(\u0026#34;Alloc Fail\\n\u0026#34;); return -1; } //write input file data to frame-\u0026gt;data buffer fread(frame-\u0026gt;data[0], 1, frame-\u0026gt;width*frame-\u0026gt;height, pInput_File); ... av_frame_free(frame); 编解码器相关的 AVCodec 结构体的分配使用avcodec_find_encoder(enum AVCodecID id)完成，该函数的作用是找到一个与 AVCodecID 匹配的已注册过得编码器；成功则返回一个指向 AVCodec ID 的指针，失败返回 NULL 指针。\n该函数的作用是确定系统中是否有该编码器，只是能够使用编码器进行特定格式编码的最基本的条件，要想使用它，至少要完成两个步骤：\n根据特定的视频数据，对该编码器进行特定的配置； 打开该编码器。 针对第一步中关于编解码器的特定参数，FFMpeg 提供了一个专门用来存放 AVCodec 所需要的配置参数的结构体 AVCodecContext 结构。\n它的分配使用avcodec_alloc_context3(const AVCodec *codec)完成，该函数根据特定的 CODEC 分配一个 AVCodecContext 结构体，并设置一些字段为默认参数，成功则返回指向 AVCodecContext 结构体的指针，失败则返回 NULL 指针。\n分配完成后，根据视频特性，手动指定与编码器相关的一些参数，比如视频宽高、像素格式、比特率、GOP 大小等。最后根据参数信息，打开找到的编码器，此处使用avcodec_open2()函数完成。\n代码实现大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 AVCodec *codec = NULL; AVCodecContext *codecCtx = NULL; //register all encoder and decoder avcodec_register_all(); //find the encoder codec = avcodec_find_encoder(codec_id); if(!codec){ printf(\u0026#34;Could Not Find the Encoder\\n\u0026#34;); return -1; } //allocate the AVCodecContext and fill it\u0026#39;s fields codecCtx = avcodec_alloc_context3(codec); if(!codecCtx){ printf(\u0026#34;Alloc AVCodecCtx Fail\\n\u0026#34;); return -1; } codecCtx-\u0026gt;bit_rate = 4000000; codecCtx-\u0026gt;width = frameWidth; codecCtx-\u0026gt;height = frameHeight; codecCtx-\u0026gt;time_base= (AVRational){1, 25}; //open the encoder if(avcodec_open2(codecCtx, codec, NULL) \u0026lt; 0){ printf(\u0026#34;Open Encoder Fail\\n\u0026#34;); } 存放编码数据的结构体为 AVPacket，使用之前要对该结构体进行初始化，初始化函数为av_init_packet(AVPacket *pkt)，该函数会初始化 AVPacket 结构体中一些字段为默认值，但它不会设置其中的 data 和 size 字段，需要单独初始化,如果此处将 data 设为 NULL、size 设为 0，编码器会自动填充这两个字段。\n有了存放编码数据的结构体后，我们就可以利用编码器进行编码了。\nFFMpeg 提供的用于视频编码的函数为avcodec_encode_video2,它作用是编码一帧视频数据，该函数比较复杂，单独列出如下：\n1 2 int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr); 它会接收来自 AVFrame-\u0026gt;data 的视频数据，并将编码数据放到 AVPacket-\u0026gt;data 指向的位置，编码数据大小为 AVPacket-\u0026gt;size。\n其参数和返回值的意义：\navctx: AVCodecContext 结构，指定了编码的一些参数； avPkt: AVPacket对象的指针，用于保存输出的码流； frame：AVFrame结构，用于传入原始的像素数据； got_packet_ptr:输出参数，用于标识是否已经有了完整的一帧； 返回值：编码成功返回 0， 失败返回负的错误码； 编码完成后就可将AVPacket-\u0026gt;data内的编码数据写到输出文件中；代码实现大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 AVPacket pkt; //init AVPacket av_init_packet(\u0026amp;pkt); pkt.data = NULL; pkt.size = 0; //encode the image ret = avcodec_encode_video2(codecCtx, \u0026amp;pkt, frame, \u0026amp;got_output); if(ret \u0026lt; 0){ printf(\u0026#34;Encode Fail\\n\u0026#34;); return -1; } if(got_output){ fwrite(pkt.data, 1, pkt.size, pOutput_File); } 编码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。\nFFMpeg 解码实现 解码实现的是将压缩域的视频数据解码为像素域的 YUV 数据。实现的过程，可以大致用如下图所示。\n从图中可以看出，大致可以分为下面三个步骤：\n首先要有待解码的压缩域的视频。 其次根据压缩域的压缩格式获得解码器。 最后解码器的输出即为像素域的 YUV 数据。 根据流程可以推倒出大致的代码实现：\n关于输入数据。首先，要分配一块内存，用于存放压缩域的视频数据；之后，对内存中的数据进行预处理，使其分为一个一个的 AVPacket 结构（AVPacket 结构的简单介绍如上面的编码实现）。最后，将 AVPacket 结构中的 data 数据给到解码器。 关于解码器。首先，利用 CODEC_ID 来获取注册的解码器；之后，将预处理过得视频数据给到解码器进行解码。 关于输出。FFMpeg 中，解码后的数据存放在 AVFrame 中；之后就将 AVFrame 中的 data 字段的数据存放到输出文件中。 对于输入数据，首先，通过 fread 函数实现将固定长度的输入文件的数据存放到一块 buffer 内。\nH.264中一个包的长度是不定的，读取固定长度的码流通常不可能刚好读出一个包的长度；\n对此，FFMpeg 提供了一个 AVCoderParserContext 结构用于解析读到 buffer 内的码流信息，直到能够取出一个完整的 H.264 包。\n为此，FFMpeg 提供的函数为av_parser_parse2，该函数比较复杂，定义如下：\n1 2 3 4 5 6 int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos); 函数的参数和返回值含义如下：\nAVCodecParserContext *s:初始化过的 AVCodecParserContext 对象，决定了码流该以怎样的标准进行解析； AVCodecContext *avctx：预先定义好的 AVCodecContext 对象； uint8_t **poutbuf：AVPacket：：data 的地址，保存解析完成的包数据。 int *poutbuf_size：AVPacket 的实际数据长度，如果没有解析出完整的一个包，该值为 0； const uint8_t *but:待解码的码流的地址； int buf_size:待解码的码流的长度； int64_t pts, int64_t dts:显示和解码的时间戳； int64_t pos:码流中的位置； 返回值为解析所使用的比特位的长度； FFMpeg 中为我们提供的该函数常用的使用方式为：\n1 2 3 4 5 6 7 8 9 while(in_len){ len = av_parser_parse2(myparser. AVCodecContext, \u0026amp;data, \u0026amp;size, in_data, in len, pts, dts, pos); in_data += len; in_len -= len; if(size) decode_frame(data, size); } 如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。\n因此，关于输入数据的处理，代码大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //open input file FILE *pInput_File = fopen(Input_FileName, \u0026#34;rb+\u0026#34;); if(!pInput_File){ printf(\u0026#34;Open Input File Fail\\n\u0026#34;); return -1; } //read compressed bitstream form file to buffer uDataSize = fread(inbuf, 1, INBUF_SIZE, pInput_File); if(uDataSize == 0){ //decode finish return -1; } //decode the data in the buffer to AVPacket.data while(uDataSize \u0026gt; 0){ len = av_parser_parse2(pCodecParserCtx, codecCtx, \u0026amp;(pkt.data), \u0026amp;(pkt.size), pDataPtr, uDataSize, AV_NOPTS_VALUE, AV_NOPTS_VALUE, AV_NOPTS_VALUE); uDataSize -= len; uDataPtr += len; if(pkt.size == 0) continue; decode_frame(pkt.data, pkt.size); } 注意，上面提到的av_parser_parse2函数用的几个参数，其实是与具体的编码格式有关的，它们应该在之前已经分配好了，我们只是放到后面来讲一下，因为它们是与具体的解码器强相关的。\n对于解码器。\n与上面提到的编码实现类似，首先，根据 CODEC_ID 找到注册的解码器 AVCodec，FFMpeg 为此提供的函数为avcodec_find_decoder()；\n其次，根据找到的解码器获取与之相关的解码器上下文结构体 AVCodecC，使用的函数为编码中提到的avcodec_alloc_context3；\n再者，如上面提到的要获取完整的一个 NALU，解码器需要分配一个 AVCodecParserContext 结构，使用函数av_parser_init；\n最后，前面的准备工作完成后，打开解码器，即可调用 FFMpeg 提供的解码函数avcodec_decode_video2对输入的压缩域的码流进行解码，并将解码数据存放到 AVFrame-\u0026gt;data 中。\n代码实现大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 AVFrame *frame = NULL; AVCodec *codec = NULL; AVCodecContext *codecCtx = NULL; AVCodecParserContext *pCodecParserCtx = NULL; //register all encoder and decoder avcodec_register_all(); //Allocate AVFrame to Store the Decode Data frame = av_frame_alloc(); if(!frame){ printf(\u0026#34;Alloc Frame Fail\\n\u0026#34;); return -1; } //Find the AVCodec Depending on the CODEC_ID codec = avcodec_find_decoder(AV_CODEC_ID_H264); if(!codec){ printf(\u0026#34;Find the Decoder Fail\\n\u0026#34;); return -1; } //Allocate the AVCodecContext codecCtx = avcodec_alloc_context3(codec); if(!codecCtx){ printf(\u0026#34;Alloc AVCodecCtx Fail\\n\u0026#34;); return -1; } //Allocate the AVCodecParserContext pCodecParserCtx = av_parser_init(AV_CODEC_ID_H264); if(!pCodecParserCtx){ printf(\u0026#34;Alloc AVCodecParserContext Fail\\n\u0026#34;); return -1; } //Open the Decoder if(avcodec_open2(codecCtx, codec, NULL) \u0026lt; 0){ printf(\u0026#34;Could not Open the Decoder\\n\u0026#34;); return -1; } //read compressed bitstream form file to buffer uDataSize = fread(inbuf, 1, INBUF_SIZE, pInput_File); if(uDataSize == 0){ //decode finish return -1; } //decode the data in the buffer to AVPacket.data while(uDataSize \u0026gt; 0){ len = av_parser_parse2(pCodecParserCtx, codecCtx, \u0026amp;(pkt.data), \u0026amp;(pkt.size), pDataPtr, uDataSize, AV_NOPTS_VALUE, AV_NOPTS_VALUE, AV_NOPTS_VALUE); uDataSize -= len; uDataPtr += len; if(pkt.size == 0) continue; //decode start avcodec_decode_video2(codecCtx, frame, \u0026amp;got_frame, pkt); } 注意，上面解码的过程中，针对具体的实现，可能要做一些具体参数上的调整，此处只是理清解码的流程。\n对于输出数据。\n解码完成后，解码出来的像素域的数据存放在 AVFrame 的 data 字段内，只需要将该字段内存放的数据之间写文件到输出文件即可。\n解码函数avcodec_decode_video2函数完成整个解码过程，对于它简单介绍如下：\n1 2 3 int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, const AVPacket *avpkt); 该函数各个参数的意义：\nAVCodecContext *avctx：编解码器上下文对象，在打开编解码器时生成； AVFrame *picture: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好； int *got_picture_ptr: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了; const AVPacket *avpkt: 前面解析好的码流包； 由此可见，当标识位为1时，代表解码一帧结束，可以写数据到文件中。代码如下：\n1 2 3 4 5 6 7 8 9 pOutput_File = fopen(Output_FileName, \u0026#34;wb\u0026#34;); if(!pOutput_File){ printf(\u0026#34;Open Output File Fail\\n\u0026#34;); return -1; } if(*got_picture_ptr){ fwrite(frame-\u0026gt;data[0],1, Len, pOutput_File) } 解码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。\n参考链接 FFMpeg 实现视频编码、解码\nffmpeg-study-recording\nFFMpeg 实现视频编码、解码、封装、解封装、转码、缩放\n","date":"2024-09-05T19:24:19.98+08:00","permalink":"https://ynhugo.github.io/p/ffmpeg-%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/","title":"FFmpeg 实现视频编码、解码"},{"content":" Ubuntu 20.04LTS FFmpeg 环境配置 FFmpeg 是音视频开发工作中不可缺少的工作技能，本文主要讲解如何在 Ubuntu 系统之上编译、搭建 FFmpeg 开发环境。\nChapter 1 安装前的环境配置 Part 1 安装环境依赖 1 sudo apt-get update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sudo apt-get install -y \\ autoconf \\ automake \\ build-essential \\ cmake \\ git-core \\ libass-dev \\ libfreetype6-dev \\ libsdl2-dev \\ libtool \\ libva-dev \\ libvdpau-dev \\ libvorbis-dev \\ libxcb1-dev \\ libxcb-shm0-dev \\ libxcb-xfixes0-dev \\ pkg-config \\ texinfo \\ wget \\ zlib1g-dev 1 sudo apt install -y ffmpeg libavcodec-dev libavformat-dev libavutil-dev Part 2 安装相关库 1 2 3 4 5 6 7 8 9 sudo apt-get install -y \\ nasm \\ yasm \\ libx264-dev \\ libx265-dev \\ libnuma-dev \\ libvpx-dev \\ libfdk-aac-dev \\ libopus-dev \\ Chapter 2 安装 FFmpeg Part 1 下载 FFmpeg 使用 4.3.1 版本\n1 2 3 4 mkdir ffmpeg \u0026amp;\u0026amp; cd ffmpeg/ wget https://ffmpeg.org/releases/ffmpeg-4.3.1.tar.bz2 tar xvf ffmpeg-4.3.1.tar.bz2 cd ffmpeg-4.3.1/ Part 2 配置编译项 1 2 3 4 5 6 7 8 9 10 11 12 ./configure --enable-gpl \\ --enable-libass \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libopus \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libx264 \\ --enable-libx265 \\ --enable-nonfree --enable-vdpau --enable-vaapi Part 3 编译 1 sudo make -j8 \u0026amp;\u0026amp; sudo make install Part 4 测试 1 ffmpeg -version 编写测试程序 1、创建C代码文件名叫hello.c，填入下面的代码内容：\n1 2 3 4 5 #include \u0026lt;libavutil/avutil.h\u0026gt; int main(int argc, char* argv[]) { av_log(NULL, AV_LOG_INFO, \u0026#34;hello world\\n\u0026#34;); } 2、保存并退出该文件，执行以下命令编译hello.c：\n1 gcc hello.c -o hello -I/usr/local/ffmpeg/include -L/usr/local/ffmpeg/lib -lavformat -lavdevice -lavfilter -lavcodec -lavutil -lswscale -lswresample -lpostproc -lm 3、运行编译好的hello程序，也就是执行以下命令：\n1 ./hello 发现控制台回显日志信息“hello world”，表示测试程序运行正常，说明FFmpeg开发环境已经成功搭建。\n4、刚才的测试程序hello.c采用C语言编写，并且使用gcc编译。若要采用C++编程的话，则需改成下面的hello.cpp代码：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; // 因为FFmpeg源码使用C语言编写，所以在C++代码中调用FFmpeg的话，要使用标记“extern \u0026#34;C\u0026#34;{……}”把FFmpeg的头文件包含进来 extern \u0026#34;C\u0026#34; { #include \u0026lt;libavutil/avutil.h\u0026gt; } int main(int argc, char* argv[]) { av_log(NULL, AV_LOG_INFO, \u0026#34;hello world\\n\u0026#34;); } 鉴于C++代码采用g++编译，于是hello.cpp的编译命令变成下面这样：\n1 g++ hello.cpp -o hello -I/usr/local/ffmpeg/include -L/usr/local/ffmpeg/bin -lavformat -lavdevice -lavfilter -lavcodec -lavutil -lswscale -lswresample -lpostproc -lm 编译完毕，同样生成名叫hello的可执行程序，如此就实现了C++代码集成FFmpeg函数的目标了。\n一键安装脚本 1 2 3 4 5 6 7 8 9 10 11 sudo apt-get update sudo apt-get install -y autoconf automake build-essential cmake git-core libass-dev libfreetype6-dev libsdl2-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev sudo apt install -y ffmpeg libavcodec-dev libavformat-dev libavutil-dev sudo apt-get install -y nasm yasm libx264-dev libx265-dev libnuma-dev libvpx-dev libfdk-aac-dev libopus-dev mkdir ffmpeg \u0026amp;\u0026amp; cd ffmpeg/ wget https://ffmpeg.org/releases/ffmpeg-4.3.1.tar.bz2 tar xvf ffmpeg-4.3.1.tar.bz2 cd ffmpeg-4.3.1/ ./configure --enable-gpl --enable-libass --enable-libfdk-aac --enable-libfreetype --enable-libopus --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-nonfree --enable-vdpau --enable-vaapi sudo make -j8 \u0026amp;\u0026amp; make examples \u0026amp;\u0026amp; sudo make install # git clone https://github.com/lazybing/ffmpeg-study-recording 参考链接 Ubuntu 20.04LTS FFmpeg 环境配置\nlinux下ffmpeg调用GPU硬件解码（VDPAU/VAAPI）保存文件\nnvdec与vaapi与vdpau的关系\nFFmpeg开发笔记（一）搭建Linux系统的开发环境\nFFMpeg 实现视频编码、解码\n","date":"2024-09-05T17:06:30.11+08:00","permalink":"https://ynhugo.github.io/p/ubuntu-20.04lts-ffmpeg-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"Ubuntu 20.04LTS FFmpeg 环境配置"},{"content":" 官方源码 体验教程 克隆仓库 1 2 git clone https://github.com/2noise/ChatTTS cd ChatTTS 安装依赖 1. 直接安装 1 pip install --upgrade -r requirements.txt 2. 使用 conda 安装 1 2 3 conda create -n chattts python=3.12 conda activate chattts pip install -r requirements.txt 快速启动 确保在执行以下命令时，处于项目根目录下。\n1. WebUI 可视化界面 1 python examples/web/webui.py 参考链接 Windows下一键安装包模式 个人建议 下载压缩包后直接提前想好将项目解压到什么路径，因为我经历过第一次配置好后再尝试更换路径进行配置就失败了。\nREDEME页面 https://github.com/yuhaolove/ChatTTS-WebUI/blob/main/README_CN.md\n下载页面 https://github.com/yuhaolove/ChatTTS-WebUI/releases/latest\n安装方式 首次使用请双击或在命令行中运行install.bat。安装完成后将直接启动webui 后续的使用直接双击run_webui.bat即可\n参考链接 Windows下一键安装包模式\n","date":"2024-09-02T01:12:06.78+08:00","permalink":"https://ynhugo.github.io/p/chattts/","title":"ChatTTS"},{"content":" 安装Anaconda 1.1 下载anaconda的安装包\n这里我们需要在官网上查找自己需要的版本，地址链接在下面:\nhttps://repo.anaconda.com/archive/\n这里以我自己安装的版本为例：\nhttps://repo.anaconda.com/archive/Anaconda3-5.3.0-Linux-x86_64.sh\n这是我选择的版本，然后我们在控制台输入这句话：\nwget https://repo.anaconda.com/archive/Anaconda3-5.3.0-Linux-x86_64.sh\n如果使用wget下载不下来的话，可以手动下载安装文件\n1.3 安装anaconda\n接下来我们需要首先赋权再执行安装程序，依次输入下面两句命令:\nchmod +x Anaconda3-5.3.0-Linux-x86_64.sh\n./Anaconda3-5.3.0-Linux-x86_64.sh\n1.4 点击Enter（回车键）\n此时显示Anaconda的信息，并且会出现More，继续按Enter，直到提示输入yes/no\n1.5 输入 yes\n1.6 继续点击 Enter\n1.7 输入 yes，添加环境变量\n这里需要注意点的就是如果你直接跳过这部设置环境变量的话：\n[no ] \u0026gt;\u0026gt;\u0026gt;\n那你需要自己到这个文件夹设置你安装Anaconda路径（比如上面显示我的是）\nhome/wangke.bashrc\n单击进去，在最后一行添加：\nexport PATH=/home/anaconda3/bin:$PATH\n需要把之前的那句话给注释掉如下所示：\n1 # export PATH=/usr/local/nvidia/bin:/usr/local/cuda/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH export PATH=/root/anaconda3/bin:$PATH\n这里只是个示例，具体的还是要看你们自己安装的路径。\n然后保存更改，输入下面这句指令：\nsource ~/.bashrc\n1.8 完成安装以及检测是否安装成功\n打开新的终端后，进入自己的文件夹目录下，输入anaconda -V（注意a要小写，V要大写），conda -V ,显示版本信息，若显示则表示安装成功。\nroot@dev-wyf-react:~/wyf# conda -V\nconda 4.5.11\nubuntu下conda如何设置镜像源（清华镜像源） ubuntu下如何设置镜像源 首先贴出.condarc，直接给出清华的镜像源，需要的小伙伴直接使用，别看内容了\n1 2 3 4 5 6 # ~/.condarc channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free show_channel_urls: True 添加conda镜像源命令（直接使用）\n1 2 3 4 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r conda config --set show_channel_urls yes 参考链接 如何在Linux服务器上安装Anaconda（超详细）\nubuntu下conda如何设置镜像源（清华镜像源）\n","date":"2024-08-21T00:46:14.95+08:00","permalink":"https://ynhugo.github.io/p/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85anaconda/","title":"Linux服务器上安装Anaconda"},{"content":" windows7安装小狼毫五笔拼音输入法 下载对应Win7的输入法 下载链接：https://rime.im/download/\n接下来下载词库，两种方式，一种是在线安装，一种是离线安装。推荐在线安装 在线安装 在线安装的方法，可以右下角右键，选择“输入法设定”，打开面板，出现“获取更多输入法设定”，点击后，跳出命令窗口，输入\nrime-wubi\n按回车，安装。完成后，再输入\nrime-pinyin-simp\n按回车，安装\n注意：不安装rime-pinyin-simp，是无法启动拼音输入的。\n重新部署即可，选择对应的输入法。\n离线安装 离线安装。安装exe文件后，需要额外下载五笔输入法库，https://github.com/rime/rime-wubi 和 https://github.com/rime/rime-pinyin-simp/\n下载后，解压到[程序文件夹] C:Program Files (x86)\\Rime\\weasel-0.14.3\\data （可以通过右下角，小狼毫输入法，右键，直接选中打开[程序文件夹]）\n之后，同理，右下角，小狼毫输入法，右键，选择[重新部署]\n部署完毕后，同理点击[输入法设定]，即可显示出五笔输入法了。\n步骤对了，其实很简单。\n参考链接 RIME／中州韻輸入法引擎下载及安装\n在windows上安装小狼毫 五笔拼音混合输入法，远离国产五笔输入法\nrime-wubi\nrime-pinyin-simp\n","date":"2024-08-12T14:35:57.46+08:00","permalink":"https://ynhugo.github.io/p/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%B0%8F%E7%8B%BC%E6%AF%AB%E4%BA%94%E7%AC%94%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95/","title":"如何安装小狼毫五笔拼音输入法"},{"content":" 酒 唱吧不是吧 清吧喝过的酒 团购198元鸡尾酒套餐 餐前酒，跟小甜水似的，喝着没感觉，由于是第一次喝，并不知道这种酒适合男女喝，下次不点了\n单人鸡尾酒 教父-65元 成分 威士忌+杏仁酒+橘子皮+冰块\n评价 味道比较苦，说是40度，其实喝着没感觉\n今夜不回家-65元 成分 龙舌兰、白橙皮力娇酒+草莓力娇酒（中和口感）、白朗姆、生命之水（伏特加的一种）\n评价 加冰块，喝着还行，没有点火\n尼格罗尼 成分 金酒、金巴力、红威末\n评价 微苦\n金汤力 成分 金酒、汤力水\n评价 喝着跟饮料似的\n古典 成分 威士忌、苏打水、苦精、方糖\n评价 微苦\n枫叶 成分 威士忌、金巴力、苏打水\n评价 口感还好\n干马天尼 成分 金酒、马天尼\n评价 口感偏柔\n长岛冰茶 成分 白橙力娇酒、伏特加、金酒、龙舌兰、白朗母、柠檬汁\n评价 喝着跟饮料似的\n威士忌酸 成分 威士忌、柠檬汁\n评价 酸甜口感，偏酸\n僵尸 成分 白朗姆、151、菠萝汁、柠檬汁、糖浆\n评价 微酸，口感还可以\n大都会 成分 伏特加、蔓越莓、君度、柠檬汁\n醉富贵-秋季限定款 成分 糖浆、白橙皮力娇酒、威士忌\n评价 第一口是苦的，然后细品能感受到一股桂花的清香，最后一口是甜的。\n莫吉托 成分 白朗姆、柠檬酸、薄荷糖浆、糖浆、苏打水\n玛格丽特 成分 龙舌兰、君度、糖浆、柠檬汁\n楂男 成分 威士忌、金酒、山楂酒（预制酒）\n评价 淡淡苦中带点山楂味道的口感\n龙舌兰日出 成分 龙舌兰、橙汁、石榴糖浆\n评价 口感还行，跟饮料差不多，有淡淡的苦味\n红粉佳人 成分 君度、鸡蛋清、红石榴糖浆\n评价 淡淡的苦味加鸡蛋清的味道，闻着有淡淡的属于鸡蛋清的腥味\n星空鸡尾酒 成分 朗姆、蓝橙、蓝柑糖浆\n评价 微甜中带着淡淡的酒味\n彩虹人生 成分 石榴糖浆、柠檬汁、橙汁、菠萝汁、伏特加、蓝橙\n评价 跟饮料差不多\n露天小酒馆 调酒 今夜不回家 成分 金酒+白朗母+龙舌兰+威士忌+伏特加+白兰地+兰橙力娇酒\n评价 还可以，确实有点劲，但是感觉还不如53度的红星二锅头\n什刹海-海棠酒吧 调酒 今夜不回家 成分 煊尼诗vsop、伏特加、白橙皮、杏仁力娇、秘方酒、任意一款高度酒\n评价 点火，喝着还行，感觉有点柔\n郑州-贰麻酒馆 调酒 明天见 成分 威士忌、白朗母、金酒、白兰地、龙舌兰、伏特加、糖浆\n评价 点火，喝着还行，感觉有点柔，听说比今夜不回家的度数还高\n酡颜 成分 白朗母、伏特加、香蕉利口酒、山楂果酱、菠萝汁、莫林蔗糖、红石榴糖浆\n评价 喝着跟饮料似的\n国王姆 成分 蓝橙力娇酒、威士忌、柠檬酸、君度力娇酒\n评价 喝着跟饮料似的\n地方推荐 美食 杭州萧山的施家八大碗 河南胡辣汤 河南烩面 山西太原柳巷铜锣湾底下的那家店的醋比较香 山西文水的醋比较香 陕西羊肉泡馍 山东煎饼卷大葱 山东朝天锅 ","date":"2024-08-01T23:39:21.36+08:00","permalink":"https://ynhugo.github.io/p/%E7%94%9F%E6%B4%BB/","title":"生活"},{"content":" 国之脊梁 相关读物 大国脊梁\n","date":"2024-07-31T08:59:15.31+08:00","permalink":"https://ynhugo.github.io/p/%E5%9B%BD%E4%B9%8B%E8%84%8A%E6%A2%81/","title":"国之脊梁"},{"content":" Zerotier+Moonlight 远控方案畅玩游戏，一文看懂如何配置操作！ 方案 使用的是 Zerotier One + moonlight 的一套控制方案，被控端（PC）使用 Zerotier One + sunshine 的一个输出\n配置 主控端：Moonlight https://github.com/moonlight-stream\n被控端：Sunshine https://github.com/LizardByte/Sunshine\nSteam link 方案 主控端：Steamlink app 或者客户端，官方下载地址：https://help.steampowered.com/en/faqs/view/7112-CD02-7B57-59F8\n被控端：Steam 客户端，并在客户端内开启远程畅玩：设置 ——\u0026gt; 远程畅玩\n注意！Sunshine 推流的时候要在防火墙给对应端口放行！直接把防火墙关了就行！\n打洞方案的软件配置 局域网下软件配置 被控端 安装并启动Sunshine，然后在你的浏览器输入 https://localhost:47990 ，进行一番密码设置，便能进入 Sunshine 的控制界面啦！点击网页菜单的PIN按钮，然后输入主控（Moonlight）那边的 PIN 码即可配对连接\n主控端 移动端下好 moonlight app 并启动，点击 “+” 号，进入后输入对应的被控端 IP 地址即可，公网下的 IP 地址在 Zerotier 这种虚拟组网软件上查看，对应 IP 由路由器分配，输入至上方 Moonlight 内即可识别\n参考链接 Zerotier+Moonlight 远控方案畅玩游戏，一文看懂如何配置操作！\n","date":"2024-07-27T01:34:59.03+08:00","permalink":"https://ynhugo.github.io/p/zerotier-moonlight-%E8%BF%9C%E6%8E%A7%E6%96%B9%E6%A1%88%E7%95%85%E7%8E%A9%E6%B8%B8%E6%88%8F/","title":"Zerotier+Moonlight 远控方案畅玩游戏"},{"content":" 从0到100循环输出数字，并且每输出一个数字后暂停1秒钟 1 for /l %i in (0, 1, 100) do @echo %i \u0026amp; timeout /t 1 \u0026gt;nul 实现效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 C:\\Windows\\System32\u0026gt;for /l %i in (0, 1, 100) do @echo %i \u0026amp; timeout /t 1 \u0026gt;nul 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ","date":"2024-07-21T14:58:24.56+08:00","permalink":"https://ynhugo.github.io/p/cmd%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/","title":"cmd环境操作技巧"},{"content":" 整蛊：聊天中，连续发送消息的vbs脚本 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 On Error Resume Next Dim wsh,s,xTimes,tle set wsh=createobject(\u0026#34;wscript.shell\u0026#34;) xTimes = inputbox(\u0026#34;请输入重发消息的次数\u0026#34;) \u0026#39;clipboardData.SetData s for i=1 to Cint(xtimes) wscript.sleep 30 wsh.AppActivate(cStr(tle)) wsh.sendKeys \u0026#34;^v\u0026#34; wsh.sendKeys \u0026#34;%s\u0026#34; next wscript.quit 参考链接 整蛊：聊天中，连续发送消息的vbs脚本\n","date":"2024-07-18T15:02:58.33+08:00","permalink":"https://ynhugo.github.io/p/vbs/","title":"vbs"},{"content":" Windows有什么小软件可以指定键盘上一个按键等同于点击屏幕上指定的地方？ 这个需求看起来非常适合用 AutoHotKey 来解决。\n首先从官网上下载 AutoHotKey 安装程序，运行后选择第一项（快速安装）即可，等待片刻，然后选择倒数第二项（运行 AutoHotKey）\n再关掉 AutoHotKey 软件窗口，并在桌面上右键，在“新建”菜单栏中选择 AutoHotKey Script，创建一个新的 ahk 脚本\n用记事本打开新建的 ahk 文件并填入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 x1 := -282 ; 要点击位置的横坐标（默认值） y1 := 1008 ; 要点击位置的纵坐标（默认值） ; 快捷键：Ctrl + F5 ^F5:: { MouseGetPos, x1, y1 ; 更新要点击的位置坐标 return } ; 快捷键：F5 F5:: { MouseClick, left, %x1%, %y1%, 1, 0 ; 在指定坐标处点击鼠标左键 return } x2 := 416 ; 要点击位置的横坐标（默认值） y2 := 634 ; 要点击位置的纵坐标（默认值） ; 快捷键：Ctrl + F6 ^F6:: { MouseGetPos, x2, y2 ; 更新要点击的位置坐标 return } ; 快捷键：F6 F6:: { MouseClick, left, %x2%, %y2%, 1, 0 ; 在指定坐标处点击鼠标左键 return } x3 := 415 ; 要点击位置的横坐标（默认值） y3 := 669 ; 要点击位置的纵坐标（默认值） ; 快捷键：Ctrl + F7 ^F7:: { MouseGetPos, x3, y3 ; 更新要点击的位置坐标 return } ; 快捷键：F7 F7:: { MouseClick, left, %x3%, %y3%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 按 F8 对应点击屏幕坐标 ; 按 ^F8 对应重新设置屏幕坐标位置 xpos := 0 ; 要点击位置的横坐标（默认值） ypos := 0 ; 要点击位置的纵坐标（默认值） ; 快捷键：^F8 ^F8:: { MouseGetPos, xpos, ypos ; 更新位置坐标 ; MsgBox,拾取光标坐标x:%xpos%,y:%ypos% return } ; 快捷键：F8 F8:: { MouseClick, left, %xpos%, %ypos%, 1, 0 ; 在指定坐标处点击鼠标左键 return } 后台自动运行-cmd脚本 1 2 3 4 5 6 @echo off if \u0026#34;%1\u0026#34;==\u0026#34;h\u0026#34; goto begin start mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;\u0026#34;\u0026#34;%~nx0\u0026#34;\u0026#34; h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin \u0026#34;D:\\Program Files\\AutoHotkey\\UX\\AutoHotkeyUX.exe\u0026#34; \u0026#34;D:\\Program Files\\AutoHotkey\\UX\\launcher.ahk\u0026#34; \u0026#34;D:\\00_zdk\\myTools\\AutoHotkey\\sendClick-scrcpy.ahk\u0026#34; %* AHK 键盘控制鼠标点击屏幕不同位置 按键控制鼠标点击屏幕特定位置 按键控制重设屏幕点击位置 按键显示当前鼠标在屏幕上的位置 V1.0代码功能 按 A 和 D 分别对应点击两个单独的屏幕坐标 按 Q 和 E分别对应重新设置两个单独的屏幕坐标位置，并弹窗显示拾取到的光标坐标 V1.0代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ; 按 A 和 D 分别对应点击两个单独的屏幕坐标 ; 按 Q 和 E 分别对应重新设置两个单独的屏幕坐标位置 xpos := 0 ; 要点击位置的横坐标（默认值） ypos := 0 ; 要点击位置的纵坐标（默认值） xpos2 := 0 ; 要点击位置的横坐标（默认值） ypos2 := 0 ; 要点击位置的纵坐标（默认值） ; 快捷键：q q:: { MouseGetPos, xpos, ypos ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos%,y:%ypos% return } ; 快捷键：a a:: { MouseClick, left, %xpos%, %ypos%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：e e:: { MouseGetPos, xpos2, ypos2 ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos2%,y:%ypos2% return } ; 快捷键：d d:: { MouseClick, left, %xpos2%, %xpos2%, 1, 0 ; 在指定坐标处点击鼠标左键 return } V2.0代码功能 按 A 和 D 分别对应点击两个单独的屏幕坐标 按 Q 和 E分别对应重新设置两个单独的屏幕坐标位置，并弹窗显示拾取到的光标坐标,3秒后弹窗自动关闭 V2.0代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 ; 按 A 、S、 D 分别对应点击三个单独的屏幕坐标 ; 按 A 、S、 D 分别对应点击三个单独的屏幕坐标 ; 按 Q 、W、 E 分别对应重新设置三个单独的屏幕坐标位置 x := 0 ; 要点击位置的横坐标（默认值） y := 0 ; 要点击位置的纵坐标（默认值） x1 := 0 ; 要点击位置的横坐标（默认值） y1 := 0 ; 要点击位置的纵坐标（默认值） x2 := 0 ; 要点击位置的横坐标（默认值） y2 := 0 ; 要点击位置的纵坐标（默认值） ; 快捷键：q q:: { MouseGetPos, x, y ; 更新位置坐标 MsgBox, 4, ,拾取坐标 x:%x% y:%y% 此弹窗1秒后关闭, 1 return } ; 快捷键：a a:: { MouseClick, left, %x%, %y%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：w w:: { MouseGetPos, x1, y1 ; 更新位置坐标 MsgBox, 4, ,拾取坐标 x:%x1% y:%y1% 此弹窗1秒后关闭, 1 return } ; 快捷键：s s:: { MouseClick, left, %x1%, %y1%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：e e:: { MouseGetPos, x2, y2 ; 更新位置坐标 MsgBox, 4, ,拾取坐标 x:%x2% y:%y2% 此弹窗1秒后关闭, 1 return } ; 快捷键：d d:: { MouseClick, left, %x2%, %y2%, 1, 0 ; 在指定坐标处点击鼠标左键s return } 简化版 按 F5 分别对应点击屏幕坐标 按 Ctrl + F5对应重新设置屏幕坐标位置，并弹窗显示拾取到的光标坐标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; 按 F5 对应点击屏幕坐标 ; 按 ^F5 对应重新设置屏幕坐标位置 xpos := 0 ; 要点击位置的横坐标（默认值） ypos := 0 ; 要点击位置的纵坐标（默认值） ; 快捷键：^F5 ^F5:: { MouseGetPos, xpos, ypos ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos%,y:%ypos% return } ; 快捷键：F5 F5:: { MouseClick, left, %xpos%, %ypos%, 1, 0 ; 在指定坐标处点击鼠标左键 return } 参考链接 Windows获取桌面坐标\nAHK 键盘控制鼠标点击屏幕不同位置\nWindows有什么小软件可以指定键盘上一个按键等同于点击屏幕上指定的地方？\nAutoHotKey 操作鼠标进行移动托动点击 1 2 3 4 5 6 7 8 9 10 11 12 13 F9:: MouseGetPos,xpos,ypos MouseClick,,%xpos%,%ypos%,,0,D MouseClick,,0,-40,,0,U,R MouseMove,%xpos%,%ypos% Return F10:: MouseGetPos,xpos,ypos MouseClick,,%xpos%,%ypos%,,0,D MouseClick,,0,40,,0,U,R MouseMove,%xpos%,%ypos% Return 参考链接 AutoHotKey 操作鼠标进行移动托动点击\nMouseGetPos\nMouseClick\nMouseMove\nautohotkey鼠标自动点击，并且可以判断是否有按键按下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sleep 3000 flag := 0 if (flag = 0) { Loop 1000 { Click, xpos, xpos sleep 100 if GetKeyState(\u0026#34;F8\u0026#34;) { flag++ MsgBox, F8按键被按下了，按回车继续 continue } } } 参考链接 autohotkey鼠标自动点击\nautohotkey如何判断有按键按下\n","date":"2024-07-17T10:41:48.8+08:00","permalink":"https://ynhugo.github.io/p/autohotkey/","title":"AutoHotKey"},{"content":" 付费 VPS raksmart 支持最低3美元的 VPS，可以用于搭建 ChatGPT，可以在 web 界面进行开关机和重装系统，重装系统时可以重置密码，配置的话通过 ssh 访问\n链接：https://www.raksmart.com/home\n免费 VPS 永久免费的公共 UNIX 服务器 注册方法 打开网址：https://sdf.org/ 直接填写邮箱和登录名称，确认即可注册。\n注册后，请在邮箱中查找来自 SDF 的邮件，极有可能是在垃圾箱中，里面给出了服务器登录的方法，包括用户名和密码。\n使用 ssh 工具，直接登录即可。\n操作建议 一款持续提供35年的服务商是值得尊敬的，如果有条件可以赞助一下；筹款商店还有光盘和徽章售卖。终身会员只要36刀！\n新人可以看看 freeBSD 的文档，对于提升有很大帮助：https://docs.freebsd.org/doc/\nSDF 提示信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ notes -r Welcome to the SDF Public Access UNIX system. (est. 1987) For quick help, type \u0026#39;help\u0026#39; For detailed questions and answers, type \u0026#39;faq\u0026#39; For user discussion boards, type \u0026#39;bboard\u0026#39; For interactive discussions, type \u0026#39;com\u0026#39; For adding yourself to the SDF User Map, see http://sdf1.org/map To setup your homepage, type \u0026#39;mkhomepg\u0026#39; To create your URL http://qq182sdf.freeshell.org, type \u0026#39;addlink\u0026#39; Classroom Student programs are located in /sys/classroom Explore and Enjoy! [1:2] (P)ROCEED, (D)ELETE, (C)ATCH UP, (R)ESPOND or (Q)UIT: PROCEED 参考链接 永久免费的公共UNIX服务器\n使用\u0026#34;Segfault\u0026#34;免费VPS教程 注册VPS 新注册一个 VPS，官方会给新注册的 VPS 分配 SECRET，把官方分配的 SECRET 保存好，每个人的 SECRET 都不一样，使用 SSH 连接的时候需要用到，不同的 SECRET 使用 SSH 连接 VPS 的时候可以避免冲突，使用 SECRET 通过 SSH 连接 VPS 的时候需要输入密码，密码都是 segfault\n点击\u0026#34;Remote Desktop\u0026#34; 点击\u0026#34;I\u0026#39;m New Here\u0026#34;，以新用户身份注册VPS 保存官方分配的 SECRET\u0026#34; 我的 SECRET 是 adm-W7NHhPqWvpNKPTcpEgkez4P2\n把 SECRET 保存好后点击 Continue 进行下一步进入网页终端环境中 如果光标没有进入终端环境中，可以按一下 Tab 键切入到终端环境中\n进入终端环境中后根据提示进行操作，然后真正进入终端环境 终端打印了 SSH 的配置信息，其中包含了 SSH 连接命令，SSH 连接命令中 SECRET 的值就是我们刚注册时官方提示要我们保存的密钥值，在本地终端 SSH 连接远程 VPS 时一个一个敲密钥值太过麻烦，直接将之前保存的密钥值粘贴一下即可，还有一个是主机名，也是新注册 VPS 时官方分配的，例如我的是 adm.segfault.net\n例如我的是：ssh -o \u0026#34;SetEnv SECRET=adm-W7NHhPqWvpNKPTcpEgkez4P2\u0026#34; root@adm.segfault.net\n终端中 SSH 连接命令中有一个反斜杠 \\，那是因为终端中是分现行显示的，我们在用的时候把反斜杠去掉输入一行命令即可\n本地SSH连接远程VPS 新注册 VPS 的 SSH 连接密码都是segfault\nVNC教程 VNC 客户端下载链接：https://www.realvnc.com/en/connect/download/viewer/windows/\n第一步，运行VNC服务 运行VNC服务后提示输入并验证密码，密码 segfault，然后VNC服务询问是否设置 view-only 密码，我输入的是 n 表示不设置\n1 vncserver 第二步，启动VNC 启动VNC后提示了需要在本地终端运行\u0026#34;ssh -L5900:0:5900 -o \u0026#39;SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2\u0026#39; root@adm.segfault.net\u0026#34;，作用是通过 SSH 隧道将本地端口 5900 映射到远程主机 adm.segfault.net 的端口 5900。通过这种方式，用户可以使用 VNC 客户端通过 SSH 连接到远程 VNC 图形界面\n1 startxvnc 第三步，本地运行\u0026#34;ssh -L5900:0:5900 -o \u0026#39;SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2\u0026#39; root@adm.segfault.net\u0026#34;进行隧道端口转发 第四步，VNC客户端连接访问 172.0.0.1:5900 成功通过 VNC 连接到远程 VPS，不过效果一般，还不如用命令行\nSegfault 提示信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ┌──(root💀adm-RecipeKit)-[~] └─# info :Cut \u0026amp; Paste these lines to your workstation\u0026#39;s shell to retain access: ###################################################################### cat \u0026gt;~/.ssh/id_sf-adm-segfault-net \u0026lt;\u0026lt;\u0026#39;__EOF__\u0026#39; -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW QyNTUxOQAAACBJFPbVdK92w4fHGb7vaG2c7XhlRTdZErUPW3Ag7lqVJAAAAIjxT/9z8U// cwAAAAtzc2gtZWQyNTUxOQAAACBJFPbVdK92w4fHGb7vaG2c7XhlRTdZErUPW3Ag7lqVJA AAAEA9D69K0YYMDbh6ZcWfmcZ1CdYk6Yryx28zc5ira9opkEkU9tV0r3bDh8cZvu9obZzt eGVFN1kStQ9bcCDuWpUkAAAAAAECAwQF -----END OPENSSH PRIVATE KEY----- __EOF__ cat \u0026gt;\u0026gt;~/.ssh/config \u0026lt;\u0026lt;\u0026#39;__EOF__\u0026#39; host recipekit User root HostName adm.segfault.net IdentityFile ~/.ssh/id_sf-adm-segfault-net SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2 __EOF__ chmod 600 ~/.ssh/config ~/.ssh/id_sf-adm-segfault-net ###################################################################### Thereafter use these commands: --\u0026gt; ssh recipekit --\u0026gt; sftp recipekit --\u0026gt; scp recipekit:stuff.tar.gz ~/ --\u0026gt; sshfs -o reconnect recipekit:/sec ~/sec ---------------------------------------------------------------------- Token : No See https://thc.org/segfault/token Your workstation : xxx.xxx.xxx.xxx (xxx) Reverse Port : Type curl sf/port for reverse port. Exit CryptoStorm : 128.127.104.110 (Sweden) Exit Mullvad : 185.77.218.15 (Helsinki/Finland) Exit NordVPN : 185.255.128.233 (Zurich/Switzerland) TOR Proxy : 172.20.0.111:9050 Shared storage : /everyone/RecipeKit (encrypted) Your storage : /sec (encrypted) Your Onion WWW : /onion (encrypted) Your Web Page : http://2xyr7jug4b5uhndzelsf7vgrxygttutc6h5mqzpwp7y6blk6owhxliqd.onion/recipekit/ SSH : ssh -o \u0026#34;SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2\u0026#34; \\ root@adm.segfault.net SSH (TOR) : torsocks ssh -o \u0026#34;SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2\u0026#34; \\ root@w5wc42fbltkdxpycsurj4zwxouhb3es3t2334lyte6euewrebjx4ryid.onion SSH (gsocket) : gsocket -s NGExNzFhNMYm ssh -o \u0026#34;SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2\u0026#34; \\ root@adm.segfault.gsocket SECRET : W7NHhPqWvpNKPTcpEgkez4P2 startfb 教程 使用下面所示的端口转发登录，密码还是 segfault，登录后在vps终端键入 startfb，保持登录状态，然后将浏览器指向 http://127.0.0.1:2900\n不要退出终端，不然本地无法访问 http://127.0.0.1:2900\n1 2 3 ssh -L2900:0:2900 -o \u0026#39;SetEnv SECRET=W7NHhPqWvpNKPTcpEgkez4P2\u0026#39; root@adm.segfault.net startfb 然后在本地访问如下链接\n1 http://127.0.0.1:2900 进入如下页面\n本地浏览器访问 VPS 的文件浏览器界面默认显示的是 VPS 根目录下的内容，而终端登录进 VPS 默认是在家目录下，在 VPS 的文件浏览器中要进入家目录下需要双击进入 sec/root\n参考链接 https://www.thc.org/segfault/\nhttps://www.thc.org/segfault/gui/\nSSH 注意事项 首先无论是付费 vps 还是免费 vps，如果需要自己配置 ssh 连接的话一定要注意配置文件里除了默认允许密码登录授权的配置以外还要确认并配置允许 ssh 公钥登录授权，如果 vps 配置这两项都是 yes，那就不需要更改了，其他配置根据自己的需要进行修改\nlinux 下 ssh 配置文件路径：/etc/ssh/sshd_config\n1 2 PasswordAuthentication yes\t# 允许通过密码进行 ssh 连接 PubkeyAuthentication yes # 允许通过 ssh 公钥进行 ssh 连接 然后改动 ssh 的配置后要重新启动 ssh 服务\n1 /etc/init.d/ssh restart ","date":"2024-07-16T21:07:26+08:00","permalink":"https://ynhugo.github.io/p/vps%E7%9B%B8%E5%85%B3/","title":"VPS相关"},{"content":" 巨掉秤7天减脂食谱 早餐 午餐 晚餐 参考链接 巨掉秤7天减脂食谱\n","date":"2024-07-16T21:01:14.93+08:00","permalink":"https://ynhugo.github.io/p/eat/","title":"eat"},{"content":" 实例 实例-1-车小猿 适用于Ubuntu与Cygwin\n发送端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define GROUP_IP \u0026#34;224.0.1.0\u0026#34; //#define GROUP_IP \u0026#34;239.0.1.10\u0026#34; int main() { // 1. 创建通信的套接字 int fd = socket(AF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\u0026#34;socket\u0026#34;); exit(0); } // 2. 设置组播属性 (经测试可以不设置发送端组播属性也能正常发送) struct in_addr opt; // 将组播地址初始化到这个结构体成员中即可 inet_pton(AF_INET, GROUP_IP, \u0026amp;opt.s_addr); setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, \u0026amp;opt, sizeof(opt)); char buf[1024]; char sendaddrbuf[64]; socklen_t len = sizeof(struct sockaddr_in); struct sockaddr_in sendaddr; struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); // 接收端需要绑定9999端口 // 发送组播消息, 需要使用组播地址, 和设置组播属性使用的组播地址一致就可以 inet_pton(AF_INET, GROUP_IP, \u0026amp;cliaddr.sin_addr.s_addr); // 3. 通信 int num = 0; while(1) { memset(buf, 0, sizeof(buf)); sprintf(buf, \u0026#34;hello, client...%d\\n\u0026#34;, num++); // 数据广播 sendto(fd, buf, strlen(buf)+1, 0, (struct sockaddr*)\u0026amp;cliaddr, len); printf(\u0026#34;发送的组播的数据: %s\\n\u0026#34;, buf); memset(buf, 0, sizeof(buf)); recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr *)\u0026amp;sendaddr, \u0026amp;len); printf(\u0026#34;sendaddr:%s, prot:%d\\n\u0026#34;, inet_ntop(AF_INET, \u0026amp;sendaddr.sin_addr.s_addr, sendaddrbuf, sizeof(sendaddrbuf)), sendaddr.sin_port); printf(\u0026#34;接收到的组播消息: %s\\n\u0026#34;, buf); } close(fd); return 0; } 接收端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define GROUP_IP \u0026#34;224.0.1.0\u0026#34; //#define GROUP_IP \u0026#34;239.0.1.10\u0026#34; int main() { // 1. 创建通信的套接字 int fd = socket(AF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\u0026#34;socket\u0026#34;); exit(0); } // 2. 通信的套接字和本地的IP与端口绑定 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); // 大端 addr.sin_addr.s_addr = htonl(INADDR_ANY); // 0.0.0.0 int ret = bind(fd, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); if(ret == -1) { perror(\u0026#34;bind\u0026#34;); exit(0); } // 3. 加入到多播组 #if 0 //使用struct ip_mreqn或者 struct ip_mreq 设置接收端组播属性都可以正常接收 struct ip_mreqn opt; // 要加入到哪个多播组, 通过组播地址来区分 inet_pton(AF_INET, GROUP_IP, \u0026amp;opt.imr_multiaddr.s_addr); opt.imr_address.s_addr = htonl(INADDR_ANY); opt.imr_ifindex = if_nametoindex(\u0026#34;ens33\u0026#34;); setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, \u0026amp;opt, sizeof(opt)); #else struct ip_mreq mreq; // 多播地址结构体 mreq.imr_multiaddr.s_addr=inet_addr(GROUP_IP); mreq.imr_interface.s_addr = htonl(INADDR_ANY);\tret=setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,\u0026amp;mreq,sizeof(mreq)); #endif char buf[1024]; char sendaddrbuf[64]; socklen_t len = sizeof(struct sockaddr_in); struct sockaddr_in sendaddr; // 3. 通信 while(1) { // 接收广播消息 memset(buf, 0, sizeof(buf)); // 阻塞等待数据达到 recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr *)\u0026amp;sendaddr, \u0026amp;len); printf(\u0026#34;sendaddr:%s, prot:%d\\n\u0026#34;, inet_ntop(AF_INET, \u0026amp;sendaddr.sin_addr.s_addr, sendaddrbuf, sizeof(sendaddrbuf)), sendaddr.sin_port); printf(\u0026#34;接收到的组播消息: %s\\n\u0026#34;, buf); sendto(fd, buf, strlen(buf)+1, 0, (struct sockaddr *)\u0026amp;sendaddr, len); } close(fd); return 0; } 编译方式 1 2 make send make recv 运行方式 先运行接收端，再运行发送端\n接收端 1 ./recv 发送端 1 ./send 实例-2-苏丙榅 适用于Ubuntu\n发送端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { // 1. 创建通信的套接字 int fd = socket(AF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\u0026#34;socket\u0026#34;); exit(0); } // 2. 设置组播属性 struct in_addr opt; // 将组播地址初始化到这个结构体成员中即可 inet_pton(AF_INET, \u0026#34;239.0.1.10\u0026#34;, \u0026amp;opt.s_addr); setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, \u0026amp;opt, sizeof(opt)); char buf[1024]; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); // 接收端需要绑定9999端口 // 发送组播消息, 需要使用组播地址, 和设置组播属性使用的组播地址一致就可以 inet_pton(AF_INET, \u0026#34;239.0.1.10\u0026#34;, \u0026amp;cliaddr.sin_addr.s_addr); // 3. 通信 int num = 0; while(1) { sprintf(buf, \u0026#34;hello, client...%d\\n\u0026#34;, num++); // 数据广播 sendto(fd, buf, strlen(buf)+1, 0, (struct sockaddr*)\u0026amp;cliaddr, len); printf(\u0026#34;发送的组播的数据: %s\\n\u0026#34;, buf); sleep(1); } close(fd); return 0; } 接收端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; int main() { // 1. 创建通信的套接字 int fd = socket(AF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\u0026#34;socket\u0026#34;); exit(0); } // 2. 通信的套接字和本地的IP与端口绑定 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); // 大端 addr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0 int ret = bind(fd, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); if(ret == -1) { perror(\u0026#34;bind\u0026#34;); exit(0); } // 3. 加入到多播组 struct ip_mreqn opt; // 要加入到哪个多播组, 通过组播地址来区分 inet_pton(AF_INET, \u0026#34;239.0.1.10\u0026#34;, \u0026amp;opt.imr_multiaddr.s_addr); opt.imr_address.s_addr = INADDR_ANY; opt.imr_ifindex = if_nametoindex(\u0026#34;ens33\u0026#34;); setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, \u0026amp;opt, sizeof(opt)); char buf[1024]; // 3. 通信 while(1) { // 接收广播消息 memset(buf, 0, sizeof(buf)); // 阻塞等待数据达到 recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(\u0026#34;接收到的组播消息: %s\\n\u0026#34;, buf); } close(fd); return 0; } 编译方式 1 2 make send make recv 运行方式 先运行接收端，再运行发送端\n接收端 1 ./recv 发送端 1 ./send 查看Linux系统是否支持多播： 方法A ifconfig出现 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric\n方法B 查看/boot/config-x.x.xx 文件中是否有如下内容\n1 2 3 CONFIG_IP_MULTICAST=y CONFIG_NET_IPIP=m CONFIG_IP_MROUTE=y 参考链接 socket之UDP组播（多播）\nUDP特性之组播（多播）\nlinux启用IPV4组播路由转发的配置和测试\n","date":"2024-07-15T13:42:34+08:00","permalink":"https://ynhugo.github.io/p/udp%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%84%E6%92%AD%E5%A4%9A%E6%92%AD/","title":"UDP特性之组播（多播）"},{"content":" 在家目录下的.profile文件中添加如下代码\n1 export LANG=zh_CN.UTF-8 .profile是POSIX SH的，SHELL应该都支持，所以将设置中文的代码放在.profile文件中是有效的\n","date":"2024-06-18T11:09:56.69+08:00","permalink":"https://ynhugo.github.io/p/sdf%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87/","title":"SDF设置中文"},{"content":" 定制按键 1 2 3 4 5 6 extra-keys = [\\ [\u0026#39;ESC\u0026#39;,\u0026#39;!\u0026#39;,\u0026#39;@\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;%\u0026#39;,\u0026#39;^\u0026#39;,\u0026#39;\u0026amp;\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;()\u0026#39;,\u0026#39;BACKSLASH\u0026#39;,\u0026#39;DEL\u0026#39;],\\ [\u0026#39;PGUP\u0026#39;,\u0026#39;PGDN\u0026#39;,\u0026#39;{}\u0026#39;,\u0026#39;\u0026lt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;[]\u0026#39;,\u0026#39;:\u0026#39;,\u0026#39;/\u0026#39;,\u0026#39;\u0026#34;\u0026#39;,\u0026#39;PGDN\u0026#39;,\u0026#39;PGUP\u0026#39;],\\ [\u0026#39;SHIFT\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;-\u0026#39;,\u0026#34;\u0026#39;\u0026#34;,\u0026#39;$\u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;,\u0026#39;,\u0026#39;HOME\u0026#39;,\u0026#39;UP\u0026#39;,\u0026#39;END\u0026#39;,\u0026#39;BKSP\u0026#39;],\\ [\u0026#39;CTRL\u0026#39;,\u0026#39;ALT\u0026#39;,\u0026#39;TAB\u0026#39;,\u0026#39;`\u0026#39;,\u0026#39;~\u0026#39;,\u0026#39;|\u0026#39;,\u0026#39;;\u0026#39;,\u0026#39;LEFT\u0026#39;,\u0026#39;DOWN\u0026#39;,\u0026#39;RIGHT\u0026#39;,\u0026#39;ENTER\u0026#39;]\\ ] ","date":"2024-05-16T11:19:30+08:00","permalink":"https://ynhugo.github.io/p/termux%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"termux快捷键"},{"content":" 同事的主机系统引导不起来了，使用大白菜和优启通重装系统都失败，重装系统的方式是一键装机时只对C盘进行操作，不需要对C盘所在的物理硬盘上的其他盘或者其他物理硬盘进行操作，只对C盘进行操作，可以C盘进行格式化，物理硬盘上的其他盘像D盘、E盘、F盘等等不能动，因为要保留数据，最后同事去电脑维修店被店老板用老毛桃以同样的方式重装成功了，考虑以后把老毛桃作为最优选，其次是优启通，再其次是大白菜。\n","date":"2024-05-08T20:40:00+08:00","permalink":"https://ynhugo.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1win7%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8D/","title":"记录一次win7系统修复"},{"content":" scrcpy scrcpy入门 官方主页 https://github.com/Genymobile/scrcpy\n下载链接 根据电脑系统环境进行选择下载\nhttps://github.com/Genymobile/scrcpy/releases/latest\n连接方式 首先，启用手机的开发者模式，接着在开发者模式找到并打开手机的usb调试模式，然后使用usb数据线连接电脑与手机，在电脑上准备好scrcpy并添加scrcpy到环境变量，先使用adb查看是否有设备，然后在电脑终端中通过adb命令设置tcpip端口和连接的ip，电脑与手机保持在同一局域网，手机ip可以通过wifi(如果是手机开热点，可以通过热点查看ip)或者手机安装termux进行查看，再接着使用adb命令列出设备列表，使用scrcpy的-s选项选择要启动的设备即可，具体操作命令如下：\n1 2 3 4 adb devices\t# 连接usb数据线后查看是否有设备 adb tcpip 5555\t# 在有设备的情况下设置端口，事实上这里似乎也可以不设置，那么可以尝试跳过这一步 adb connect 192.168.*.*:5555\t# 设置连接方式 scrcpy -s 192.168.*.*:5555\t# 使用scrcpy进行连接 无线投屏 在第一次进行过有线连接后，第二次就可以拔掉数据线进行连接了\n安卓端录屏工具scrcpy 1 scrcpy --record file.mp4 #file.mp4 是自己设置的文件名和对应的格式 scrcpy不传输声音，并且当scrcpy连接到设备时使设备黑屏，只显示scrcpy画面 该操作适用于蓝牙耳机连接手机，然后scrcpy投屏设备的场景\n1 scrcpy --no-audio -S scrcpy指定窗口位置和大小 1 scrcpy -s 192.168.*.*:5555 --window-x 1920 --window-y 0 --window-height 1080 如果要指定宽度可以增加选项：–window-width 100\n通过脚本连接 ssh_host是ssh配置文件中的host，也可以改为user@hostname的形式，需要结合termux使用\n1 2 3 4 5 6 7 echo \u0026#34;adb shell input keyevent 82; adb shell input keyevent 82; sleep 0.4; adb shell input text password \u0026amp;\u0026amp; clear\u0026#34; echo \u0026#34;adb shell input keyevent 224; adb shell input keyevent 82;\u0026#34; adb kill-server adb start-server ssh_host=\u0026#34;rog8\u0026#34;; mapfile -t ip_array \u0026lt; \u0026lt;(ssh $ssh_host ifconfig | grep -oE \u0026#34;inet ?192.168.[0-9]{0,3}.[0-9]{0,3}\u0026#34; | awk \u0026#39;{print $2}\u0026#39;); adb connect \u0026#34;${ip_array[0]}\u0026#34; scrcpy -s $(adb devices | grep -Ew \u0026#34;.*device\u0026#34; | awk \u0026#39;{$2=\u0026#34;\u0026#34;; print}\u0026#39; | head -n 1) -S 通过脚本解锁手机并连接-1 1 adb shell input keyevent 82; adb shell input keyevent 82; sleep 0.4; adb shell input text password \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; scrcpy --no-audio -S \u0026amp; 通过脚本解锁手机并连接-2 脚本名称：auto_android_scrcpy.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 IPV4:Port\u0026#34; elif [ \u0026#34;${num_args}\u0026#34; -eq 1 ]; then adb connect $1; scrcpy -s $1 --no-audio -S \u0026amp; elif [ \u0026#34;$2\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$2\u0026#34; = \u0026#34;rescrcpy\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; scrcpy -s $1 --no-audio -S \u0026amp;\u0026amp; clear \u0026amp; fi fi 通过脚本解锁手机并连接-3 该脚本使用的前提条件是两个显示器，因为指定坐标是x=1920,y=1038。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 num_args=$# # 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 IPV4:Port\u0026#34; elif [ \u0026#34;${num_args}\u0026#34; -eq 1 ]; then adb connect $1; # scrcpy -s $1 --no-audio -S \u0026amp; scrcpy -s $1 --no-audio --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; elif [ \u0026#34;$2\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$2\u0026#34; = \u0026#34;rescrcpy\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; scrcpy -s $1 --no-audio -S \u0026amp;\u0026amp; clear \u0026amp; fi fi 通过脚本解锁手机并连接-4 基于\u0026#34;通过脚本解锁手机并连接-3\u0026#34;，优化解锁，添加了解锁前连接adb的命令，使解决可以单独使用，添加了锁命令，使手机没有通过scrcpy远程控制时也可以通过脚本对手机进行锁屏操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 IPV4:Port\u0026#34; elif [ \u0026#34;${num_args}\u0026#34; -eq 1 ]; then adb connect $1; # scrcpy -s $1 --no-audio -S \u0026amp; scrcpy -s $1 --no-audio --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; elif [ \u0026#34;$2\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb connect $1; adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$2\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb connect $1; adb -s $1 shell input keyevent 26 elif [ \u0026#34;$2\u0026#34; = \u0026#34;rescrcpy\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; scrcpy -s $1 --no-audio -S \u0026amp;\u0026amp; clear \u0026amp; fi fi 通过脚本解锁手机并连接-5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 IPV4:Port\u0026#34; elif [ \u0026#34;${num_args}\u0026#34; -eq 1 ]; then adb connect $1; # scrcpy -s $1 --no-audio -S \u0026amp; scrcpy -s $1 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; elif [ \u0026#34;$2\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$3\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock password\u0026#34; else adb connect $1; adb -s $1 shell input keyevent 82; adb -s $1 shell input keyevent 82; sleep 0.4; adb -s $1 shell input text $3 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$2\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb connect $1; adb -s $1 shell input keyevent 26 fi 通过脚本解锁手机并连接-6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 usb/net IPV4:Port\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; # scrcpy -s $2 --no-audio -S \u0026amp; scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; elif [ \u0026#34;$1\u0026#34; = \u0026#34;usb\u0026#34; ]; then scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; fi if [ \u0026#34;$3\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; fi if [ \u0026#34;$4\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 usb/net device unlock password\u0026#34; else adb -s $2 shell input keyevent 82; adb -s $2 shell input keyevent 82; sleep 0.4; adb -s $2 shell input text $4 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$3\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s $2 shell input keyevent 26 fi 参考链接 scrcpy无法输入中文问题解决\n通过脚本解锁手机并连接-7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 usb/net IPV4:Port\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; # scrcpy -s $2 --no-audio -S \u0026amp; scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; elif [ \u0026#34;$1\u0026#34; = \u0026#34;usb\u0026#34; ]; then scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; fi if [ \u0026#34;$3\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; fi if [ \u0026#34;$4\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 usb/net device unlock passward\u0026#34; else adb -s $2 shell input keyevent 82; adb -s $2 shell input keyevent 82; sleep 0.4; adb -s $2 shell input text $4 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$3\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s $2 shell input keyevent 26 fi if [ \u0026#34;$1\u0026#34; = \u0026#34;lock\u0026#34; ] || [ \u0026#34;$1\u0026#34; = \u0026#34;unlock\u0026#34; ]; then device=$(adb devices | grep -w \u0026#34;device\u0026#34; | awk \u0026#39;NR==1{print $1}\u0026#39;); if [ \u0026#34;$1\u0026#34; = \u0026#34;unlock\u0026#34; ]; then\tif [ \u0026#34;$2\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock passward\u0026#34; else adb -s ${device} shell input keyevent 82; adb -s ${device} shell input keyevent 82; sleep 0.4; adb -s ${device} shell input text $2 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$1\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s ${device} shell input keyevent 26 fi fi 通过脚本解锁手机并连接-8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 usb/net IPV4:Port\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; # scrcpy -s $2 --no-audio -S \u0026amp; scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; elif [ \u0026#34;$1\u0026#34; = \u0026#34;usb\u0026#34; ]; then scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 --window-y 0 --window-height 1038 -S \u0026amp; fi if [ \u0026#34;$3\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; fi if [ \u0026#34;$4\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 usb/net deviceid unlock passward\u0026#34; else adb -s $2 shell input keyevent 82; adb -s $2 shell input keyevent 82; sleep 0.4; adb -s $2 shell input text $4 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$3\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s $2 shell input keyevent 26 fi if [ \u0026#34;$1\u0026#34; = \u0026#34;lock\u0026#34; ] || [ \u0026#34;$1\u0026#34; = \u0026#34;unlock\u0026#34; ]; then device=$(adb devices | grep -w \u0026#34;device\u0026#34; | awk \u0026#39;NR==1{print $1}\u0026#39;); if [ \u0026#34;$1\u0026#34; = \u0026#34;unlock\u0026#34; ]; then\tif [ \u0026#34;$2\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock passward\u0026#34; else adb -s ${device} shell input keyevent 82; adb -s ${device} shell input keyevent 82; sleep 0.4; adb -s ${device} shell input text $2 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$1\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s ${device} shell input keyevent 26 fi fi if [ \u0026#34;$1\u0026#34; = \u0026#34;example\u0026#34; ]; then echo \u0026#34;bash $0 usb \\$(adb devices | grep -w \\\u0026#34;device\\\u0026#34; | awk \u0026#39;NR==1{print \\$1}\u0026#39;) unlock \\$passwd\u0026#34; fi 通过脚本解锁手机并连接-9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 num_args=$#\t# 获取参数数量 if [ \u0026#34;${num_args}\u0026#34; -eq 0 ]; then echo -e \u0026#34;Usage: \\n$0 usb/net IPV4:Port\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; # scrcpy -s $2 --no-audio -S \u0026amp; scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 -S \u0026amp; elif [ \u0026#34;$1\u0026#34; = \u0026#34;usb\u0026#34; ]; then scrcpy -s $2 --no-audio --keyboard=uhid --window-x 1920 -S \u0026amp; fi if [ \u0026#34;$3\u0026#34; = \u0026#34;unlock\u0026#34; ]; then if [ \u0026#34;$1\u0026#34; = \u0026#34;net\u0026#34; ]; then adb connect $2; fi if [ \u0026#34;$4\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 usb/net deviceid unlock passward\u0026#34; else adb -s $2 shell input keyevent 82; adb -s $2 shell input keyevent 82; sleep 0.4; adb -s $2 shell input text $4 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$3\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s $2 shell input keyevent 26 fi if [ \u0026#34;$1\u0026#34; = \u0026#34;lock\u0026#34; ] || [ \u0026#34;$1\u0026#34; = \u0026#34;unlock\u0026#34; ]; then device=$(adb devices | grep -w \u0026#34;device\u0026#34; | awk \u0026#39;NR==1{print $1}\u0026#39;); if [ \u0026#34;$1\u0026#34; = \u0026#34;unlock\u0026#34; ]; then\tif [ \u0026#34;$2\u0026#34; = \u0026#34;\u0026#34; ]; then echo -e \u0026#34;Usage: \\n$0 unlock passward\u0026#34; else adb -s ${device} shell input keyevent 82; adb -s ${device} shell input keyevent 82; sleep 0.4; adb -s ${device} shell input text $2 \u0026amp;\u0026amp; clear fi elif [ \u0026#34;$1\u0026#34; = \u0026#34;lock\u0026#34; ]; then adb -s ${device} shell input keyevent 26 fi fi if [ \u0026#34;$1\u0026#34; = \u0026#34;example\u0026#34; ]; then echo \u0026#34;bash $0 usb \\$(adb devices | grep -w \\\u0026#34;device\\\u0026#34; | awk \u0026#39;NR==1{print \\$1}\u0026#39;) unlock \\$passwd\u0026#34; fi 注意事项 scrcpy建议使用最新版本，如果手机的安卓版本较高，而scrcpy的版本又较老的话，会出现一些快捷键用不了的情况，而最新版本的scrcpy则会好很多，一般快捷键都支持\n参考链接 scrcpy - 手机无线投屏到电脑\nscrcpy使用教程\nScrcpy – 通过Linux桌面显示和控制Android 设备\nScrCpy工具的快捷键\nscrcpy投屏教程、scrcpy无线投屏、scrcpy命令大全\n异地组网——5 分钟，使用内网穿透快速实现远程手机桌面！ 准备 PC 安装 Scrcpy 控制器 Scrpy 控制器是一款免 Root 的开源安卓设备投屏工具，支持 USB 和 WIFI 两种连接方式\n它适用于 Linux、Mac OS、Windows\n根据系统类型，通过下面链接选择合适的方式进行安装\nPS：以 Windows 为例，我们只需要下载 Zip 压缩包，然后将文件夹目录添加到 PATH 环境变量中\nhttps://github.com/Genymobile/scrcpy#summary\n配置教程参考，将scrcpy按照参考教程中adb的配置方式进行配置：\nhttps://sspai.com/post/40471\nPC 和 Android 设备分别安装网穿透工具 这里以蒲公英为例，到官网选择「 蒲公英-个人版 」进行下载\n下载地址：\nhttps://pgy.oray.com/download/personal/#visitor\n首先，保证 PC 与 Android 设备在同一局域网，这里的局域网是指通过数据线将PC与手机连接在一起\n然后，在 PC 端完成注册登录\n最后，在 Android 设备上以同一个账号进行登录\n实操一下 Android 设备开启网络调试并连接 首先，在 Android 设备中开启「 开发者选项 」，并打开「 USB 调试 」\n不同手机开启「 开发者选项 」的方式不一样，大家可以自行搜索，另外 MIUI 需要另外开启「 USB 调试（安全设置） 」\n然后，Android 设备通过数据线连接 PC，使用 adb 命令开启手机的网络调试\nPS：这里指定网络连接的端口号为 5555\n查询连接的设备列表 1 2 3 C:\\Users\\xingag\u0026gt;adb devices List of devices attached 0e279f0d7d33 device 开启手机的网络调试，端口为5555 1 2 C:\\Users\\xingag\u0026gt;adb tcpip 5555 restarting in TCP mode port: 5555 接着，断开数据线连接，在蒲公英 PC 客户端上查看 Android 设备的 IP 地址，通过「 该 IP 地址 + 端口号 」连接手机设备\n比如：PC版本蒲公英显示手机的ip地址为：172.11.1.233 1 adb connect 172.11.1.233:5555 使用adb命令连接设备 1 2 C:\\Users\\xingag\u0026gt;adb connect 172.11.1.233:5555 connected to 172.11.1.233:5555 最后，可以通过一些简单的 adb 命令测试一下是否能控制手机\n比如：修改屏幕的大小 1 adb shell wm size 1000x1000 恢复原来屏幕尺寸 1 adb shell wm size reset 休眠或者解锁屏幕 1 adb shell input keyevent 26 局域网屏幕控制 在 CMD 命令行，使用「 scrcpy.exe 」命令就可以将手机投屏在 PC 上了，如此就能在 PC 端完成对手机的完全控制了\nscrcpy 功能非常地强大，可以通过一些参数命令设置屏幕控制的特性\n比如，通过 -S 设置投屏的同时关闭设备屏幕，也可以通过 -b、-m 改变比特率、限制分辨率，提高屏幕控制的响应速度\n直接将手机界面投屏到PC上，通过PC可以控制手机界面 1 scrcpy.exe 投屏的同时，关闭设备屏幕 1 scrcpy.exe -S 通过改变比特率和限制分辨率，提高响应速度 -b 2M:改变比特率为2M，减少延迟，默认码率为8M，码率越高，画质越好，但是同时延迟越大 -m 1024：限制分辨率提供响应性能，分辨率越高，延迟越大 –max-fps：限制帧率，提升响应速度 1 scrcpy -b 2M -m 1024 --max-fps 15 远程屏幕控制 上面的操作都是在同一局域网下完成的 PC 端对 Android 设备的屏幕控制\n事实上，只要保证 Android 设备上的蒲公英 App 一直在线，PC 即使在外网环境下，开启 PC 版本的蒲公英，也能远程控制之前配置好的 Android 设备\n如此，就完成了远程控制 Android 设备屏幕的需求了 参考链接 5 分钟，使用内网穿透快速实现远程手机桌面！\n解锁手机 1 adb shell input text password\t# 输入密码 测试 手机密码：123456\n1 adb shell input keyevent 82; adb shell input keyevent 82; sleep 0.4; adb shell input text 123456; sleep 2; adb shell input keyevent 26 #输入密码解锁后延时2秒，然后再锁屏 解锁手机：adb shell input keyevent 82\n延时0.4秒：sleep 0.4\n输入密码：adb shell input text 123456\n锁屏：adb shell input keyevent 26\n实操命令 1 adb shell input keyevent 82; adb shell input keyevent 82; sleep 0.4; adb shell input text 123456 # 实操命令为去掉前边测试命令中的解锁后延时2秒再锁屏的过程 参考链接 利用 ADB 解锁手机指引\nadb shell input keyevent (具体操作) – 模拟按键事件 KeyCode\n常用 adb 指令\nadb 命令模拟按键事件 KeyCode\n华为手机有线连接 adb\n华为手机无线连接 adb\nADB Android Device Unauthorized\n自动化测试: adb 解锁手机的思路\n如何用bash脚本创建screen并向其发送命令？ 1 screen -dmS test 1 2 3 4 screen -dmS test screen -S test -X stuff \u0026#34;ls -a\\n\u0026#34; 或 screen -S test -p 0 -X stuff \u0026#34;ls -a\\n\u0026#34; 解析命令-ChatGPT 这些命令是使用 screen 进行会话管理和自动化输入的示例。我们来逐个解析：\n1. screen -dmS test 各部分解析： screen：启动 screen 会话，screen 是一个终端多路复用器，允许在一个终端窗口内运行多个虚拟终端。 -d：这个选项告诉 screen 在后台启动会话。也就是说，screen 会话启动后不会占用当前的终端窗口，而是将其放在后台运行。 -m：强制启动一个新的会话，即使没有其他正在运行的 screen 会话。 -S test：指定会话的名称为 test。-S 选项后面的 test 是会话的标识符，通过这个名字，你可以后续对该会话进行操作（例如发送命令、分离等）。 作用： 这个命令的作用是：启动一个名为 test 的 screen 会话，并将其放在后台运行。此时会话没有关联到任何窗口（终端）。它是一个“分离模式”启动的 screen 会话。\n—\n2. screen -S test -X stuff \u0026#34;ls -a\\n\u0026#34; 各部分解析： screen：再次调用 screen，用于对已存在的 screen 会话进行操作。 -S test：指定要操作的会话名称为 test。 -X：执行对 screen 会话的命令。-X 选项让我们向 screen 会话发送命令。 stuff \u0026#34;ls -a\\n\u0026#34;：stuff 命令将 ls -a（列出当前目录的所有文件，包括隐藏文件）发送到指定会话的当前窗口中，并模拟按下回车键（\\n）。这等同于在该会话的终端中执行了 ls -a 命令。 作用： 该命令将 ls -a 这个命令发送到名为 test 的 screen 会话中的当前窗口，模拟在该窗口执行 ls -a。由于是后台操作，所以并不会直接在终端显示输出，命令的结果会被发送到该 screen 会话的输出流。\n—\n3. screen -S test -p 0 -X stuff \u0026#34;ls -a\\n\u0026#34; 各部分解析： screen：同样，调用 screen 来操作会话。 -S test：指定会话名称为 test。 -p 0：指定窗口编号为 0，即第一个窗口。screen 会话可以包含多个窗口，这个命令告诉 screen 要向编号为 0 的窗口发送命令。 -X stuff \u0026#34;ls -a\\n\u0026#34;：将 ls -a 发送到指定窗口，并模拟按下回车键。 作用： 该命令将 ls -a 命令发送到名为 test 的 screen 会话中的第一个窗口（编号为 0），并模拟按下回车键。这意味着，如果会话已经包含多个窗口，这个命令只会作用于第一个窗口，而不会影响其他窗口。\n—\n总结 screen -dmS test：在后台启动一个新的 screen 会话，命名为 test。 screen -S test -X stuff \u0026#34;ls -a\\n\u0026#34;：向名为 test 的 screen 会话的当前窗口发送 ls -a 命令并执行。 screen -S test -p 0 -X stuff \u0026#34;ls -a\\n\u0026#34;：向名为 test 的 screen 会话的第一个窗口（编号为 0）发送 ls -a 命令并执行。 这些命令组合起来，可以实现对后台 screen 会话的自动化控制和命令发送，适用于需要在后台运行的程序和脚本的自动化管理。\n参考链接 用bash脚本创建screen并向其发送命令\n","date":"2024-04-21T16:45:23.3+08:00","permalink":"https://ynhugo.github.io/p/scrcpy%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"scrcpy使用教程"},{"content":" 使用方式 1 curl \u0026#34;http://translate.google.com/translate_a/single?client=gtx\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;dt=t\u0026amp;q=good\u0026#34; 使用示例 使用门槛，该api由谷歌提供，因此使用的话需要具备一定的上网条件\n1 2 3 ┌──(root💀adm-RecipeKit)-[~] └─# curl \u0026#34;http://translate.google.com/translate_a/single?client=gtx\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;dt=t\u0026amp;q=good\u0026#34; [[[\u0026#34;好的\u0026#34;,\u0026#34;good\u0026#34;,null,null,10]],null,\u0026#34;en\u0026#34;,null,null,null,null,[]] 翻译单词-脚本实现 1 curl \u0026#34;http://translate.google.com/translate_a/single?client=gtx\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;dt=t\u0026amp;q=$1\u0026#34; 使用示例 1 2 3 ┌──(root💀adm-RecipeKit)-[~] └─# ./translate.sh good [[[\u0026#34;好的\u0026#34;,\u0026#34;good\u0026#34;,null,null,10]],null,\u0026#34;en\u0026#34;,null,null,null,null,[]] 翻译句子-脚本实现-1 1 2 date=\u0026#34;$(echo \u0026#34;$1\u0026#34; | sed -e \u0026#39;s/ /%20/g\u0026#39;)\u0026#34; curl \u0026#34;http://translate.google.com/translate_a/single?client=gtx\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;dt=t\u0026amp;q=${date}\u0026#34; 使用示例 1 2 3 ┌──(root💀adm-RecipeKit)-[~] └─# ./translate.sh \u0026#34;HOW old are you?\u0026#34; [[[\u0026#34;你今年多大？\u0026#34;,\u0026#34;HOW old are you.\u0026#34;,null,null,10]],null,\u0026#34;en\u0026#34;,null,null,null,null,[]] 使用示例-VPS 1 2 3 4 $ ssh sdf \u0026#39;./translate.sh \u0026#34;How old are you?\u0026#34;\u0026#39; % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 91 0 91 0 0 1101 0 --:--:-- --:--:-[[[\u0026#34;你今年多大？\u0026#34;,\u0026#34;How old are you?\u0026#34;,null,null,10]],null,\u0026#34;en\u0026#34;,null,null,null,null,[]]- --:--:-- 1109 翻译句子-脚本实现-2 1 2 3 4 5 6 7 8 9 10 #!/usr/bin/bash args=\u0026#34;$#\u0026#34; for ((i = 1; i \u0026lt; args; i++)); do data+=\u0026#34;${!i}%20\u0026#34; done # echo \u0026#34;${data}${!#}\u0026#34; curl \u0026#34;http://translate.google.com/translate_a/single?client=gtx\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;dt=t\u0026amp;q=${data} 使用示例 1 2 3 ┌──(root💀adm-RecipeKit)-[~] └─# echo \u0026#34;How old are you?\u0026#34; | xargs ./translate.sh [[[\u0026#34;几岁了\u0026#34;,\u0026#34;How old are\u0026#34;,null,null,3,null,null,[[]],[[[\u0026#34;6ffafab0da7e640be86ac09d0d5e539c\u0026#34;,\u0026#34;en_zh_2023q1.md\u0026#34;]]]]],null,\u0026#34;en\u0026#34;,null,null,null,null,[]] 参考链接 Google 单词翻译 API.py\n","date":"2024-04-05T17:38:21.3+08:00","permalink":"https://ynhugo.github.io/p/%E8%B0%B7%E6%AD%8Capi%E7%BF%BB%E8%AF%91/","title":"谷歌api翻译"},{"content":" 用javascript写一个提取csdn正文的代码，并导入到剪切版或者弹出一个文本格式化的文本框用来保存内容方便复制，我要看到正文内容所在的文本框 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 提取CSDN博文的正文内容 function extractArticleContent() { // 查找文章内容所在的元素，通常在 class 为 \u0026#39;article_content\u0026#39; 的 div 中 var articleContentElement = document.querySelector(\u0026#39;.article_content\u0026#39;); if (articleContentElement) { // 获取文章内容 var articleContent = articleContentElement.innerText; // 创建文本框元素 var textBox = document.createElement(\u0026#39;textarea\u0026#39;); // 设置文本框的内容为文章内容 textBox.value = articleContent; // 设置文本框样式 textBox.style.width = \u0026#39;100%\u0026#39;; textBox.style.height = \u0026#39;300px\u0026#39;; textBox.style.resize = \u0026#39;none\u0026#39;; // 将文本框添加到页面中 document.body.appendChild(textBox); // 将文章内容复制到剪切板 copyToClipboard(articleContent); // 弹出提示框提示用户内容已经提取 alert(\u0026#39;文章内容已提取到文本框中，并已复制到剪切板，您可以复制保存。\u0026#39;); } else { alert(\u0026#39;未找到文章内容\u0026#39;); } } // 将内容复制到剪切板 function copyToClipboard(content) { // 创建临时文本框元素 var tempTextArea = document.createElement(\u0026#39;textarea\u0026#39;); // 将内容设置为临时文本框的值 tempTextArea.value = content; // 将临时文本框添加到页面中 document.body.appendChild(tempTextArea); // 选择临时文本框的内容 tempTextArea.select(); // 执行复制操作 document.execCommand(\u0026#39;copy\u0026#39;); // 移除临时文本框元素 document.body.removeChild(tempTextArea); } // 调用提取文章内容的函数 extractArticleContent(); 用javascript写一个提取csdn正文包括图片的代码，并导入到剪切版或者弹出一个文本格式化的文本框用来保存内容方便复制，我要看到正文内容所在的文本框 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 提取CSDN博文的正文内容，包括图片链接 function extractArticleContentWithImages() { // 查找文章内容所在的元素，通常在 class 为 \u0026#39;article_content\u0026#39; 的 div 中 var articleContentElement = document.querySelector(\u0026#39;.article_content\u0026#39;); if (articleContentElement) { // 获取文章内容 var articleContent = articleContentElement.innerHTML; // 创建文本框元素 var textBox = document.createElement(\u0026#39;textarea\u0026#39;); // 设置文本框的内容为文章内容 textBox.value = articleContent; // 设置文本框样式 textBox.style.width = \u0026#39;100%\u0026#39;; textBox.style.height = \u0026#39;300px\u0026#39;; textBox.style.resize = \u0026#39;none\u0026#39;; // 将文本框添加到页面中 document.body.appendChild(textBox); // 将文章内容复制到剪切板 copyToClipboard(articleContent); // 弹出提示框提示用户内容已经提取 alert(\u0026#39;文章内容已提取到文本框中，并已复制到剪切板，您可以复制保存。\u0026#39;); } else { alert(\u0026#39;未找到文章内容\u0026#39;); } } // 将内容复制到剪切板 function copyToClipboard(content) { // 创建临时文本框元素 var tempTextArea = document.createElement(\u0026#39;textarea\u0026#39;); // 将内容设置为临时文本框的值 tempTextArea.value = content; // 将临时文本框添加到页面中 document.body.appendChild(tempTextArea); // 选择临时文本框的内容 tempTextArea.select(); // 执行复制操作 document.execCommand(\u0026#39;copy\u0026#39;); // 移除临时文本框元素 document.body.removeChild(tempTextArea); } // 调用提取文章内容的函数 extractArticleContentWithImages(); 用javascript在浏览器地址栏实现文本框的话 1 javascript:prompt(\u0026#34;请输入文本：\u0026#34;) 浏览器开发者工具去掉网页中代码块的行号 依次执行以下代码\n1 var elements = document.querySelectorAll(\u0026#39;span.lnt\u0026#39;); 1 2 3 elements.forEach(function(element) { element.innerHTML = \u0026#39;\u0026#39;; }); ","date":"2024-04-04T20:19:17.45+08:00","permalink":"https://ynhugo.github.io/p/javascript%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/","title":"javascript操作技巧"},{"content":" 1 chrome://translate-internals/ ","date":"2024-04-04T01:46:37.23+08:00","permalink":"https://ynhugo.github.io/p/chrome%E5%86%85%E7%BD%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BF%BB%E8%AF%91%E4%B9%A0%E6%83%AF%E7%9A%84%E9%93%BE%E6%8E%A5/","title":"chrome内置的配置翻译习惯的链接"},{"content":" 简单教程 b站将服务器地址与串流密钥拼接在一起形成推流服务器地址\n1 ffmpeg -re -i input.mp4 -c:v libx264 -c:a aac -f flv \u0026#34;服务器地址/串流密钥\u0026#34; 上面的命令中，-re 参数表示以“实时”模式读取视频数据，这意味着 ffmpeg 会尽量按照视频的原始帧率来读取数据。-i input.mp4 参数指定了输入文件的名称，-c:v libx264 和 -c:a aac 参数分别指定了视频流和音频流使用的编码器。-f flv 参数指定了输出文件的格式，在这里我们使用 flv 格式。最后，\u0026#34;rtmp://your-server-url/app/stream\u0026#34;是推流服务器的地址，你需要将其替换为你自己的服务器地址。\n参考链接 闲置vps挂直播赚钱\n用ffmpeg在Windows11下的命令行模式推流到B站直播间\n","date":"2024-04-02T14:57:38+08:00","permalink":"https://ynhugo.github.io/p/b%E7%AB%9924%E5%B0%8F%E6%97%B6%E4%B8%8D%E9%97%B4%E6%96%AD%E7%9B%B4%E6%92%AD%E6%95%99%E7%A8%8B/","title":"b站24小时不间断直播教程"},{"content":" 安装termux termux的下载安装及使用教程 termux官网\ntermux教程\n初始化操作 termux-setup-storage #给访问权限\napt update \u0026amp;\u0026amp; apt upgrade -y \u0026amp;\u0026amp; pkg update \u0026amp;\u0026amp; pkg upgrade -y #检查更新并升\npkg install vim #文本编辑工具\n其它工具的安装 pkg install git #根据个人需要选择性安装\npkg install nodejs-lts -g #用来安装各种插件，根据个人需要选择性安装\nnpm install hexo-cli -g #必须先安装nodejs再执行，用来搭建博客，根据个人需要选择性安装\npkg install proot-distro #可用来安装linux系统，根据个人需要选择性安装\ntermux-openssh 安装好termux之后，想尝试一下termux的ssh，以我为例，做一个总结。\n注意：以下操作需要保证电脑跟手机保持在同一个局域网，且是电脑连接手机。\npkg install openssh #安装openssh\npasswd #电脑在连接termux时会提示输入密码，所以需要在termux中提前设置，执行passwd后会提示设置密码并确认密码。\nwhoami #查看termux的用户名。\nifconfig #查看termux的ip，我的是wlan1部分，看inet的后的ip地址。\nssh -p user@ip #user为termux执行whoami后看到的用户名，ip为执行ifconfig后看到的wlan1部分inet对应的ip。\n接下来会询问\u0026#34;yes or no\u0026#34;,输入yes，输入密码，然后连接成功。\n通过Termux和VNC实现以手机为服务器的桌面办公 参考链接 通过Termux和VNC实现以手机为服务器的桌面办公\ntermux利用工作proot-distro安装linux\n解决了termux安装ubuntu系统和安装系统的中文支持问题\n安装ubuntu和图形界面 现在安装ubuntu，我是通过proot-distro来安装的\n1 apt install proot-distro 然后键入proot-distro list来显示可安装包，这个方法不但可以方便的安装ubuntu可以看到你还可以用它来安装其它linux的发行版。 这里我们安装ubuntu\n1 proot-distro install ubuntu 这时候会从外网下载几十M的大文件(没听错几十兆而已，但很慢)，有时候网络不好，多试几次。 显示安装成功后就可以登入了\n1 proot-distro login ubuntu 当然你也可以把这条命令加入到自启动项里面，每次就可以自动登陆了。\n连接VNC图形化操作 进入ubuntu后先更新软件源\n1 apt update 然后安装需要用到的图形化服务软件\n1 apt install xfce4 xfce4-goodies 会安装xfc4轻量级图形界面服务，这一步大概会消耗1G的空间，当然也可以试着去安装其他的图形界面服务如gnome\n安装xfc4参考：https://blog.csdn.net/cunchi4221/article/details/107471665\n然后安装tigervnc。tigervnc感觉比tightvnc要配置简单一些\n1 apt install tigervnc-standalone-server tigervnc-common 然后做一下简单的配置\n运行\n1 vncserver 来设置密码\n然后创建启动脚本：\n1 nano .vnc/xstartup 如上命令就是用文本编辑器nano(当然你可以用其他文本编辑器)编辑用户文件夹下的.vnc文件夹下的xstartup文件(如果没有就创建一个)内容如下：\n1 2 #!/usr/bin/bash xfce4-session 注意xfce4-session后面不要跟\u0026amp;号，不然会在运行vncserver时提示过早退出，然后记得给它加执行的权限。\n1 chmod +x .vnc/xstartup 首次设置VNC时，它将在端口5901上启动默认服务器实例。\n如下是一个启动vnc服务器的例子：\n1 vncserver :1 -localhost no -geometry 1920x1080 然后就可以通过vnc的客户端登陆了，为了能够远端登陆不仅仅是本机登陆，设置-localhost no 是必要的。由于VNC是不加密的，会在登陆时提示如下，当然也可以自行百度实现在此基础上的外加SSH通道的加密。\n输入刚才设置的密码就可以登陆了\n之后就是熟悉的ubuntu界面了，可以自由安装自己喜欢的程序了\n中文语言设置 1 2 3 4 5 apt install language-pack-zh-hans* 安装中文包 apt install language-pack-gnome-zh-hans* 安装中文包 apt install fonts-wqy-* # $ apt install fonts-wqy-microhei 安装中文字体 # $ apt install fronts-wqy-zenhei 另一个中文字体 1 vim /etc/default/locale 更改内容如下：\n1 2 3 4 5 6 7 8 9 10 11 LANG=\u0026#34;zh_CN.UTF-8\u0026#34; LANGUAGE=\u0026#34;zh_CN:en_US:en\u0026#34; LC_NUMERIC=\u0026#34;zh_CN.UTF-8\u0026#34; LC_TIME=\u0026#34;zh_CN.UTF-8\u0026#34; LC_MONETARY=\u0026#34;zh_CN.UTF-8\u0026#34; LC_PAPER=\u0026#34;zh_CN.UTF-8\u0026#34; LC_IDENTIFICATION=\u0026#34;zh_CN.UTF-8\u0026#34; LC_NAME=\u0026#34;zh_CN.UTF-8\u0026#34; LC_ADDRESS=\u0026#34;zh_CN.UTF-8\u0026#34; LC_TELEPHONE=\u0026#34;zh_CN.UTF-8\u0026#34; LC_MEASUREMENT=\u0026#34;zh_CN.UTF-8\u0026#34; 保存后执行\n1 fc-cache -fv #最好进行这一步后再安装fcitx，否则有可能输入法不起做用。 则控制台终端己经会出现中文了\n如果安装过程中发现一些缺失的东东 1 2 apt install dialog apt install apt-utils 关于中文输入法 1 2 3 apt install fcitx apt install fcitx-config-* apt install fcitx-table-wbpy # 五笔拼音 如果通过VNC或别的XDSL进入XFCE，有fcitx图标，也能看到拼音，五笔输入法，但是却输入不了中文 1 vim ~/.profile 在结尾加入\n1 2 3 4 #fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=”@im=fcitx” 然后退出图形界面后，重启动。中文输入法可用了。\n如果要一进入桌面就有fcitx，则可 1 cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/ termux使用技巧 在termux查看手机内置存储 1 ls $EXTERNAL_STORAGE 热键 创建新的标签页：Ctrl+Alt+c\n切换到下一个标签页：Ctrl+Alt+n\nTermux设置——服务自启动 首先奉上官方Wilki: https://wiki.termux.com/wiki/Termux-services\n用过Linux的朋友应该对runit并不陌生，runit是一个用于服务监控的UNIX软件，它提供以下两种服务：\n当服务器启动的时候启动定义好的服务。 监控运行的服务，当服务发生意外中断的时候，自动重启服务。 而termux-services就是基于runit封装的，至此大部分runit功能及命令，并专门针对Termux特殊结构做了优化。\ntermux-services会主动监视$PREFIX/var/service/目录，会自动未目录下服务生成守护程序，当服务意外崩溃时，会第一时间将服务重新启动。\n同时termux-services默认会后台启动服务，并将服务的输出流做重定向。\n安装： 1 pkg install termux-services -y 安装完成后会随软件开启自动运行。\n原生支持的服务 包名 进程服务名 默认使用端口 服务描述 apache2 httpd 8080 Apache Web Server HTTP Web Server at atd AT and batch delayed command scheduling utility and daemon at bitcoin bitcoind Bitcoin Core busybox telnetd 8023 Remote terminal service Telnet busybox ftpd 8021 FTP (File Transfer Protocol) FTP cronie crond Daemon that runs specified programs at scheduled times cron emacs emacsd Extensible, customizable text editor-and more EMACS ipfs ipfs A peer-to-peer hypermedia distribution protocol IPFS libmosquitto mosquitto 1883 MQTT is a lightweight, publish-subscribe network protocol MQTT lighttpd lighttpd 8080 Lighttpd Small webserver HTTP Web Server lnd lnd Lightning Network Daemon mariadb mysqld 3306 MariaDB Community-developed fork of the MySQL from its original authors mpd mpd Music Player Daemon (MPD) mpdscribble mpdscribble MPD client which submits tracks being played nginx nginx 8080 NGINX Web server HTTP Web Server openssh sshd 8022 OpenSSH SSH postgresql postgres 5432 PostgreSQL database PostgreSQL privoxy privoxy Privoxy is non-caching web proxy with advanced filtering capabilities HTTP Proxy tor tor The Onion Router anonymizing overlay network Tor transmission transmission BitTorrent client BitTorrent 上表中的服务安装时就会自动在$PREFIX/var/service/下生成自己的服务文件夹：\n相关命令 1 2 3 4 5 sv-enable sshd\t#sshd服务设为自启动 sv-disable sshd\t#取消sshd自启动 sv down sshd\t#停止sshd服务，并使本次Termux运行期间sshd自启动服务失效 sv up sshd\t#启动sshd服务 sv status sshd\t#查看sshd服务运行状态 自己编写一个自启动服务 自启动脚本创建 在$PREFIX/var/service/下创建子目录，子目录名即为自启动服务名,这里使用test_ato作为自启动服务名：\n1 mkdir -p $PREFIX/var/service/test_ato 接下来创建执行脚本run:\n1 vim $PREFIX/var/service/test_ato/run 脚本内容：\n1 2 3 #!/data/data/com.termux/files/usr/bin/sh exec 2\u0026gt;\u0026amp;1 exec ~/test/test.sh 2\u0026gt;\u0026amp;1 保存，赋予其执行权限：\n1 chmod +x $PREFIX/var/service/test_ato/log/run 配置服务的输出日志 log/run中内容：\n1 2 3 #!/data/data/com.termux/files/usr/bin/sh svlogger=\u0026#34;/data/data/com.termux/files/usr/share/termux-services/svlogger\u0026#34; exec \u0026#34;${svlogger}\u0026#34; \u0026#34;$@\u0026#34; 保存，赋予其执行权限：\n1 chmod +x $PREFIX/var/service/test_ato/log/run 此时，日志文件被重定向到了目录$PREFIX/var/log/sv/\u0026lt;服务名\u0026gt;中\n自启动服务测试 将test.sh设为自启动：\n1 sv-enable test_ato 重启Termux应用，此时test.sh已经开始运行，查看日志文件$PREFIX/var/log/sv/test_ato/current已经开始稳定输出日志信息了。\n一个简单的模板服务就写好了，可以根据这个模板来编写自己需要的服务。\n参考链接 Termux设置——服务自启动\n","date":"2024-03-31T16:11:45.5+08:00","permalink":"https://ynhugo.github.io/p/termux_study/","title":"termux_study"},{"content":" 初识adb adb shell下载链接：https://wws.lanzoui.com/iNYNiq9l3yd\n打开文件所在文件夹，将地址栏清空并键入cmd，然后回车，在cmd窗口键入adb shell测试use调试是否连接成功，如果出现美元符号表示连接成功。\nadb命令 adb shell am monitor #执行该命令后在手机上打开要卸载的应用，获取包名\nadb shell pm disable-user 包名 #停用应用\nadb shell pm enable 包名 #恢复应用\nadb install -r apk文件路径 #安装应用，直接将文件拖入cmd窗口可直接实现插入路径\nadb shell pm list packages #显示包名列表\nadb uninstall 包名 #卸载应用\nadb安装软件实操 emulator代表实际序列号，如果有多个序号号的话需要指定一下，序列号可以通过\u0026#34;adb devices\u0026#34;查看\n1 adb -s emulator-5554 install rustdesk-1.2.7-aarch64-signed.apk adb命令安装apk脚本 1 mapfile -t files \u0026lt; \u0026lt;(find ./ -name \u0026#34;*.apk\u0026#34; | awk -F \u0026#34;/\u0026#34; \u0026#39;{print $2}\u0026#39;); for i in \u0026#34;${files[@]}\u0026#34;; do adb install \u0026#34;${i}\u0026#34;; done Android adb 查看已经安装的应用、安装应用、卸载应用 adb shell pm list packages -[option] 命令查看已经安装的应用，列出包名，后面加不同的后缀输出不同信息。 adb shell pm list packages ####查看当前连接设备或者虚拟机的所有包\nadb shell pm list packages -d #####只输出禁用的包。\nadb shell pm list packages -e #####只输出启用的包。\nadb shell pm list packages -s #####只输出系统的包。\nadb shell pm list packages -i #####只输出包和安装信息（安装来源）。\nadb shell pm list packages -u #####只输出包和未安装包信息（安装来源）。\nadb shell pm list packages -i #####只输出包和安装信息（安装来源）。\nadb shell pm list packages -f #####输出包和包相关联的文件\nadb shell pm list packages -3 #####输出所有第三方包。\nadb shell pm list packages -[option] \u0026#34;sina\u0026#34; #####按照要求搜索包。\n想要获取应用的详细信息需要使用以下命令 adb shell dumpsys package [pkgName]\n将安装包pull到本地 1.查询应用安装包路径 adb shell pm list packages -f 2.将安装包pull到本地 adb pull [安装包路径] [本地路径]\n使用示例 1 2 3 $ adb shell pm list packages -3 -f | grep \u0026#34;autojs\u0026#34; package:/data/app/~~EM3uClqaGqOJmFtgZzu5mg==/org.autojs.autojs6-uw8ReTCkJ0WgHz6xbYclsw==/base.apk=org.autojs.autojs6 package:/data/app/~~2QN6HKjtOdxJUztZ3psK-Q==/org.autojs.autojs6.test-xnGjPdkp-SKSPTDsWvP1PQ==/base.apk=org.autojs.autojs6.test 1 adb pull /data/app/~~2QN6HKjtOdxJUztZ3psK-Q==/org.autojs.autojs6.test-xnGjPdkp-SKSPTDsWvP1PQ==/base.apk ./ 参考链接 Android adb 查看已经安装的应用、安装应用、卸载应用\n使用ADB命令查看手机已安装应用详细信息，包含应用名称\n有些手机需要解锁system分区（如小米） 输入：adb root\n输入：adb disable-verity\n查看手机连接状态：adb device\n获得root权限：root\n设置超级用户模式 : su\n退出su : exit\n重启命令：adb reboot\n重启到Rec：adb reboot recovery\n重启到Fastboot：adb reboot bootloader\n推送ROM包：adb sideload \u0026lt;Rom包\u0026gt;\n把文件从手机中复制到电脑上 : adb pull \u0026lt;手机路径\u0026gt; \u0026lt;电脑路径\u0026gt;\n把文件从电脑复制到手机上 : adb push \u0026lt;电脑路径\u0026gt; \u0026lt;手机路径\u0026gt;\n重新挂载文件系统 : adb remount\n安装软件 : adb install apk文件名称.apk\n卸载apk软件 : adb uninstall apk包名.apk\nFastboot命令：\n查看连接状态 ：fastboot devices\n重启 ：fastboot reboot\n重启到Fastboot ：fastboot reboot-bootloader\n除非你很了解该命令，否则以下命令请谨慎使用：\n解锁 ：fastboot flashing unlock或fastboot oem unlock\n上锁 ：fastboot flashing lock或fastboot oem lock\n清除分区数据 ：fastboot erase \u0026lt;boot/system/data/cache/userdata/recovery\u0026gt;\n清除分区(四清) ：fastboot erase system -w\n格式化分区数据 ：fastboot format \u0026lt;boot/system/data/cache/userdata/recovery\u0026gt;\n烧写分区 ：fastboot flash \u0026lt; boot/system recovery/radio/bootloader splash1/\u0026gt; \u0026lt;*.img\u0026gt;\n以下是常用命令，可供大家查阅： 启动 adb server 命令：adb start-server\n停止 adb server 命令：adb kill-server\n查看 adb 版本：adb version\n安装 APK命令：adb install [-lrtsdg] \u0026lt;path_to_apk\u0026gt;\n卸载应用命令：adb uninstall [-k] \u0026lt;packagename\u0026gt;\n清除应用数据与缓存：adb shell pm clear \u0026lt;packagename\u0026gt;\n查看正在运行的 Services命令：adb shell dumpsys activity services [\u0026lt;packagename\u0026gt;]\n查看应用详细信息命令：adb shell dumpsys package \u0026lt;packagename\u0026gt;\n发送广播，命令格式：adb shell am broadcast [options] \u0026lt;INTENT\u0026gt;\n强制停止应用命令：adb shell am force-stop \u0026lt;packagename\u0026gt;\n文件管理复制设备里的文件到电脑：adb pull \u0026lt;设备里的文件路径\u0026gt; [电脑上的目录]\n复制电脑里的文件到设备：adb push \u0026lt;电脑上的文件路径\u0026gt; \u0026lt;设备里的目录\u0026gt;\n电池状况命令：adb shell dumpsys battery\nadb help, 列出所有的选项说明及子命令\n已停用应用包名(个人某手机已停用应用)： com.ivvi.browser 自带浏览器\ncom.android.fmradio FM电台\ncom.upgadata.ivvi 游戏电台\ncom.iflytek.inputmethod 讯飞输入法\ncom.yulong.freezeroom 应用冻结\ncom.icoolme.android.weather 最美天气\ncom.yulong.android.videoplayer 视频\ncom.redstone.ota.ui 系统更新\ncom.coolpad.music 音乐\ncom.android.stk sim卡应用\ncom.yulong.android.backup 备份与恢复\n安卓adb shell常用的命令 install/uninstall，在设备上安装 APK。 1 adb install path_to_apk dumpsys（dump system）比较强大的系统服务查询-安卓无需电脑使用adb连接本机，免root控制充电 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 查看当前系统所支持的dump服务 adb shell dumpsys -l # 比如电池信息 adb shell dumpsys battery adb shell dumpsys battery set status 1 #设置电池为非充电状态 adb shell dumpsys battery set status 2 #设置电池为充电状态 # 一些就手机安装linux做服务器之后，又不能一直充电，就可以使用这个方法来自动充放电，保护电池。 adb shell dumpsys battery set level 100 #设置电量百分比 adb shell dumpsys battery unplug #设置断开充电 # 可以拿来做伪装电量。 adb shell dumpsys battery reset # 恢复 wm（windows manager）窗口管理器，可以设置一些屏幕参数。 1 2 3 4 5 # 查看分辨率 adb shell wm size # 查看dpi adb shell wm density logcat，查看日志，方便提交bug。 1 2 3 4 5 6 7 8 9 10 11 12 13 adb logcat \u0026#34;*:W\u0026#34; # 日志输出级别 V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） # 清理日志 adb logcat -c reboot，重启。 1 2 3 4 5 6 7 8 #重启 adb reboot #重启到recovery模式 adb reboot recovery #重启到bl模式 adb reboot bootloader 参考链接 安卓设备通过Termux实现本机ADB\n安卓无需电脑使用adb连接本机，免root控制充电\n安卓adb shell常用的命令\n消除ADB错误“more than one device and emulator”的方法 当我连着手机充电的时候，启动模拟器调试，执行ADB指令时，报错。\n1 2 3 4 $ adb shell error: more than one device and emulator $ adb install e:\\good.apk error: more than one device and emulator 碰到这种情况，首先要查一下，是不是真的有多个设备或模拟器。\n1 2 3 4 $ adb devices List of devices attached emulator-5554 device adfadcb96b03cf02 device 发现还真是多个设备，那就需要为ADB命令指定设备的序列号了。\n1 $ adb -s emulator-5554 shell 也就是如上所示，给命令加上-s的参数就可以了！\n如果实际上只有一个设备或模拟器，并且查到有offline的状态； 那就说明是ADB本身的BUG所导致的，就需要用如下的方法处理下了：\n1 2 $ adb kill-server $ taskkill /f /im adb.exe 第一条命令是杀ADB的服务，第二条命令是杀ADB的进程！ 如果第一条没有用，才考虑用第二条命令再试试看的\n参考链接 消除ADB错误“more than one device and emulator”的方法\n通过ADB命令备份和恢复Android手机信息 在Android设备上，ADB（Android Debug Bridge）是一个强大的命令行工具，可以用于与设备进行通信和控制设备。通过ADB命令，你可以备份和恢复手机信息，包括应用数据、联系人、短信等。\n备份手机信息 连接设备 首先，确保你的Android设备已开启开发者选项和USB调试模式。然后，通过USB将设备连接到电脑。\n安装ADB工具 在电脑上安装ADB工具。你可以从Android官方网站下载适用于Windows、Mac和Linux的ADB工具。\n打开命令行窗口 打开命令行窗口（Windows用户可以使用命令提示符或PowerShell，Mac和Linux用户可以使用终端）。\n检测设备 在命令行窗口中输入以下命令，检测设备是否正确连接： adb devices 如果设备已正确连接，你应该能在列表中看到你的设备。\n备份手机信息 使用以下命令备份手机信息： adb backup -all 该命令将备份应用数据和设备设置，并生成一个名为backup.ab的文件。默认情况下，该文件将保存在电脑的当前目录下。\n加密备份文件（可选） 如果你想加密备份文件，可以在备份时输入密码。输入以下命令： adb backup -all -password yourpassword\n恢复手机信息 如果需要恢复手机信息，请按照以下步骤操作：\n连接设备 通过USB将设备连接到电脑。\n打开命令行窗口 打开命令行窗口（Windows用户可以使用命令提示符或PowerShell，Mac和Linux用户可以使用终端）。\n恢复备份文件 使用以下命令恢复备份文件： adb restore backup.ab点击恢复数据即可。\n参考链接 通过ADB命令备份和恢复Android手机信息\nadb按键 adb-按键 唤醒屏幕+划动屏幕 1 adb shell input keyevent 224; adb shell input keyevent 82; adb shell input keyevent (具体操作) – 模拟按键事件 KeyCode 1 2 adb shell input keyevent 4\t# 这条命令相当于按了设备的Backkey键 adb shell input keyevent 82 # 可以解锁屏幕 每个数字与keycode对应表如下： 0 KEYCODE_UNKNOWN 1 KEYCODE_MENU 2 KEYCODE_SOFT_RIGHT 3 KEYCODE_HOME 4 KEYCODE_BACK 5 KEYCODE_CALL 6 KEYCODE_ENDCALL 7 KEYCODE_0 8 KEYCODE_1 9 KEYCODE_2 10 KEYCODE_3 11 KEYCODE_4 12 KEYCODE_5 13 KEYCODE_6 14 KEYCODE_7 15 KEYCODE_8 16 KEYCODE_9 17 KEYCODE_STAR 18 KEYCODE_POUND 19 KEYCODE_DPAD_UP 20 KEYCODE_DPAD_DOWN 21 KEYCODE_DPAD_LEFT 22 KEYCODE_DPAD_RIGHT 23 KEYCODE_DPAD_CENTER 24 KEYCODE_VOLUME_UP 25 KEYCODE_VOLUME_DOWN 26 KEYCODE_POWER 27 KEYCODE_CAMERA 28 KEYCODE_CLEAR 29 KEYCODE_A 30 KEYCODE_B 31 KEYCODE_C 32 KEYCODE_D 33 KEYCODE_E 34 KEYCODE_F 35 KEYCODE_G 36 KEYCODE_H 37 KEYCODE_I 38 KEYCODE_J 39 KEYCODE_K 40 KEYCODE_L 41 KEYCODE_M 42 KEYCODE_N 43 KEYCODE_O 44 KEYCODE_P 45 KEYCODE_Q 46 KEYCODE_R 47 KEYCODE_S 48 KEYCODE_T 49 KEYCODE_U 50 KEYCODE_V 51 KEYCODE_W 52 KEYCODE_X 53 KEYCODE_Y 54 KEYCODE_Z 55 KEYCODE_COMMA 56 KEYCODE_PERIOD 57 KEYCODE_ALT_LEFT 58 KEYCODE_ALT_RIGHT 59 KEYCODE_SHIFT_LEFT 60 KEYCODE_SHIFT_RIGHT 61 KEYCODE_TAB 62 KEYCODE_SPACE 63 KEYCODE_SYM 64 KEYCODE_EXPLORER 65 KEYCODE_ENVELOPE 66 KEYCODE_ENTER 67 KEYCODE_DEL 68 KEYCODE_GRAVE 69 KEYCODE_MINUS 70 KEYCODE_EQUALS 71 KEYCODE_LEFT_BRACKET 72 KEYCODE_RIGHT_BRACKET 73 KEYCODE_BACKSLASH 74 KEYCODE_SEMICOLON 75 KEYCODE_APOSTROPHE 76 KEYCODE_SLASH 77 KEYCODE_AT 78 KEYCODE_NUM 79 KEYCODE_HEADSETHOOK 80 KEYCODE_FOCUS 81 KEYCODE_PLUS 82 KEYCODE_MENU 83 KEYCODE_NOTIFICATION 84 KEYCODE_SEARCH 85 TAG_LAST_KEYCODE 电话键 KEYCODE_CALL 拨号键 5 KEYCODE_ENDCALL 挂机键 6 KEYCODE_HOME 按键Home 3 KEYCODE_MENU 菜单键 82 KEYCODE_BACK 返回键 4 KEYCODE_SEARCH 搜索键 84 KEYCODE_CAMERA 拍照键 27 KEYCODE_FOCUS 拍照对焦键 80 KEYCODE_POWER 电源键 26 KEYCODE_NOTIFICATION 通知键 83 KEYCODE_MUTE 话筒静音键 91 KEYCODE_VOLUME_MUTE 扬声器静音键 164 KEYCODE_VOLUME_UP 音量增加键 24 KEYCODE_VOLUME_DOWN 音量减小键 25 控制键 KEYCODE_ENTER 回车键 66 KEYCODE_ESCAPE ESC键 111 KEYCODE_DPAD_CENTER 导航键 确定键 23 KEYCODE_DPAD_UP 导航键 向上 19 KEYCODE_DPAD_DOWN 导航键 向下 20 KEYCODE_DPAD_LEFT 导航键 向左 21 KEYCODE_DPAD_RIGHT 导航键 向右 22 KEYCODE_MOVE_HOME 光标移动到开始键 122 KEYCODE_MOVE_END 光标移动到末尾键 123 KEYCODE_PAGE_UP 向上翻页键 92 KEYCODE_PAGE_DOWN 向下翻页键 93 KEYCODE_DEL 退格键 67 KEYCODE_FORWARD_DEL 删除键 112 KEYCODE_INSERT 插入键 124 KEYCODE_TAB Tab键 61 KEYCODE_NUM_LOCK 小键盘锁 143 KEYCODE_CAPS_LOCK 大写锁定键 115 KEYCODE_BREAK Break/Pause键 121 KEYCODE_SCROLL_LOCK 滚动锁定键 116 KEYCODE_ZOOM_IN 放大键 168 KEYCODE_ZOOM_OUT 缩小键 169 按键 KEYCODE_0 按键\u0026#39;0\u0026#39; 7 KEYCODE_1 按键\u0026#39;1\u0026#39; 8 KEYCODE_2 按键\u0026#39;2\u0026#39; 9 KEYCODE_3 按键\u0026#39;3\u0026#39; 10 KEYCODE_4 按键\u0026#39;4\u0026#39; 11 KEYCODE_5 按键\u0026#39;5\u0026#39; 12 KEYCODE_6 按键\u0026#39;6\u0026#39; 13 KEYCODE_7 按键\u0026#39;7\u0026#39; 14 KEYCODE_8 按键\u0026#39;8\u0026#39; 15 KEYCODE_9 按键\u0026#39;9\u0026#39; 16 KEYCODE_A 按键\u0026#39;A\u0026#39; 29 KEYCODE_B 按键\u0026#39;B\u0026#39; 30 KEYCODE_C 按键\u0026#39;C\u0026#39; 31 KEYCODE_D 按键\u0026#39;D\u0026#39; 32 KEYCODE_E 按键\u0026#39;E\u0026#39; 33 KEYCODE_F 按键\u0026#39;F\u0026#39; 34 KEYCODE_G 按键\u0026#39;G\u0026#39; 35 KEYCODE_H 按键\u0026#39;H\u0026#39; 36 KEYCODE_I 按键\u0026#39;I\u0026#39; 37 KEYCODE_J 按键\u0026#39;J\u0026#39; 38 KEYCODE_K 按键\u0026#39;K\u0026#39; 39 KEYCODE_L 按键\u0026#39;L\u0026#39; 40 KEYCODE_M 按键\u0026#39;M\u0026#39; 41 KEYCODE_N 按键\u0026#39;N\u0026#39; 42 KEYCODE_O 按键\u0026#39;O\u0026#39; 43 KEYCODE_P 按键\u0026#39;P\u0026#39; 44 KEYCODE_Q 按键\u0026#39;Q\u0026#39; 45 KEYCODE_R 按键\u0026#39;R\u0026#39; 46 KEYCODE_S 按键\u0026#39;S\u0026#39; 47 KEYCODE_T 按键\u0026#39;T\u0026#39; 48 KEYCODE_U 按键\u0026#39;U\u0026#39; 49 KEYCODE_V 按键\u0026#39;V\u0026#39; 50 KEYCODE_W 按键\u0026#39;W\u0026#39; 51 KEYCODE_X 按键\u0026#39;X\u0026#39; 52 KEYCODE_Y 按键\u0026#39;Y\u0026#39; 53 KEYCODE_Z 按键\u0026#39;Z\u0026#39; 54 多媒体键 KEYCODE_MEDIA_PLAY 多媒体键 播放 KEYCODE_MEDIA_STOP 多媒体键 停止 KEYCODE_MEDIA_PAUSE 多媒体键 暂停 KEYCODE_MEDIA_PLAY_PAUSE 多媒体键 播放/暂停 KEYCODE_MEDIA_FAST_FORWARD 多媒体键 快进 KEYCODE_MEDIA_REWIND 多媒体键 快退 KEYCODE_MEDIA_NEXT 多媒体键 下一首 KEYCODE_MEDIA_PREVIOUS 多媒体键 上一首 KEYCODE_MEDIA_CLOSE 多媒体键 关闭 KEYCODE_MEDIA_EJECT 多媒体键 弹出 KEYCODE_MEDIA_RECORD 多媒体键 录音 F1~F12功能键 KEYCODE_F1 按键F1 KEYCODE_F2 按键F2 KEYCODE_F3 按键F3 KEYCODE_F4 按键F4 KEYCODE_F5 按键F5 KEYCODE_F6 按键F6 KEYCODE_F7 按键F7 KEYCODE_F8 按键F8 KEYCODE_F9 按键F9 KEYCODE_F10 按键F10 KEYCODE_F11 按键F11 KEYCODE_F12 按键F12 符号按键 KEYCODE_PLUS 按键\u0026#39;+\u0026#39; KEYCODE_MINUS 按键\u0026#39;-\u0026#39; KEYCODE_STAR 按键\u0026#39;*\u0026#39; KEYCODE_SLASH 按键\u0026#39;/\u0026#39; KEYCODE_EQUALS 按键\u0026#39;=\u0026#39; KEYCODE_AT 按键\u0026#39;@\u0026#39; KEYCODE_POUND 按键\u0026#39;#\u0026#39; KEYCODE_APOSTROPHE 按键\u0026#39;\u0026#39;\u0026#39; (单引号) KEYCODE_BACKSLASH 按键\u0026#39;\\\u0026#39; KEYCODE_COMMA 按键\u0026#39;,\u0026#39; KEYCODE_PERIOD 按键\u0026#39;.\u0026#39; KEYCODE_LEFT_BRACKET 按键\u0026#39;[\u0026#39; KEYCODE_RIGHT_BRACKET 按键\u0026#39;]\u0026#39; KEYCODE_SEMICOLON 按键\u0026#39;;\u0026#39; KEYCODE_GRAVE 按键\u0026#39;`\u0026#39; KEYCODE_SPACE 空格键 小键盘按键 KEYCODE_NUMPAD_0 小键盘按键\u0026#39;0\u0026#39; KEYCODE_NUMPAD_1 小键盘按键\u0026#39;1\u0026#39; KEYCODE_NUMPAD_2 小键盘按键\u0026#39;2\u0026#39; KEYCODE_NUMPAD_3 小键盘按键\u0026#39;3\u0026#39; KEYCODE_NUMPAD_4 小键盘按键\u0026#39;4\u0026#39; KEYCODE_NUMPAD_5 小键盘按键\u0026#39;5\u0026#39; KEYCODE_NUMPAD_6 小键盘按键\u0026#39;6\u0026#39; KEYCODE_NUMPAD_7 小键盘按键\u0026#39;7\u0026#39; KEYCODE_NUMPAD_8 小键盘按键\u0026#39;8\u0026#39; KEYCODE_NUMPAD_9 小键盘按键\u0026#39;9\u0026#39; KEYCODE_NUMPAD_ADD 小键盘按键\u0026#39;+\u0026#39; KEYCODE_NUMPAD_SUBTRACT 小键盘按键\u0026#39;-\u0026#39; KEYCODE_NUMPAD_MULTIPLY 小键盘按键\u0026#39;*\u0026#39; KEYCODE_NUMPAD_DIVIDE 小键盘按键\u0026#39;/\u0026#39; KEYCODE_NUMPAD_EQUALS 小键盘按键\u0026#39;=\u0026#39; KEYCODE_NUMPAD_COMMA 小键盘按键\u0026#39;,\u0026#39; KEYCODE_NUMPAD_DOT 小键盘按键\u0026#39;.\u0026#39; KEYCODE_NUMPAD_LEFT_PAREN 小键盘按键\u0026#39;(\u0026#39; KEYCODE_NUMPAD_RIGHT_PAREN 小键盘按键\u0026#39;)\u0026#39; KEYCODE_NUMPAD_ENTER 小键盘按键回车 参考链接 adb shell input keyevent (具体操作) – 模拟按键事件 KeyCode\nadb推拉文件或文件夹 adb拉取文件 redeme.txt文件会从安卓设备被拷贝到PC端temp目录下\n1 adb pull /storage/emulated/0/Download/book/redeme.txt D:\\cygwin\\home\\temp adb拉取文件夹 拉取文件夹与拉取文件相比，多了一个-a选项\nbook文件夹会从安卓设备被拷贝到PC端temp-book目录下，temp-book目录如果不存在时会自动新建该目录，如果不指定新建目录，则book目录下的所以文件会被拷贝到temp目录下，而不是book目录被拷贝到temp-book目录下\n1 adb pull -a /storage/emulated/0/Download/book/嵌入式/ D:\\cygwin\\home\\temp-book adb推送文件 redeme.txt文件会从PC端被拷贝到安卓设备的test目录下\n1 adb push D:\\cygwin\\home\\temp\\redeme.txt /storage/emulated/0/Download/test adb推送文件夹 推送文件与推送文件夹的命令模式一样\ntemp-book文件夹会从PC端被拷贝到安卓设备的test目录下，test目录下会看到temp-book目录\n1 adb push D:\\cygwin\\home\\temp\\temp-book /storage/emulated/0/Download/test 参考链接 adb pull 整个文件夹详解\nadb push文件夹\n安卓教程：使用adb工具进行文件推送\nadb命令从PC端传输文件到安卓手机端指定目录下\n","date":"2024-03-31T15:56:35.18+08:00","permalink":"https://ynhugo.github.io/p/adb%E6%95%99%E7%A8%8B/","title":"adb教程"},{"content":" 获取链接来源 关键字 javascript 需要自己手动输入，然后加一个冒号，后边跟上要执行的代码\n1 javascript:alert(document.referrer) 网页音视频的一些基本操作技巧 控制视频倍速示例：document.querySelector(\u0026#34;video\u0026#34;).playbackRate=\u0026#39;8\u0026#39;;\n音视频自动播放示例：document.querySelector(\u0026#34;audio\u0026#34;).play();\n音视频暂停示例：document.querySelector(\u0026#34;audio\u0026#34;).pause();\n音视频进度跳转示例：document.querySelector(\u0026#34;audio\u0026#34;).currentTime=0;\n音视频后退进度示例：document.querySelector(\u0026#34;video\u0026#34;).currentTime-=5;\n音视频前进进度示例：document.querySelector(\u0026#34;video\u0026#34;).currentTime+=5;\nHTML5使用JavaScript控制＜audio\u0026gt;音频的播放\nJs控制页面刷新（局部刷新\u0026amp;全页面刷新）\n","date":"2024-03-31T15:39:23.66+08:00","permalink":"https://ynhugo.github.io/p/%E7%BD%91%E9%A1%B5%E6%93%8D%E4%BD%9C/","title":"网页操作"},{"content":" word2007解决配置进度问题 解决办法1(注册office安装文件，office2007)\n1、出现这个问题是office配置注册文件有错误，通过命令修正这个文件即可\n打开开始—-运行(或者 windows 键+R) 输入下面内容\n如若是Office 2003的对应问题，在运行对话框中输入：\n1 reg add HKCU\\Software\\Microsoft\\Office\\11.0\\Word\\Options /v NoReReg /t REG_DWORD /d 1 回车即可\n若是Office 2007的对应问题，在运行对话框中输入：\n1 reg add HKCU\\Software\\Microsoft\\Office\\14.0\\Word\\Options /v NoReReg /t REG_DWORD /d 1 参考链接 office2007每次打开都配置进度_office2007 每次打开word,excel等显示正在配置Office Professional Plus 2007的解决方…\n","date":"2024-03-29T20:39:57.95+08:00","permalink":"https://ynhugo.github.io/p/word2007%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E8%BF%9B%E5%BA%A6%E9%97%AE%E9%A2%98/","title":"word2007解决配置进度问题"},{"content":" 使用方式 最简单的使用方式是在终端执行 bc 命令，然后就进入计算环境，直接输入计算式子进行计算即可\n还有一种是通过管道进行计算的，也是我比较喜欢的，如果要计算复杂的式子，用管道会比较方便\n以下是一个运行示例，输出十六进制，输入十进制，将十进制256转换为十六进制100\n1 2 $ echo \u0026#34;obase=16;ibase=10;256\u0026#34; | bc 100 scale代表结果如果包含小数，则保留两位小数 1 echo \u0026#34;scale=2; (100*8000)/12/7000\u0026#34; | bc 嵌套运算示例\n1 2 $ echo \u0026#34;$(echo \u0026#34;$(echo \u0026#34;$(echo \u0026#34;1*10\u0026#34;)\u0026#34; | bc) * 10\u0026#34; | bc) * 10\u0026#34; | bc 1000 三角函数、开方和幂次运算 bc在使用参数-l指定代数运算模式下也支持三角函数、开方、幂次等操作。 但是与matlab等语言不同的是，为了简化代码，bc中三角函数与数学上的函数名字有所不同，具体如下：\ns(x) 计算 sin(x)，以下x皆为弧度表示 c(x) 计算 cos(x) a(x) 计算arctangent(x) l(x) 计算ln(x) e(x) 计算e的x次方，其中e为自然底数 x^y 计算x的y次方 sqrt(x) 计算根号下x\n例如： 分别计算sin(1)，cos(0)，arctan(1.0):\n1 2 3 4 5 6 ~$ echo \u0026#34;s(1)\u0026#34; | bc -l .84147098480789650665 ~$ echo \u0026#34;c(0.0)\u0026#34; | bc -l 1.00000000000000000000 ~$ echo \u0026#34;a(1.0)\u0026#34; | bc -l .78539816339744830961 分别计算ln(2)，pow(e,1):\n1 2 3 4 ~$ echo \u0026#34;l(2)\u0026#34; | bc -l .69314718055994530941 ~$ echo \u0026#34;e(1)\u0026#34; | bc -l 2.71828182845904523536 分别计算pow(2,3)，sqrt(9.0)：\n1 2 3 4 ~$ echo \u0026#34;2^3\u0026#34; | bc -l 8 ~$ echo \u0026#34;sqrt(9.0)\u0026#34; | bc -l 3.00000000000000000000 如何进行移位运算 进行移位运算 以十六进制输出\n1 2 echo \u0026#34;obase=16; $(echo $((1\u0026lt;\u0026lt;29)))\u0026#34; | bc echo \u0026#34;obase=16; $(((1 \u0026lt;\u0026lt; 22) | (1 \u0026lt;\u0026lt; 20) | (4 \u0026lt;\u0026lt; 12) | 6))\u0026#34; | bc 或\n1 temp=0; temp=$(echo \u0026#34;$(((1 \u0026lt;\u0026lt; 22) | (1 \u0026lt;\u0026lt; 20) | (4 \u0026lt;\u0026lt; 12) | 6))\u0026#34; | bc); echo \u0026#34;obase=16; $temp\u0026#34; | bc 以二进制输出\n1 echo \u0026#34;obase=2; $(echo $((1\u0026lt;\u0026lt;29)))\u0026#34; | bc 进制转换 1 echo \u0026#34;0x$(echo \u0026#34;obase=2;ibase=16;3A\u0026#34; | bc)\u0026#34; 参考链接 第八篇 shell位运算，左移，右移，与运算，进制转换\n注意事项 先设置 obase 在设置 ibase，计算器正常。\n在 bc 计算器中，obase 与 ibase 的赋值有先后顺序。\n且在计算过程中 obase 与 ibase 只能赋值一次。\n进行三角函数、开方，幂次等代数运算时，一定要加上参数-l，表示进行代数运算，不然无法使用内置的三角函数、开方等函数。\n","date":"2024-03-28T01:04:36.43+08:00","permalink":"https://ynhugo.github.io/p/bc%E8%AE%A1%E7%AE%97%E5%99%A8/","title":"bc计算器"},{"content":" 系统 Ctrl+.：按下后会在全角中文标点和半角英文标点之间切换\nAlt+Esc：会立即将当前窗口切换到下一个在后台打开的窗口，切换顺序通常与 Alt + Tab 的列表顺序一致。\n资源监视器：resmon.exe，可以在运行框输入resmon并运行以打开资源监视器\n调出搜索框：Win+Q与Win+S\n步骤记录器：psr\n鼠标控制：win+r_main.cpl\n网络管理：win+r_ncpa.cpl\ncmd窗口查看windows的 C:\\Windows§ystem32 的目录下相关后缀的文件：dir /a *.cpl或dir /a *.msc\n以管理员身份打开cmd：按下Win + R键，打开\u0026#34;运行\u0026#34;对话框，在对话框中输入\u0026#34;cmd\u0026#34;，然后按下Ctrl + Shift + Enter键。\n文件资源管理器打开多文件夹操作：用Ctrl选中多个连接或用shift选中连续文件夹，然后按住ctrl键，再同时双击其它未选中文件夹即可以多窗口的形式打开文件夹\n打开系统：在开始菜单搜索xi（xitong）或者 system 或者 setting 可以弹出区别于老版控制面板的系统设置\n调整窗口：win+z\n步骤记录器：打开windows搜索菜单搜索步骤记录器并运行，可以录制操作步骤，停止录制时可以查看录制下来的操作\nalt + space：打开窗口菜单\n打开开始菜单：Ctrl + Esc\nwinget安装程序示例： winget install –id=Microsoft.WindowsTerminal -l \u0026#34;D:Program Files (x86)\u0026#34;\n打开控制台根节点：win+r_mmc\n如何将kali linux安装在u盘上？\n进入kali.org官网下载Live Boot，然后用rufus刻录到u盘上，rufus界面默认设置，除高级选项显示外围硬盘，然后写入镜像模式为以DD镜像写入，制作完成。\n如何将porteus linux发行版安装在u盘上，在porteus.org找到任意版本镜像下载下来后用rufus刻录到u盘上即可，之后重启电脑通过u盘进入系统即可。\n如何将tiny core linux安装在u盘上，到http://tinycorelinux.net/找到镜像下载之后再通过Etcher刻录进u盘即可。\n高级操作：1、打开regedit；2、打开msconfig.exe(安全模式)；3、gpedit;\n查看电脑端口状态：win+r_cmd_netstat\n任务栏程式切换：win+t和win+shitf+t(倒着切换)\n文件强制删除(针对权限不高的文件)：shift+delete\n注销：win+r_logoff\n打开窗口设置：Alt + Space\n打开文件属性：Alt + Enter\n创建虚拟桌面：ctrl+win+d\n虚拟桌面间切换：win+ctrl+方向键\n关闭虚拟桌面：ctrl+win+F4\n从程式切换到桌面：win+m\n打开虚拟键盘：Ctrl + Win + o\n打开投影：Ctrl + Win + p\n打开开始菜单：ctrl + esc\n查看桌面：win+逗号\n一键回到桌面：win+d\n任务栏打开新应用：win+1..9\n多个应用程式分屏：win+方向键\n应用切换：alt+tab\n显示任务视窗：win+tab\n任务管理器：ctrl+shift+esc 或者 ctrl+alt+.\n打开文档浏览器：win+e\n新增视窗：ctrl+n\n打开文档特定类型文件：ctrl+O\n使用放大镜：win+加号键或减号键\n捕捉屏幕：win+psr\n快速截图：win+shift+s\n使用操作中心：win+a\n进入设置：win+i\n与系统语音助手对话：win+c\n使用系统游戏栏：win+g\n锁住pc：win+L\n打开高级系统设置：win+r-\u0026gt;sysdm.cpl\n退出桌面：ctrl+alt+delete\n系统自带表情：win+句号\n打印页面：ctrl+p\n保存页面：ctrl+s\n放大或缩小：ctrl+加号或等于键，ctrl+减号或杠键，ctrl+右括号或零键\n资源监视器：Win+r_resmon/perfmon /res\n打开设置的关于页面：Win+pouse\n投影：win+p\n框选识别文字：ctrl+alt+o\n框选翻译文字：ctrl+alt+f\n打开键盘：ctrl+win+o\n重新创建notepad：Ctrl + Shift + N\n打印机设置：ctrl+shift+p\n使用命令提示符来注册电脑上全部的dll文件：for %1 in (%windir%\\system32\\*.dll) do regsvr32.exe /s %1\n查找计算机：ctrl+win+f\n切换到windows powershell：win+x\n快速启动：C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows§tart MenuPrograms§tartup\n一键关闭电脑所有软体：taskkill /F /FI \u0026#34;USERNAME eq Administrator\u0026#34; /FI \u0026#34;IMAGENAME ne explorer.exe\u0026#34; /FI \u0026#34;IMAGENAME ne dwm.exe\u0026#34;\n一键关闭电脑所有软体：taskkill /F /FI \u0026#34;IMAGENAME ne explorer.exe\u0026#34; /FI \u0026#34;IMAGENAME ne dwm.exe\u0026#34;\n查看电脑连接过的wifi的密码：netsh wlan show profiles name=wifi名字 key=clear\n连接无线设备：win+k\n显示系统信息：按Win键，输入 msinfo并回车或直接搜索 系统信息\n高级菜单：win+x\nrss订阅：https://ynrss.herokuapp.com/\n用cmd命令装逼：先color a回车，再dir /s回车即可\n查看端口排错：netstart -ano | findsrt 50524\n阻止所有弹窗的相关设置方法：win+r_control.exe_网络和internet_internet选项_隐私_启用弹出窗口阻止程序(B)_阻止\n级别(高)_win+e_此电脑_管理_点开任务计划程序小箭头_任务计划程序库_把所有程序状态改为禁用\n远程转接：win+r_control.exe_系统的安全_允许远程访问_允许远程连接到此计算机(L)——win+r_mstsc_输入对方电脑ip\n查看端口排错：netstart -ano | findsrt 50524\n如何查看系统信息：win+r_control.exe_系统_查看RAM的大小和处理器的速度\n修复电脑损坏文件：win+r_chkdsk(回车)_sfc /scannow\n清理电脑垃圾文件：win+r_cmd_%temp%和win+r_cleanmgr\n进入启动文件夹（开机自启动）：shell:startup\n电脑截图的6种方法：ctrl+alt+a（qq截图）、alt+a（微信截图）、shift+alt+a（企业微信截图）、win+shift+a（花样截图）、ctrl+alt+x（wps截图）、电脑自带截图小工具\n删除字符串快捷键：ctrl + backspace\n关闭cmd：taskkill /f /im cmd.exe\n计算机性能实时检测程序：perfmon.msc\n查看或修改电脑程序状态：msconfig\nDirectX诊断工具也查询电脑具体配置：dxdiag\n远程控制电脑，只需输入ip即可：mstsc\n一键清理磁盘内垃圾：cleanmgr\n在dos窗口查看当前路径：echo %pa%\n下载网页视频的方法：F12_network(网络)_F5(刷新一下)_点击刷新出来的链接即可\n上帝之眼(使用方法，把这串代码命名到一个新建的空文件夹之可)：GodMode.{ED7BA470-8E54-465E-825C-99712043E01C}\n一键关闭cmd程式（bat文件）：start taskkill /f /im cmd.exe\n电脑自带工具-哈希值校验：例如要校验 ideaIU-2018.1.exe ，正确做法是在文件所在文件夹输入 certutil -hashfile ideaIU-2018.1.exe sha256 ，即 certutil -hashfile + 文件名(包括后缀) + sha256 ;如果不加最后一个参数，则默认是这个 certutil -hashfile filename md5 ；还有一种方法是：Get-FileHash 文件路径 -Algorithm 校验的Hash值类型| Format-List\n用vbs打开指定文件：createobject(\u0026#34;wscript.shell\u0026#34;).run \u0026#34;cmd /c start D:\\__easyHelper__\u0026#34;\nvbs设置循环次数：\ndim s\ndo until s=999\ns=s+1\nmsgbox\u0026#34;这里写窗口显示内容\u0026#34;\nloop\n999是循环次数，可以修改\n查看电脑vbs的环境变量：进入cmd，输入set即可\n在cmd窗口无限循环输出自定义文字：for /l %a in (0,0,1) do echo 自定义\n可用来尝试激活电脑：slmgr /skms kms.03k.org\nslmgr /ato\n快捷方式关机：创建快捷方式，输入slidetoshutdown,确定后再将快捷方式的名字改为自定义的即可\n修复(清空)u盘的方法：win+r_cmd_diskpart_list disk_select disk 1(所要操作的磁盘序号)_clean\n创建分区的方法：win+r_cmd_create partition primary_select partition 1(对应清空的磁盘序号)_active_format fs=ntfs quick\n查看磁盘的相关修改参数：lsit disk\n掌握win7的快捷键，没有鼠标您也从容使用系统：\n一、Win键相关的快捷键\nWin + Home 将所有使用中窗口以外的窗口最小化（和摇动使用中窗口一样意思）\nWin + Space空格键 将所有桌面上的窗口透明化（和鼠标移到工作列的最右下角一样意思）\nWin + ↑上方向键 最大化使用中窗口（和将窗口用鼠标拖到屏幕上缘一样意思）\nShift + Win + ↑上方向键 垂直最大化使用中窗口（但水平宽度不变）\nWin +↓下方向键 最小化窗口／还原先前最大化的使用中窗口\nWin +左／右方向键 窗口靠到屏幕的左右两侧（和将窗口用鼠标拖到左右边缘一样意思）\nShift + Win +左/右方向键 将窗口移到左、右屏幕（如果你有接双屏幕的话）工作列快速列\nWin + 1~9 开启工作列上相对应的软件，从左到右依顺序为Win+1到Win+9\nShift + Win + 1~9 开启对应位置软件的一个新「分身」，例如firefox的话会是开新窗口（鼠标是Shift+点软件）\nCtrl + Win + 1~9 在对应位置软件已开的分身中切换\nAlt + Win + 1~9 开启对应位置软件的右键选单\nCtrl + Shift + 鼠标点软件以管理员权限开启该软件\nWIN +点击任务栏快捷方式 在此程序中新建一个实例\nWin + (+/-)：　打开Windows放大、缩小功能\nWin + G 在屏幕上的Gadget间切换\nWin + X 打开移动中心\nWin + D 显示桌面，最小化所有窗口\nWin + E 打开资源管理器\nWin + F 打开资源管理器搜索结果\nWin + L 锁定计算机，回到登陆窗口\nWin + M 最小化当前窗口\nWin + P 投影机输出设定（仅屏幕、同步显示、延伸、仅投影机）\nWin + R 打开运行窗口\nWin + T 工作列的Alt+Tab\nWin + U 打开控制面板轻松访问中心\nWin + Break 打开控制面板系统属性\nWin + Tab 打开Flip3D任务切换功能\n二、Windows基础快捷键\nF1 帮助\nCtrl+C ( Ctrl+Insert) 复制选中项目\nCtrl+X 剪切选中项目\nCtrl+V ( Shift+Insert) 粘贴选中项目\nCtrl+Z 撤销\nCtrl+Y 重做\nDelete ( Ctrl+D) 删除选中项目至回收站\nShift+Delete 直接删除选中项目\nF2 重命名选中项目\nCtrl+A 全选\nF3 搜索\nAlt+Enter 显示选中项目属性\nAlt+F4 关闭当前项目或退出当前程序\nAlt+空格 打开当前窗口的快捷方式菜单\nAlt+Tab 在当前运行的窗口中切换\nCtrl+Alt+Tab 使用方向键在当前运行的窗口中切换\nCtrl+滚轮 改变桌面图标大小\nwin+Tab 开启Aero Flip 3-D\nCtrl+win +Tab 使用方向键在Aero Flip 3D程序中切换\nAlt+Esc 在当前打开的程序间切换\nF4 显示资源管理器的地址栏列表\nShift+F10 显示选中项目的快捷方式菜单\nCtrl+Esc 打开开始菜单\nF10 激活当前窗口的菜单栏\nF5 ( Ctrl+R) 刷新\nAlt+↑ 资源管理区中返回文件夹的上一级菜单\nEsc 取消当前操作\nCtrl+Shift+Esc 打开任务栏管理器\n插入光盘时按住Shift 禁止CD/DVD的自动运行\n右边或左边的Ctrl+Shift 改变阅读顺序\nhosts文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. #\t127.0.0.1 localhost #\t::1 localhost 浏览器 搜索标签页：Ctrl+shift+a\n截图技巧：F12-\u0026gt;Ctrl+Shift+p-\u0026gt;截图/capture，中文是截图，英文是capture\n打开开发模式：ctrl+shift+j\n打开Chrome浏览器的任务管理器：shift+esc\n打开/关闭书签栏：Ctrl + Shift + B\n为所有标签页添加书签：Ctrl + Shift + D\n打开删除数据器数据：Ctrl + Shift + Delete\n批量提取一个网页里面的链接：可以先用正则表达式将链接提取出来，然后再用在线批量打开链接网站如a-site.cn/tool/kai\n如何在网页上查看时间：点开F12，在控制台输入 document.write(document.lastModified); 指令即可\n从新窗口打开链接：shift+D+鼠标左键点击链接进入跳转\n分页之间切换：ctrl+1..8,ctrl+9到最后一个分页\n从当前分布移动到下一个分页：ctrl+tab，反序切换：ctrl+shift+tab\n关闭或新增分页：关闭分布ctrl+w,撤销关闭分布ctrl+shift+t，新增分页ctrl+t\n快进、恢复、还原：ctrl+加号或等于键，ctrl+减号或杠键，ctrl+右括号或零键\n跳到视频起始处：Fn+右括号或零键\n视频进度起始或结尾切换以及页面滚动：Fn+方向键，空格配合shift反向滚动\n添加书签：ctrl+d\n书签管理：ctrl+shift+o\n查看浏览记录：ctrl+h\n查看下载：ctrl+j\n移动到网址栏：ctrl+l\n刷新页面：ctrl+r或F5\n在同一页面切换链接：alt+左右方向键\n网页查找：ctrl+f或F3\n清除浏览器浏览数据：ctrl+shift+delete\n查看网页原代码：ctrl+u\n如何查看网站记录的密码：针对自动填入网站密码的网站，只需右键菜单点击检查选项查看关于密码的源代码，将密码的type=\u0026#34;原名字\u0026#34;改为text后再点击网页密码的位置即可查看密码\n搜索的快捷方式：在地址栏中输入搜索引擎后按tab即可直接搜索\n在浏览器中从新窗口打开链接：shift+左键点击链接\n关闭所有打开的标签页和浏览器：Ctrl + Shift + w\n退出Chrome浏览器：\nYouTube:\n前一部：shift+p\n后一部：shift+n\n暂停：k\n视频进度跳转：数字键(小跳转)、Fn+方向键(大跳转)\n暂停：k\n静音：m\n油管的观看记录：youtube.com/feed/history\n电影：\n4个免费电影资源网站：imomoe.la、aiyy.tv、aidi.tv、cupfox.com\n网站的访问技巧：\nb站：search.bilibili.com/all?keyword=搜索内容\n油管：https://www.youtube.com/results?search_query=搜索内容\n百度：https://baidu.com/s?\u0026amp;word=1\n360搜索：m.so.com/s?q=1\n谷歌：google.com/search?q=1\ngithub：github.com/search?q=1\nyou.com(搜索引擎)：you.com/search?q=1\n","date":"2024-03-28T00:02:35.87+08:00","permalink":"https://ynhugo.github.io/p/windows%E7%83%AD%E9%94%AE%E5%A4%A7%E5%85%A8/","title":"windows热键大全"},{"content":"\\n：设置文档的标题 参考链接 面向产品经理的Emacs系列教程 remacs的世界\nremacs的世界\n面向产品经理的Emacs系列教程配套配置文件 面向产品经理的Emacs系列教程配套配置文件\nearly-init.el 在Emacs刚启动，还未加载主要配置文件时的配置文件。\n在 Emacs Lisp 中，可以使用 functionp 函数来判断一个符号是否绑定到一个函数上。functionp 函数用于检查一个对象是否是一个函数。如果对象是一个函数，functionp 将返回 t，否则返回 nil。\n下面是一个示例代码，演示了如何使用 if 条件判断函数是否存在：\n1 2 3 (if (functionp \u0026#39;g-org-insert-note-header) (message \u0026#34;函数 g-org-insert-note-header 存在\u0026#34;) (message \u0026#34;函数 g-org-insert-note-header 不存在\u0026#34;)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 ;;; early-init.el --- Emacs pre-initialization config -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: ;; 设置垃圾回收参数 (setq gc-cons-threshold most-positive-fixnum) (setq gc-cons-percentage 0.6) ;; 启动早期不加载`package.el\u0026#39;包管理器 (setq package-enable-at-startup nil) ;; 不从包缓存中加载 (setq package-quickstart nil) ;; 禁止展示菜单栏、工具栏和纵向滚动条 (push \u0026#39;(menu-bar-lines . 0) default-frame-alist) (push \u0026#39;(tool-bar-lines . 0) default-frame-alist) (push \u0026#39;(vertical-scroll-bars) default-frame-alist) ;; 禁止自动缩放窗口先 (setq frame-inhibit-implied-resize t) ;; 禁止Echo Area显示For information about GNU Emacs and the GNU system,type C-h C-a (fset \u0026#39;display-startup-echo-area-message \u0026#39;ignore) ;; 禁止菜单栏、工具栏、滚动条模式，禁止启动屏幕和文件对话框 (menu-bar-mode -1) (if(functionp \u0026#39;scroll-bar-mode) (scroll-bar-mode -1)) (if(functionp \u0026#39;toogle-menu-bar) (toogle-menu-bar -1) ) (if(functionp \u0026#39;tool-bar-mode) (tool-bar-mode -1) ) (setq inhibit-splash-screen t) (setq use-file-dialog nil) ;; 在这个阶段不编译 (setq comp-deferred-compilation nil) (setq frame-title-format \u0026#34;emacs@%b\u0026#34;) ;;在标题栏显示buffer的名字，而不是 emacs@wangyin.com 这样没用的提示。 (provide \u0026#39;early-init) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; early-init.el ends here init.el init.el 是Emacs的主要配置文件。\ninit.el 文件头 1 2 3 4 ;;; init.el --- The main init entry for Emacs -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: package包管理配置 1 2 3 4 5 6 7 8 9 10 11 12 (require \u0026#39;package) (setq package-archives \u0026#39;( (\u0026#34;melpa-cn\u0026#34; . \u0026#34;https://mirrors.ustc.edu.cn/elpa/melpa/\u0026#34;) (\u0026#34;nongnu-cn\u0026#34; . \u0026#34;https://mirrors.ustc.edu.cn/elpa/nongnu/\u0026#34;) (\u0026#34;gnu-cn\u0026#34; . \u0026#34;https://mirrors.ustc.edu.cn/elpa/gnu/\u0026#34;) ;; (\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) ;; (\u0026#34;gnu\u0026#34; . \u0026#34;https://elpa.gnu.org/packages/\u0026#34;) ;; (\u0026#34;nongnu\u0026#34; . \u0026#34;https://elpa.nongnu.org/nongnu/\u0026#34;) )) (package-initialize) 安装use-package插件 use-package 是一个让Emacs配置更加结构化更加清晰的一个宏插件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ;; 安装 `use-package\u0026#39; (unless (package-installed-p \u0026#39;use-package) (package-refresh-contents) (package-install \u0026#39;use-package)) ;; 配置 `use-package\u0026#39; (eval-and-compile (setq use-package-always-ensure nil) (setq use-package-always-defer nil) (setq use-package-expand-minimally nil) (setq use-package-enable-imenu-support t) (if (daemonp) (setq use-package-always-demand t))) (eval-when-compile (require \u0026#39;use-package)) ;; 安装 `use-package\u0026#39; 的集成模块 (use-package use-package-ensure-system-package :ensure t) (use-package diminish :ensure t) (use-package bind-key :ensure t) quelpa包管理器 quelpa 是配合 package.el 使用的，基于git的一个包管理器。\n使用示例：\n示例1 常规操作 1 2 3 4 5 (use-package org-super-links :quelpa (org-super-links :fetcher github :repo \u0026#34;toshism/org-super-links\u0026#34;) :bind :config ) 示例2 github访问不了，使用项目镜像链接 1 2 3 4 5 6 7 (quelpa \u0026#39;(org-super-liks :fetcher git :url \u0026#34;https://hub.nuaa.cf/toshism/org-super-links\u0026#34;)) (use-package org-super-links :ensure nil 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; 安装 `quelpa\u0026#39; (use-package quelpa :ensure t :commands quelpa :config :custom (quelpa-git-clone-depth 1) (quelpa-update-melpa-p nil) (quelpa-self-upgrade-p nil) (quelpa-checkout-melpa-p nil)) ;; `quelpa\u0026#39; 与 `use-package\u0026#39; 集成 (use-package quelpa-use-package :ensure t) 加载模块化配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ;; 将lisp目录放到加载路径的前面以加快启动速度 (let ((dir (locate-user-emacs-file \u0026#34;lisp\u0026#34;))) (add-to-list \u0026#39;load-path (file-name-as-directory dir))) ;; 加载各模块化配置 ;; 不要在`*message*\u0026#39;缓冲区显示加载模块化配置的信息 (with-temp-message \u0026#34;\u0026#34; (require \u0026#39;init-base) ; 一些基本配置 (require \u0026#39;init-ui) ; UI交互 (require \u0026#39;init-edit) ; 编辑行为 (require \u0026#39;init-completion) ; 补全系统 (require \u0026#39;init-dired) ; 文件管理 (require \u0026#39;init-tools) ; 相关工具 (require \u0026#39;init-org) ; org相关设置 (require \u0026#39;init-rss) ; RSS配置 (require \u0026#39;init-shell) ; Shell配置 (require \u0026#39;init-browser) ; 浏览器配置 ) init.el 文件尾 1 2 3 (provide \u0026#39;init) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init.el ends here init-ui.el init-ui.el 文件头 1 2 3 4 ;;; init-ui.el --- UI settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: spacemacs-theme主题 spacemacs-theme 是我非常喜欢的一个主题包。\n1 2 3 4 5 6 7 (use-package spacemacs-theme :ensure t :config (load-theme \u0026#39;spacemacs-dark t) ; Dark theme ;; 或者 ;; (load-theme \u0026#39;spacemacs-light t) ; Light theme ) 其他UI零散设置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 ;; 禁用一些GUI特性 (setq use-dialog-box nil) ; 鼠标操作不使用对话框 (setq inhibit-default-init t) ; 不加载 `default\u0026#39; 库 (setq inhibit-startup-screen t) ; 不加载启动画面 (setq inhibit-startup-message t) ; 不加载启动消息 (setq inhibit-startup-buffer-menu t) ; 不显示缓冲区列表 ;; ;; 草稿缓冲区默认文字设置 ;; (setq initial-scratch-message (concat \u0026#34;;; Happy hacking, \u0026#34; ;; (capitalize user-login-name) \u0026#34; - Emacs ♥ you!\\n\\n\u0026#34;)) ;; 设置缓冲区的文字方向为从左到右 (setq bidi-paragraph-direction \u0026#39;left-to-right) ;; 禁止使用双向括号算法 ;; (setq bidi-inhibit-bpa t) ;; 设置自动折行宽度为80个字符，默认值为70 (setq-default fill-column 80) ;; 设置大文件阈值为100MB，默认10MB (setq large-file-warning-threshold 100000000) ;; ;; 以16进制显示字节数 ;; (setq display-raw-bytes-as-hex t) ;; 有输入时禁止 `fontification\u0026#39; 相关的函数钩子，能让滚动更顺滑 (setq redisplay-skip-fontification-on-input t) ;; 禁止响铃 (setq ring-bell-function \u0026#39;ignore) ;; 禁止闪烁光标 (blink-cursor-mode -1) ;; 在光标处而非鼠标所在位置粘贴 (setq mouse-yank-at-point t) ;; 拷贝粘贴设置 (setq select-enable-primary nil) ; 选择文字时不拷贝 (setq select-enable-clipboard t) ; 拷贝时使用剪贴板 ;; 鼠标滚动设置 (setq scroll-step 2) (setq scroll-margin 0) (setq hscroll-step 2) (setq hscroll-margin 2) (setq scroll-conservatively 101) (setq scroll-up-aggressively 0.01) (setq scroll-down-aggressively 0.01) (setq scroll-preserve-screen-position \u0026#39;always) ;; 对于高的行禁止自动垂直滚动 (setq auto-window-vscroll nil) ;; 设置新分屏打开的位置的阈值 (setq split-width-threshold (assoc-default \u0026#39;width default-frame-alist)) (setq split-height-threshold nil) ;; TAB键设置，在Emacs里不使用TAB键，所有的TAB默认为4个空格 ;; (setq-default indent-tabs-mode nil) ;; (setq-default tab-width 4) (setq-default indent-tabs-mode t) (setq-default tab-width 4) (setq c-default-style \u0026#34;linux\u0026#34;) (setq c-basic-offset 4) ;; yes或no提示设置，通过下面这个函数设置当缓冲区名字匹配到预设的字符串时自动回答yes (setq original-y-or-n-p \u0026#39;y-or-n-p) (defalias \u0026#39;original-y-or-n-p (symbol-function \u0026#39;y-or-n-p)) (defun default-yes-sometimes (prompt) \u0026#34;automatically say y when buffer name match following string\u0026#34; (if (or (string-match \u0026#34;has a running process\u0026#34; prompt) (string-match \u0026#34;does not exist; create\u0026#34; prompt) (string-match \u0026#34;modified; kill anyway\u0026#34; prompt) (string-match \u0026#34;Delete buffer using\u0026#34; prompt) (string-match \u0026#34;Kill buffer of\u0026#34; prompt) (string-match \u0026#34;still connected. Kill it?\u0026#34; prompt) (string-match \u0026#34;Shutdown the client\u0026#39;s kernel\u0026#34; prompt) (string-match \u0026#34;kill them and exit anyway\u0026#34; prompt) (string-match \u0026#34;Revert buffer from file\u0026#34; prompt) (string-match \u0026#34;Kill Dired buffer of\u0026#34; prompt) (string-match \u0026#34;delete buffer using\u0026#34; prompt) (string-match \u0026#34;Kill all pass entry\u0026#34; prompt) (string-match \u0026#34;for all cursors\u0026#34; prompt) (string-match \u0026#34;Do you want edit the entry\u0026#34; prompt)) t (original-y-or-n-p prompt))) (defalias \u0026#39;yes-or-no-p \u0026#39;default-yes-sometimes) (defalias \u0026#39;y-or-n-p \u0026#39;default-yes-sometimes) ;; 设置剪贴板历史长度300，默认为60 (setq kill-ring-max 200) ;; 在剪贴板里不存储重复内容 (setq kill-do-not-save-duplicates t) ;; 设置位置记录长度为6，默认为16 ;; 可以使用 `counsel-mark-ring\u0026#39; or `consult-mark\u0026#39; (C-x j) 来访问光标位置记录 ;; 使用 C-x C-SPC 执行 `pop-global-mark\u0026#39; 直接跳转到上一个全局位置处 ;; 使用 C-u C-SPC 跳转到本地位置处 (setq mark-ring-max 6) (setq global-mark-ring-max 6) ;; 设置 emacs-lisp 的限制 (setq max-lisp-eval-depth 10000) ; 默认值为 800 (setq max-specpdl-size 10000) ; 默认值为 1600 ;; 启用 `list-timers\u0026#39;, `list-threads\u0026#39; 这两个命令 (put \u0026#39;list-timers \u0026#39;disabled nil) (put \u0026#39;list-threads \u0026#39;disabled nil) ;; 在命令行里支持鼠标 (xterm-mouse-mode 1) ;; 退出Emacs时进行确认 (setq confirm-kill-emacs \u0026#39;y-or-n-p) ;; 在模式栏上显示当前光标的列号 (column-number-mode t) (add-hook \u0026#39;org-mode-hook (lambda () (setq truncate-lines nil))) ;自动换行(折行) ;; 显示行号 (if (\u0026gt;= emacs-major-version 29) (global-display-line-numbers-mode) (global-linum-mode t)) (defun reload-emacs-config () (interactive) (load-file \u0026#34;~/.emacs.d/init.el\u0026#34;)) (global-set-key (kbd \u0026#34;C-c C-SPC\u0026#34;) \u0026#39;reload-emacs-config) (defun close-current-window () (interactive) (delete-window) ) (global-set-key (kbd \u0026#34;C-c z\u0026#34;) \u0026#39;close-current-window) 编码设置 统一使用 UTF-8 编码。\n1 2 3 ;; 配置编码 (prefer-coding-system \u0026#39;utf-8) (setq-default buffer-file-coding-system \u0026#39;utf-8) keycast按键展示 keycast mode 插件可以在模式栏上展示所有的按键，以及对应的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 (use-package keycast :ensure t :hook (after-init . keycast-mode) ;; :custom-face ;; (keycast-key ((t (:background \u0026#34;#0030b4\u0026#34; :weight bold)))) ;; (keycast-command ((t (:foreground \u0026#34;#0030b4\u0026#34; :weight bold)))) :config ;; set for doom-modeline support ;; With the latest change 72d9add, mode-line-keycast needs to be modified to keycast-mode-line. (define-minor-mode keycast-mode \u0026#34;Show current command and its key binding in the mode line (fix for use with doom-mode-line).\u0026#34; :global t (if keycast-mode (progn (add-hook \u0026#39;pre-command-hook \u0026#39;keycast--update t) (add-to-list \u0026#39;global-mode-string \u0026#39;(\u0026#34;\u0026#34; keycast-mode-line \u0026#34; \u0026#34;))) (remove-hook \u0026#39;pre-command-hook \u0026#39;keycast--update) (setq global-mode-string (delete \u0026#39;(\u0026#34;\u0026#34; keycast-mode-line \u0026#34; \u0026#34;) global-mode-string)) )) (dolist (input \u0026#39;(self-insert-command org-self-insert-command)) (add-to-list \u0026#39;keycast-substitute-alist `(,input \u0026#34;.\u0026#34; \u0026#34;Typing…\u0026#34;))) (dolist (event \u0026#39;(mouse-event-p mouse-movement-p mwheel-scroll)) (add-to-list \u0026#39;keycast-substitute-alist `(,event nil))) (setq keycast-log-format \u0026#34;%-20K%C\\n\u0026#34;) (setq keycast-log-frame-alist \u0026#39;((minibuffer . nil))) (setq keycast-log-newest-first t) ) shackle窗口管理 shackle 插件能自定义窗口的弹出方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (use-package shackle :ensure t :hook (after-init . shackle-mode) :init (setq shackle-lighter \u0026#34;\u0026#34;) (setq shackle-select-reused-windows nil) ; default nil (setq shackle-default-alignment \u0026#39;below) ; default below (setq shackle-default-size 0.4) ; default 0.5 (setq shackle-rules ;; CONDITION(:regexp) :select :inhibit-window-quit :size+:align|:other :same|:popup \u0026#39;((compilation-mode :ignore t) (\u0026#34;\\\\*Async Shell.*\\\\*\u0026#34; :regexp t :ignore t) (\u0026#34;\\\\*corfu.*\\\\*\u0026#34; :regexp t :ignore t) (\u0026#34;*eshell*\u0026#34; :select t :size 0.4 :align t :popup t) (helpful-mode :select t :size 0.6 :align right :popup t) (\u0026#34;*Messages*\u0026#34; :select t :size 0.4 :align t :popup t) (\u0026#34;*Calendar*\u0026#34; :select t :size 0.3 :align t :popup t) (\u0026#34;*info*\u0026#34; :select t :same t) (magit-status-mode :select t :inhibit-window-quit t :same t) (magit-log-mode :select t :inhibit-window-quit t :same t) )) ) popper窗口弹出管理 我们通过 popper 插件，来控制窗口的弹出行为，与 shackle 一起配合使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 (use-package popper :ensure t :bind ((\u0026#34;M-`\u0026#34; . popper-toggle-latest) (\u0026#34;M-\u0026lt;tab\u0026gt;\u0026#34; . popper-cycle) (\u0026#34;M-\\\\\u0026#34; . popper-toggle-type) ) :init (setq popper-reference-buffers \u0026#39;(\u0026#34;\\\\*Messages\\\\*\u0026#34; \u0026#34;\\\\*Async Shell Command\\\\*\u0026#34; help-mode helpful-mode occur-mode pass-view-mode \u0026#34;^\\\\*eshell.*\\\\*$\u0026#34; eshell-mode ;; eshell as a popup \u0026#34;^\\\\*shell.*\\\\*$\u0026#34; shell-mode ;; shell as a popup (\u0026#34;\\\\*corfu\\\\*\u0026#34; . hide) (compilation-mode . hide) ;; derived from `fundamental-mode\u0026#39; and fewer than 10 lines will be considered a popup (lambda (buf) (with-current-buffer buf (and (derived-mode-p \u0026#39;fundamental-mode) (\u0026lt; (count-lines (point-min) (point-max)) 10)))) ) ) (popper-mode +1) (popper-echo-mode +1) :config ;; group by project.el, projectile, directory or perspective (setq popper-group-function nil) ;; pop in child frame or not (setq popper-display-function #\u0026#39;display-buffer-in-child-frame) ;; use `shackle.el\u0026#39; to control popup (setq popper-display-control nil) ) winner窗口管理 内置的 winner 插件是一个窗口管理器，可以通过 winner-undo 和 winner-redo 命令恢复或重做窗口布局。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (use-package winner :ensure nil :hook (after-init . winner-mode) :commands (winner-undo winner-redo) :config (setq winner-boring-buffers \u0026#39;(\u0026#34;*Completions*\u0026#34; \u0026#34;*Compile-Log*\u0026#34; \u0026#34;*inferior-lisp*\u0026#34; \u0026#34;*Fuzzy Completions*\u0026#34; \u0026#34;*Apropos*\u0026#34; \u0026#34;*Help*\u0026#34; \u0026#34;*cvs*\u0026#34; \u0026#34;*Buffer List*\u0026#34; \u0026#34;*Ibuffer*\u0026#34; \u0026#34;*esh command on file*\u0026#34;)) ) init-ui.el 文件尾 1 2 3 (provide \u0026#39;init-ui) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-ui.el ends here init-base.el init-base.el 文件头 1 2 3 4 ;;; init-base.el --- Basical settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: savehist记住迷你缓冲区历史 记住迷你缓冲区历史。\n1 2 3 4 5 6 7 8 9 10 11 12 13 (use-package savehist :ensure nil :hook (after-init . savehist-mode) :config ;; Allow commands in minibuffers, will affect `dired-do-dired-do-find-regexp-and-replace\u0026#39; command: (setq enable-recursive-minibuffers t) (setq history-length 1000) (setq savehist-additional-variables \u0026#39;(mark-ring global-mark-ring search-ring regexp-search-ring extended-command-history)) (setq savehist-autosave-interval 300)) saveplace记住每个文件的光标位置 自动记住每个文件的最后一次访问的光标位置。\n1 2 3 (use-package saveplace :ensure nil :hook (after-init . save-place-mode)) undo-tree撤销设置 undo-tree 插件可以提供一个可视化的撤销、重做系统，我们使用 C-/ 来撤销，使用 M-_ 来重做。\n1 2 3 4 5 6 7 (use-package undo-tree :ensure t :hook (after-init . global-undo-tree-mode) :config ;; don\u0026#39;t save undo history to local files (setq undo-tree-auto-save-history nil) ) super-save自动保存 super-save 插件能自动保存缓冲区。它可以设置在某些行为（如窗口切换、或窗口空闲一段时间）下自动保存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 (use-package super-save :ensure t :hook (after-init . super-save-mode) :config ;; Emacs空闲是否自动保存，这里不设置 (setq super-save-auto-save-when-idle nil) ;; 切换窗口自动保存 (add-to-list \u0026#39;super-save-triggers \u0026#39;other-window) ;; 查找文件时自动保存 (add-to-list \u0026#39;super-save-hook-triggers \u0026#39;find-file-hook) ;; 远程文件编辑不自动保存 (setq super-save-remote-files nil) ;; 特定后缀名的文件不自动保存 (setq super-save-exclude \u0026#39;(\u0026#34;.gpg\u0026#34;)) ;; 自动保存时，保存所有缓冲区 (defun super-save/save-all-buffers () (save-excursion (dolist (buf (buffer-list)) (set-buffer buf) (when (and buffer-file-name (buffer-modified-p (current-buffer)) (file-writable-p buffer-file-name) (if (file-remote-p buffer-file-name) super-save-remote-files t)) (save-buffer))))) (advice-add \u0026#39;super-save-command :override \u0026#39;super-save/save-all-buffers) ) init-base.el 文件尾 1 2 3 (provide \u0026#39;init-base) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-base.el ends here init-edit.el init-edit.el 文件头 1 2 3 4 ;;; init-edit.el --- Editing settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: Emacs备份设置 不使用Emacs的自动备份设置。\n1 2 (setq make-backup-files nil) ; 不自动备份 (setq auto-save-default nil) ; 不使用Emacs自带的自动保存 解除一些不常用的快捷键 将一些不常用的快捷键解除，防止误操作。\n1 2 3 4 5 6 ;; 解除不常用的快捷键定义 (global-set-key (kbd \u0026#34;s-q\u0026#34;) nil) (global-set-key (kbd \u0026#34;M-z\u0026#34;) nil) (global-set-key (kbd \u0026#34;M-m\u0026#34;) nil) (global-set-key (kbd \u0026#34;C-x C-z\u0026#34;) nil) (global-set-key [mouse-2] nil) delsel选择文本输入时直接替换 Emacs默认选择文本后直接输入，是不会直接删除所选择的文本进行替换的。通过内置的 delsel 插件来实现这个行为。\n1 2 3 4 ;; Directly modify when selecting text (use-package delsel :ensure t :hook (after-init . delete-selection-mode)) 自动重载设置 当我们的文件发生了改变后，我们希望Emacs里打开的永远是最新的文件，这个时候，我们需要对自动重载进行设置，让我们的Emacs在文件发生改变的时候自动重载文件。\n1 2 3 4 5 6 7 8 9 10 11 (use-package autorevert :ensure t :hook (after-init . global-auto-revert-mode) ;; :bind (\u0026#34;s-u\u0026#34; . revert-buffer) :custom (auto-revert-interval 10) (auto-revert-avoid-polling t) (auto-revert-verbose nil) (auto-revert-remote-files t) (auto-revert-check-vc-info t) (global-auto-revert-non-file-buffers t)) avy光标移动 avy 是一个光标移动插件，能快速将光标移动到屏幕上的任意字符，非常强大！\n1 2 3 4 (use-package avy :ensure t :bind ((\u0026#34;M-j\u0026#34; . avy-goto-char-timer))) amx 记录命令历史 amx - GitHub 主页\n这个插件可以记录我们每次调用 M-x 时输入的命令历史，然后每次将最常用的显示在前面，这对于我们短时间希望频繁输入某几个命令的场景非常有用。\n1 2 3 (use-package amx :ensure t :init (amx-mode)) window-numbering 快捷键切换窗口 分屏之后的emacs在屏幕切换的时候会比较麻烦，针对这个功能有一个可以实现这个的插件，也就是window-numbering。\n使用方法：\u0026lt;M-number\u0026gt;\n1 2 3 4 5 (use-package window-numbering :ensure t ;; :defer 3 :init (window-numbering-mode t) ) mwim 优化光标移动到行首/行尾 mwim - GitHub 主页\nC-a 对应了 move-beginning-of-line，M-m 对应了 back-to-indentation。当代码有缩进时，前者会把光标移动到行首（到空格之前），后者会移动到代码文字的开头（到空格之后）。那么实际中这两个按法差别较大，且不易区分，使用起来不方便。mwim 就将二者合并，覆盖 C-a 为 mwim-beginning-of-code-or-line，这样按一次 C-a 时移动到代码文字开头，再按一次则是移动到整行的行首，如此反复。\n同时，更有意义的是，它还可以覆盖 C-e move-end-of-line 为 mwim-end-of-code-or-line，当本行代码结尾有注释时，第一次按 C-e 将光标移动到代码尾部、注释之前。再按一次则是移动到整行的行尾。 这就大大提高了写代码的效率。\n1 2 3 4 5 (use-package mwim :ensure t :bind (\u0026#34;C-a\u0026#34; . mwim-beginning-of-code-or-line) (\u0026#34;C-e\u0026#34; . mwim-end-of-code-or-line)) dashboard 配置欢迎页面 dashboard - GitHub 主页\n起初每当我们打开 Emacs 都有一个欢迎界面，显示了一些 Emacs 的帮助信息。这对刚入门而言比较方便，但当我们熟练后这个页面就逐渐无用了。dashboard 就是一个新的欢迎界面，可以列出最近打开的项目、最近打开的文件等等。按下 p 或 r 就可以快速 跳转到相应小结里。还可以列出来标记过的书签、org-mode （Emacs 自带的一个强大的笔记系统）日程、自定义控件等。\n1 2 3 4 5 6 7 8 9 10 (use-package dashboard :ensure t :config ;; (setq dashboard-banner-logo-title \u0026#34;Welcome to Emacs!\u0026#34;) ;; 个性签名，随读者喜好设置 ;; (setq dashboard-projects-backend \u0026#39;projectile) ;; 读者可以暂时注释掉这一行，等安装了 projectile 后再使用 (setq dashboard-startup-banner \u0026#39;official) ;; 也可以自定义图片 (setq dashboard-items \u0026#39;((recents . 10) ;; 显示多少个最近文件 (bookmarks . 10) ;; 显示多少个最近书签 (projects . 10))) ;; 显示多少个最近项目 (dashboard-setup-startup-hook)) projectile 配合dashboard使用\n1 2 (use-package projectile :ensure t) marginalia 为 Emacs minibuffer 中的选项添加注解 marginalia - GitHub 主页\n一个为 Emacs minibuffer 中的选项添加注解的插件。\n1 2 3 4 5 (use-package marginalia :ensure t :init (marginalia-mode) :bind (:map minibuffer-local-map (\u0026#34;M-A\u0026#34; . marginalia-cycle))) which-key 根据快捷键前缀提示快捷键 which-key - GitHub 主页\n当按下部分快捷键前缀时，它会通过 minibuffer 提示你都有哪些可以按的快捷键及其命令名。\n1 2 3 (use-package which-key :ensure t :init (which-key-mode)) hydra 把一组特定场景的命令组织到一起， 通过简单按键来进行调用 hydra - GitHub 主页\nhydra 主要功能是把一组特定场景的命令组织到一起， 通过简单按键来进行调用。\n1 2 (use-package hydra :ensure t) use-package-hydra 配合hydra使用\n1 2 3 (use-package use-package-hydra :ensure t :after hydra) multiple-cursors多光标编辑 multiple-cursors 插件能让Emacs实现多光标编辑和移动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 (use-package multiple-cursors :ensure t :after hydra :bind ((\u0026#34;C-x M-h m\u0026#34; . hydra-multiple-cursors/body) (\u0026#34;C-M-\u0026lt;mouse-1\u0026gt;\u0026#34; . mc/toggle-cursor-on-click)) :hydra (hydra-multiple-cursors (:hint nil) \u0026#34; Up^^ Down^^ Miscellaneous % 2(mc/num-cursors) cursor%s(if (\u0026gt; (mc/num-cursors) 1) \\\u0026#34;s\\\u0026#34; \\\u0026#34;\\\u0026#34;) ------------------------------------------------------------------ [_p_] Prev [_n_] Next [_l_] Edit lines [_0_] Insert numbers [_P_] Skip [_N_] Skip [_a_] Mark all [_A_] Insert letters [_M-p_] Unmark [_M-n_] Unmark [_s_] Search [_q_] Quit [_|_] Align with input CHAR [Click] Cursor at point\u0026#34; (\u0026#34;l\u0026#34; mc/edit-lines :exit t) (\u0026#34;a\u0026#34; mc/mark-all-like-this :exit t) (\u0026#34;n\u0026#34; mc/mark-next-like-this) (\u0026#34;N\u0026#34; mc/skip-to-next-like-this) (\u0026#34;M-n\u0026#34; mc/unmark-next-like-this) (\u0026#34;p\u0026#34; mc/mark-previous-like-this) (\u0026#34;P\u0026#34; mc/skip-to-previous-like-this) (\u0026#34;M-p\u0026#34; mc/unmark-previous-like-this) (\u0026#34;|\u0026#34; mc/vertical-align) (\u0026#34;s\u0026#34; mc/mark-all-in-region-regexp :exit t) (\u0026#34;0\u0026#34; mc/insert-numbers :exit t) (\u0026#34;A\u0026#34; mc/insert-letters :exit t) (\u0026#34;\u0026lt;mouse-1\u0026gt;\u0026#34; mc/add-cursor-on-click) ;; Help with click recognition in this hydra (\u0026#34;\u0026lt;down-mouse-1\u0026gt;\u0026#34; ignore) (\u0026#34;\u0026lt;drag-mouse-1\u0026gt;\u0026#34; ignore) (\u0026#34;q\u0026#34; nil))) highlight-symbol 高亮出当前 Buffer 中所有的、与光标所在处的符号相同的符号 highlight-symbol - GitHub 主页\n这个插件可以高亮出当前 Buffer 中所有的、与光标所在处的符号相同的符号。也就是例如一些同名变量、函数名等。虽然在后面我们使用一些其他插件时也会捎带有类似功能，但它可以同时高亮很多字符，便于阅读代码等。\n1 2 3 4 5 6 7 8 (use-package highlight-symbol :ensure t :init (highlight-symbol-mode) :bind ( (\u0026#34;\u0026lt;f10\u0026gt;\u0026#34; . highlight-symbol)\t; 按下 F10 键就可高亮当前符号 (\u0026#34;\u0026lt;f9\u0026gt;\u0026#34; . highlight-symbol-remove-all) ; 取消 Emacs 中所有当前高亮的符号 ) ) rainbow-delimiters 用不同颜色标记多级括号，方便看清代码块 rainbow-delimiters - GitHub 主页\n这个插件可以用不同颜色标记多级括号，方便看清代码块（尤其在 EmacsLisp 中）。\n1 2 3 (use-package rainbow-delimiters :ensure t :hook (prog-mode . rainbow-delimiters-mode)) evil（为 Vim 用户） evil - GitHub 主页\nevil 可以让习惯了 Vim 的用户在 Emacs 中使用 Vim 按键方式，大大减轻了 Vim 用户转入 Emacs 的成本。\n1 2 3 4 5 (use-package evil :ensure t ;; :init (evil-mode) :bind ((\u0026#34;C-x C-z\u0026#34; . evil-mode))) WorkLogReport 工作日志报告 插入工作日志报告模板\n为什么%s会被替换为时间戳而不是其他内容被替换为时间戳，原理是什么 这是因为在 Emacs Lisp 中，`format` 函数的工作方式类似于 C 语言中的 `printf` 函数。`format` 函数接受一个格式字符串和一系列参数，然后根据格式字符串中的格式指定符（如 `%s`、`%d` 等）将后续的参数插入到格式字符串中。\n在你的代码中，`format` 函数的格式字符串是：\n```lisp \u0026#34;* %s ,#+BEGIN_SRC emacs-lisp :tangle %s.txt %s: name\\n1、 ,#+END_SRC\u0026#34; ```\n这个字符串中有三个 `%s`，所以 `format` 函数需要三个额外的参数。在你的代码中，这三个参数都是 `block-name`，即你处理过的时间戳。\n所以，当 `format` 函数运行时，它会依次取出 `block-name`，并将其插入到格式字符串中的 `%s` 的位置。这就是为什么 `%s` 会被替换为时间戳的原理。\n如果你希望将不同的内容插入到格式字符串中，你只需提供不同的参数即可。例如：\n```lisp (format \u0026#34;Hello, %s! Today is %s.\u0026#34; \u0026#34;Alice\u0026#34; \u0026#34;Monday\u0026#34;) ```\n这段代码会返回字符串 \u0026#34;Hello, Alice! Today is Monday.\u0026#34;。 ,****************************************************************************** 这句有什么用：(block-name (concat clean-time)) ; 构建代码块名 这一句 `(block-name (concat clean-time))` 的作用是创建一个新的变量 `block-name`，并将其设置为 `clean-time` 的值。\n在这个上下文中，`clean-time` 是一个已经去除了破折号和冒号的时间字符串。`concat` 函数通常用于连接多个字符串，但在这里，它只有一个参数 `clean-time`，所以它实际上只是返回 `clean-time` 的值。\n因此，这一句的效果就是创建了一个新的变量 `block-name`，并将其设置为与 `clean-time` 相同的值。后面的代码中使用 `block-name` 作为代码块的名字。\n如果你的代码中没有需要使用不同的名称来表示清理过的时间戳，那么这一行代码实际上是不必要的，你可以直接使用 `clean-time`。但是，如果你打算在后续的代码中修改 `block-name` 或 `clean-time` 的值，那么这一行代码就很有用了，因为它确保了 `block-name` 和 `clean-time` 是两个独立的变量，修改一个不会影响另一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (defun add-code-block () \u0026#34;在当前位置添加一个代码块，并以时间作为块名进行命名\u0026#34; (interactive) (let* ((time (format-time-string \u0026#34;%Y-%m-%d\u0026#34;)) ; 获取当前时间 (clean-time (replace-regexp-in-string \u0026#34;[-:]\u0026#34; \u0026#34;\u0026#34; time)) ; 去除时间中的破折号和冒号 (block-name (concat clean-time)) ; 构建代码块名 (code-block (format \u0026#34;*** %s\\n ,#+BEGIN_SRC emacs-lisp :tangle %s.txt %s: name\\n1、 ,#+END_SRC\\n\\n\u0026#34; block-name clean-time block-name))) (insert code-block))) ; 在当前位置插入代码块 ;; 设置快捷键 C-c b 绑定到 add-code-block 函数 (global-set-key (kbd \u0026#34;C-c SPC r\u0026#34;) \u0026#39;add-code-block) g-org-insert-note-header 插入一些 Org 模式的头部信息 用于在当前光标位置插入一些 Org 模式的头部信息。这些头部信息包括了一些选项，标题，作者以及一些其他设置\n1 2 3 4 5 6 (defun g-org-insert-note-header () ;;; 定义一个名为g-org-insert-note-header ()的函数 (interactive) ;;; 函数的一个特殊声明，表示函数可以被用户调用 (insert \u0026#34;#+TITLE: \\n#+AUTHOR: yenao\\n#+OPTIONS: toc:t num:10 H:10 ^:nil \\\\n:t broken-links:nil pri:t\\n#+STARTUP: overview\\n#+HTML_HEAD: \\\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; type=\\\u0026#34;text\\/css\\\u0026#34; href=\\\u0026#34;http:\\/\\/gongzhitaao.org\\/orgcss\\/org.css\\\u0026#34;\\/\\\u0026gt;\\n\u0026#34; )) ;;; insert函数用于在当前 光标位置插入指定的文本内容，当你调用这个函数时，它会在当前光标位置插入文本#+OPTIONS: ^:nil、#+TITLE: 和#+AUTHOR: yenao ;; #+LANGUAGE: zh-CN ;; zh-CN或者en g-org-emacs-lisp-code-block 插入emacs-lisp代码块 用于插入emacs-lisp代码块\n1 2 3 4 (defun g-org-emacs-lisp-code-block () (interactive) (insert \u0026#34;#+begin_src emacs-lisp\\n\\n#+end_src\u0026#34;) ) g-org-c-code-block 插入C语言代码块 用于插入c语言的代码块\n1 2 3 4 (defun g-org-c-code-block () (interactive) (insert \u0026#34;#+begin_src c\\n\\n#+end_src\u0026#34;) ) g-org-bash-code-block 插入bash语言的代码块 用于插入bash语言的代码块\n1 2 3 4 (defun g-org-bash-code-block () (interactive) (insert \u0026#34;#+begin_src bash\\n\\n#+end_src\u0026#34;) ) g-org-html-code-block 插入html语言的代码块 用于插入html语言的代码块\n1 2 3 4 (defun g-org-html-code-block () (interactive) (insert \u0026#34;#+begin_src html\\n\\n#+end_src\u0026#34;) ) markdown 使emacs支持markdown模式编辑文件\n1 2 3 4 5 6 7 8 9 10 (use-package markdown-mode :ensure t :defer t :config ;;markdown设置 (autoload \u0026#39;markdown-mode \u0026#34;markdown-mode\u0026#34; \u0026#34;Major mode for editing Markdown files\u0026#34; t) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.markdown\\\\\u0026#39;\u0026#34; . markdown-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.md\\\\\u0026#39;\u0026#34; . markdown-mode)) ) init-edit.el 文件尾 1 2 3 4 5 6 ;; (message \u0026#34;init-base configuration: %.2fs\u0026#34; ;; (float-time (time-subtract (current-time) my/init-base-start-time))) (provide \u0026#39;init-edit) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-edit.el ends here init-org.el init-org.el 文件头 1 2 3 4 ;;; init-org.el --- Org mode settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: org-appear自动展开强调链接 通过 org-appear 插件，当我们的光标移动到Org mode里的强调、链接上时，会自动展开，这样方便进行编辑。\n1 2 3 4 5 6 7 8 9 10 (use-package org-appear :ensure t :hook (org-mode . org-appear-mode) :config (setq org-appear-autolinks t) (setq org-appear-autosubmarkers t) (setq org-appear-autoentities t) (setq org-appear-autokeywords t) (setq org-appear-inside-latex t) ) org-auto-tangle自动tangle设置 org-auto-tangle 插件可以在Org mode下自动进行tangle。\n1 2 3 4 5 6 (use-package org-auto-tangle :ensure t :hook (org-mode . org-auto-tangle-mode) :config (setq org-auto-tangle-default t) ) org-capture快速记录设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 (use-package org-capture :ensure nil :bind (\u0026#34;C-c c\u0026#34; . (lambda () (interactive) (org-capture))) :hook ((org-capture-mode . (lambda () (setq-local org-complete-tags-always-offer-all-agenda-tags t))) (org-capture-mode . delete-other-windows)) :custom (org-capture-use-agenda-date nil) ;; define common template (org-capture-templates `((\u0026#34;t\u0026#34; \u0026#34;Tasks\u0026#34; entry (file+headline \u0026#34;tasks.org\u0026#34; \u0026#34;Reminders\u0026#34;) \u0026#34;* TODO %i%?\u0026#34; :empty-lines-after 1 :prepend t) (\u0026#34;n\u0026#34; \u0026#34;Notes\u0026#34; entry (file+headline \u0026#34;capture.org\u0026#34; \u0026#34;Notes\u0026#34;) \u0026#34;* %? %^g\\n%i\\n\u0026#34; :empty-lines-after 1) ;; For EWW (\u0026#34;b\u0026#34; \u0026#34;Bookmarks\u0026#34; entry (file+headline \u0026#34;capture.org\u0026#34; \u0026#34;Bookmarks\u0026#34;) \u0026#34;* %:description\\n\\n%a%?\u0026#34; :empty-lines 1 :immediate-finish t) (\u0026#34;d\u0026#34; \u0026#34;Diary\u0026#34;) (\u0026#34;dt\u0026#34; \u0026#34;Today\u0026#39;s TODO list\u0026#34; entry (file+olp+datetree \u0026#34;diary.org\u0026#34;) \u0026#34;* Today\u0026#39;s TODO list [/]\\n%T\\n\\n** TODO %?\u0026#34; :empty-lines 1 :jump-to-captured t) (\u0026#34;do\u0026#34; \u0026#34;Other stuff\u0026#34; entry (file+olp+datetree \u0026#34;diary.org\u0026#34;) \u0026#34;* %?\\n%T\\n\\n%i\u0026#34; :empty-lines 1 :jump-to-captured t) )) ) denote笔记设置 denote 是一个轻量级的笔记插件，拥有良好的文件名命名模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 (use-package denote :ensure t :hook (dired-mode . denote-dired-mode-in-directories) :bind ((\u0026#34;C-c d n\u0026#34; . denote) (\u0026#34;C-c d d\u0026#34; . denote-date) (\u0026#34;C-c d t\u0026#34; . denote-type) (\u0026#34;C-c d s\u0026#34; . denote-subdirectory) (\u0026#34;C-c d f\u0026#34; . denote-open-or-create) (\u0026#34;C-c d r\u0026#34; . denote-dired-rename-file)) :init (with-eval-after-load \u0026#39;org-capture (setq denote-org-capture-specifiers \u0026#34;%l\\n%i\\n%?\u0026#34;) (add-to-list \u0026#39;org-capture-templates \u0026#39;(\u0026#34;N\u0026#34; \u0026#34;New note (with denote.el)\u0026#34; plain (file denote-last-path) #\u0026#39;denote-org-capture :no-save t :immediate-finish nil :kill-buffer t :jump-to-captured t))) :config (setq denote-directory (expand-file-name \u0026#34;~/org/denote/\u0026#34;)) (setq denote-known-keywords \u0026#39;(\u0026#34;emacs\u0026#34; \u0026#34;entertainment\u0026#34; \u0026#34;reading\u0026#34; \u0026#34;studying\u0026#34;)) (setq denote-infer-keywords t) (setq denote-sort-keywords t) ;; org is default, set others such as text, markdown-yaml, markdown-toml (setq denote-file-type nil) (setq denote-prompts \u0026#39;(title keywords)) ;; We allow multi-word keywords by default. The author\u0026#39;s personal ;; preference is for single-word keywords for a more rigid workflow. (setq denote-allow-multi-word-keywords t) (setq denote-date-format nil) ;; If you use Markdown or plain text files (Org renders links as buttons ;; right away) (add-hook \u0026#39;find-file-hook #\u0026#39;denote-link-buttonize-buffer) (setq denote-dired-rename-expert nil) ;; OR if only want it in `denote-dired-directories\u0026#39;: (add-hook \u0026#39;dired-mode-hook #\u0026#39;denote-dired-mode-in-directories) ) consult-notes查找笔记 consult-notes 插件可以通过consult快速找到笔记。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 (use-package consult-notes :ensure t :commands (consult-notes consult-notes-search-in-all-notes) :bind ((\u0026#34;C-c n f\u0026#34; . consult-notes) (\u0026#34;C-c n c\u0026#34; . consult-notes-search-in-all-notes)) :config (setq consult-notes-file-dir-sources `( (\u0026#34;work\u0026#34; ?w ,(concat org-directory \u0026#34;/midea/\u0026#34;)) (\u0026#34;article\u0026#34; ?a ,(concat org-directory \u0026#34;/article/\u0026#34;)) (\u0026#34;org\u0026#34; ?o ,(concat org-directory \u0026#34;/\u0026#34;)) (\u0026#34;hugo\u0026#34; ?h ,(concat org-directory \u0026#34;/hugo/\u0026#34;)) (\u0026#34;books\u0026#34; ?b ,(concat (getenv \u0026#34;HOME\u0026#34;) \u0026#34;/Books/\u0026#34;)) )) ;; embark support (with-eval-after-load \u0026#39;embark (defun consult-notes-open-dired (cand) \u0026#34;Open notes directory dired with point on file CAND.\u0026#34; (interactive \u0026#34;fNote: \u0026#34;) ;; dired-jump is in dired-x.el but is moved to dired in Emacs 28 (dired-jump nil cand)) (defun consult-notes-marked (cand) \u0026#34;Open a notes file CAND in Marked 2. Marked 2 is a mac app that renders markdown.\u0026#34; (interactive \u0026#34;fNote: \u0026#34;) (call-process-shell-command (format \u0026#34;open -a \\\u0026#34;Marked 2\\\u0026#34; \\\u0026#34;%s\\\u0026#34;\u0026#34; (expand-file-name cand)))) (defun consult-notes-grep (cand) \u0026#34;Run grep in directory of notes file CAND.\u0026#34; (interactive \u0026#34;fNote: \u0026#34;) (consult-grep (file-name-directory cand))) (embark-define-keymap consult-notes-map \u0026#34;Keymap for Embark notes actions.\u0026#34; :parent embark-file-map (\u0026#34;d\u0026#34; consult-notes-dired) (\u0026#34;g\u0026#34; consult-notes-grep) (\u0026#34;m\u0026#34; consult-notes-marked)) (add-to-list \u0026#39;embark-keymap-alist `(,consult-notes-category . consult-notes-map)) ;; make embark-export use dired for notes (setf (alist-get consult-notes-category embark-exporters-alist) #\u0026#39;embark-export-dired) ) ) org-super-links反链设置 org-super-links 插件可以设置反向链接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (quelpa \u0026#39;(org-super-liks :fetcher git :url \u0026#34;https://hub.nuaa.cf/toshism/org-super-links\u0026#34;)) (use-package org-super-links :ensure nil :bind ((\u0026#34;C-c s s\u0026#34; . org-super-links-link) (\u0026#34;C-c s l\u0026#34; . org-super-links-store-link) (\u0026#34;C-c s C-l\u0026#34; . org-super-links-insert-link) (\u0026#34;C-c s d\u0026#34; . org-super-links-quick-insert-drawer-link) (\u0026#34;C-c s i\u0026#34; . org-super-links-quick-insert-inline-link) (\u0026#34;C-c s C-d\u0026#34; . org-super-links-delete-link)) :config (setq org-super-links-related-into-drawer t) (setq\torg-super-links-link-prefix \u0026#39;org-super-links-link-prefix-timestamp)) ox文件导出通用设置 下面是org文件导出的通用设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 (use-package ox :ensure nil :custom (org-export-with-toc t) (org-export-with-tags \u0026#39;not-in-toc) (org-export-with-drawers nil) (org-export-with-priority t) (org-export-with-footnotes t) (org-export-with-smart-quotes t) (org-export-with-section-numbers t) (org-export-with-sub-superscripts \u0026#39;{}) ;; `org-export-use-babel\u0026#39; set to nil will cause all source block header arguments to be ignored This means that code blocks with the argument :exports none or :exports results will end up in the export. ;; See: ;; https://stackoverflow.com/questions/29952543/how-do-i-prevent-org-mode-from-executing-all-of-the-babel-source-blocks (org-export-use-babel t) (org-export-headline-levels 9) (org-export-coding-system \u0026#39;utf-8) (org-export-with-broken-links \u0026#39;mark) (org-export-default-language \u0026#34;zh-CN\u0026#34;) ; 默认是en ;; (org-ascii-text-width 72) ) org导出后端设置 ox-html导出HTML设置 我们先来对HTML导出做一个基本设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (use-package ox-html :ensure nil :init ;; add support for video (defun org-video-link-export (path desc backend) (let ((ext (file-name-extension path))) (cond ((eq \u0026#39;html backend) (format \u0026#34;\u0026lt;video width=\u0026#39;800\u0026#39; preload=\u0026#39;metadata\u0026#39; controls=\u0026#39;controls\u0026#39;\u0026gt;\u0026lt;source type=\u0026#39;video/%s\u0026#39; src=\u0026#39;%s\u0026#39; /\u0026gt;\u0026lt;/video\u0026gt;\u0026#34; ext path)) ;; fall-through case for everything else (t path)))) (org-link-set-parameters \u0026#34;video\u0026#34; :export \u0026#39;org-video-link-export) :custom (org-html-doctype \u0026#34;html5\u0026#34;) (org-html-html5-fancy t) (org-html-checkbox-type \u0026#39;unicode) (org-html-validation-link nil)) (use-package htmlize :ensure t :custom (htmlize-pre-style t) (htmlize-output-type \u0026#39;inline-css)) ox-latex导出PDF设置 ox-latex 是Org mode自带的功能，可以将Org文件导出为latex文件和PDF文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 (use-package ox-latex :ensure nil :defer t :config (add-to-list \u0026#39;org-latex-classes \u0026#39;(\u0026#34;cn-article\u0026#34; \u0026#34;\\\\documentclass[UTF8,a4paper]{article}\u0026#34; (\u0026#34;\\\\section{%s}\u0026#34; . \u0026#34;\\\\section*{%s}\u0026#34;) (\u0026#34;\\\\subsection{%s}\u0026#34; . \u0026#34;\\\\subsection*{%s}\u0026#34;) (\u0026#34;\\\\subsubsection{%s}\u0026#34; . \u0026#34;\\\\subsubsection*{%s}\u0026#34;) (\u0026#34;\\\\paragraph{%s}\u0026#34; . \u0026#34;\\\\paragraph*{%s}\u0026#34;) (\u0026#34;\\\\subparagraph{%s}\u0026#34; . \u0026#34;\\\\subparagraph*{%s}\u0026#34;))) (add-to-list \u0026#39;org-latex-classes \u0026#39;(\u0026#34;cn-report\u0026#34; \u0026#34;\\\\documentclass[11pt,a4paper]{report}\u0026#34; (\u0026#34;\\\\chapter{%s}\u0026#34; . \u0026#34;\\\\chapter*{%s}\u0026#34;) (\u0026#34;\\\\section{%s}\u0026#34; . \u0026#34;\\\\section*{%s}\u0026#34;) (\u0026#34;\\\\subsection{%s}\u0026#34; . \u0026#34;\\\\subsection*{%s}\u0026#34;) (\u0026#34;\\\\subsubsection{%s}\u0026#34; . \u0026#34;\\\\subsubsection*{%s}\u0026#34;))) (setq org-latex-default-class \u0026#34;cn-article\u0026#34;) (setq org-latex-image-default-height \u0026#34;0.9\\\\textheight\u0026#34; org-latex-image-default-width \u0026#34;\\\\linewidth\u0026#34;) (setq org-latex-pdf-process \u0026#39;(\u0026#34;xelatex -interaction nonstopmode -output-directory %o %f\u0026#34; \u0026#34;bibtex %b\u0026#34; \u0026#34;xelatex -interaction nonstopmode -output-directory %o %f\u0026#34; \u0026#34;xelatex -interaction nonstopmode -output-directory %o %f\u0026#34; \u0026#34;rm -fr %b.out %b.log %b.tex %b.brf %b.bbl auto\u0026#34; )) ;; 使用 Listings 宏包格式化源代码(只是把代码框用 listing 环境框起来，还需要额外的设置) (setq org-latex-listings t) ;; mapping jupyter-python to Python (add-to-list \u0026#39;org-latex-listings-langs \u0026#39;(jupyter-python \u0026#34;Python\u0026#34;)) ;; Options for \\lset command（reference to listing Manual) (setq org-latex-listings-options \u0026#39;( (\u0026#34;basicstyle\u0026#34; \u0026#34;\\\\small\\\\ttfamily\u0026#34;) ; 源代码字体样式 (\u0026#34;keywordstyle\u0026#34; \u0026#34;\\\\color{eminence}\\\\small\u0026#34;) ; 关键词字体样式 ;; (\u0026#34;identifierstyle\u0026#34; \u0026#34;\\\\color{doc}\\\\small\u0026#34;) (\u0026#34;commentstyle\u0026#34; \u0026#34;\\\\color{commentgreen}\\\\small\\\\itshape\u0026#34;) ; 批注样式 (\u0026#34;stringstyle\u0026#34; \u0026#34;\\\\color{red}\\\\small\u0026#34;) ; 字符串样式 (\u0026#34;showstringspaces\u0026#34; \u0026#34;false\u0026#34;) ; 字符串空格显示 (\u0026#34;numbers\u0026#34; \u0026#34;left\u0026#34;) ; 行号显示 (\u0026#34;numberstyle\u0026#34; \u0026#34;\\\\color{preprocess}\u0026#34;) ; 行号样式 (\u0026#34;stepnumber\u0026#34; \u0026#34;1\u0026#34;) ; 行号递增 (\u0026#34;xleftmargin\u0026#34; \u0026#34;2em\u0026#34;) ; ;; (\u0026#34;backgroundcolor\u0026#34; \u0026#34;\\\\color{background}\u0026#34;) ; 代码框背景色 (\u0026#34;tabsize\u0026#34; \u0026#34;4\u0026#34;) ; TAB 等效空格数 (\u0026#34;captionpos\u0026#34; \u0026#34;t\u0026#34;) ; 标题位置 top or buttom(t|b) (\u0026#34;breaklines\u0026#34; \u0026#34;true\u0026#34;) ; 自动断行 (\u0026#34;breakatwhitespace\u0026#34; \u0026#34;true\u0026#34;) ; 只在空格分行 (\u0026#34;showspaces\u0026#34; \u0026#34;false\u0026#34;) ; 显示空格 (\u0026#34;columns\u0026#34; \u0026#34;flexible\u0026#34;) ; 列样式 (\u0026#34;frame\u0026#34; \u0026#34;tb\u0026#34;) ; 代码框：single, or tb 上下线 (\u0026#34;frameleftmargin\u0026#34; \u0026#34;1.5em\u0026#34;) ; frame 向右偏移 ;; (\u0026#34;frameround\u0026#34; \u0026#34;tttt\u0026#34;) ; 代码框： 圆角 ;; (\u0026#34;framesep\u0026#34; \u0026#34;0pt\u0026#34;) ;; (\u0026#34;framerule\u0026#34; \u0026#34;1pt\u0026#34;) ; 框的线宽 ;; (\u0026#34;rulecolor\u0026#34; \u0026#34;\\\\color{background}\u0026#34;) ; 框颜色 ;; (\u0026#34;fillcolor\u0026#34; \u0026#34;\\\\color{white}\u0026#34;) ;; (\u0026#34;rulesepcolor\u0026#34; \u0026#34;\\\\color{comdil}\u0026#34;) (\u0026#34;framexleftmargin\u0026#34; \u0026#34;5mm\u0026#34;) ; let line numer inside frame )) ) ox-gfm导出Markdown设置 我们通过 ox-gfm 插件来导出Github样式的Markdown文件。\n1 2 3 (use-package ox-gfm :ensure t :after ox) ox-publish导出静态站点设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 (unless (file-exists-p \u0026#34;~/org\u0026#34;) (make-directory \u0026#34;~/org\u0026#34;)) (use-package ox-publish :ensure nil :commands (org-publish org-publish-all) :config (setq org-export-global-macros \u0026#39;((\u0026#34;timestamp\u0026#34; . \u0026#34;@@html:\u0026lt;span class=\\\u0026#34;timestamp\\\u0026#34;\u0026gt;[$1]\u0026lt;/span\u0026gt;@@\u0026#34;))) ;; sitemap 生成函数 (defun my/org-sitemap-date-entry-format (entry style project) \u0026#34;Format ENTRY in org-publish PROJECT Sitemap format ENTRY ENTRY STYLE format that includes date.\u0026#34; (let ((filename (org-publish-find-title entry project))) (if (= (length filename) 0) (format \u0026#34;*%s*\u0026#34; entry) (format \u0026#34;{{{timestamp(%s)}}} [[file:%s][%s]]\u0026#34; (format-time-string \u0026#34;%Y-%m-%d\u0026#34; (org-publish-find-date entry project)) entry filename)))) ;; 设置 org-publish 的项目列表 (setq org-publish-project-alist \u0026#39;( ;; 笔记部分 (\u0026#34;org-notes\u0026#34; :base-directory \u0026#34;~/org/\u0026#34; :base-extension \u0026#34;org\u0026#34; :exclude \u0026#34;\\\\(tasks\\\\|test\\\\|scratch\\\\|diary\\\\|capture\\\\|mail\\\\|habits\\\\|resume\\\\|meetings\\\\|personal\\\\|org-beamer-example\\\\)\\\\.org\\\\|test\\\\|article\\\\|roam\\\\|hugo\u0026#34; :publishing-directory \u0026#34;~/public_html/\u0026#34; :recursive t ; include subdirectories if t :publishing-function org-html-publish-to-html :headline-levels 6 :auto-preamble t :auto-sitemap t :sitemap-filename \u0026#34;sitemap.org\u0026#34; :sitemap-title \u0026#34;Sitemap\u0026#34; :sitemap-format-entry my/org-sitemap-date-entry-format) ;; 静态资源部分 (\u0026#34;org-static\u0026#34; :base-directory \u0026#34;~/org/\u0026#34; :base-extension \u0026#34;css\\\\|js\\\\|png\\\\|jpg\\\\|gif\\\\|pdf\\\\|mp3\\\\|ogg\\\\|swf\\\\|mov\u0026#34; :publishing-directory \u0026#34;~/public_html/\u0026#34; :recursive t :publishing-function org-publish-attachment) ;; 项目集合 (\u0026#34;org\u0026#34; :components (\u0026#34;org-notes\u0026#34; \u0026#34;org-static\u0026#34;)) )) ) ox-hugo导出博客设置 ox-hugo 插件可以将 org 文件导出为 hugo 需要的 Markdown 文件，并快速通过 hugo 进行博客的生成和发布。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 (use-package ox-hugo :ensure t :config (setq org-hugo-base-dir \u0026#34;~/ox-hugo/\u0026#34;) (with-eval-after-load \u0026#39;org-capture (defun org-hugo-new-subtree-post-capture-template () \u0026#34;Returns `org-capture\u0026#39; template string for new Hugo post. See `org-capture-templates\u0026#39; for more information.\u0026#34; (let* ((title (read-from-minibuffer \u0026#34;Post Title: \u0026#34;)) ; Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #\u0026#39;identity `( ,(concat \u0026#34;* TODO \u0026#34; title) \u0026#34;:PROPERTIES:\u0026#34; ,(concat \u0026#34;:EXPORT_FILE_NAME: \u0026#34; fname) \u0026#34;:END:\u0026#34; \u0026#34;%?\\n\u0026#34;) ; Place the cursor here finally \u0026#34;\\n\u0026#34;))) (add-to-list \u0026#39;org-capture-templates \u0026#39;(\u0026#34;h\u0026#34; ; `org-capture\u0026#39; binding + h \u0026#34;Hugo post\u0026#34; entry ;; It is assumed that below file is present in `org-directory\u0026#39; ;; and that it has a \u0026#34;Blog Ideas\u0026#34; heading. It can even be a ;; symlink pointing to the actual location of capture.org! (file+olp \u0026#34;capture.org\u0026#34; \u0026#34;Notes\u0026#34;) (function org-hugo-new-subtree-post-capture-template)))) ) toc-org目录自动生成 toc-org 插件可以在Org文件里自动生成目录，只需给一个标题行设置一个标签为 toc 或 toc_2 即可（后者只生成2层）。\n1 2 3 (use-package toc-org :ensure t :hook (org-mode . toc-org-mode)) ol新增链接类型 google Org mode\n1 2 3 4 5 6 7 8 9 10 11 12 13 (use-package ol :ensure nil :defer t :custom (org-link-keep-stored-after-insertion t) (org-link-abbrev-alist \u0026#39;((\u0026#34;github\u0026#34; . \u0026#34;https://github.com/\u0026#34;) (\u0026#34;gitlab\u0026#34; . \u0026#34;https://gitlab.com/\u0026#34;) (\u0026#34;google\u0026#34; . \u0026#34;https://google.com/search?q=\u0026#34;) (\u0026#34;baidu\u0026#34; . \u0026#34;https://baidu.com/s?wd=\u0026#34;) (\u0026#34;rfc\u0026#34; . \u0026#34;https://tools.ietf.org/html/\u0026#34;) (\u0026#34;wiki\u0026#34; . \u0026#34;https://en.wikipedia.org/wiki/\u0026#34;) (\u0026#34;youtube\u0026#34; . \u0026#34;https://youtube.com/watch?v=\u0026#34;) (\u0026#34;zhihu\u0026#34; . \u0026#34;https://zhihu.com/question/\u0026#34;)))) 图片粘贴 通过 pngpaste 这个命令行工具，将系统剪贴板里的图片，输出到当前文件同名的 assets 文件夹下，然后自动在当前org文件的光标处插入图片链接，并设置图片链接的宽度属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 (use-package emacs :ensure nil :after org :bind (:map org-mode-map (\u0026#34;M-p\u0026#34; . my/org-insert-clipboard-image)) :config (defun my/org-insert-clipboard-image (width) \u0026#34;create a time stamped unique-named file from the clipboard in the sub-directory (%filename.assets) as the org-buffer and insert a link to this file.\u0026#34; (interactive (list (read-string (format \u0026#34;Input image width, default is 800: \u0026#34;) nil nil \u0026#34;800\u0026#34;))) ;; 设置图片存放的文件夹位置为 `当前Org文件同名.assets\u0026#39; (setq foldername (concat (file-name-base (buffer-file-name)) \u0026#34;.assets/\u0026#34;)) (if (not (file-exists-p foldername)) (mkdir foldername)) ;; 设置图片的文件名，格式为 `img_年月日_时分秒.png\u0026#39; (setq imgName (concat \u0026#34;img_\u0026#34; (format-time-string \u0026#34;%Y%m%d_%H%M%S\u0026#34;) \u0026#34;.png\u0026#34;)) ;; 图片文件的相对路径 (setq relativeFilename (concat (file-name-base (buffer-name)) \u0026#34;.assets/\u0026#34; imgName)) ;; 根据不同的操作系统设置不同的命令行工具 (cond ((string-equal system-type \u0026#34;gnu/linux\u0026#34;) (shell-command (concat \u0026#34;xclip -selection clipboard -t image/png -o \u0026gt; \u0026#34; relativeFilename))) ((string-equal system-type \u0026#34;darwin\u0026#34;) (shell-command (concat \u0026#34;pngpaste \u0026#34; relativeFilename)))) ;; 给粘贴好的图片链接加上宽度属性，方便导出 (insert (concat \u0026#34;\\n#+DOWNLOADED: screenshot @ \u0026#34; (format-time-string \u0026#34;%Y-%m-%d %a %H:%M:%S\u0026#34; (current-time)) \u0026#34;\\n#+CAPTION: \\n#+ATTR_ORG: :width \u0026#34; width \u0026#34;\\n#+ATTR_LATEX: :width \u0026#34; (if (\u0026gt;= (/ (string-to-number width) 800.0) 1.0) \u0026#34;1.0\u0026#34; (number-to-string (/ (string-to-number width) 800.0))) \u0026#34;\\\\linewidth :float nil\\n\u0026#34; \u0026#34;#+ATTR_HTML: :width \u0026#34; width \u0026#34;\\n[[file:\u0026#34; relativeFilename \u0026#34;]]\\n\u0026#34;)) ;; 重新显示一下图片 (org-redisplay-inline-images) ) ) init-org.el 文件尾 1 2 3 (provide \u0026#39;init-org) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-org.el ends here init-completion.el Emacs的补全设置。\ninit-completion.el 文件头 1 2 3 4 ;;; init-completion.el --- Completion settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: vertico 提供了一个垂直样式的补全系统 vertico 插件提供了一个垂直样式的补全系统。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 (use-package vertico :ensure t :hook (after-init . vertico-mode) :bind (:map minibuffer-local-map (\u0026#34;M-\u0026lt;DEL\u0026gt;\u0026#34; . my/minibuffer-backward-kill) :map vertico-map (\u0026#34;M-q\u0026#34; . vertico-quick-insert)) ; use C-g to exit :config (defun my/minibuffer-backward-kill (arg) \u0026#34;When minibuffer is completing a file name delete up to parent folder, otherwise delete a word\u0026#34; (interactive \u0026#34;p\u0026#34;) (if minibuffer-completing-file-name ;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608 (if (string-match-p \u0026#34;/.\u0026#34; (minibuffer-contents)) (zap-up-to-char (- arg) ?/) (delete-minibuffer-contents)) (backward-kill-word arg))) ;; Do not allow the cursor in the minibuffer prompt (setq minibuffer-prompt-properties \u0026#39;(read-only t cursor-intangible t face minibuffer-prompt)) (add-hook \u0026#39;minibuffer-setup-hook #\u0026#39;cursor-intangible-mode) (setq vertico-cycle t) ; cycle from last to first :custom (vertico-count 15) ; number of candidates to display, default is 10 ) orderless 插件提供一种无序的补全新姿势，将一个搜索的范式变成数个以空格分隔的部分 oderless 插件提供一种无序的补全新姿势，将一个搜索的范式变成数个以空格分隔的部分，各部分之间没有顺序，你要做的就是根据记忆输入关键词、空格、关键词。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; support Pinyin first character match for orderless, avy etc. (use-package pinyinlib :ensure t) ;; orderless 是一种哲学思想 (use-package orderless :ensure t :init (setq completion-styles \u0026#39;(orderless partial-completion basic)) (setq orderless-component-separator \u0026#34;[ \u0026amp;]\u0026#34;) ; \u0026amp; is for company because space will break completion (setq completion-category-defaults nil) (setq completion-category-overrides nil) :config ;; make completion support pinyin, refer to ;; https://emacs-china.org/t/vertico/17913/2 (defun completion--regex-pinyin (str) (orderless-regexp (pinyinlib-build-regexp-string str))) (add-to-list \u0026#39;orderless-matching-styles \u0026#39;completion--regex-pinyin) ) marginalia 给迷你缓冲区的补全候选条目添加一些提示 marginalia 插件给迷你缓冲区的补全候选条目添加一些提示。\n1 2 3 4 5 6 ;; minibuffer helpful annotations (use-package marginalia :ensure t :hook (after-init . marginalia-mode) :custom (marginalia-annotators \u0026#39;(marginalia-annotators-heavy marginalia-annotators-light nil))) consult 基于Emacs自带的补全机制，提供了一系列的补全命令 consult 插件基于Emacs自带的补全机制，提供了一系列的补全命令。\nFor locate on MacOS:\nlocate is not enabled in MacOS by default. We need to enable it via: sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist Then we need to wait locate to build db for the whole file system. If there is something wrong with updating locate db, we can update it manually via: chomd 755 ~/Library ~/Downloads ~/Documents ~/Desktop sudo /usr/libexec/locate.updatedb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 (use-package consult :ensure t :after org :bind (([remap goto-line] . consult-goto-line) ([remap isearch-forward] . consult-line-symbol-at-point) ; my-consult-ripgrep-or-line ([remap switch-to-buffer] . consult-buffer) ([remap switch-to-buffer-other-window] . consult-buffer-other-window) ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame) ([remap yank-pop] . consult-yank-pop) ([remap apropos] . consult-apropos) ([remap bookmark-jump] . consult-bookmark) ([remap goto-line] . consult-goto-line) ([remap imenu] . consult-imenu) ([remap multi-occur] . consult-multi-occur) ([remap recentf-open-files] . consult-recent-file) (\u0026#34;C-x j\u0026#34; . consult-mark) (\u0026#34;C-c g\u0026#34; . consult-ripgrep) (\u0026#34;C-c f\u0026#34; . consult-find) (\u0026#34;\\e\\ef\u0026#34; . consult-locate) ; need to enable locate first (\u0026#34;C-c n h\u0026#34; . my/consult-find-org-headings) :map org-mode-map (\u0026#34;C-c C-j\u0026#34; . consult-org-heading) :map minibuffer-local-map (\u0026#34;C-r\u0026#34; . consult-history) :map isearch-mode-map (\u0026#34;C-;\u0026#34; . consult-line) :map prog-mode-map (\u0026#34;C-c C-j\u0026#34; . consult-outline) ) :hook (completion-list-mode . consult-preview-at-point-mode) :init ;; Optionally configure the register formatting. This improves the register ;; preview for `consult-register\u0026#39;, `consult-register-load\u0026#39;, ;; `consult-register-store\u0026#39; and the Emacs built-ins. (setq register-preview-delay 0 register-preview-function #\u0026#39;consult-register-format) ;; Optionally tweak the register preview window. ;; This adds thin lines, sorting and hides the mode line of the window. (advice-add #\u0026#39;register-preview :override #\u0026#39;consult-register-window) ;; Use Consult to select xref locations with preview (setq xref-show-xrefs-function #\u0026#39;consult-xref xref-show-definitions-function #\u0026#39;consult-xref) ;; MacOS locate doesn\u0026#39;t support `--ignore-case --existing\u0026#39; args. (setq consult-locate-args (pcase system-type (\u0026#39;gnu/linux \u0026#34;locate --ignore-case --existing --regex\u0026#34;) (\u0026#39;darwin \u0026#34;mdfind -name\u0026#34;))) :config (consult-customize consult-theme :preview-key \u0026#39;(:debounce 0.2 any) consult-ripgrep consult-git-grep consult-grep consult-bookmark consult-recent-file consult-xref consult--source-recent-file consult--source-project-recent-file consult--source-bookmark :preview-key \u0026#39;(:debounce 0.4 any)) ;; Optionally configure the narrowing key. ;; Both \u0026lt; and C-+ work reasonably well. (setq consult-narrow-key \u0026#34;\u0026lt;\u0026#34;) ;; (kbd \u0026#34;C-+\u0026#34;) (autoload \u0026#39;projectile-project-root \u0026#34;projectile\u0026#34;) (setq consult-project-root-function #\u0026#39;projectile-project-root) ;; search all org file headings under a directory, see: ;; https://emacs-china.org/t/org-files-heading-entry/20830/4 (defun my/consult-find-org-headings (\u0026amp;optional match) \u0026#34;find headngs in all org files.\u0026#34; (interactive) (consult-org-heading match (directory-files org-directory t \u0026#34;^[0-9]\\\\{8\\\\}.+\\\\.org$\u0026#34;))) ;; Use `consult-ripgrep\u0026#39; instead of `consult-line\u0026#39; in large buffers (defun consult-line-symbol-at-point () \u0026#34;Consult line the synbol where the point is\u0026#34; (interactive) (consult-line (thing-at-point \u0026#39;symbol))) ) company Emacs最广为使用的补全插件 Emacs最广为使用的补全插件便是 company-mode，其官方主页上已有详细的说明。\n1 2 3 4 5 6 7 8 9 10 11 (use-package company :ensure t :defer 3 :init (global-company-mode t) :config (setq company-minimum-prefix-length 1) (setq company-tooltip-align-annotations t) (setq company-idle-delay 0.0) (setq company-show-numbers t) (setq company-selection-wrap-around t) (setq company-transformers \u0026#39;(company-sort-by-occurrence))) yasnippet模板补全 yasnippet 插件是一个非常强大的模板补全系统。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; yasnippet settings (use-package yasnippet :ensure t :diminish yas-minor-mode :hook ((after-init . yas-reload-all) ((prog-mode LaTeX-mode org-mode) . yas-minor-mode)) :config ;; Suppress warning for yasnippet code. (require \u0026#39;warnings) (add-to-list \u0026#39;warning-suppress-types \u0026#39;(yasnippet backquote-change)) (setq yas-prompt-functions \u0026#39;(yas-x-prompt yas-dropdown-prompt)) (defun smarter-yas-expand-next-field () \u0026#34;Try to `yas-expand\u0026#39; then `yas-next-field\u0026#39; at current cursor position.\u0026#34; (interactive) (let ((old-point (point)) (old-tick (buffer-chars-modified-tick))) (yas-expand) (when (and (eq old-point (point)) (eq old-tick (buffer-chars-modified-tick))) (ignore-errors (yas-next-field)))))) css for html export 1 2 3 4 5 6 7 8 9 # -*- mode: snippet -*- # name: CssForHtmlExport # key: \u0026lt;css # -- ,#+TITLE: ${1:`(file-name-base buffer-file-name)`} ,#+OPTIONS: toc:nil num:3 H:4 ^:nil pri:t ,#+HTML_HEAD: \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;http://gongzhitaao.org/orgcss/org.css\u0026#34;/\u0026gt; $0 emacslisp 1 2 3 4 5 6 7 # -*- mode: snippet -*- # name: emacslisp # key: \u0026lt;el # -- ,#+BEGIN_SRC emacs-lisp $0 \\#+END_SRC embark 插件提供了一系列的迷你缓冲区的类似右键机制的增强 embark 插件提供了一系列的迷你缓冲区的类似右键机制的增强。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 (use-package embark :ensure t :bind (([remap describe-bindings] . embark-bindings) (\u0026#34;C-\u0026#39;\u0026#34; . embark-act) :map minibuffer-local-map :map minibuffer-local-completion-map (\u0026#34;TAB\u0026#34; . minibuffer-force-complete) :map embark-file-map (\u0026#34;E\u0026#34; . consult-file-externally) ; Open file externally, or `we\u0026#39; in Ranger (\u0026#34;O\u0026#34; . consult-directory-externally) ; Open directory externally ) :init ;; Optionally replace the key help with a completing-read interface (setq prefix-help-command #\u0026#39;embark-prefix-help-command) :config ;; Show Embark actions via which-key (setq embark-action-indicator (lambda (map) (which-key--show-keymap \u0026#34;Embark\u0026#34; map nil nil \u0026#39;no-paging) #\u0026#39;which-key--hide-popup-ignore-command) embark-become-indicator embark-action-indicator) ;; open directory (defun consult-directory-externally (file) \u0026#34;Open directory externally using the default application of the system.\u0026#34; (interactive \u0026#34;fOpen externally: \u0026#34;) (if (and (eq system-type \u0026#39;windows-nt) (fboundp \u0026#39;w32-shell-execute)) (shell-command-to-string (encode-coding-string (replace-regexp-in-string \u0026#34;/\u0026#34; \u0026#34;\\\\\\\\\u0026#34; (format \u0026#34;explorer.exe %s\u0026#34; (file-name-directory (expand-file-name file)))) \u0026#39;gbk)) (call-process (pcase system-type (\u0026#39;darwin \u0026#34;open\u0026#34;) (\u0026#39;cygwin \u0026#34;cygstart\u0026#34;) (_ \u0026#34;xdg-open\u0026#34;)) nil 0 nil (file-name-directory (expand-file-name file))))) ;; Hide the mode line of the Embark live/completions buffers (add-to-list \u0026#39;display-buffer-alist \u0026#39;(\u0026#34;\\\\`\\\\*Embark Collect \\\\(Live\\\\|Completions\\\\)\\\\*\u0026#34; nil (window-parameters (mode-line-format . none)))) ) (use-package embark-consult :ensure t :hook (embark-collect-mode . consult-preview-at-point-mode)) init-completion.el 文件尾 1 2 3 (provide \u0026#39;init-completion) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-completion.el ends here init-dired.el Emacs文件管理设置。\ninit-dired.el 文件头 1 2 3 4 ;;; init-dired.el --- Dired settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: init-dired.el 文件尾 1 2 3 (provide \u0026#39;init-dired) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-dired.el ends here init-tools.el init-tools.el 文件头 1 2 3 4 ;;; init-tools.el --- Tools settings -*- lexical-binding: t -*- ;;; Commentary: Useful tools to make Emacs efficient! ;;; Code: helpful帮助增强 helpful 插件提供了帮助增强。\n1 2 3 4 5 6 7 8 9 10 11 12 (use-package helpful :ensure t :commands (helpful-callable helpful-variable helpful-command helpful-key helpful-mode) :bind (([remap describe-command] . helpful-command) (\u0026#34;C-h f\u0026#34; . helpful-callable) (\u0026#34;C-h v\u0026#34; . helpful-variable) (\u0026#34;C-h s\u0026#34; . helpful-symbol) (\u0026#34;C-h S\u0026#34; . describe-syntax) (\u0026#34;C-h m\u0026#34; . describe-mode) (\u0026#34;C-h F\u0026#34; . describe-face) ([remap describe-key] . helpful-key)) ) pass密码管理 通过 pass 插件来进行密码管理。\n1 2 3 4 (use-package pass :ensure t :commands (pass) ) cnfonts 用于缩放字体 cnfonts 原来叫: chinese-fonts-setup, 是一个 Emacs 中英文字体配置工 具。可以比较方便地实现中文字体和英文字体等宽（也就是大家常说的中英 文对齐）。\n1 2 3 4 5 6 7 8 (use-package cnfonts :ensure t :defer 3 :init (cnfonts-mode t) :config (define-key cnfonts-mode-map (kbd \u0026#34;C--\u0026#34;) #\u0026#39;cnfonts-decrease-fontsize) (define-key cnfonts-mode-map (kbd \u0026#34;C-=\u0026#34;) #\u0026#39;cnfonts-increase-fontsize) ) bhj-fonts字体配置 参考链接\n狠狠地折腾了一把Emacs中文字体\n全局放大Emacs字体\nbhj-fonts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 (defun qiang-font-existsp (font) (if (null (x-list-fonts font)) nil t)) (defun qiang-make-font-string (font-name font-size) (if (and (stringp font-size) (equal \u0026#34;:\u0026#34; (string (elt font-size 0)))) (format \u0026#34;%s%s\u0026#34; font-name font-size) (format \u0026#34;%s-%s\u0026#34; font-name font-size))) (defvar bhj-english-font-size nil) (defun qiang-set-font (english-fonts english-font-size chinese-fonts \u0026amp;optional chinese-fonts-scale ) (setq chinese-fonts-scale (or chinese-fonts-scale 1.2)) (save-excursion (with-current-buffer (find-file-noselect \u0026#34;~/.config/system-config/emacs-font-size\u0026#34;) (delete-region (point-min) (point-max)) (insert (format \u0026#34;%s\u0026#34; english-font-size)) (let ((before-save-hook nil) (after-save-hook nil)) (save-buffer)) (kill-buffer))) (setq face-font-rescale-alist `((\u0026#34;Microsoft Yahei\u0026#34; . ,chinese-fonts-scale) (\u0026#34;Microsoft_Yahei\u0026#34; . ,chinese-fonts-scale) (\u0026#34;微软雅黑\u0026#34; . ,chinese-fonts-scale) (\u0026#34;WenQuanYi Zen Hei\u0026#34; . ,chinese-fonts-scale))) \u0026#34;english-font-size could be set to \\\u0026#34;:pixelsize=18\\\u0026#34; or a integer. If set/leave chinese-font-size to nil, it will follow english-font-size\u0026#34; (require \u0026#39;cl) ; for find if (setq bhj-english-font-size english-font-size) (let ((en-font (qiang-make-font-string (find-if #\u0026#39;qiang-font-existsp english-fonts) english-font-size)) (zh-font (font-spec :family (find-if #\u0026#39;qiang-font-existsp chinese-fonts)))) ;; Set the default English font ;; ;; The following 2 method cannot make the font settig work in new frames. ;; (set-default-font \u0026#34;Consolas:pixelsize=18\u0026#34;) ;; (add-to-list \u0026#39;default-frame-alist \u0026#39;(font . \u0026#34;Consolas:pixelsize=18\u0026#34;)) ;; We have to use set-face-attribute (set-face-attribute \u0026#39;default nil :font en-font) (condition-case font-error (progn (set-face-font \u0026#39;italic (font-spec :family \u0026#34;JetBrains Mono\u0026#34; :slant \u0026#39;italic :weight \u0026#39;normal :size (+ 0.0 english-font-size))) (set-face-font \u0026#39;bold-italic (font-spec :family \u0026#34;JetBrains Mono\u0026#34; :slant \u0026#39;italic :weight \u0026#39;bold :size (+ 0.0 english-font-size))) (set-fontset-font t \u0026#39;symbol (font-spec :family \u0026#34;JetBrains Mono\u0026#34;))) (error nil)) (set-fontset-font t \u0026#39;symbol (font-spec :family \u0026#34;Unifont\u0026#34;) nil \u0026#39;append) (set-fontset-font t \u0026#39;(#x2009 . #x2009) (font-spec :family \u0026#34;B\u0026amp;H LucidaBright\u0026#34;)) (set-fontset-font t nil (font-spec :family \u0026#34;DejaVu Sans\u0026#34;)) ;; Set Chinese font ;; Do not use \u0026#39;unicode charset, it will cause the english font setting invalid (dolist (charset \u0026#39;(kana han cjk-misc bopomofo)) (set-fontset-font t charset zh-font))) (when (and (boundp \u0026#39;global-emojify-mode) global-emojify-mode) (global-emojify-mode 1)) (shell-command-to-string \u0026#34;setsid sawfish-client -e \u0026#39;(maximize-window (input-focus))\u0026#39;\u0026#34;)) (defvar bhj-english-fonts \u0026#39;(\u0026#34;JetBrains Mono\u0026#34; \u0026#34;Monaco\u0026#34; \u0026#34;Consolas\u0026#34; \u0026#34;DejaVu Sans Mono\u0026#34; \u0026#34;Monospace\u0026#34; \u0026#34;Courier New\u0026#34;)) (defvar bhj-chinese-fonts \u0026#39;(\u0026#34;Microsoft Yahei\u0026#34; \u0026#34;Microsoft_Yahei\u0026#34; \u0026#34;微软雅黑\u0026#34; \u0026#34;文泉驿等宽微米黑\u0026#34; \u0026#34;黑体\u0026#34; \u0026#34;新宋体\u0026#34; \u0026#34;宋体\u0026#34;)) (qiang-set-font bhj-english-fonts (if (file-exists-p \u0026#34;~/.config/system-config/emacs-font-size\u0026#34;) (save-excursion (find-file \u0026#34;~/.config/system-config/emacs-font-size\u0026#34;) (goto-char (point-min)) (let ((monaco-font-size (read (current-buffer)))) (kill-buffer (current-buffer)) (if (numberp monaco-font-size) monaco-font-size 12.5))) 12.5) bhj-chinese-fonts) (defvar chinese-font-size-scale-alist nil) ;; On different platforms, I need to set different scaling rate for ;; differnt font size. (cond ((and (boundp \u0026#39;*is-a-mac*) *is-a-mac*) (setq chinese-font-size-scale-alist \u0026#39;((10.5 . 1.3) (11.5 . 1.3) (16 . 1.3) (18 . 1.25)))) ((and (boundp \u0026#39;*is-a-win*) *is-a-win*) (setq chinese-font-size-scale-alist \u0026#39;((11.5 . 1.25) (16 . 1.25)))) (t ;; is a linux:-) (setq chinese-font-size-scale-alist \u0026#39;((12 . 1.25) (12.5 . 1.25) (14 . 1.20) (16 . 1.25) (20 . 1.20))))) (defvar bhj-english-font-size-steps \u0026#39;(9 10.5 11.5 12 12.5 13 14 16 18 20 22 40)) (defun bhj-step-frame-font-size (step) (let ((steps bhj-english-font-size-steps) next-size) (when (\u0026lt; step 0) (setq steps (reverse bhj-english-font-size-steps))) (setq next-size (cadr (member bhj-english-font-size steps))) (when next-size (qiang-set-font bhj-english-fonts next-size bhj-chinese-fonts (cdr (assoc next-size chinese-font-size-scale-alist))) (message \u0026#34;Your font size is set to %.1f\u0026#34; next-size)))) ;; (global-set-key (kbd \u0026#34;C-x M--\u0026#34;) (lambda () (interactive) (bhj-step-frame-font-size -1))) ;; (global-set-key (kbd \u0026#34;C-x M-=\u0026#34;) (lambda () (interactive) (bhj-step-frame-font-size 1))) (global-set-key (kbd \u0026#34;C--\u0026#34;) (lambda () (interactive) (bhj-step-frame-font-size -1))) (global-set-key (kbd \u0026#34;C-=\u0026#34;) (lambda () (interactive) (bhj-step-frame-font-size 1))) (set-face-attribute \u0026#39;default nil :font (font-spec)) ;; {%org-mode%} ;; here are 20 hanzi and 40 english chars, see if they are the same width ;; 你你你你你你你你你你你你你你你你你你你你 ;; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ;; /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/ ;; {%/org-mode%} init-tools.el 文件尾 1 2 3 (provide \u0026#39;init-tools) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-tools.el ends here init-rss.el Emacs的RSS新闻阅读设置\ninit-rss.el 文件头 1 2 3 4 ;;; init-rss.el --- RSS settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: elfeed 一个非常棒的RSS新闻阅读客户端 elfeed 插件是一个非常棒的RSS新闻阅读客户端。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 (use-package elfeed :ensure t :hook ((elfeed-new-entry . (lambda () (elfeed-make-tagger :feed-url \u0026#34;video\u0026#34; :add \u0026#39;(video)) (elfeed-make-tagger :entry-title \u0026#34;图卦\u0026#34; :add \u0026#39;(pic))))) :bind ((\u0026#34;C-x M-r\u0026#34; . elfeed) :map elfeed-search-mode-map (\u0026#34;g\u0026#34; . elfeed-update) (\u0026#34;G\u0026#34; . elfeed-search-update--force) (\u0026#34;o\u0026#34; . elfeed-default-browser-open) :map elfeed-show-mode-map (\u0026#34;M-v\u0026#34; . scroll-down-command) (\u0026#34;j\u0026#34; . scroll-up-line) (\u0026#34;k\u0026#34; . scroll-down-line)) :config (setq elfeed-db-directory \u0026#34;~/.elfeed\u0026#34;) ;; capture template for elfeed (with-eval-after-load \u0026#39;org-capture (add-to-list \u0026#39;org-capture-templates \u0026#39;(\u0026#34;r\u0026#34; \u0026#34;Elfeed RSS\u0026#34; entry (file+headline \u0026#34;capture.org\u0026#34; \u0026#34;Elfeed\u0026#34;) \u0026#34;* %:elfeed-entry-title :READ:\\n%?\\n%a\u0026#34; :empty-lines-after 1 :prepend t)) (add-to-list \u0026#39;org-capture-templates-contexts \u0026#39;(\u0026#34;r\u0026#34; ((in-mode . \u0026#34;elfeed-show-mode\u0026#34;) (in-mode . \u0026#34;elfeed-search-mode\u0026#34;))))) ;; ================================ ;; open entry with browser ;; ================================ (defun elfeed-default-browser-open (\u0026amp;optional use-generic-p) \u0026#34;open with default browser\u0026#34; (interactive \u0026#34;P\u0026#34;) (let ((entries (elfeed-search-selected))) (cl-loop for entry in entries do (elfeed-untag entry \u0026#39;unread) when (elfeed-entry-link entry) do (browse-url it)) (mapc #\u0026#39;elfeed-search-update-entry entries) (unless (use-region-p) (forward-line)))) :custom (elfeed-feeds \u0026#39;( (\u0026#34;https://planet.emacslife.com/atom.xml\u0026#34; emacs) (\u0026#34;http://www.dapenti.com/blog/rss2.asp?name=xilei\u0026#34; news) (\u0026#34;https://remacs.cc/index.xml\u0026#34; emacs) )) (elfeed-use-curl t) (elfeed-curl-max-connections 10) (elfeed-enclosure-default-dir \u0026#34;~/Downloads/\u0026#34;) ;; (elfeed-search-filter \u0026#34;@4-months-ago +\u0026#34;) (elfeed-search-filter \u0026#34;\u0026#34;) (elfeed-sort-order \u0026#39;descending) (elfeed-search-clipboard-type \u0026#39;CLIPBOARD) (elfeed-search-title-max-width 100) (elfeed-search-title-min-width 30) (elfeed-search-trailing-width 25) (elfeed-show-truncate-long-urls t) (elfeed-show-unique-buffers t) (elfeed-search-date-format \u0026#39;(\u0026#34;%F %R\u0026#34; 16 :left)) ) elfeed-goodies给elfeed优化增强 我们通过 elfeed-goodies 插件给 elfeed 进行优化增强：\n1 2 3 4 5 6 7 (use-package elfeed-goodies :ensure t :hook (after-init . elfeed-goodies/setup) :config ;; set elfeed show entry switch function (setq elfeed-show-entry-switch #\u0026#39;elfeed-goodies/switch-pane) ; switch-to-buffer, pop-to-buffer ) init-rss.el 文件尾 1 2 3 (provide \u0026#39;init-rss) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-rss.el ends here init-shell.el Emacs里的shell设置。\ninit-shell.el 文件头 1 2 3 4 ;;; init-shell.el --- (E)shell settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: eshell 基本配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 (use-package eshell :ensure nil :functions eshell/alias :hook ((eshell-mode . (lambda () (term-mode-common-init) ;; Remove cmd args word by word (modify-syntax-entry ?- \u0026#34;w\u0026#34;) (visual-line-mode 1) (setenv \u0026#34;PAGER\u0026#34; \u0026#34;cat\u0026#34;))) ) :config (defun term-mode-common-init () \u0026#34;The common initialization for term.\u0026#34; (setq-local scroll-margin 0) (setq-local truncate-lines t) ) ;; 在Emacs里输入vi，直接在buffer里打开文件 (defalias \u0026#39;eshell/vi \u0026#39;find-file) (defalias \u0026#39;eshell/vim \u0026#39;find-file) ;; 语法高亮显示 (defun eshell/bat (file) \u0026#34;cat FILE with syntax highlight.\u0026#34; (with-temp-buffer (insert-file-contents file) (let ((buffer-file-name file)) (delay-mode-hooks (set-auto-mode) (font-lock-ensure))) (buffer-string))) (defalias \u0026#39;eshell/cat \u0026#39;eshell/bat) ;; 交互式进入目录 (defun eshell/z () \u0026#34;cd to directory with completion.\u0026#34; (let ((dir (completing-read \u0026#34;Directory: \u0026#34; (ring-elements eshell-last-dir-ring) nil t))) (eshell/cd dir))) ;; 查找文件 (defun eshell/f (filename \u0026amp;optional dir) \u0026#34;Search for files matching FILENAME in either DIR or the current directory.\u0026#34; (let ((cmd (concat ;; using find (executable-find \u0026#34;find\u0026#34;) \u0026#34; \u0026#34; (or dir \u0026#34;.\u0026#34;) \u0026#34; -not -path \u0026#39;*/.git*\u0026#39;\u0026#34; ; ignore .git directory \u0026#34; -and -not -path \u0026#39;build\u0026#39;\u0026#34; ; ignore cmake build directory \u0026#34; -and -not -path \u0026#39;*/eln-cache*\u0026#39;\u0026#34; ; ignore eln cache \u0026#34; -and -type f -and -iname \u0026#34; \u0026#34;\u0026#39;*\u0026#34; filename \u0026#34;*\u0026#39;\u0026#34;))) (eshell-command-result cmd))) :custom (eshell-banner-message \u0026#39;(format \u0026#34;%s %s\\n\u0026#34; (propertize (format \u0026#34; %s \u0026#34; (string-trim (buffer-name))) \u0026#39;face \u0026#39;mode-line-highlight) (propertize (current-time-string) \u0026#39;face \u0026#39;font-lock-keyword-face))) (eshell-scroll-to-bottom-on-input \u0026#39;all) (eshell-scroll-to-bottom-on-output \u0026#39;all) (eshell-kill-on-exit t) (eshell-kill-processes-on-exit t) ;; Don\u0026#39;t record command in history if starts with whitespace (eshell-input-filter \u0026#39;eshell-input-filter-initial-space) (eshell-error-if-no-glob t) (eshell-glob-case-insensitive t) ;; set scripts (eshell-rc-script (locate-user-emacs-file \u0026#34;etc/eshell/profile\u0026#34;)) (eshell-login-script (locate-user-emacs-file \u0026#34;etc/eshell/login\u0026#34;)) ) eshell alias 设置 1 2 3 4 5 6 7 8 9 alias ff find-file $1 alias fo find-file-other-window $1 alias d dired $1 alias ll ls -alh alias l. ls -dh .* alias up eshell-up $1 alias pk eshell-up-peek $1 alias less view-file $1 alias more view-file $1 eshell 里的 C-d 让 C-d 更智能：\n1 2 3 4 5 6 7 8 9 10 11 (use-package em-rebind :ensure nil :commands eshell-delchar-or-maybe-eof) (use-package esh-mode :ensure nil :bind (:map eshell-mode-map (\u0026#34;C-d\u0026#34; . eshell-delchar-or-maybe-eof) (\u0026#34;C-r\u0026#34; . consult-history) (\u0026#34;C-l\u0026#34; . eshell/clear)) ) Eshell 的命令历史 1 2 3 4 5 6 7 (use-package em-hist :ensure nil :defer t :custom (eshell-history-size 1024) (eshell-hist-ignoredups t) (eshell-save-history-on-exit t)) 有些命令使用 term 有一些命令如 top，我们还是使用 term：\n1 2 3 4 5 6 7 8 9 ;; following commands will run on term instead (use-package em-term :ensure nil :defer t :custom (eshell-visual-commands \u0026#39;(\u0026#34;top\u0026#34; \u0026#34;htop\u0026#34; \u0026#34;less\u0026#34; \u0026#34;more\u0026#34;)) (eshell-visual-subcommands \u0026#39;((\u0026#34;git\u0026#34; \u0026#34;help\u0026#34; \u0026#34;lg\u0026#34; \u0026#34;log\u0026#34; \u0026#34;diff\u0026#34; \u0026#34;show\u0026#34;))) (eshell-visual-options \u0026#39;((\u0026#34;git\u0026#34; \u0026#34;--help\u0026#34; \u0026#34;--paginate\u0026#34;))) (eshell-destroy-buffer-when-process-dies t)) eshell-git-prompt 命令行主题 eshell-git-prompt 插件提供了数个好看的 Eshell 命令行主题。\n1 2 3 4 5 6 7 8 (use-package eshell-git-prompt :ensure t :after esh-mode :custom-face (eshell-git-prompt-multiline2-dir-face ((t (:foreground \u0026#34;#c09035\u0026#34; :bold t)))) :config (eshell-git-prompt-use-theme \u0026#39;multiline2) ) eshell-syntax-highlighting 语法高亮 eshell-syntax-highlighting 插件为Eshell提供语法高亮。\n1 2 3 4 5 6 7 (use-package eshell-syntax-highlighting :after esh-mode :ensure t :hook (eshell-mode . eshell-syntax-highlighting-global-mode) :custom-face (eshell-syntax-highlighting-shell-command-face ((t (:foreground \u0026#34;#7cc77f\u0026#34; :bold t)))) ) capf-autosuggest自动补全 capf-autosuggest 提供Fish类似的Eshell命令自动补全功能。类似的插件还有 esh-autosuggest。\n1 2 3 4 5 6 (use-package capf-autosuggest :ensure t :hook ((eshell-mode comint-mode) . capf-autosuggest-mode) :custom-face (capf-autosuggest-face ((t (:foreground \u0026#34;#dae7ff\u0026#34;)))) ) eshell-up快速进入父级文件夹 eshell-up 插件可以快速进入当前文件夹的任何一个父级文件夹。通过 up 命令（已经设置了up 在eshell里的alias）进入当前文件夹的任何一级父目录。\n1 2 3 4 5 6 7 (use-package eshell-up :ensure t :commands (eshell-up eshell-up-peek) :config ;; to print the matching parent directory before changing to it (setq eshell-up-print-parent-dir t) ) init-shell.el 文件尾 1 2 3 (provide \u0026#39;init-shell) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-shell.el ends here init-browser.el init-browser.el 文件头 1 2 3 4 ;;; init-browser.el --- Browser settings -*- lexical-binding: t -*- ;;; Commentary: ;;; Code: EWW 配置 Emacs 内置 EWW 浏览器配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 (use-package shr :ensure nil :defer t :custom (shr-inhibit-images t) ; 不显示图片 (shr-image-animate nil) ; 不显示 gif ) (use-package eww :ensure nil :commands eww eww-follow-link :hook (eww-mode . visual-line-mode) :bind ( :map eww-mode-map (\u0026#34;o\u0026#34; . eww-browse-with-external-browser) (\u0026#34;D\u0026#34; . eww-forward-url) (\u0026#34;S\u0026#34; . eww-back-url) (\u0026#34;f\u0026#34; . link-hint-open-link) (\u0026#34;TAB\u0026#34; . shr-next-link) (\u0026#34;\u0026lt;backtab\u0026gt;\u0026#34; . shr-previous-link) (\u0026#34;j\u0026#34; . scroll-up-line) (\u0026#34;k\u0026#34; . scroll-down-line) ) :config (setq eww-download-directory (expand-file-name \u0026#34;~/Downloads\u0026#34;)) (custom-set-variables \u0026#39;(eww-search-prefix \u0026#34;https://cn.bing.com/search?q=\u0026#34;)) ) init-browser.el 文件尾 1 2 3 (provide \u0026#39;init-browser) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init-browser.el ends here ","date":"2024-03-26T00:55:07+08:00","permalink":"https://ynhugo.github.io/p/remacs.org/","title":"remacs.org"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 emacs_file=\u0026#34;emacs-28.2.tar.xz\u0026#34; emacs_dir=\u0026#34;emacs-28.2\u0026#34; emacs_installed=\u0026#34;/usr/local/bin/emacs-28.2\u0026#34; if [ \u0026#34;$emacs_installed\u0026#34; ]; then echo \u0026#34;emacs-28.2 is installed.\u0026#34; else sudo apt install libncurses-dev -y; sudo apt install libgnutls28-dev -y; if [ \u0026#34;$emacs_file\u0026#34; ]; then echo \u0026#34;$emacs_file exists.\u0026#34; else wget http://mirrors.ustc.edu.cn/gnu/emacs/$emacs_file fi if [ \u0026#34;$emacs_dir\u0026#34; ]; then echo \u0026#34;$emacs_dir exists.\u0026#34; else tar -xvf $emacs_file fi cd $emacs_dir ./configure --without-x --with-gnutls=yes \u0026amp;\u0026amp; chmod +x ./* \u0026amp;\u0026amp; sudo make \u0026amp;\u0026amp; sudo make install fi ","date":"2024-03-26T00:55:07+08:00","permalink":"https://ynhugo.github.io/p/ubuntu_16.04.1_compile_emacs/","title":"ubuntu_16.04.1_compile_emacs"},{"content":" 今天在网上发现一个好用切换emacs窗口的插件：\u0026#34;window-numbering\u0026#34;，通过\u0026#34;M-数字\u0026#34;进行窗口切换，安装好该插件后，在加载后，窗口的左下角会出现数字，例如\u0026#34;1-UUU\u0026#34;这样的字符串，通过第一个字符对应的数值进行窗口区分，我用\u0026#34;use-package\u0026#34;进行安装，代码如下：\n1 2 3 4 (use-package window-numbering :ensure t :init (window-numbering-mode t) ) ","date":"2024-03-26T00:55:07+08:00","permalink":"https://ynhugo.github.io/p/window_numbering/","title":"window_numbering"},{"content":" windos 在emacs官网下载\u0026#34;emacs-28.2-no-deps.zip\u0026#34;，\u0026#34;no-deps\u0026#34;表示没有依赖，下载之后解压该并重命名为\u0026#34;emacs\u0026#34;，然后在\u0026#34;emacs/share/emacs/site-lisp/\u0026#34;下创建\u0026#34;site-start.el\u0026#34;文件并添加以下代码\n1 2 3 4 5 6 7 (defvar program-dir (replace-regexp-in-string \u0026#34;share/emacs.*/etc/$\u0026#34; \u0026#34;home/\u0026#34; data-directory :from-end)) (setenv \u0026#34;HOME\u0026#34; program-dir) (load \u0026#34;~/.emacs.d/init.el\u0026#34;) 如果打开u盘中的emacs提示找不到libgmp-10.dll，可以将安装到电脑上的emacs安装目录的bin目录下的libgmp-10.dll拷贝到u盘emacs存放目录的bin路径下与emacs可执行文件保持同一路径即可\n也可以下载博客中提供的libgmp-10.dll：libgmp-10.dll\n","date":"2024-03-26T00:55:07+08:00","permalink":"https://ynhugo.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%B0%86emacs%E7%BB%BF%E8%89%B2%E4%BE%BF%E6%90%BA%E5%8C%96_%E6%89%93%E5%8C%85%E5%8D%B3%E7%94%A8/","title":"从零开始将Emacs绿色便携化_打包即用"},{"content":" 如果想要运行的话，在文件开头设置好运行语言，然后再加载一下该文件 1 2 3 4 (org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((C . t) )) 加载命令是： load-file 以我正在的编辑的 ts.org 文件为例 添加运行语言后，并设置 tangle，加载文件，执行 M-x，输入 load-file 后回车，输入当前文件名 ts.org 并回车加载成功。\n","date":"2024-03-26T00:55:06+08:00","permalink":"https://ynhugo.github.io/p/","title":""},{"content":" 学习emacs 首先有一些最基本的命令：\nM-x #命令模式 clipboard-kill-region #剪切区域并发送到系统剪切板和Kill环中，需 要配合命令模式使用 clipboard-kill-ring-save #复制区域内容到系统剪切板和Kill 环中，需要 配合命令模式使用 clipboard-yank #从剪切板中粘贴到Emacs中，需要配合命令模式 使用\nC-x u #重做，也就是撤销 C-x h #全选 C-w #删除 C-h f #查看函数绑定按键 C-k #从光标位置删除至行尾 C-p #移动到上一行 C-n #移动到下一行 C-b #向左移一个字符 C-f #向右移一个字符 C-x,C-s 保存 C-x,C-c 退出 emacs自带简单教程 emacs 自带的简单入门教程\n推荐emacs教程 专业 Emacs 入门（一）\n专业 Emacs 入门（二）：基础操作\n专业 Emacs 入门（三）：多文件与模式\n专业 Emacs 入门（四）：基本配置\n专业 Emacs 入门（五）：插件篇——功能优化类\n专业 Emacs 入门（六）：插件篇——功能增强类\n专业 Emacs 入门（七）：插件篇——编程开发类\n专业 Emacs 入门（八）：外观主题\n专业 Emacs 入门（九）：实用小技巧\n专业 Emacs 入门（十）：笔记系统 org-mode\n专业 Emacs 入门（十一）：AI 集成\n推荐书籍 Emacs-生存指南\nGNU-Emacs-Lisp编程入门\nANSI-Common-Lisp-中文版\nemacs入门教程 \u0026lt;C-h t\u0026gt; 查看官方教程，教程会根据系统语言显示中文 Emacs文件和目录操作模式Dired 参考链接 Emacs文件和目录操作模式Dired\n\u0026lt;\u0026gt; 内对应要执行的快捷键，C 表示 Ctrl 键，RET 表示回车，M 表示 Alt 键\n\u0026lt;C-x d\u0026gt; 进入Dired模式 \u0026lt;C-x C-f\u0026gt; RET PATH 打开PATH目录 在目录模式(dired)下的操作 将文件根据时间进行排序\n\u0026lt;s\u0026gt; 将文件按时间进行排序，按下 s 后使最新修改的文件排在前边 移动光标\n\u0026lt;SPACE\u0026gt;、\u0026lt;C-n\u0026gt;、\u0026lt;n\u0026gt; 向下 \u0026lt;Backspace\u0026gt;、\u0026lt;C-p\u0026gt;、\u0026lt;p\u0026gt; 向上 \u0026lt;ENTER\u0026gt; 进入子目录 \u0026lt;q\u0026gt; 退出子目录 查看文件内容\n\u0026lt;v\u0026gt; 移动到某文件以只读模式查看 \u0026lt;s\u0026gt; 递增查找字符串 \u0026lt;q\u0026gt; 退出只读模式 编辑文件\n\u0026lt;f\u0026gt; 编辑文件 \u0026lt;C-x k\u0026gt; 关闭当前buffer \u0026lt;C-b\u0026gt; 切换到上一个buffer，也可以rpv tab 键显示其他buffer手动输入切换 \u0026lt;C-x C-b\u0026gt; 显示buffer列表 \u0026lt;C-x C-f M-y\u0026gt; 重新编辑关掉的文件，\u0026lt;M-y\u0026gt;递归历史记录，找到关闭的文件并打开 文件的删除、复制、重命名、压缩与解压缩、比较\n\u0026lt;d\u0026gt; 加上待删除标记 \u0026lt;u\u0026gt; 取消标记 \u0026lt;x\u0026gt; 执行被记的文件 \u0026lt;#\u0026gt; 给所有自动文件添加待删除标记 \u0026lt;~\u0026gt; 给所有备份文件添加待删除标记 \u0026lt;D\u0026gt; 立即删除指定文件 \u0026lt;l\u0026gt; 用于复制光标所在文件文件 \u0026lt;2 C\u0026gt; 复制光标所在位置文件以及后一个文件 \u0026lt;R\u0026gt; 重命名或移动文件 \u0026lt;Z\u0026gt; 压缩与解压缩操作 \u0026lt;=\u0026gt; 比较当前文件与待输入的文件，类似于lunix的diff命令 在文件上运行linux命令，在文件上按\u0026lt;!\u0026gt;键\n对文件组进行操作\n\u0026lt;m\u0026gt; 标记文件 \u0026lt;%m\u0026gt; 使用正则标记 \u0026lt;+\u0026gt; 创建目录 linux下加载emacs配置文件提示：无法检查签名：没有公钥 参考链接 Emacs: Failed to verify signature archive-contents.sig或gpg: 无法检查签名：没有公钥\nEmacs 中更换文件的换行符格式 您可以使用 M-x set-buffer-file-coding-system 命令来实现这一操作。\n具体步骤如下：\n打开您想要更改换行符格式的文件。 执行 M-x set-buffer-file-coding-system 命令。 在弹出的提示中输入 unix，然后按 Enter。 这样就可以将文件的换行符格式从 Windows 格式（\\r\\n）转换为 Unix 格式（\\n）了。如果您希望将文件的换行符格式从 Unix 转换为 Windows 格式，可以在第三步中输入 dos。\nEmacs 选中内容后用 eww 搜索技巧 Emacs 中选择内容后执行如下命令\n1 \u0026lt;M-s,M-w\u0026gt; emacs导出html文件如何忽略不存在的文件路径 在Emacs中导出HTML文件时，如果需要忽略不存在的文件路径，你可以使用org-mode提供的一些选项来控制导出的行为。具体来说，你可以在org文件中使用以下选项：\n这将告诉org-mode在导出HTML时忽略不存在的文件路径，避免在导出时出现错误或警告。\n下面是一个示例：\n1 #+OPTIONS: broken-links:nil 通过设置这个选项，当你在Emacs中导出HTML文件时，org-mode会忽略不存在的文件路径，从而避免出现问题。\n安装emacs 对于Emacs，通常是带有图形界面的。然而，你可以安装一个被称为\u0026#34;Emacs in Terminal\u0026#34;的版本，它是一个没有图形界面的纯文本模式的Emacs。\n你可以尝试以下两种方法之一来安装\u0026#34;Emacs in Terminal\u0026#34;版本：\n命令行安装：\n打开终端（命令行界面）。\n输入以下命令以安装\u0026#34;Emacs in Terminal\u0026#34;版本：\n1 2 sudo apt-get update sudo apt-get install emacs-nox 这将安装一个没有图形界面的Emacs版本。\n手动编译安装：\n首先，你需要从Emacs官方网站下载源代码压缩包（tar.gz）。\n解压缩下载的源代码压缩包。\n进入解压缩后的目录，并执行以下命令：\n1 2 3 ./configure --without-x make sudo make install 这将通过 –without-x 选项编译一个没有图形界面的 Emacs 版本，并安装到系统中。\n无论你选择哪种方法，安装完成后，你可以在命令行中使用以下命令来启动\u0026#34;Emacs in Terminal\u0026#34;：\n1 emacs 这将在纯文本模式下启动Emacs，而不会调用图形界面。\nemacs使用技巧 emacs列操作与emacs寄存器的操作 Emacs列操作\nEmacs 编辑环境，第 4 部分: 选项、寄存器和书签\nemacs操作-显示空格，选中区域搜索空格并替换 显示空格和行尾标识：global-whitespace-mode\n查找并替换掉空格：M-% //执行命令，输入空格，回车，什么都不要输入，回车，输入感叹号\u0026#34;!\u0026#34;，选中区域搜索到的空格被替换消失。\nemacs: org-mode与gtd 用Emacs org mode实现任务管理（基础）\nEmacs Org Mode GTD工作流（实现任务管理、日期安排、工作日志记录）\nemacs文件头设置显示缩进和打开级别 文件头 1 2 3 4 5 #+STARTUP：overview ;;默认 top-level headlines only #+STARTUP：content ;;all headlines #+STARTUP：showall ;;默认 no folding of any entries #+STARTUP：showeveryting #+STARTUP：indent emacs查看按键使用记录 在 Emacs 中查看按键使用记录通常是指查看你在当前 Emacs 会话中输入的按键序列，这对于了解自己的操作习惯、调试快捷键冲突等问题很有帮助。你可以使用以下步骤来查看按键使用记录：\n在 Emacs 中打开一个 buffer（比如说使用 C-x C-f 打开一个文件）。 按下 C-h l（即 Control 键加上 h 键，然后加上 l 键），这将显示你最近的按键序列。 在 C-h l 命令执行后，会在 Emacs 下方显示你最近按下的按键序列，通常显示最近的 300 次按键记录。这些记录可以帮助你了解自己在 Emacs 中的操作习惯，并且在遇到问题时可以查看自己的操作过程，有助于快速排查问题。\n请注意，这个按键记录只是在当前 Emacs 会话中有效，一旦关闭 Emacs，这些记录就会消失。如果你需要更长时间的按键记录或者想要保存按键记录以备将来查看，你可能需要使用 Emacs 的其他插件或者进行一些配置。\n要确保嵌套代码块在 Org-mode 文档中显示为普通文本，可以使用 verbatim 或 example 代码块来避免被执行。下面是一个适合网页显示的示例： 1 2 3 4 5 ls #+begin_example # This is an inner code block echo \u0026#34;Inner block\u0026#34; #+end_example 在这个示例中，#+begin_example 和 #+end_example 用于将嵌套的代码块作为普通文本处理。确保在网页中显示时，它们不会被执行，而是以文本形式显示。\n对org-mode中的表格进行排序.org 在org-mode中,你可以快速地对表格进行排序,方法是将光标定位到表格上,然后按下 C-c ^. 再选择排序的类型(例如,a表示按字母顺序排序,n表示按数字来排序). 若你选择排序类型时使用了大写的字母,那么表示进行反向排序.\n排序时的key取之于光标所在的列,同时文档中也说明了排序的范围:\nThe range of lines is the range between the nearest horizontal separator lines, or the entire table of no such lines exist.\n参考链接 对org-mode中的表格进行排序\nOrg-mode基本按键\nemacs-document\norg-mode\norg-mode表格开启纵横坐标显示 使用快捷键 \u0026#34;C-c }\u0026#34; 可以开启表格的横纵坐标显示——若要关闭的话也是用它\n参考链接 强大的 Org mode(3): 表格的基本操作及公式、绘图\norg-mode表格进行公式编辑 如果是用 \u0026#34;C-c \u0026#39;\u0026#34; 来进行公式编辑，在输入表格位置时，会看到表格上对应的位置会在当时高亮，所以建议用这种方式进行编辑。\n参考链接 强大的 Org mode(3): 表格的基本操作及公式、绘图\n参考链接 Org Mode常用快捷键\n","date":"2024-03-26T00:55:06+08:00","permalink":"https://ynhugo.github.io/p/emacs_study/","title":"emacs_study"},{"content":" emacs使用正则表达式 参考链接\nEmacs 正则表达式搜索替换的小技巧\n使用方法 先执行\u0026#34;M-x isearch-forward-regexp \u0026lt;RET\u0026gt;\u0026#34;，然后用emacs的正则表达式规则匹配内容，匹配好内容后直接无缝衔接执行\u0026#34;M-%\u0026#34;对前边正则表达式匹配的内容进行替换。\n要匹配多个换行符并直到以指定内容结尾，你可以使用以下正则表达式 要匹配多个换行符并直到以指定内容结尾，你可以使用以下正则表达式\n1 [[:ascii:]\\n\\r]*指定内容$ 在这里：\n[[:ascii:]\\n\\r]* 匹配任意ASCII字符、换行符（\\n）、回车符（\\r）零次或多次。 指定内容$ 表示以 \u0026#34;指定内容\u0026#34; 结尾的文本行。 在 Emacs 中，你可以使用 query-replace-regexp 或 replace-regexp 命令来执行基于正则表达式的替换操作。你可以按下 M-% 进入交互式查找替换模式，然后输入上述正则表达式进行匹配和替换操作。\noccur命令-根据正则表达式匹配内容到新的buffer 执行命令：\u0026lt;M-x occur\u0026gt;\n","date":"2024-03-26T00:55:06+08:00","permalink":"https://ynhugo.github.io/p/emacs_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"emacs_正则表达式"},{"content":" 节点获取 访问链接：https://pastebin.com/bKQsUFMR\n密码：0FXccDRchB\n访问之后应首先拷贝代码内容，保存到本地为.sh脚本并授予执行权限\n脚本功能：优选 IP 并获取 CF 的分流节点\n第一个建议执行方式：./ccf_v4.sh\n第二个建议执行方式：curl https://api.filedoge.com/download/b1cf49263090aee5acfc698e556ed8a5d8b13c3e3ed0fdea15cff09e62f5bb31e4aa372b93135cbf5ed5 | bash\n节点转换查看：for i in $(cat nodes.txt | base64 -d); do echo $i | awk -F \u0026#34;//\u0026#34; \u0026#39;{print $2}\u0026#39; | base64 -d | jq; sleep 1; done\n支持终端：Termux、Cygwin、Linux\n","date":"2024-03-26T00:24:38+08:00","permalink":"https://ynhugo.github.io/p/%E8%8A%82%E7%82%B9%E8%8E%B7%E5%8F%96/","title":"节点获取"},{"content":" 准备域名 申请一个域名\n将准备好的域名进行 DNS 解析，添加 A 记录进行解析，对应服务器 IPV4\n申请证书 需要注意的是服务器 IP 要能够正常 PING 的通，不然在一些网络环境可能不能正常使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #安装socat： apt install socat #安装acme： curl https://get.acme.sh | sh #添加软链接： ln -s /root/.acme.sh/acme.sh /usr/local/bin/acme.sh #注册账号： acme.sh --register-account -m my@example.com #开放80端口： ufw allow 80 #申请证书： acme.sh --issue -d 替换为你的域名 --standalone -k ec-256 #安装证书，指定证书私钥与完整的证书链安装路径： acme.sh --installcert -d 替换为你的域名 --ecc --key-file /root/server.key --fullchain-file /root/server.crt #如果默认CA无法颁发，则可以切换下列CA： #切换 Let’s Encrypt： acme.sh --set-default-ca --server letsencrypt #切换 Buypass： acme.sh --set-default-ca --server buypass #切换 ZeroSSL： acme.sh --set-default-ca --server zerossl 自签证书 自签证书的话，域名或ip访问报警告，这时需要将自签的证书导入到受信任的颁发机构中\n1 2 3 4 5 6 7 8 #生成私钥： openssl ecparam -genkey -name prime256v1 -out ca.key #生成证书，指定要签给的域名： openssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \u0026#34;/CN=bing.com\u0026#34; # 如果在生成证书的时候提示没有 .rnd 随机种子文件，解决方法：在缺少 .rnd 的目录中生成 .rnd，默认是在家目录缺少 .rnd，因此直接将 .rnd 生成在家目录下 openssl rand -writerand ~/.rnd 伪装网站 如果服务器上安装了 nginx，可以在 nginx 默认的欢迎页面文件的目录下增加一个 index.html，index.html内容可以在网上随便找，我找了一个代码是作为精美web首页的\n参考链接 https://bulianglin.com/archives/guide.html\nHTML+CSS制作一个精美Web首页（100行代码以内）\n","date":"2024-03-26T00:24:36+08:00","permalink":"https://ynhugo.github.io/p/acme%E8%84%9A%E6%9C%AC%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6%E6%95%99%E7%A8%8B/","title":"acme脚本申请证书教程"},{"content":" windows10 + ubuntu16.04.4，安装双系统的技巧，windows环境先分区，给最后一个盘分区大一些，再将最后一般盘压缩出用于安装ubuntu自定义的空闲空间，用rufus制作ubuntu启动盘，安装ubuntu的时候的时候选择\u0026#34;其他分区\u0026#34;中自己分出来的空闲空间，对该空闲空间分出8G作为交换空间，剩下的挂载根目录，然后选中根目录进行安装即可\n","date":"2024-03-26T00:24:36+08:00","permalink":"https://ynhugo.github.io/p/%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/","title":"安装双系统教程"},{"content":" 参考链接 https://zhuanlan.zhihu.com/p/420194002\n如何编写一个Linux内核模块 前言 Linux 系统为应用程序提供了功能强大且容易扩展的 API，但在某些情况下，这还远远不够。与硬件交互或进行需要访问系统中特权信息的操作时，就需要一个内核模块。\nLinux 内核模块是一段编译后的二进制代码，直接插入 Linux 内核中，在 Ring 0 （x86–64处理器中执行最低和受保护程度最低的执行环）上运行。这里的代码完全不受检查，但是运行速度很快，可以访问系统中的所有内容。\nIntel X86架构使用了4个级别来标明不同的特权级。 Ring 0 实际就是内核态，拥有最高权限。而一般应用程序处于 Ring 3状态–用户态。在Linux中，还存在 Ring 1 和 Ring 2 两个级别，一般归属驱动程序的级别。在Windows平台没有 Ring 1 和 Ring 2 两个级别，只用 Ring 0 内核态和 Ring 3 用户态。在权限约束上，高特权等级状态可以阅读低特权等级状态的数据，例如进程上下文、代码、数据等等，但反之则不可。 Ring 0 最高可以读取 Ring 0-3 所有的内容， Ring 1 可以读 Ring 1-3 的， Ring 2 以此类推， Ring 3 只能读自己的数据。\n为什么要开发内核模块 编写 Linux 内核模块并不是因为内核太庞大而不敢修改。直接修改内核源码会导致很多问题，例如：通过更改内核，你将面临数据丢失和系统损坏的风险。内核代码没有常规 Linux 应用程序所拥有的安全防护机制，如果内核发生故障，将锁死整个系统。\n更糟糕的是，当你修改内核并导致错误后，可能不会立即表现出来。如果模块发生错误，在其加载时就锁定系统是最好的选择，如果不锁定，当你向模块中添加更多代码时，你将会面临失控循环和内存泄漏的风险，如果不小心，它们会随着计算机继续运行而持续增长，最终，关键的存储器结构甚至缓冲区都可能被覆盖。\n编写内核模块时，基本是可以丢弃传统的应用程序开发范例。除了加载和卸载模块之外，你还需要编写响应系统事件的代码（而不是按顺序模式执行的代码）。通过内核开发，你正在编写API，而不是应用程序。\n你也无权访问标准库，虽然内核提供了一些函数，例如 printk （可替代 printf）和 kmalloc （以与 malloc 相似的方式运行），但你在很大程度上只能使用自己的设备。此外，在卸载模块时，你需要将自己清理干净，系统不会在你的模块被卸载后进行垃圾回收。\n开发的工具准备 开始编写 Linux 内核模块之前，我们首先要准备一些工具。最重要的是，你需要有一台 Linux 机器，尽管可以使用任何 Linux 发行版，但本文中，我使用的是 Ubuntu 16.04 LTS，如果你使用的其他发行版，可能需要稍微调整安装命令。\n其次，你需要一台物理机或虚拟机，我不建议你直接使用物理机编写内核模块，因为当你出错时，主机的数据可能会丢失。在编写和调试内核模块的过程中，你至少会锁定机器几次，内核崩溃时，最新的代码更改可能仍在写缓冲区中，因此，你的源文件可能会损坏，在虚拟机中进行测试可以避免这种风险。\n最后，你至少需要了解一些C。对于内核来说，C++ 在运行时太大了，因此编写纯 C 代码是必不可少的。另外，对于其与硬件的交互，了解一些组件可能会有所帮助。\n安装开发环境 让我们开始编写一些代码，准备环境：\n1 2 mkdir -p ~/src/lkm_example cd ~/src/lkm_example 启动您喜欢的编辑器（在我的例子中是vim），并创建具有以下内容的文件 lkm_example.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;abin\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A simple example Linux module.\u0026#34;); MODULE_VERSION(\u0026#34;0.01\u0026#34;); static int __init lkm_example_init(void) { printk(KERN_INFO \u0026#34;Hello, World!\\n\u0026#34;); return 0; } static void __exit lkm_example_exit(void) { printk(KERN_INFO \u0026#34;Goodbye, World!\\n\u0026#34;); } module_init(lkm_example_init); module_exit(lkm_example_exit); 现在，我们已经构建了最简单的内核模块，下面介绍代码的细节：\n#includes 包括 Linux 内核开发所需的必需头文件。\n根据模块的许可证，可以将 MODULE_LICENSE 设置为各种值。要查看完整列表，请运行：\n1 grep \u0026#34;MODULE_LICENSE\u0026#34; -B 27 /usr/src/linux-headers-`uname -r`/include/linux/module.h 我们将 init （加载）和 exit （卸载）函数都定义为静态并返回 int 。\n注意使用 printk 而不是 printf ，另外， printk 与 printf 共享的参数也不相同。例如， KERN_INFO 是一个标志，用于声明应为该行设置的日志记录优先级，并且不带逗号。内核在printk函数中对此进行分类以节省堆栈内存。\n在文件末尾，我们调用 module_init 和 module_exit 函数告诉内核哪些函数是内核模块的加载和卸载函数。这使我们可以任意命名这两个函数。\n目前，还无法编译此文件，我们需要一个 Makefile ，请注意， make 对于空格和制表符敏感，因此请确保在适当的地方使用制表符而不是空格。\n1 2 3 4 5 obj-m += lkm_example.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 如果我们运行 \u0026#34;make\u0026#34;，它将成功编译你编写的模块，编译后的文件为 \u0026#34;lkm_example.ko\u0026#34;，如果收到任何错误，请检查示例源文件中的引号是否正确，并且不要将其粘贴为UTF-8字符。\n现在我们可以将此模块加载进内核进行测试了，命令如下：\n1 sudo insmod lkm_example.ko 如果一切顺利，你将看不到任何输出，因为 printk 函数不会输出到控制台，而是输出到内核日志。要看到内核日志中的内容，我们需要运行：\n1 sudo dmesg 你应该看到以时间戳为前缀的行：\u0026#34;Hello, World!\u0026#34;，这意味着我们的内核模块已加载并成功打印到内核日志中。\n我们还可以检查模块是否已被加载：\n1 lsmod | grep \u0026#34;lkm_example\u0026#34; 要卸载模块，运行：\n1 sudo rmmod lkm_example 如果再次运行 dmesg ，你将看到\u0026#34;Goodbye, World!\u0026#34; 在日志中。你也可以再次使用 lsmod 命令确认它已卸载。\n如你所见，此测试工作流程有点繁琐，因此要使其自动化，我们可以在 Makefile 中添加：\n1 2 3 4 5 test: sudo dmesg -C sudo insmod lkm_example.ko sudo rmmod lkm_example.ko dmesg 现在，运行：\n1 make test 一般模块 让我们再思考下。尽管内核模块可以完成各种任务，但与应用程序进行交互是其最常见的用途之一。\n由于操作系统限制了应用程序查看内核空间内存的内容，因此，应用程序必须使用API与内核进行通信。尽管从技术上讲，有多种方法可以完成此操作，但最常见的方法是创建设备文件。\n你以前可能已经与设备文件进行过交互。使用 /dev/zero ， /dev/null 或类似设备的命令就是与名为 zero 和 null 的设备进行交互，这些设备将返回期望的值。\n在我们的示例中，我们将返回 \u0026#34;Hello，World\u0026#34;，虽然这些字符串对于应用程序并没有什么用，但它将显示通过设备文件响应应用程序的过程。\n这是完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;Robert W. Oliver II\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A simple example Linux module.\u0026#34;); MODULE_VERSION(\u0026#34;0.01\u0026#34;); #define DEVICE_NAME \u0026#34;lkm_example\u0026#34; #define EXAMPLE_MSG \u0026#34;Hello, World!\\n\u0026#34; #define MSG_BUFFER_LEN 15 /* Prototypes for device functions */ static int device_open(struct inode *, struct file *); static int device_release(struct inode *, struct file *); static ssize_t device_read(struct file *, char *, size_t, loff_t *); static ssize_t device_write(struct file *, const char *, size_t, loff_t *); static int major_num; static int device_open_count = 0; static char msg_buffer[MSG_BUFFER_LEN]; static char *msg_ptr; /* This structure points to all of the device functions */ static struct file_operations file_ops = { .read = device_read, .write = device_write, .open = device_open, .release = device_release }; /* When a process reads from our device, this gets called. */ static ssize_t device_read(struct file *flip, char *buffer, size_t len, loff_t *offset) { int bytes_read = 0; /* If we’re at the end, loop back to the beginning */ if (*msg_ptr == 0) { msg_ptr = msg_buffer; } /* Put data in the buffer */ while (len \u0026amp;\u0026amp; *msg_ptr) { /* Buffer is in user data, not kernel, so you can’t just reference ,* with a pointer. The function put_user handles this for us */ put_user(*(msg_ptr++), buffer++); len--; bytes_read++; } return bytes_read; } /* Called when a process tries to write to our device */ static ssize_t device_write(struct file *flip, const char *buffer, size_t len, loff_t *offset) { /* This is a read-only device */ printk(KERN_ALERT \u0026#34;This operation is not supported.\\n\u0026#34;); return -EINVAL; } /* Called when a process opens our device */ static int device_open(struct inode *inode, struct file *file) { /* If device is open, return busy */ if (device_open_count) { return -EBUSY; } device_open_count++; try_module_get(THIS_MODULE); return 0; } /* Called when a process closes our device */ static int device_release(struct inode *inode, struct file *file) { /* Decrement the open counter and usage count. Without this, the module would not unload. */ device_open_count--; module_put(THIS_MODULE); return 0; } static int __init lkm_example_init(void) { /* Fill buffer with our message */ strncpy(msg_buffer, EXAMPLE_MSG, MSG_BUFFER_LEN); /* Set the msg_ptr to the buffer */ msg_ptr = msg_buffer; /* Try to register character device */ major_num = register_chrdev(0, \u0026#34;lkm_example\u0026#34;, \u0026amp;file_ops); if (major_num \u0026lt; 0) { printk(KERN_ALERT \u0026#34;Could not register device: %d\\n\u0026#34;, major_num); return major_num; } else { printk(KERN_INFO \u0026#34;lkm_example module loaded with device major number %d\\n\u0026#34;, major_num); return 0; } } static void __exit lkm_example_exit(void) { /* Remember — we have to clean up after ourselves. Unregister the character device. */ unregister_chrdev(major_num, DEVICE_NAME); printk(KERN_INFO \u0026#34;Goodbye, World!\\n\u0026#34;); } /* Register module functions */ module_init(lkm_example_init); module_exit(lkm_example_exit); 既然我们的示例所做的不仅仅是在加载和卸载时打印一条消息，让我们修改 Makefile，使其仅加载模块而不卸载模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 obj-m += lkm_example.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean test: # We put a — in front of the rmmod command to tell make to ignore # an error in case the module isn’t loaded. -sudo rmmod lkm_example # Clear the kernel log without echo sudo dmesg -C # Insert the module sudo insmod lkm_example.ko # Display the kernel log dmesg 现在，当您运行 \u0026#34;make test\u0026#34; 时，您将看到设备主号码的输出。在我们的示例中，这是由内核自动分配的，但是，你需要此值来创建设备。\n获取从 \u0026#34;make test\u0026#34; 获得的值，并使用它来创建设备文件，以便我们可以从用户空间与内核模块进行通信：\n1 sudo mknod /dev/lkm_example c MAJOR 0 在上面的示例中，将 MAJOR 替换为你运行 \u0026#34;make test\u0026#34; 或 \u0026#34;dmesg\u0026#34; 后得到的值，我得到的 MAJOR 为 236，如上图，mknod 命令中的 \u0026#34;c\u0026#34; 告诉 mknod 我们需要创建一个字符设备文件。\n现在我们可以从设备中获取内容：\n1 cat /dev/lkm_example 或者通过 \u0026#34;dd\u0026#34; 命令：\n1 dd if=/dev/lkm_example of=test bs=14 count=100 你也可以通过应用程序访问此设备，它们不必编译应用程序–甚至Python、Ruby和PHP脚本也可以访问这些数据。\n完成测试后，将其删除并卸载模块：\n1 2 sudo rm /dev/lkm_example sudo rmmod lkm_example 总结 尽管提供的示例是简单内核模块，但完全可以根据此结构来构造自己的模块，以完成非常复杂的任务。\n请记住，在内核模块开发过程中完全靠自己。如果为客户提供一个项目的报价，一定要把预期的调试时间增加一倍，甚至三倍。内核代码必须尽可能的完美，以确保运行它的系统的完整性和可靠性。\n","date":"2024-03-26T00:24:36+08:00","permalink":"https://ynhugo.github.io/p/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAlinux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","title":"如何编写一个Linux内核模块"},{"content":" 通用语法如下所示 1 $ ssh [用户名]@[远程主机名或 IP] [命令或脚本] 使用示例 以下代码为 Termux 环境使用示例，termux-clipboard-set 为 Termux 剪切板，\u0026#34;sed -n \u0026#39;13\u0026#39;p\u0026#34; 输出指定行\n1 ssh thc_1 ./ccf.sh 104.19.62.5 | sed -n \u0026#39;13\u0026#39;p | termux-clipboard-set 参考链接 如何通过SSH在远程Linux系统上运行命令\n","date":"2024-03-26T00:24:36+08:00","permalink":"https://ynhugo.github.io/p/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87ssh%E5%9C%A8%E8%BF%9C%E7%A8%8Blinux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/","title":"如何通过SSH在远程Linux系统上运行命令"},{"content":" 创建第一个脚本，并拷贝第一个脚本为第二个脚本，再创建第三个脚本，并将第一个脚本的内容输出到第三个脚本 用\u0026#34;fgets\u0026#34;和\u0026#34;fputs\u0026#34;将第一个脚本的内容输出到第三个脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { FILE* fd_1; FILE* fd_2; char* path_1 = \u0026#34;./test_1.sh\u0026#34;; char* path_2 = \u0026#34;./test_2.sh\u0026#34;; char* path_3 = \u0026#34;./test_3.sh\u0026#34;; char *buffer_1; char command[100]; /* 创建文件 */ fd_1 = fopen(path_1, \u0026#34;w\u0026#34;); /* 输出一个空行 */ sprintf(command, \u0026#34;echo \\\u0026#34;\\\u0026#34;\u0026#34;); system(command); /* 判断变量\u0026#34;path_2\u0026#34;对应的文件是否存在 */ sprintf(command, \u0026#34;echo \\\u0026#34;if [ ! -f %s ]; then\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_2, path_1); system(command); /* 如果变量\u0026#34;path_2\u0026#34;对应的文件不存在，则将变量\u0026#34;path_1\u0026#34;对应的文件拷贝为变量\u0026#34;path_2\u0026#34;对应的文件 */ sprintf(command, \u0026#34;echo \\\u0026#34;cp %s %s\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_1, path_2, path_1); system(command); sprintf(command, \u0026#34;echo \\\u0026#34;fi\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_1); system(command); /* 运行变量\u0026#34;path_1\u0026#34;对应的脚本 */ sprintf(command, \u0026#34;sh %s\u0026#34;, path_1); system(command); /* 以只读的方式打开变量\u0026#34;path_1\u0026#34;对应的文件 */ fd_1 = fopen(path_1, \u0026#34;r\u0026#34;); /* 创建\u0026#34;path_3\u0026#34;对应的文件 */ fd_2 = fopen(path_3, \u0026#34;w\u0026#34;); if (fd_1 == NULL || fd_2 == NULL) { printf(\u0026#34;文件打开失败\\n\u0026#34;); return 1; } /* 获取变量\u0026#34;path_1\u0026#34;对应的文件内容 */ while (fgets(command, sizeof(command), fd_1) != NULL) { /* 将变量\u0026#34;path_1\u0026#34;对应的文件内容输出到变量\u0026#34;path_3\u0026#34;对应的文件 */ fputs(command, fd_2); } return 0; } 用\u0026#34;fread\u0026#34;和\u0026#34;fwrite\u0026#34;将第一个脚本的内容输出到第三个脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { FILE* fd_1; FILE* fd_2; char* path_1 = \u0026#34;./test_1.sh\u0026#34;; char* path_2 = \u0026#34;./test_2.sh\u0026#34;; char* path_3 = \u0026#34;./test_3.sh\u0026#34;; char *buffer_1 = (char*)malloc(sizeof(char) * 1024 *1024); char* command = (char*)malloc(sizeof(char) * 1024 * 1024); /* 创建文件 */ fd_1 = fopen(path_1, \u0026#34;w\u0026#34;); /* 输出一个空行 */ sprintf(command, \u0026#34;echo \\\u0026#34;\\\u0026#34;\u0026#34;); system(command); /* 判断变量\u0026#34;path_2\u0026#34;对应的文件是否存在 */ sprintf(command, \u0026#34;echo \\\u0026#34;if [ ! -f %s ]; then\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_2, path_1); system(command); /* 如果变量\u0026#34;path_2\u0026#34;对应的文件不存在，则将变量\u0026#34;path_1\u0026#34;对应的文件拷贝为变量\u0026#34;path_2\u0026#34;对应的文件 */ sprintf(command, \u0026#34;echo \\\u0026#34;cp %s %s\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_1, path_2, path_1); system(command); sprintf(command, \u0026#34;echo \\\u0026#34;fi\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_1); system(command); /* 运行变量\u0026#34;path_1\u0026#34;对应的脚本 */ sprintf(command, \u0026#34;sh %s\u0026#34;, path_1); system(command); /* 以只读的方式打开变量\u0026#34;path_1\u0026#34;对应的文件 */ fd_1 = fopen(path_1, \u0026#34;r\u0026#34;); /* 创建变量\u0026#34;path_3\u0026#34;对应的文件 */ fd_2 = fopen(path_3, \u0026#34;w\u0026#34;); /* 读取变量\u0026#34;path_1\u0026#34;对应的文件内容 */ fread(buffer_1, 1024, 1, fd_1); /* 将变量\u0026#34;path_1\u0026#34;对应的文件内容写入到变量\u0026#34;path_3\u0026#34;对应的文件中 */ fwrite(buffer_1, 1024, 1, fd_2); return 0; } 获取变量\u0026#34;command\u0026#34;对应的缓存区中实际字符个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { FILE* fd_1; FILE* fd_2; char* path_1 = \u0026#34;./test_1.sh\u0026#34;; char* path_2 = \u0026#34;./test_2.sh\u0026#34;; char* path_3 = \u0026#34;./test_3.sh\u0026#34;; char *buffer_1 = (char*)malloc(sizeof(char) * 1024 *1024); char* command = (char*)malloc(sizeof(char) * 1024 * 1024); int j = 0; /* 创建文件 */ fd_1 = fopen(path_1, \u0026#34;w\u0026#34;); /* 输出一个空行 */ sprintf(command, \u0026#34;echo \\\u0026#34;\\\u0026#34;\u0026#34;); system(command); j = 0; while(command[j] != \u0026#39;\\0\u0026#39;) { j++; } printf(\u0026#34;cur_line: %d, j: %d\\n\u0026#34;, __LINE__, j);\t/* 判断变量\u0026#34;path_2\u0026#34;对应的文件是否存在 */ sprintf(command, \u0026#34;echo \\\u0026#34;if [ ! -f %s ]; then\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_2, path_1); system(command); j = 0; while(command[j] != \u0026#39;\\0\u0026#39;) { j++; } printf(\u0026#34;cur_line: %d, j: %d\\n\u0026#34;, __LINE__, j); /* 如果变量\u0026#34;path_2\u0026#34;对应的文件不存在，则将变量\u0026#34;path_1\u0026#34;对应的文件拷贝为变量\u0026#34;path_2\u0026#34;对应的文件 */ sprintf(command, \u0026#34;echo \\\u0026#34;cp %s %s\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_1, path_2, path_1); system(command); j = 0; while(command[j] != \u0026#39;\\0\u0026#39;) { j++; } printf(\u0026#34;cur_line: %d, j: %d\\n\u0026#34;, __LINE__, j);\tsprintf(command, \u0026#34;echo \\\u0026#34;fi\\\u0026#34; \u0026gt;\u0026gt; %s\u0026#34;, path_1); system(command); j = 0; while(command[j] != \u0026#39;\\0\u0026#39;) { j++; } printf(\u0026#34;cur_line: %d, j: %d\\n\u0026#34;, __LINE__, j);\t/* 运行变量\u0026#34;path_1\u0026#34;对应的脚本 */ sprintf(command, \u0026#34;sh %s\u0026#34;, path_1); j = 0; while(command[j] != \u0026#39;\\0\u0026#39;) { j++; } printf(\u0026#34;cur_line: %d, j: %d\\n\u0026#34;, __LINE__, j); system(command); /* 以只读的方式打开变量\u0026#34;path_1\u0026#34;对应的文件 */ fd_1 = fopen(path_1, \u0026#34;r\u0026#34;); /* 创建变量\u0026#34;path_3\u0026#34;对应的文件 */ fd_2 = fopen(path_3, \u0026#34;w\u0026#34;); /* 读取变量\u0026#34;path_1\u0026#34;对应的文件内容 */ fread(buffer_1, 1024, 1, fd_1); /* 将变量\u0026#34;path_1\u0026#34;对应的文件内容写入到变量\u0026#34;path_3\u0026#34;对应的文件中 */ fwrite(buffer_1, 1024, 1, fd_2); return 0; } ","date":"2024-03-26T00:24:36+08:00","permalink":"https://ynhugo.github.io/p/%E5%9C%A8c%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%90%E8%A1%8Cshell%E8%84%9A%E6%9C%AC/","title":"在C语言中运行shell脚本"},{"content":" 在浏览器中，可以通过网页中的 JavaScript 代码获取到一些关于用户浏览器和操作系统的信息。在前端开发中，可以使用 `navigator.userAgent` 属性来获取当前浏览器的 User-Agent 字符串。\n例如，下面的 JavaScript 代码可以获取到当前浏览器的 User-Agent 字符串并输出到控制台：\n1 console.log(navigator.userAgent); 运行这段代码，你将会在浏览器的开发者工具中看到输出的 User-Agent 字符串，它包含了浏览器的名称、版本号、操作系统等信息。\n需要注意的是，由于浏览器的安全策略限制，JavaScript 不能获取到完整的操作系统信息，只能获取到一些相关的标识信息。而且，用户可以通过修改浏览器的 User-Agent 字符串来伪装自己的浏览器身份，所以 User-Agent 并不是绝对可靠的身份验证方式。\n但是，在服务器端，它可以通过解析 HTTP 请求头部中的 User-Agent 字段来获取浏览器的信息，以便进行适当的处理和响应。\n","date":"2024-03-26T00:24:36+08:00","permalink":"https://ynhugo.github.io/p/%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E9%80%9A%E8%BF%87javascfipt%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E5%88%B0%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/","title":"在网页中通过JavaScfipt代码获取到一些关于浏览器和操作系统的信息"},{"content":" vim_studay vim常用命令 `u` 撤销上次命令 `Ctrl+r` 恢复撤销命令 `x` 删除光标所在的字符或选中文字 `d(移动命令)` 删除移动命令对应的内容 `dd` 删除光标所在行，可以ndd复制多行 `D` 删除至行尾 `dw` 从光标位置删除到单词末尾 `d0` 从光标位置删除到一行的起始位置 `d}` 从光标位置删除到段落结尾 `ndd` 从光标位置向下连续删除 n 行 `d代码行G` 从光标所在行 删除到 指定代码行 之间的所有代码 `d’a` 从光标所在行 删除到 标记a 之间的所有代码 `touch 文件名(或文件名+后缀)` 建立空文件 `echo \u0026#39;内容\u0026#39; \u0026gt; 文件` 将内容写入文件 `x,X` #在一行字当中，x为向后删除-个字符,X为向前删除 `nx` #n为数字，连续向后删除n个字符 `dd` #删除游标所在的那一 -整列(常用) `ndd` #n为数字,删除光标所在的向下n列 `d1G` #删除光标所在到第一行的所有数据 `dG` #删除光标所在到最后一行的所有数据 `d$` #删除游标所在处，到该行的最后一个字符 `d0` #那个是数字的0，删除游标所在处，到该行的最前面一个字符 `vy` #复制游标所在的那- -行(常用) `nyy` #n为数字。 复制光标所在的向下n列，例如20yy则是复制20 列(常用) `y1G` #复制游标所在列到第- 列的所有数据 `yG` #复制游标所在列到最后一列的所有数据 `y0` #复制光标所在的那个字符到该行行首的所有数据 `y$` #复制光标所在的那个字符到该行行尾的所有数据 `p,P` #p为将已复制的数据在光标下一行贴上，P则为贴在游标上一行!举例来说，我目前光标在第20行，且己经复制了10行数据。则按下p后，那10行数据会贴在原本的20标在第20行，且己经复制了10行数据。则按下p后，那10行数据会贴在原本的20行之后，亦即由21行开始贴。但如果是按下P呢?那么原本的第20行会被推到变成30行 ( 常用) `J` #将光标所在列与下一列的数据结合成同一列 `c` #重复删除多个数据，例如向下删除10行，[10c] `u` #复原前一个动作。(常用)\nctrl + c 退出模式\n命令模式下： ctrl + p 向上一行 ctrl + n 向下一行 ctrl + o 打开最近打开过的文件\n在插入模式下： ctrl + i / ctrl + t 从光标位置向后补一个tab ctrl + y 复制上一行同一列的字符 ctrl + u 删除光标前的内容 ctrl + n / ctrl + p 打开补全列表 ctrl + h 删除光标前的一个字符 ctrl + x 特殊功能模式，ctrl + y / ctrl + e 上下移动页面 ctrl + j / ctrl + m 向下补空行 ctrl + w 删除单词\n`Ctrl+r` #重做上一个动作。(常用) `.` #不要怀疑!这就是小数点!意思重复前一个动作的意思。如果你想要重复删除、重复贴上等等动作，按下小数点就好了! (常用)\n基于单词/字串的移动命令 移动命令\t说明 w\t移动到下一个单词的开头 W\t移动到下一个字串的开头 e\t移动到当前单词的末尾，或者下一个单词的末尾 E\t移动到当前字串的末尾，或者下一个字串的末尾 b\t移动到当前单词的开头，或者前一个单词的开头 B\t移动到当前字串的开头，或者前一个字串的开头 ge\t移动到上一个单词的结尾 gE\t移动到上一个字串 的结尾\n","date":"2024-03-26T00:24:34+08:00","permalink":"https://ynhugo.github.io/p/vim_study/","title":"vim_study"},{"content":" z-libary 自动获取最新网址的神奇邮箱 在这里还要给大家介绍一个可以自动获取最新网址的邮箱。\n只要给 blackbox@zlib.se 随便发个邮件，它会自动告诉你最新的网址。\n而且邮件里面还会告诉你一个客服的邮箱，也是可以联系的。\n参考链接 Zlibrary最新使用方法(国内版)(2023.11.20更新)+其他好用电子书网站推荐\n","date":"2024-03-26T00:24:34+08:00","permalink":"https://ynhugo.github.io/p/z-libary/","title":"z-libary"},{"content":" highlightcode 将代码进行高亮显示，可以粘贴到word中\nhttps://highlightcode.com/\ncarbon 将代码高亮并转为图片，支持在线预览和下载\nhttps://carbon.now.sh/\n","date":"2024-03-26T00:24:34+08:00","permalink":"https://ynhugo.github.io/p/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/","title":"代码高亮"},{"content":" RUSTDESK 缺点：延迟比较高，大约在 500ms-1000ms，比向日葵慢的多 优点：可以不需要实名认证，可以不需要手机号或者邮箱注册登录\n免费开源的远程控制软件！支持全平台 Winodws、mac、安卓、iOS Github 开源项目：【点击前往】\n官方说明文档 RUSTDESK\n参考链接 免费开源的远程控制软件！支持全平台 Winodws、mac、安卓、iOS\n","date":"2024-03-26T00:24:34+08:00","permalink":"https://ynhugo.github.io/p/%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%BD%AF%E4%BB%B6-%E6%94%AF%E6%8C%81%E5%85%A8%E5%B9%B3%E5%8F%B0/","title":"免费开源的远程控制软件-支持全平台"},{"content":" 说明 通过FileDoge的API上传文件，并将上传文件后返回的文件信息保存到本地文件中，该文件保留在家目录下。\n运行脚本，如果要上传文件到云端，第一个选项应为\u0026#34;-upload\u0026#34;，则第二个选项为文件路径，上传文件后会返回文件的\u0026#34;token\u0026#34;和\u0026#34;delete_token\u0026#34;等基本信息，并且会保存上传时产生的日志文件在本地，上传结束后会返回日志文件所在路径；如果要查看云端文件的信息，则第一个选项应为\u0026#34;-file\u0026#34;，第二个选项应为对应云端的\u0026#34;token\u0026#34;；如果要删除云端文件，则第一个选项应为\u0026#34;-delete\u0026#34;，第二个选项为\u0026#34;token\u0026#34;，第三个选项为\u0026#34;delete_token\u0026#34;；如果要下载文件，则第一个选项应为\u0026#34;-download\u0026#34;，第二个选项为\u0026#34;上传结束后会返回日志文件所在路径\u0026#34;，脚本会从日志文件中检测到\u0026#34;token\u0026#34;并将相应的文件下载下来，如果是大于200MB的文件则会自动合并；如果要查看帮助手册，则第一个选项应为\u0026#34;–help\u0026#34;。\n脚本下载 点击下载：filedoge.sh\n下载脚本后记得给脚本执行权限\n1 chmod +x filedoge.sh 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 cmdself=$0 if [ -z \u0026#34;$1\u0026#34; ]; then echo \u0026#34;Upload File: ${cmdself} -upload \\\u0026#34;filepath\\\u0026#34;\u0026#34; echo \u0026#34;File Information: ${cmdself} -file \\\u0026#34;token\\\u0026#34;\u0026#34; echo \u0026#34;Delete File: ${cmdself} -delete \\\u0026#34;token\\\u0026#34; \\\u0026#34;delete_token\\\u0026#34;\u0026#34; echo \u0026#34;Download File: ${cmdself} -download \\\u0026#34;Upload file log\\\u0026#34;\u0026#34; echo \u0026#34;Help: ${cmdself} --help\u0026#34; fi # Upload File if [ \u0026#34;$1\u0026#34; == \u0026#34;-upload\u0026#34; ]; then\tfilePath=$2 filePathName=$(echo \u0026#34;${filePath}\u0026#34; | tr \u0026#39;\\/\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $NF}\u0026#39;) FileDogeLogDir=\u0026#34;${HOME}/FileDoge/Log\u0026#34;\tlog=${FileDogeLogDir}/${filePathName}/${filePathName}.txt.1 if [ ! -d \u0026#34;${FileDogeLogDir}/${filePathName}\u0026#34; ]; then mkdir -p \u0026#34;${FileDogeLogDir}/${filePathName}\u0026#34; fi\tcompile_size=$((200 * 1024 * 1024)) compile_file_size=$(stat -c%s \u0026#34;${filePath}\u0026#34;) if [ \u0026#34;${compile_file_size}\u0026#34; -ge \u0026#34;${compile_size}\u0026#34; ]; then split -d -b 199m ${filePath} ${filePath}_split_ lookup_var=$(ls -l ${filePath}_split_* | sort -nr | nl | tail -n 1 | awk \u0026#39;{print $1}\u0026#39;) if [ -f \u0026#34;${log}\u0026#34; ]; then if [ \u0026#34;${filePathName}_*.txt\u0026#34; ]; then flag=0 flag=$(ls \u0026#34;${FileDogeLogDir}/${filePathName}/${filePathName}\u0026#34;.txt.* | tail -n 1 | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $NF}\u0026#39;) log=${FileDogeLogDir}/${filePathName}/${filePathName}.txt.$((flag + 1)) fi fi for ((i = 0; i \u0026lt; ${lookup_var}; i++)) do lookup_num=$(printf \u0026#34;%02d\\n\u0026#34; $i) curl --location --request POST \u0026#39;https://api.filedoge.com/upload\u0026#39; -H \u0026#34;Content-Type: multipart/form-data;\u0026#34; --form \u0026#34;file=@${filePath}_split_${lookup_num}\u0026#34; | cat \u0026gt;\u0026gt; ${log} \u0026amp;\u0026amp; echo \u0026#34;$(readlink -f ${log})\u0026#34; \u0026amp;\u0026amp; cat ${log} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${log} done else if [ -f \u0026#34;${log}\u0026#34; ]; then flag=0 flag=$(ls \u0026#34;${FileDogeLogDir}/${filePathName}/${filePathName}\u0026#34;.txt.* | tail -n 1 | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $NF}\u0026#39;) log=${FileDogeLogDir}/${filePathName}/${filePathName}.txt.$((flag + 1)) fi curl --location --request POST \u0026#39;https://api.filedoge.com/upload\u0026#39; -H \u0026#34;Content-Type: multipart/form-data;\u0026#34; --form \u0026#34;file=@${filePath}\u0026#34; | cat \u0026gt;\u0026gt; ${log} \u0026amp;\u0026amp; echo \u0026#34;$(readlink -f ${log})\u0026#34; \u0026amp;\u0026amp; cat ${log} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${log} fi fi if [ \u0026#34;$1\u0026#34; == \u0026#34;-file\u0026#34; ] || [ \u0026#34;$1\u0026#34; == \u0026#34;-delete\u0026#34; ]; then token=$2 # File Information if [ \u0026#34;$1\u0026#34; == \u0026#34;-file\u0026#34; ]; then curl --location --request GET \u0026#34;https://api.filedoge.com/info/${token}\u0026#34; # Delete File elif [ \u0026#34;$1\u0026#34; == \u0026#34;-delete\u0026#34; ]; then delete_token=$3 curl --location --request POST \u0026#34;https://api.filedoge.com/delete/${token}/{$delete_token}\u0026#34; fi fi # Download File if [ \u0026#34;$1\u0026#34; == \u0026#34;-download\u0026#34; ]; then multifile_token=$2 multifile_token_num=$(cat ${multifile_token} | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $4}\u0026#39; | nl | tail -n 1 | awk \u0026#39;{print $1}\u0026#39;) if [ \u0026#34;${multifile_token_num}\u0026#34; == 1 ]; then token=$(cat ${multifile_token} | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $4}\u0026#39;) download_file_name=$(${cmdself} -file ${token} | tr \u0026#39;,\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | grep --color \u0026#34;originalFilename\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) download_file_url=$(${cmdself} -file ${token} | tr \u0026#39;,\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | grep --color \u0026#34;downloadUrl\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) FileDogeDownloadDir=\u0026#34;${HOME}/FileDoge/Download/${download_file_name}\u0026#34; if [ ! -d \u0026#34;$FileDogeDownloadDir\u0026#34; ]; then mkdir -p ${FileDogeDownloadDir} fi wget -P ${FileDogeDownloadDir} ${download_file_url}\tif [ -f \u0026#34;${FileDogeDownloadDir}/${download_file_name}\u0026#34; ]; then latest_file=$(ls \u0026#34;${FileDogeDownloadDir}/${download_file_name}\u0026#34;.* 2\u0026gt;/dev/null | tail -n 1) if [ -n \u0026#34;${latest_file}\u0026#34; ]; then flag=0 flag=$(ls \u0026#34;${FileDogeDownloadDir}/${download_file_name}\u0026#34;.* | tail -n 1 | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $NF}\u0026#39;) mv -v ${FileDogeDownloadDir}/${token} ${FileDogeDownloadDir}/${download_file_name}.$((flag + 1)) else mv -v ${FileDogeDownloadDir}/${token} ${FileDogeDownloadDir}/${download_file_name}.$((flag + 1)) fi else mv -v ${FileDogeDownloadDir}/${token} ${FileDogeDownloadDir}/${download_file_name}\tfi elif [ \u0026#34;${multifile_token_num}\u0026#34; -gt \u0026#34;1\u0026#34; ]; then filePath=$2 catFileName=$(cat ${filePath} | sed -n \u0026#34;1\u0026#34;p | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $14}\u0026#39; | awk -F \u0026#39;_\u0026#39; \u0026#39;{print $1}\u0026#39;) splitFileName=$(cat ${filePath} | sed -n \u0026#34;1\u0026#34;p | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $14}\u0026#39; | tr -d \u0026#39;0-9\u0026#39;) for ((i = 1; i \u0026lt;= ${multifile_token_num}; i++)) do token=$(cat ${multifile_token} | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $4}\u0026#39; | nl | sed -n \u0026#34;${i}\u0026#34;p | awk \u0026#39;{print $2}\u0026#39;)\tdownload_file_name=$(${cmdself} -file ${token} | tr \u0026#39;,\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | grep --color \u0026#34;originalFilename\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) download_file_url=$(${cmdself} -file ${token} | tr \u0026#39;,\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | grep --color \u0026#34;downloadUrl\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) FileDogeDownloadDir=\u0026#34;${HOME}/FileDoge/Download/${catFileName}\u0026#34; if [ ! -d \u0026#34;$FileDogeDownloadDir\u0026#34; ]; then mkdir -p ${FileDogeDownloadDir} fi wget -P ${FileDogeDownloadDir} ${download_file_url}\tif [ -f \u0026#34;${FileDogeDownloadDir}/${download_file_name}\u0026#34; ]; then latest_file=$(ls \u0026#34;${FileDogeDownloadDir}/${download_file_name}\u0026#34;.* 2\u0026gt;/dev/null | tail -n 1) if [ -n \u0026#34;${latest_file}\u0026#34; ]; then flag=0 flag=$(ls \u0026#34;${FileDogeDownloadDir}/${download_file_name}\u0026#34;.* | tail -n 1 | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $NF}\u0026#39;) mv -v ${FileDogeDownloadDir}/${token} ${FileDogeDownloadDir}/${download_file_name}.$((flag + 1)) else mv -v ${FileDogeDownloadDir}/${token} ${FileDogeDownloadDir}/${download_file_name}.$((flag + 1)) fi else mv -v ${FileDogeDownloadDir}/${token} ${FileDogeDownloadDir}/${download_file_name} fi done if [ -f \u0026#34;${FileDogeDownloadDir}/${catFileName}\u0026#34; ]; then\trm -rf \u0026#34;${FileDogeDownloadDir}/${catFileName}\u0026#34; fi for ((i = 0; i \u0026lt; multifile_token_num; i++)) do lookup_num=$(printf \u0026#34;%02d\\n\u0026#34; $i) cat ${FileDogeDownloadDir}/${splitFileName}$(printf \u0026#34;%02d\u0026#34; $((lookup_num))) \u0026gt;\u0026gt; ${FileDogeDownloadDir}/${catFileName} done fi fi if [ \u0026#34;$1\u0026#34; == \u0026#34;--help\u0026#34; ] \u0026amp;\u0026amp; [ -z \u0026#34;$2\u0026#34; ]; then echo \u0026#34;File Doge API\u0026#34; echo \u0026#34;File Doge offers a free and unmetered API to upload and generate download links for files up to 200mb in size, although we do not guarantee that the API remain free or unmetered in the future\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;Upload File\u0026#34; echo \u0026#34;You will send us a file with POST request with a size less than 200mb\u0026#34; echo \u0026#34;curl --location --request POST \u0026#39;https://api.filedoge.com/upload\u0026#39; -H \\\u0026#34;Content-Type: multipart/form-data;\\\u0026#34; --form \u0026#39;file=@filePath\u0026#39;\u0026#34; echo \u0026#34;Successfull Response\u0026#34; echo \u0026#34;{\u0026#34; echo \u0026#34;\ttoken: fileToken,\u0026#34; echo \u0026#34;\t\u0026#34;name\u0026#34;: fileName,\u0026#34; echo \u0026#34;\t\u0026#34;size\u0026#34;: fileSizeInBytes,\u0026#34; echo \u0026#34;\t\u0026#34;originalFilename\u0026#34;: originalFilename,\u0026#34; echo \u0026#34;\t\u0026#34;createdAt\u0026#34;: creationDate,\u0026#34; echo \u0026#34;\t\u0026#34;mimeType\u0026#34;: fileMimeType\u0026#34; echo \u0026#34;\t\u0026#34;deleteToken\u0026#34;: fileDeleteToken\u0026#34; echo \u0026#34;}\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;File Information\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;You will send us a file token with GET request to get information\u0026#34; echo \u0026#34;curl --location --request GET \u0026#39;https://api.filedoge.com/info/TOKEN\u0026#39;\u0026#34; echo \u0026#34;Successfull Response\u0026#34; echo \u0026#34;{\u0026#34; echo \u0026#34;\ttoken: fileToken,\u0026#34; echo \u0026#34;\t\u0026#34;name\u0026#34;: fileName,\u0026#34; echo \u0026#34;\t\u0026#34;size\u0026#34;: fileSizeInBytes,\u0026#34; echo \u0026#34;\t\u0026#34;originalFilename\u0026#34;: originalFilename,\u0026#34; echo \u0026#34;\t\u0026#34;createdAt\u0026#34;: creationDate,\u0026#34; echo \u0026#34;\t\u0026#34;mimeType\u0026#34;: fileMimeType\u0026#34; echo \u0026#34;\t\u0026#34;downloadUrl\u0026#34;: directUrlToDownloadFile\u0026#34; echo \u0026#34;}\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;Delete File\u0026#34; echo \u0026#34;You can delete your files using the file token and delete identifier\u0026#34; echo \u0026#34;curl --location --request POST \u0026#39;https://api.filedoge.com/delete/\\$TOKEN/\\$DELETE_TOKEN\u0026#39;\u0026#34; echo \u0026#34;Successfull Response\u0026#34; echo \u0026#34;{\u0026#34; echo \u0026#34;\tmessgae: \u0026#34;File Deleted Successfully\u0026#34;,\u0026#34; echo \u0026#34;}\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;Errors\u0026#34; echo \u0026#34;If you or us encounter an error we respond with 200 OK and a JSON which is specify what\u0026#39;s went wrong\u0026#34; echo \u0026#34;Error Example\u0026#34; echo \u0026#34;{\u0026#34; echo \u0026#34;\terror: errorMessage,\u0026#34; echo \u0026#34;}\u0026#34; fi ","date":"2024-03-26T00:24:34+08:00","permalink":"https://ynhugo.github.io/p/%E4%BD%BF%E7%94%A8filedoge%E7%9A%84api%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6/","title":"使用FileDoge的API保存文件"},{"content":" 灰狼云空间_免费虚拟主机_FTP空间免费申请_0元免备案FTP建站 官网链接：https://yun316.net/\n","date":"2024-03-26T00:24:34+08:00","permalink":"https://ynhugo.github.io/p/%E4%B8%BB%E6%9C%BA%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3/","title":"主机空间相关"},{"content":" 默认参数 魔术棒-Debug：\n仿真参数 -p后跟的是stm32单片机型号\n魔术棒-Debug：\n添加仿真串口配置文件 文件格式：.ini\n文件内容\n1 2 MODE COM1 115200,0,8,1 ASSIGN COM1 \u0026lt;S1IN\u0026gt; S1OUT 重写输入/输出函数 重写输入/输出函数是在main.c文件中完成的\n重写输入/输出函数之前需要先在main.c文件包含一下\u0026#34;stdio.h\u0026#34;头文件\n1 #include \u0026#34;stdio.h\u0026#34; 在main.c重写printf函数 1 2 3 4 5 6 7 int fputc(int c, FILE * f) {\tint ch = 0; ch=c; HAL_UART_Transmit(\u0026amp;huart1,(uint8_t*)\u0026amp;ch,1,1000);//发送串口 return c; } 在main.c重写scanf函数 1 2 3 4 5 6 int fgetc(FILE * F) { int ch_r = 0; HAL_UART_Receive (\u0026amp;huart1,(uint8_t*)\u0026amp;ch_r,1,0xffff);//接收 return ch_r; } 参考链接 https://blog.csdn.net/qq_28317769/article/details/106659139\nSTM32自学笔记-0-重写printf和scanf\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/keil%E4%BB%BF%E7%9C%9Fstm32f103%E7%B3%BB%E5%88%97%E5%8D%95%E7%89%87%E6%9C%BA%E9%AD%94%E6%9C%AF%E6%A3%92%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/","title":"keil仿真stm32f103系列单片机魔术棒参数设置"},{"content":" Keil模拟STM32F103体验 准备工作 安装 5.14 版本及以上的 MDK-ARM （Keil） 集成开发环境,在安装好 MDK-ARM 集成开发环境后，再安装 STM32F1xx\\_DFP PACK 包 MDK-ARM 下载链接：http://www.keil.com/download/ 下载一份完整的 OneOS-Metis-v1.1.0 代码 OneOS-Metis-v1.1.0 官方：https://gitee.com/cmcc-oneos/OneOS-Metis OneOS-Metis-v1.1.0 下载链接：https://gitee.com/cmcc-oneos/OneOS-Metis/repository/blazearchive/v1.1.0.zip?Expires=1702803860\u0026amp;Signature=oPuPAPCFdt8jnzQMvffNMHtQsL4eAU3CxeXk%2BpS763s%3D 打开使用Keil模拟器的示例工程 1.进入到 OneOS-Metis-v1.1.0\\projects\\stm32f103rc 目录中，双击“project.uvprojx”文件，打开stm32f103rc的Keil工程文件，重新编译一遍工程，然后点击魔法棒，接着点击 Deubg，选中 Use Simulator\n2.打开模拟器串口、运行程序并观察SHELL界面\n3.运行help命令\n通过输入help命令并长按回车可以查看当前系统支持的命令\n执行she命令时，输入命令后必须长按回车才能执行命令，否则会反应很慢，我猜是只按一下回车的过程太快，只有长按的时候让这个回车按下的过程保持的长一些才能被检测到\n4.查看内存堆使用情况\n其中 show_mem 是查看内存堆使用的情况，输入并长按回车来执行此命令\n参考链接 不用板子也能跑！Keil模拟STM32F103体验\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/keil%E6%A8%A1%E6%8B%9Fstm32f103%E4%BD%93%E9%AA%8C/","title":"Keil模拟STM32F103体验"},{"content":" Proteus导入第三方元件 proteus是我们常用的用来模拟仿真的EDA软件之一，但是有些仿真确苦于没有自带的软件库无法实现，下面是如何将所需的芯片导入proteus中的方法。\n注意：在proteus中添加第三方库需在proteus8.9及之后的版本才可实现，8.9之前只能使用自带元件库或者自行绘制。\n下面呢以NXP的RT1064为例展示如何添加第三方元件库到proteus中。\n1、访问\u0026#34;https://componentsearchengine.com/part-view\u0026#34;在搜索框搜索你所需的芯片或者元件，然后登陆并下载芯片包（如果找不到的话还可以提交信息，一般两个工作日会在邮箱收到绘制好的芯片包），必须科学上网才能注册成功；\n2、解压下载的压缩包，然后打开proteus，下面就该将芯片包导入元件库中；\n3、在proteus菜单栏选择library-\u0026gt;Impart Parts，然后选择select file，找到解压之后的芯片包，然后在proteus文件中找到.pdif文件导入，之后选择Import Part，之后就是傻瓜式的点击Next、OK，最后点击close，这样我们的芯片导入就成功了，我们可以随意调用了。\n参考链接 Proteus元件库中添加第三方的单片机芯片\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/proteus%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%85%83%E4%BB%B6/","title":"Proteus导入第三方元件"},{"content":" 参考链接 【零基础玩转STM32】-01-创建工程（STM32仿真教程）\n环境搭建 安装STM32CubeMX 在安装CubeMX之前先安装java环境\njava下载链接：https://javadl.oracle.com/webapps/download/AutoDL?BundleId=249203_b291ca3e0c8548b5a51d5a5f50063037\nST官网搜索 STM32CubeMX，下载对应电脑平台的最新版本\n下载页面：https://www.st.com/zh/development-tools/stm32cubemx.html\n安装MDK-ARM keil官网点击Download，访问产品下载页面，进入MDK-ARM下载页面，下载MDK539.exe，我当前看到的是MDK539.exe\n下载页面：https://www.keil.com/demo/eval/arm.htm\n安装Proteus 微信公众号搜索软件管家，进入公众号下载目录，找到proteus，下载最高版本\n可通过浏览器打开软件管家软件目录，在页面搜索找到 proteus\n软件管家公众号软件目录：https://mp.weixin.qq.com/s/uaqvED0_vFcqXmgkTlKYpQ\nProteus 8.15下载链接：https://mp.weixin.qq.com/s?__biz=MzA4MjU4MTg2Ng==\u0026amp;mid=2247515066\u0026amp;idx=5\u0026amp;sn=ba4b87dad87c1f13ccc595934269bfaa\u0026amp;chksm=9f817bbfa8f6f2a9cd6e6690e6a791ca3fd43f9bddf8ea06d2da4b07c28ce5600d79703d72f5\u0026amp;scene=21#wechat_redirect\nProteus搭建STM32F103C8T6最小系统 图中有一个绿色的LED灯作为电源指示灯\n最小系统配置：\n芯片配置：\nProteus仿真实现流水灯 proteus配置原理图 Proteus流水灯原理图：\nCubeMX配置STM32F103C8T6 GPIO配置：\nRCC配置：\n时钟配置：\n工程管理-Project：\n工程管理-Code Generator：\n最后生成代码并打开keil\nkeil核心代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET); HAL_Delay(500); HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET); HAL_Delay(500); HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET); HAL_Delay(500); HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET); HAL_Delay(500); /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ 实验源代码 基于HAL库Proteus仿真STM32F103C8T6\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/proteus%E5%9F%BA%E4%BA%8Ehal%E5%BA%93%E4%BB%BF%E7%9C%9Fstm32f103c8t6/","title":"Proteus基于HAL库仿真STM32F103C8T6"},{"content":" STM32CubeMX实现串口通信 STM32CubeMX版本：6.10\n在安装STM32CubeMX之前需要电脑上有Java环境\nJava下载链接：https://javadl.oracle.com/webapps/download/AutoDL?BundleId=249203_b291ca3e0c8548b5a51d5a5f50063037\nSTM32CubeMX下载链接：https://www.st.com/zh/development-tools/stm32cubemx.html\nKeil5(MDK-ARM)下载链接：https://pan.baidu.com/s/1kC7h3ljv1iENa0mSP2a0aQ?pwd=pxsy\nProteus下载链接：https://mp.weixin.qq.com/s?__biz=MzA4MjU4MTg2Ng==\u0026amp;mid=2247515066\u0026amp;idx=5\u0026amp;sn=ba4b87dad87c1f13ccc595934269bfaa\u0026amp;chksm=9f817bbfa8f6f2a9cd6e6690e6a791ca3fd43f9bddf8ea06d2da4b07c28ce5600d79703d72f5\u0026amp;scene=21#wechat_redirect\n串口调试助手：https://pan.baidu.com/s/1E5SprNfWX1yqPddtvsa8sw?pwd=e6vn\nVSPD下载链接：https://www.xue51.com/soft/9349.html#xzdz\n使用STM32CubeMX 安装固件库 若点击 Manage embedded software packages 后，出现失败，则需要随便点击其它任一选项，进行下载一些文件，比如点击 file-\u0026gt;new project ，等下载后，再进行安装固件库。\n1.进入嵌入式软件包管理界面\n2.如果进入失败，则点击一下旁边的INSTALL/REMOVE，安装嵌入式软件包，如果提示登录的话，就将在ST官网注册的信息输入到CubeMX的登录框内进行登录，然后就可以接着安装了\n然后再次进行第一步的操作，这次就可以进入嵌入式软件包管理界面了，接着选择自己开发板的固件库，我这里是f1的。选择版本安装，我这里已经安装过了。\n工程设置 1.点击 file -\u0026gt; new project 建立工程\n按步骤即可。搜索型号，选择合适的型号进行工程建立\n2.进行系统调试及基准时钟配置。\n点击 System Core下拉栏中的 SYS。选择debug调试接口。我选择 serial Wire\nSW模式就选择serial Wire。JTAG模式就选择JTAG，4pin和5pin的区别多了一个复位引脚\nstlink调试就是SW模式，jlink调试就是JTAG模式\n3.进行时钟RCC选项配置\n点击 System Core下拉栏中的 RCC。可以都选外部晶振Crystal/Ceramic Resonator。\nBYPASS Clock Source（旁路时钟源）\nCrystal/Ceramic Resonator（石英/陶瓷 晶振）\n4.进行系统具体时钟配置\n(1)点击“Clock Configuration”选项栏进入时钟树配置界面。\n(2)选择外部时钟HSE 8MHz\n(3)PLL锁相环倍频9倍（8*9=72）\n(4)系统时钟来源选择为PLL\n(5)设置APB1分频器为 /2\n5.设置串口\n这里选择USART1。串口配置的引脚为默认 PA6、PA7，无法手动更改。\n第三步中 设置MODE为 异步通信(Asynchronous)\n第四步中参数默认设置为 波特率为115200 Bits/s，传输数据长度为8 Bit，奇偶检验无，停止位1。以及下面未显示出的 接收和发送都使能\n6.设置完成后，点击 Project Manager 选项，进入工程设置界面，选择 Project 选项。\n不管工程名称还是路径都不要有中文，否则后面编译文件会出错。\nProject Name：工程名称\nProject Location：点击后面的\u0026#34;Browse\u0026#34;选择你想要将生成的工程保存到哪个目录里面。\nApplication Structure：应用程序结构\nBasic：是基础的结构，一般不包含中间件（RTOS、文件系统、USB设备等） Advanced：相反就是包含中间件，一般针对相对复杂一点的工程。 Toolchain/IDE：根据你用的编译软件进行选择 使用KEIL就选择keil的对应版本。不要高于版本\n其他默认。\nCode Generator 选项可以进行默认。这里我多勾选一个。\nCode Generator 选项说明：\ncopy all used libraries into the project folder：复制所有库文件（不管工程需要用到还是没用到）到生成的工程目录中，此做法可以使在不使用Cubemx或者电脑没有安装cubemx,依然可以按照标准库的编程习惯调用HAL库函数进行程序编写。 Copy only the necessary library files： 只复制必要的库文件。这个相比上一个减少了很多文件。比如你没有使用CAN、SPI…等外设，就不会拷贝相关库文件到你工程下。 Add necessary library files as reference in the toolchain project configuration file ：在工具链项目配置文件中添加必要的库文件作为参考。这里没有复制HAL库文件，只添加了必要文件（如main.c）。相比上面，没有Drivers相关文件。 Generate peripheral initialization as a pair of’.c/.h’ files per peripheral：每个外设生成独立的.C .H文件，方便独立管理。不勾：所有初始化代码都生成在main.c 勾选：初始化代码生成在对应的外设文件。 如UART初始化代码生成在uart.c中。 Backup previously generated files when re-generating：在重新生成时备份以前生成的文件。重新生成代码时，会在相关目录中生成一个Backup文件夹，将之前源文件拷贝到其中。 keep user code when re-generating：重新生成代码时，保留用户代码(前提是代码写在规定的位置。也就是生成工程文件中的BEGIN和END之间。否则同样会删除。后面会根据生成的工程进行说明) delete previously generated files when not re-generated：删除以前生成但现在没有选择生成的文件 比如：之前生成了led.c，现在重新配置没有led.c，则会删除之前的led.c文件。(此功能根据自身要求进行取舍) 点击 GENERATE CODE 生成代码。然后打开工程\n编译代码。编译无误\nUSART串口通信 UART函数库介绍 结构体以及函数定义均在头文件： stm32f1xx_hal_uart.h\nUART结构体定义\n1 UART_HandleTypeDef huart1; 串口发送/接收函数\n1 2 3 4 5 6 7 8 9 10 11 HAL_UART_Transmit()：串口发送数据，使用超时管理机制; HAL_UART_Receive()：串口接收数据，使用超时管理机制; HAL_UART_Transmit_IT()：串口中断模式发送; HAL_UART_Receive_IT()：串口中断模式接收; HAL_UART_Transmit_DMA()：串口DMA模式发送; HAL_UART_Transmit_DMA()：串口DMA模式接收; 串口发送数据：\n1 HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout) 功能：串口发送指定长度的数据。如果超时没发送完成，则不再发送，返回超时标志（HAL_TIMEOUT）。\n参数：\n*UART_HandleTypeDef huart：UART结构体（ huart1） *pData：需要发送的数据 Size：发送的字节数 Timeout：最大发送时间，发送数据超过该时间退出发送 举例：\n1 HAL_UART_Transmit(\u0026amp;huart1, (uint8_t *)\u0026#34;diyu\u0026#34;, 4, 0xffff); //串口发送4个字节数据，最大传输时间0xfff 代码编写 在文件 main.c中的while循环里添加代码\n1 2 3 4 5 6 7 8 while (1) { /* USER CODE END WHILE */ //添加下面两行代码 HAL_UART_Transmit(\u0026amp;huart1, (uint8_t *)\u0026#34;hello windows!\\r\\n\u0026#34;, 16 , 0xffff); HAL_Delay(1000); //延时1s /* USER CODE BEGIN 3 */ } VSPD配置虚拟串口 Proteus仿真STM32F103C8 添加 STM32F103C8 和 虚拟终端 配置STM32单片机参数 配置虚拟终端参数 配置COMPIM参数 效果展示 编译，将程序烧录或下载进，打开串口助手查看接收到的数据。\n波特率、停止位、数据位、校验位要与配置的一致\n重写输入/输出函数 重写输入/输出函数是在main.c文件中完成的\n重写输入/输出函数之前需要先在main.c文件包含一下\u0026#34;stdio.h\u0026#34;头文件\n1 #include \u0026#34;stdio.h\u0026#34; 在main.c重写printf函数 1 2 3 4 5 6 7 int fputc(int c, FILE * f) {\tint ch = 0; ch=c; HAL_UART_Transmit(\u0026amp;huart1,(uint8_t*)\u0026amp;ch,1,1000);//发送串口 return c; } 在main.c重写scanf函数 1 2 3 4 5 6 int fgetc(FILE * F) { int ch_r = 0; HAL_UART_Receive (\u0026amp;huart1,(uint8_t*)\u0026amp;ch_r,1,0xffff);//接收 return ch_r; } 参考链接 STM32CubeMX实现串口通信\nSTM32学习：串口通讯（proteus仿真）\nhttps://blog.csdn.net/qq_28317769/article/details/106659139\nSTM32自学笔记-0-重写printf和scanf\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/stm32cubemx%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","title":"STM32CubeMX实现串口通信"},{"content":" STM32Cube IDE与MX区别？STM32CubeMX介绍、下载与安装 页面链接：https://blog.csdn.net/chenhuanqiangnihao/article/details/126308350\n安装STM32CubeMX 在安装CubeMX之前先安装java环境\njava下载链接：https://javadl.oracle.com/webapps/download/AutoDL?BundleId=249203_b291ca3e0c8548b5a51d5a5f50063037\nST官网搜索 STM32CubeMX，下载对应电脑平台的最新版本\n下载页面：https://www.st.com/zh/development-tools/stm32cubemx.html\n安装STM32CubeIDE ST官网搜索 STM32CubeIDE，下载对应电脑平台的最新版本\n下载页面：https://www.st.com/zh/development-tools/stm32cubeide.html\n安装MDK-ARM keil官网点击Download，访问产品下载页面，进入MDK-ARM下载页面，下载MDK539.exe，我当前看到的是MDK539.exe\n下载页面：https://www.keil.com/demo/eval/arm.htm\n安装Proteus 微信公众号搜索软件管家，进入公众号下载目录，找到proteus，下载最高版本\n可通过浏览器打开软件管家软件目录，在页面搜索找到 proteus\n软件管家公众号软件目录：https://mp.weixin.qq.com/s/uaqvED0_vFcqXmgkTlKYpQ\nProteus 8.15下载链接：https://mp.weixin.qq.com/s?__biz=MzA4MjU4MTg2Ng==\u0026amp;mid=2247515066\u0026amp;idx=5\u0026amp;sn=ba4b87dad87c1f13ccc595934269bfaa\u0026amp;chksm=9f817bbfa8f6f2a9cd6e6690e6a791ca3fd43f9bddf8ea06d2da4b07c28ce5600d79703d72f5\u0026amp;scene=21#wechat_redirect\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/stm32%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"STM32仿真环境搭建"},{"content":" 如果想随时随地发表自由化、匿名化的文章，可以使用 telegra.ph，telegram 的产品，因此使用的时候需要科学上网，该网站对中文的支持一般，但是也不影响使用，写第一个中文的时候，再敲击键盘字母的时候会多一个字母出现在文章开头，解决这样 bug 的方式是可以在开头敲一个空格，然后开始正文，写完文章后再将文章开头的空格删除掉即可，写完的文章，点击 PUBLISH 后，复制当前页面链接即可将文章分享给别人，别人不具备编辑权限。\n参考链接：https://sspai.com/post/36378\n","date":"2024-03-26T00:24:32+08:00","permalink":"https://ynhugo.github.io/p/telegra/","title":"telegra"},{"content":" info-setup \u0026#34;inno-setup\u0026#34;是较常用且简单的软件打包工具。\n参考链接：Inno setup 打包教程(转载) 安装并打开 inno setup 软件 运行环境 系统：Windows 7\n软件：inno setup 5.5.5\n安装 inno setup 5.5.5完成后，点击 “开始” → “所有程序” → “Inno Setup 5” → “ Inno Setup” ，运行 Inno Setup 编译器； 在弹出的 “欢迎” 对话框中点击 “取消”，便可看到 Inno Setup 编译器的主界面\n按向导完成打包 在主界面菜单中，点击 “文件” → “新建” 在弹出的 “Inno Setup 脚本向导” 对话框中点击 “下一步”\n在弹出的 “应用程序信息” 对话框里填写要制作程序 “安装包” 信息，点击“下一步” 弹出 “应用程序文件夹”； “应用程序文件夹” 对话框如下图，一般默认即可，\n点击 “下一步” 弹出 “应用程序文件” 对话框，点击 “应用程序主执行文件(M)” 下的 “浏览”按钮，\n选择相应的应用程序主执行文件（TCP调试助手(V1.9).exe）；\n再点击 “添加文件夹”按钮，在弹出的 “浏览文件夹”对话框选择要封装文件夹，单击“确定”\n在弹出的“配置”对话框中点击“是”按钮，\n选中“ E:\\TCP调试助手\\* ” ，点击 “编辑”按钮，便可定义刚才添加的文件夹制作成 “安装包” 之后的安装路径，一般默认即可 选择完成后点击 “确定” ，然后点击 “下一步” ，弹出 “应用程序图标” 对话框，勾选 “在开始菜单文件夹中创建卸载图标（U）” 点击 “下一步” ，弹出 “应用程序文档” 对话框，均可为空 完成之后点击 “下一步” 弹出 “安装语言” 对话框，根据需要勾选语言 完成之后点击 “下一步” 弹出 “编译设置” 对话框； 点击 “下一步” 弹出 “Inno Setup 预处理器” 对话框； 点击 “下一步” 弹出 “你已经成功完成 Inno Setup 脚本向导”；\n点击 “完成” ，弹出 “Inno Setup 编译器” 提示窗口 编译脚本 在前面 “Inno Setup 编译器” 提示窗口中选择 “是” ，或者在主菜单 “构建” → “编译”\n","date":"2024-03-26T00:24:30+08:00","permalink":"https://ynhugo.github.io/p/inno-setup%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BD%AC%E8%BD%BD/","title":"inno-setup打包应用程序(转载)"},{"content":" nc - 网络工具箱中的\u0026#34;瑞士军刀\u0026#34; nc 是 Linux 下强大的网络命令行工具，主要用于 TCP、UDP、UNIX域套接字 相关的操作\n它被设计成可以由其他程序灵活驱动可靠的后台工具，拥有 \u0026#34;瑞士军刀\u0026#34; 的美称，每个系统管理员都应该掌握它\nnc -h nc 命令的帮助手册提供了以下信息：\n连接到某处：\n语法：=nc [-options] hostname port[s] [ports] …= 说明：用于向指定主机和端口发起连接。 监听传入连接：\n语法：=nc -l -p port [-options] [hostname] [port]= 说明：在指定端口上监听传入连接。 选项包括：\n-c shell commands ：作为 -e 使用，用于执行 shell 命令（潜在危险） -e filename ：连接后执行指定程序（潜在危险） -b ：允许广播 -g gateway ：指定源站点路由跳数，最多 8 个 -G num ：设置源站点路由指针：4、8、12 等 -h ：显示帮助信息 -i secs ：发送行或扫描端口的延迟间隔 -k ：在套接字上设置保持活动选项 -l ：监听模式，用于接受传入连接 -n ：仅使用数字 IP 地址，不进行 DNS 解析 -o file ：以十六进制转储流量 -p port ：本地端口号 -r ：随机化本地和远程端口 -q secs ：在标准输入 EOF 后退出，并延迟指定秒数 -s addr ：本地源地址 -T tos ：设置服务类型 -t ：应答 TELNET 协商 -u ：UDP 模式 -v ：详细输出（使用两次更详细） -w secs ：连接和最终网络读取的超时时间 -C ：将 CRLF 发送为行结束符 -z ：零 I/O 模式（用于扫描） 扫描端口 有时需要测试服务器的端口连通性，下面是测试服务器(IP:10.3.3.3 22) 22 端口是否开启的例子\n1 2 3 4 5 6 7 8 9 ┌──(root💀adm-RecipeKit)-[~] └─# nc -z -v -w 3 segfault.net 22 DNS fwd/rev mismatch: segfault.net != one.one.one.one segfault.net [144.76.220.20] 22 (ssh) open ┌──(root💀adm-RecipeKit)-[~] └─# nc -z -v -w 3 segfault.net 6000 DNS fwd/rev mismatch: segfault.net != one.one.one.one segfault.net [144.76.220.20] 6000 (x11) : Connection refused -z 选项是报告连接状态(只连接不发送数据)\n-v 选项是输出命令过程信息,\n-w 是设置超时时间,默认是秒，如果要设置毫秒的话，可以在数字后面加上 ms, 比如：-w 3 是3秒超时，-w 300ms 表示超时时间是300毫秒\n从上面的结果可以看出，目标服务器上 22 端口是开启的，6000 端口是关闭的\n例子中扫描的是 TCP 协议的端口，如果要扫描 UDP 协议的端口，需要加上 -u 选项，如果换成 UDP 端口的话，上面的命令就会变成 nc -uz -v -w 3 segfault.net 22 聊天服务器 机器 A 的终端开启端口侦听，机器 B 连接 A 侦听的端口并向A发送数据。具体过程如下：\n机器 A 相当于一个简易的命令行聊天服务器，机器 B 相当于客户端的功能，默认使用 TCP 协议连接服务器 机器 A 在本地开启一个侦听 8000 端口的服务，机器 B 连接 机器 A 的 8000 端口，连接成功之后可以互相发送数据了 机器 A 1 2 3 4 5 6 7 8 ┌──(root💀adm-RecipeKit)-[~] └─# nc -l -p 8000 test 1 2 3 4 5 机器 B 1 2 3 4 5 6 7 8 ┌──(root💀adm-RecipeKit)-[~] └─# nc 100.126.224.24 8000 test 1 2 3 4 5 传输文件 机器 A 和机器 B 之间可以通过 nc 命令传输文件,具体步骤如下：\n机器 A 作为服务器，侦听 8000 端口并重定向到 out.txt 文件, 机器 B 连接机器 A 成功之后，自动把 input.txt 文件传输到服务器\n机器 A 1 nc -l -p 8000 \u0026gt; out.txt 机器 B 1 nc 100.126.224.24 8000 \u0026lt; ts.sh 创建后门 可以在系统中创建后门执行 bash 命令的服务,因为涉及到系统安全性问题，所以生产环境要慎用，不过平时在内网开发环境中用 来测试的话就很方便了，具体的使用步骤如下：\n上面的例子中，机器 A 开启端口 8000 的本地服务，服务会使用 /bin/bash 执行收到的命令，机器 B 客户端连上 机器 A 后，输入任意的命令，都相当于在63机器上执行，命令结果返回给64机器\n说明：-e 选项默认使用的是 /bin/bash 执行命令, 这里的 -e 也可以换成 -c ,唯一区别是 -c 默认使用的是 /bin/sh 执行命令\n机器 A 1 2 ┌──(root💀adm-RecipeKit)-[~] └─# nc -l -p 8000 -e /bin/bash 机器 B 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ┌──(root💀adm-RecipeKit)-[~] └─# nc 100.126.224.24 8000 ls CloudflareST Desktop Documents Downloads Music Pictures Public Templates Videos info.txt out.txt test.bin ts.sh wordlists yenao_ccf.sh ls -l total 28 drwxr-xr-x 2 root root 4096 Mar 14 18:13 CloudflareST drwxr-xr-x 2 root root 4096 Feb 22 05:30 Desktop drwxr-xr-x 2 root root 10 Feb 22 05:48 Documents drwxr-xr-x 2 root root 10 Feb 22 05:48 Downloads drwxr-xr-x 2 root root 10 Feb 22 05:48 Music drwxr-xr-x 2 root root 10 Feb 22 05:48 Pictures drwxr-xr-x 2 root root 10 Feb 22 05:48 Public drwxr-xr-x 2 root root 10 Feb 22 05:48 Templates drwxr-xr-x 2 root root 10 Feb 22 05:48 Videos -rw-r--r-- 1 root root 7 Mar 15 01:46 info.txt -rw-r--r-- 1 root root 0 Mar 16 08:48 out.txt -rw-r--r-- 1 root root 209715200 Mar 14 03:17 test.bin -rwxr-xr-x 1 root root 427 Mar 14 17:49 ts.sh lrwxrwxrwx 1 root root 20 Feb 22 05:30 wordlists -\u0026gt; /usr/share/wordlists -rwxr-xr-x 1 root root 3596 Mar 15 02:17 yenao_ccf.sh 远程执行脚本 nc 支持远程执行 shell 脚本和 lua 脚本\nshell 脚本 脚本 s.sh 脚本内容如下：\n1 2 3 #!/bin/sh echo \u0026#34;this is a shell programming...\u0026#34; 服务器端 1 2 ┌──(root💀adm-RecipeKit)-[~] └─# nc -l 100.126.224.24 -p 8000 -e ./s.sh 客户端 1 2 3 ┌──(root💀adm-RecipeKit)-[~] └─# nc 100.126.224.24 8000 this is a shell programming... Web服务器 nc 可以当做简易的 web 服务器，现服务器本地有一个 index.html 文件，内容如下\n1 2 3 4 5 6 7 8 9 HTTP/1.0 200 OK \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;This is a Netcat Basic HTTP server!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 服务器执行 nc -k -l 192.168.70.63 8080 \u0026lt; index.html 命令监听8080端口\n打开浏览器，地址栏输入 192.168.70.63:8080，具体效果如下图:\n此时，服务器端的输出如下：\n注意：-k 选项是指监听模式接受多个连接,如果没有指定 -k 选项的话，浏览器访问一次，服务器就会退出了\n机器 A 1 2 3 4 5 6 ┌──(root💀adm-RecipeKit)-[~] └─# nc -l 100.126.224.24 -p 80 \u0026lt; index.html GET / HTTP/1.1 Host: 100.126.224.24 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3 Accept: */* 机器 B 1 2 ┌──(root💀adm-RecipeKit)-[~] └─# curl -A \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\u0026#34; 100.126.224.24 80 作为浏览器 nc 不仅可以当作web服务器，还可以当作浏览器发送HTTP请求\n以百度首页为例, 输入 nc www.baidu.com 80，回车之后，再次输入 GET / HTTP/1.0 再次敲击两次回车，即可获得百度首页的HTML 文档内容，由于百度首页HTML太长，下面的例子只是文档的部分内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ┌──(root💀adm-RecipeKit)-[~] └─# nc www.baidu.com 80 GET / HTTP/1.0 HTTP/1.0 200 OK Accept-Ranges: bytes Cache-Control: no-cache Content-Length: 9508 Content-Type: text/html Date: Sat, 16 Mar 2024 09:19:44 GMT P3p: CP=\u0026#34; OTI DSP COR IVA OUR IND COM \u0026#34; P3p: CP=\u0026#34; OTI DSP COR IVA OUR IND COM \u0026#34; Pragma: no-cache Server: BWS/1.1 查找运行在端口上的服务 nc 可以扫描指定IP上指定端口是否开启，那能否查找到指定IP上运行于指定端口上的服务呢？ 答案是肯定的，以下的例子是获取指定IP上 22 号端口上运行的服务\n1 2 3 4 5 ┌──(root💀adm-RecipeKit)-[~] └─# nc -v segfault.net 22 DNS fwd/rev mismatch: segfault.net != one.one.one.one segfault.net [144.76.220.20] 22 (ssh) open SSH-2.0-OpenSSH_9.6 从上面的例子中可以看出，机器(segfault.net)上 22 号端口上运行的是 SSH 服务\n","date":"2024-03-26T00:24:30+08:00","permalink":"https://ynhugo.github.io/p/nc%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/","title":"nc命令教程"},{"content":" 加密内容 使用openssl对字符串\u0026#34;test\u0026#34;进行了AES-256-CBC加密，并使用密码\u0026#34;1\u0026#34;进行了加密操作。加密后的输出是经过Base64编码的字符串。\n1 echo \u0026#34;test\u0026#34; | openssl enc -aes-256-cbc -a -k 11 解密内容 要解密这个加密文本，您可以使用以下命令：\n1 echo \u0026#34;加密后输出的经过Base64编码的字符串\u0026#34; | openssl enc -aes256 -a -d -k 1 ","date":"2024-03-26T00:24:30+08:00","permalink":"https://ynhugo.github.io/p/openssl%E5%8A%A0%E5%AF%86%E8%81%8A%E5%A4%A9%E5%86%85%E5%AE%B9/","title":"openssl加密聊天内容"},{"content":" VS2017安装 要在QT中配置MSVC构建套件，必须首先安装Visual Studio，安装的VS的具体版本按QT的当前版本支持的下载。QT5.14.2支持VS2017，VST017社区版的下载地址：VS2017社区版下载。\n选择安装C/C++部分，具体安装过程比较简单，可以自行搜索\nQT安装 QT的版本选择的是QT5.14.2，这是目前QT官方能提供的自带安装程序的最新版本，下载地址：QT5.14.2下载地址，选择下载 qt-opensource-windows-x86-5.14.2.exe 。\nQT中配置MSVC 进入微软官网下载Win10 SDK: Win10 SDK下载地址。下载winsdksetup.exe，只选择 Debug for Windows的工具即可，其他都不选择，安装完成之后，QT就会自动进行MSVC的配置（最好重启一下电脑）。\n参考链接 QT5.14搭建MSVC(VS2017) x86 以及64位编译器开发环境搭建（GDB配置）\nQT - QT中配置MSVC编译环境 以及 VS中配置QT开发环境\n","date":"2024-03-26T00:24:30+08:00","permalink":"https://ynhugo.github.io/p/qt5.14%E6%90%AD%E5%BB%BAmsvc_vs2017%E4%BB%A5%E5%8F%8A64%E4%BD%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.org/","title":"QT5.14搭建MSVC_VS2017以及64位编译器开发环境搭建.org"},{"content":" 使用 C 语言在 Linux 环境下获得微秒级时间 数据结构 1 int gettimeofday(struct timeval*tv, struct timezone *tz); /* 其参数 tv 是保存获取时间结果的结构体，参数 tz 用于保存时区结果： */ 结构体timezone的定义 1 2 3 4 struct timezone{ int tz_minuteswest;/*格林威治时间往西方的时差*/ int tz_dsttime;/*DST 时间的修正方式*/ } timezone 参数若不使用则传入NULL即可。\n结构体timeval的定义 1 2 3 4 struct timeval{ long int tv_sec; // 秒数 long int tv_usec; // 微秒数 } 代码实例 temp.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; // for printf() #include \u0026lt;sys/time.h\u0026gt; // for gettimeofday() #include \u0026lt;unistd.h\u0026gt; // for sleep() int main() { struct timeval start, end; gettimeofday( \u0026amp;start, NULL ); printf(\u0026#34;start : %d.%d\\n\u0026#34;, start.tv_sec, start.tv_usec); sleep(1); gettimeofday( \u0026amp;end, NULL ); printf(\u0026#34;end : %d.%d\\n\u0026#34;, end.tv_sec, end.tv_usec); return 0; } 编译 1 g++ -o temp temp.cpp 运行及结果 1 2 3 $ ./temp start : 1418118324.633128 end : 1418118325.634616 usleep函数 1 2 #include \u0026lt;unistd.h\u0026gt; usleep(time);\t// 百万分之一秒 使用 C 语言在 windows 环境下获得微秒级时间 C 语言如何实现微秒级计算程序运行时间\nC 语言中用 clock() 函数计算程序运行时间只能达到毫秒级,要想使用微秒级别的计算,只能求助于CPU时钟频率.\n先使用 QueryPerformanceFrequency() 函数获取本机 CPU 的频率，QueryPerformanceFrequency() 函数包含在 windows.h 库中 再分别用 QueryPerformanceCounter() 函数在程序开始和结束时计数,相当于一个时间戳\n再通过 double dTimeTake = ((double)endCount.QuadPart - (double)startCount.QuadPart) / (double)fre.QuadPart; 计算时间差.输出.\n计算程序运行时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int main(void) { LARGE_INTEGER fre = {0}; LARGE_INTEGER startCount = {0}; LARGE_INTEGER endCount = {0}; QueryPerformanceFrequency(\u0026amp;fre); QueryPerformanceCounter(\u0026amp;startCount); /* Sleep(2000);\t/\\* 单位为毫秒 *\\/ */ printf(\u0026#34;Hello.\\n\u0026#34;); QueryPerformanceCounter(\u0026amp;endCount); double dTimeTake = ((double)endCount.QuadPart - (double)startCount.QuadPart) / (double)fre.QuadPart; printf(\u0026#34;用时 %f 秒\\n\u0026#34;, dTimeTake); /* 单位为秒 */ printf(\u0026#34;用时 %f 微秒\\n\u0026#34;, (dTimeTake * 1000000)); /* 单位为微秒 */ return 0; } 参考链接 linux下获取微秒级精度的时间\nC语言如何实现微秒级计算程序运行时间\nWindow系统下C/C++程序毫秒级和微秒级执行时间获取方法（转载）\nC语言获得0.01微秒级程序运行时间的方法\n","date":"2024-03-26T00:24:28+08:00","permalink":"https://ynhugo.github.io/p/c%E8%AF%AD%E8%A8%80%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4/","title":"c语言获取操作时间"},{"content":" GDB调试 命令 解释 set print thread-events off 运行gdb时关闭线程事件 (gdb) set logging on 输入这个命令后，此后的调试信息将输出到指定文件 set logging enabled on/off (gdb) set logging file \u0026lt;文件名\u0026gt; 设置输出的文件名称 (gdb) set logging off 输入这个命令，关闭到指定文件的输出 file \u0026lt;文件名\u0026gt; 加载被调试的可执行程序文件，因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。 r Run的简写，运行被调试的程序,如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。 c Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 info functions 列出函数的名字 b \u0026lt;行号\u0026gt; b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置，其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 b \u0026lt;函数名称\u0026gt; b *\u0026lt;函数名称\u0026gt; d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 b *\u0026lt;代码地址\u0026gt; d [编号] rbreak printNum* 对所有调用printNum函数都设置断点 rbreak . 对所有函数设置断点 rbreak test.c:. 对test.c中的所有函数设置断点 rbreak test.c:^print tbreak test.c:l0 在第10行设置临时断点 ignore 1 30 设置跳过多次的断点，其中，1是要忽略的断点号，可以通过前面的方式查找到，30是需要跳过的次数。这样设置之后，会跳过前面30次。 watch a 设置一个一旦值发生变化就停止的断点. info breakpoints 查看已设置的断点 p \u0026lt;变量名称\u0026gt; Print的简写，显示指定变量（临时变量或全局变量）的值。 i Info的简写，用于显示各类信息，详情请查阅“help i”。 q Quit的简写，退出GDB调试环境。 help [命令名称] GDB帮助命令，提供对GDB名种命令的解释说明，如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询 ","date":"2024-03-26T00:24:28+08:00","permalink":"https://ynhugo.github.io/p/gdb%E8%B0%83%E8%AF%95/","title":"GDB调试"},{"content":" 付费域名购买 GNAME 支持批量注册\n链接：https://www.gname.com/\nNameSilo Whois隐私是免费的，可以适当的进行一下隐私保护，而且域名还都挺便宜的\n链接：https://www.namesilo.com/\nNamecheap 域名便宜，1-2美元一年\n链接：https://www.namecheap.com/ 免费域名注册 链接1：https://nic.eu.org/\n链接2：http://eu.org\n","date":"2024-03-26T00:24:28+08:00","permalink":"https://ynhugo.github.io/p/%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0/","title":"域名购买"},{"content":" 免费域名注册 1.EU.org域名，永久免费 使用虚拟信息网站的信息注册\u0026#34;nic.eu.org\u0026#34;，然后注册域名，\u0026#34;Name servers\u0026#34;选择\u0026#34;server names\u0026#34;，填入\u0026#34;Cloudflare\u0026#34;的DNS服务器，确认后检查无误后等待官方通过，时间一般比较长，需要耐心等待\n参考链接 2023年 最新免费域名注册教程！支持 .com顶级域名\n","date":"2024-03-26T00:24:28+08:00","permalink":"https://ynhugo.github.io/p/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C/","title":"域名注册"},{"content":" 实验环境 在虚拟机(vmware)中做的实验，同时运行ubuntu16.04.3虚拟操作系统和windows10专业版虚拟操作系统\n这两个虚拟操作系统都是格接模式，并且勾选\u0026#34;复制物理网络连接状态(P)\u0026#34;选项\nwindows10虚拟操作系统为了使实验更顺利，保险起见，将防火墙给关闭，关闭防火墙的办法就是将防火墙的三个网络分别是\u0026#34;域网络\u0026#34;、\u0026#34;专用网络\u0026#34;、\u0026#34;公用网络\u0026#34;给关闭就可以了\n实验步骤 安装Windows OpenSSH 首先通过powershell安装OpenSSH的服务端\n在开始图标上点击右键，选择Windows PowerShell(管理员)(A)\n在powershell中输入：\n1 2 3 4 5 # 安装OpenSSH客户端 Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0 # 安装OpenSSH服务端 Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 在powershell中输入：\n1 Get-WindowsCapability -Online | ? Name -like \u0026#39;OpenSSH*\u0026#39; 若返回为：\n1 2 3 4 5 Name : OpenSSH.Client~~~~0.0.1.0 State : Installed Name : OpenSSH.Server~~~~0.0.1.0 State : Installed 则表示安装成功，若返回为：\n1 2 3 4 5 Name : OpenSSH.Client~~~~0.0.1.0 State : NotPresent Name : OpenSSH.Server~~~~0.0.1.0 State : NotPresent 表示安装失败，再来一遍吧，注意全程需要管理员权限。\n启动SSH服务器 依然是以管理员身份打开PowerShell，然后运行以下命令来启动 sshd service\n1 2 3 4 5 6 7 8 9 10 11 # 启动sshd服务 Start-Service sshd # 将sshd服务设置为自动启动，若不设置需要在每次重启后重新开启sshd Set-Service -Name sshd -StartupType \u0026#39;Automatic\u0026#39; # 确认防火墙规则，一般在安装时会配置好 Get-NetFirewallRule -Name *ssh* # 若安装时未添加防火墙规则\u0026#34;OpenSSH-Server-In-TCP\u0026#34;，则通过以下命令添加，不过我除此之外还关闭了防火墙 New-NetFirewallRule -Name sshd -DisplayName \u0026#39;OpenSSH Server (sshd)\u0026#39; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22 开启密钥登录 这一步是重中之重，加强安全，减少麻烦！！！\n生成密钥的方法都是一样的，可以自行搜索，与linux不同的地方在于权限管理和默认authorized_keys存放位置。\n公钥 (~\\.ssh\\id_rsa.pub) 的内容需放置在服务器上的一个名为authorized_keys的文本文件中，该文件位于 C:\\Users\\username\\.ssh\\。 OpenSSH 客户端包括了 scp 来帮助实现此目的，这是一个安全的文件传输实用工具。\n将本地的公钥部署到服务器上\n1 2 3 4 5 6 7 # 确保服务器上存在.ssh 文件夹，若不存在则使用下面命令创建 ssh username@ip mkdir C:\\Users\\username\\.ssh\\ #通过scp将本地的公钥上传到服务器上并重命名为authorized_keys，注意此方法会覆盖原有authorized_keys scp C:\\Users\\username\\.ssh\\id_rsa.pub user1@ip:C:\\Users\\username\\.ssh\\authorized_keys # 其实更推荐直接将客户端的密钥拷贝到服务端的authorized_keys中 通过上述方法会覆盖原有authorized_keys文件，若要添加多个公钥，则通过记事本（更推荐使用vscode等文本编辑器）打开authorized_keys，把另起一行并把新公钥粘贴到authorized_keys文件中。\n以下是windows中特有的操作\n更改authorized_keys文件权限，不更改则无法通过密钥登录\n1 2 远程通过ACL更改文件权限 ssh --% user1@ip icacls.exe \u0026#34;C:\\Users\\username\\.ssh\\authorized_keys\u0026#34; /inheritance:r /grant \u0026#34;Administrators:F\u0026#34; /grant \u0026#34;SYSTEM:F\u0026#34; 在服务器端则可以通过以下命令修改，注意需要管理员权限。\n1 2 #在服务器端修改authorized_keys文件权限 icacls.exe \u0026#34;C:\\Users\\Administrator\\.ssh\\authorized_keys\u0026#34; /inheritance:r /grant \u0026#34;Administrators:F\u0026#34; /grant \u0026#34;SYSTEM:F\u0026#34; 在Windows OpenSSH中，默认的授权密钥存放位置为ProgramData\\ssh\\administrators_authorized_keys，此位置对应为管理用户权限。因此需要修改默认授权文件位置。通过文本编辑器（推荐vscode）打开ProgramData\\ssh\\sshd_config，修改以下条目\n1 2 3 4 5 6 7 8 9 10 11 12 # 允许公钥授权访问，确保条目不被注释 PubkeyAuthentication yes # 授权文件存放位置，确保条目不被注释 AuthorizedKeysFile\t.ssh/authorized_keys # 可选，关闭密码登录，提高安全性 PasswordAuthentication no # 注释掉默认授权文件位置，确保以下条目被注释 # Match Group administrators # AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys 注意修改sshd_config需要管理员权限，修改完成后保存并推出。\n在PowerShell(管理员)中重启sshd服务\n1 2 # 重启sshd，需要管理员权限 Restart-Service sshd 至此可以尽情享受windows服务器带来的各种不便了！enjoy！！！\n最后附赠如何使用PowerShell卸载Windows OpenSSH\n1 2 3 4 5 # 卸载 OpenSSH 客户端 Remove-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0 # 卸载 OpenSSH 服务端 Remove-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 卸载后如果要重装需要先重启系统然后再重新安装\n参考链接 ssh远程连接windows\n","date":"2024-03-26T00:24:26+08:00","permalink":"https://ynhugo.github.io/p/ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5windows%E6%95%99%E7%A8%8B/","title":"ssh远程连接windows教程"},{"content":" windows11(WSL)安装Linux18.04.6LTS 先将WSL2设为默认版本\n1 wsl --set-default-version 2 然后在windows应用商店搜索ubuntu找到ubuntu18.04.6下载安装\nubuntu换源脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash cp /etc/apt/sources.list /etc/apt/sources.list.bak cat /etc/apt/sources.list \u0026gt; /etc/apt/sources.list cat \u0026gt; /etc/apt/sources.list \u0026lt;\u0026lt; endl ## 18.04LTS # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse endl 1 sudo apt update -y \u0026amp;\u0026amp; sudo apt upgrade -y 卸载wsl-ubuntu18.04.6参考链接： Windows子系统(WSL2)中自定义安装Ubuntu并换源\nWindows 10(WSL) 安装Linux发行版Ubuntu18.04\n","date":"2024-03-26T00:24:26+08:00","permalink":"https://ynhugo.github.io/p/wsl_ubuntu18_04_6/","title":"Wsl_ubuntu18_04_6"},{"content":" 将Emacs添加到右键快捷菜单中 通过右键菜单打开文件 长期用Emacs写代码，但是每次都是从命令行启动，有个麻烦事，针对单个文件，且该文件处在目录较深时，还要在命令中一层层敲进去，程序猿的时间都是很宝贵的，下面就来看看如何将Emacs添加到右键菜单中：\n从“run”中运行“regedit”启动注册表； 在打开的注册表中找到“HKEY_CLASSES_ROOT\\*”，这里需要注意，其中的“*”可不是指在“HKEY_CLASSES_ROOT”下，而该项的下面有个子项叫“*”。在该子项下新建一个名为“shell”的项，如果没有，直接新建，如果有，可以不用新建；\n此时，在“HKEY_CLASSES_ROOT\\*\\shell”上右键，选中“新建”-\u0026gt;“项”，键入“Emacs 编辑(\u0026amp;M)”。然后在“HKEY_CLASSES_ROOT\\*\\shell\\”下新建一个项，命名为\u0026#34;通过 Emacs 打开\u0026#34;，再在“HKEY_CLASSES_ROOT\\*\\shell\\通过emacs打开”下新建一个项，命名为“command”；\n然后，选中“HKEY_CLASSES_ROOT\\*\\shell\\通过emacs打开\\command”项，在右边的栏目中，双击“名称”为“默认”的项，双击，在打开的对话框中的“数值数据”框内添加你自己Emacs的安装目录下的“bin”目录，并在后面空一格添加“%1”，确定即可，如我的是“D:Program Files (x86)\\emacs-28.2\\bin\\runemacs.exe \u0026#34;%1\u0026#34;”。\n此时，你在一个源代码文件上右键点击时，就可以看到有了“Emacs编辑”可选项！\nOpen Emacs here 给右键菜单添加“Open Emacs here”这个选项\n打开注册表，定位到HKEY_CLASSES_ROOT\\Directory\\Background\\shell（如果Background下面没有shell目录，就自己新建一个）。\n在shell下右键-新建项,其名称为“Open Emacs here”,此为右键菜单显示名称。\n在shell下右键-新建-字符串，命名为Icon,双击编辑，其值为“D:Program Files (x86)\\emacs-28.2\\bin\\runemacs.exe”，在右键菜单中会自动显示该软件图标。\n在\u0026#34;Open Emacs here\u0026#34;下右键-新建-项，命名为command,其值为\u0026#34;D:Program Files (x86)\\emacs-28.2\\bin\\runemacs.exe\u0026#34;。\n此时，在任何一个目录空白处右键，即可出现Open Emacs here选项，单击即可启动emacs并在Emacs中自动进入当前目录。考虑到PowerShell右键选项需要按住Shift才会在右键菜单中显示出来，想把Open Emacs here也搞成这样子。只需这样操作：\n在Open Emacs here下右键-\u0026gt; 新建字符串，命名为“Extended”（与Icon字段同级）即可。\n通过注册表文件实现添加 Emacs 到右键菜单 使用此注册表文件之前需要根据 Emacs 的实际安装目录将注册表文件中的路径替换一下\n假如注册表文件中的某路径不存在，那么就先进入这个不存在的路径的上一级存在的路径，逐级递进，这样注册表在执行的时候就会将不存在的路径一级一级的创建出来，如果注册表文件中的有效路径后连着跟了两个或两个以上的不存在的路径名，则添加注册表会失败\n1 2 3 4 5 6 7 8 9 10 11 12 13 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell] [HKEY_CLASSES_ROOT\\*\\shell\\Edit with Emacs] \u0026#34;icon\u0026#34;=\u0026#34;D:\\\\Program Files (x86)\\\\emacs-28.2\\\\bin\\\\runemacs.exe\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\Edit with Emacs\\command] @=\u0026#34;D:\\\\Program Files (x86)\\\\emacs-28.2\\\\bin\\\\runemacs.exe \\\u0026#34;%1\\\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell] [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open Emacs here] \u0026#34;icon\u0026#34;=\u0026#34;D:\\\\Program Files (x86)\\\\emacs-28.2\\\\bin\\\\runemacs.exe\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open Emacs here\\command] @=\u0026#34;D:\\\\Program Files (x86)\\\\emacs-28.2\\\\bin\\\\runemacs.exe\u0026#34; 将 Emacs 添加进右键菜单的注册表文件下载 点击下载\n下载该注册表文件后双击运行即可\n通过bat脚本实现添加 Emacs 到右键菜单 如果运行该bat脚本失败的话可以尝试以管理员身份运行\n运行该脚本后会提示输入 emacs 安装路径，将自己电脑上的emacs的实际安装路径输入即可，如 D:Programs\\emacs-28.2\\bin\\runemacs.exe\n脚本中的 REM 起注释作用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @echo off REM 等待用户输入参数 set /p runemacs_path=请输入 runemacs.exe 路径：%1 REM /p 是 echo 命令的一个选项，用于暂停输出并等待用户按下任意键继续 REM 使用输入的参数进行操作 REM echo runemacs.exe 路径：%runemacs_path% REM 对斜杠进行转义 set runemacs_path=%runemacs_path:\\=\\\\% echo 转义后的 runemacs.exe 路径: \u0026#34;%runemacs_path%\u0026#34; echo Windows Registry Editor Version 5.00 \u0026gt;\u0026gt; auto_set_runemacs.reg REM echo. 表示输出一个空行 echo. \u0026gt;\u0026gt; auto_set_runemacs.reg echo [HKEY_CLASSES_ROOT\\*\\shell] \u0026gt;\u0026gt; auto_set_runemacs.reg echo [HKEY_CLASSES_ROOT\\*\\shell\\Edit with Emacs] \u0026gt;\u0026gt; auto_set_runemacs.reg echo \u0026#34;icon\u0026#34;=\u0026#34;%runemacs_path%\u0026#34; \u0026gt;\u0026gt; auto_set_runemacs.reg echo [HKEY_CLASSES_ROOT\\*\\shell\\Edit with Emacs\\command] \u0026gt;\u0026gt; auto_set_runemacs.reg echo @=\u0026#34;%runemacs_path% \\\u0026#34;%%1\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; auto_set_runemacs.reg echo. \u0026gt;\u0026gt; auto_set_runemacs.reg echo [HKEY_CLASSES_ROOT\\Directory\\Background\\shell] \u0026gt;\u0026gt; auto_set_runemacs.reg echo [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open Emacs here] \u0026gt;\u0026gt; auto_set_runemacs.reg echo \u0026#34;icon\u0026#34;=\u0026#34;%runemacs_path%\u0026#34; \u0026gt;\u0026gt; auto_set_runemacs.reg echo [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open Emacs here\\command] \u0026gt;\u0026gt; auto_set_runemacs.reg echo @=\u0026#34;%runemacs_path%\u0026#34; \u0026gt;\u0026gt; auto_set_runemacs.reg REM /eait的作用是等start命令执行完后再运行批处理脚本 start /wait auto_set_runemacs.reg del /f auto_set_runemacs.reg REM 其他操作... 将 Emacs 添加进右键菜单的注册表文件下载 点击下载\n下载该注册表文件后双击运行即可\n右键菜单启动emacs默认以管理员身份运行 emacs添加到右键菜单打开文件，普通用户是没有问题的，但是通过在任务栏修改emacs的属性以管理员身份运行的时候再通过右键打开emacs就打不开了，这时候可以将开始菜单中的emacs快捷方式的属性也更改为以管理员身份运行，或者直接在emacs的安装目录将emacs的属性更改\n参考链接 将Emacs添加到右键快捷菜单中\n将Emacs添加到Windows资源管理器右键菜单\n","date":"2024-03-26T00:24:26+08:00","permalink":"https://ynhugo.github.io/p/%E5%B0%86emacs%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%8F%B3%E9%94%AE%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD/","title":"将Emacs添加到右键快捷菜单中"},{"content":" 参考链接 五笔字根表 五笔字型拆字规则 输入法 本博客内容大多参考 爱五笔 网站\n五笔字根表 可以先把25个字母背下来，再背对应的字根，按照从左往右，从上往下的顺序记忆25个字母：QWERT、YUIOP、ASDFG、HJKLM、XCVBN，其中字母Z没有分配字根，因此不用管字母Z\n86版五笔口诀 五笔字根在键盘上分五个区，对应\u0026#34;横、竖、撇、捺、折\u0026#34;这五个区，以下五个区中字母对应按键，数字对应每个区的第一个按键到第五个按键，例如11表示第一个区的第一个按键，33表示第三个区第三个按键，42代表第四个区第二个按键\n横区(一) G 11 王旁青头戋(兼)五一\nF 12 土士二干十寸雨\nD 13 大犬三(羊)古石厂\nS 14 木丁西\nA 15 工戈草头右框七\n竖区(丨) H 21 目具上止卜虎皮\nJ 22 日早两竖与虫依\nK 23 口与川，字根稀\nL 24 田甲方框四车力\nM 25 山由贝，下框几\n撇(丿) T 31 禾竹一撇双人立，反文条头共三一\nR 32 白手看头三二斤\nE 33 月彡(衫)乃用家衣底\nW 34 人和八，三四里\nQ 35 金勺缺点无尾鱼，犬旁留儿一点夕，氏无七(妻)\n捺(丶) Y 41 言文方广在四一，高头一捺谁人去\nU 42 立辛两点六门疒\nI 43 水旁兴头小倒立\nO 44 火业头，四点米\nP 45 之字军盖道建底，摘礻(示)衤(衣)\n折区(乙) N 51 已半巳满不出己，左框折尸心和羽\nB 52 子耳了也框向上\nV 53 女刀九臼山朝西\nC 54 又巴马，丢矢矣\nX 55 慈母无心弓和匕，幼无力\n86版五笔字型字根表及助记词 五笔一级简码表 打出来一个汉字最多要敲四次按键，而一级简码只需要敲一次按键\n在五笔输入法打字中，汉字输入时，出现率最高的文字，被有效的分配了“一级简码”，它充分的利用了26个“字母键（Z键除外）”，使用这项特有的功能可以有效的提高打字速度。\n关于一级简码，这里特别推荐一个网站：https://www.iwubi.net/article/2\n五笔拆字原理 关于五笔拆字原理，这里推荐一个网站，感觉这个网站讲的挺好的：https://www.iwubi.net/article/5\n","date":"2024-03-26T00:24:26+08:00","permalink":"https://ynhugo.github.io/p/%E4%BA%94%E7%AC%94%E5%85%A5%E9%97%A8/","title":"五笔入门"},{"content":" 如果没有安装vmware的话可以看我的另一篇文章：vmware安装教程\nwindows10下载链接(需要用迅雷下载)：ed2k://|file|zh-cn_windows_10_consumer_editions_version_22h2_updated_dec_2023_x64_dvd_3045f975.iso|6235348992|A12E47ED16415F13D4965AC629897278|/\n下载好的windows10映像，映像内含专业版，也是准备安装的版本\n打开vmware后，点击\u0026#34;文件\u0026#34;的新建虚拟机\n以\u0026#34;自定义(高级)(C)\u0026#34;类型配置安装windows10，然后\u0026#34;下一步\u0026#34;\n\u0026#34;虚拟机硬件兼容性\u0026#34;不需要更改，默认即可，然后\u0026#34;下一步\u0026#34;\n选择\u0026#34;稍后安装操作系统(S)\u0026#34;，然后\u0026#34;下一步\u0026#34;\n\u0026#34;客户机操作系统\u0026#34;选择\u0026#34;Microsoft Windows(W)\u0026#34;\n\u0026#34;客户机操作系统\u0026#34;的\u0026#34;版本(V)\u0026#34;选择\u0026#34;Windows 10 x64\u0026#34;，然后\u0026#34;下一步\u0026#34;\n虚拟机的位置更改一下，可以更改到D盘，这个路径要提要创建好，得是真实的路径，然后\u0026#34;下一步\u0026#34;\n\u0026#34;固件类型\u0026#34;选择\u0026#34;BIOS(O)\u0026#34;，然后\u0026#34;下一步\u0026#34;\n\u0026#34;处理器配置\u0026#34;可以根据电脑性能进行配置，比如\u0026#34;处理器数量(P)\u0026#34;选择为1，\u0026#34;每个处理器的内核数量(C)\u0026#34;对应的个数尽可能大，软件不报警告即可，然后\u0026#34;下一步\u0026#34;\n内存可以点击设置为\u0026#34;4 GB\u0026#34;，然后下一步\n\u0026#34;网络类型\u0026#34;默认为\u0026#34;使用网络地址转换(NAT)(E)\u0026#34;即可，然后下一步\n\u0026#34;I/O控制器类型\u0026#34;默认推荐的即可，不需要更改，然后\u0026#34;下一步\u0026#34;\n\u0026#34;磁盘类型\u0026#34;也按照默认推荐的即可\n选择\u0026#34;创建新的虚拟磁盘(V)\u0026#34;，然后\u0026#34;下一步\u0026#34;\n设置磁盘容量，至少30GB，这里我按照推荐的来，如果准备长期使用现在正在安装的虚拟机的话，可以将磁盘容量设置的再大一些，如100GB、150GB、200GB都可以，只要电脑本身有足够大的空闲空间就行，然后选择\u0026#34;将虚拟磁盘存储为单个文件\u0026#34;，接着\u0026#34;下一步\u0026#34;\n\u0026#34;磁盘文件\u0026#34;名称不需要更改，但是需要将\u0026#34;磁盘文件\u0026#34;保存的路径更改一下，\u0026#34;磁盘文件\u0026#34;保存\u0026#34;windows10虚拟机安装位置\u0026#34;，与前边设置的\u0026#34;虚拟机位置\u0026#34;为同一路径，然后\u0026#34;下一步\u0026#34;\n点击\u0026#34;自定义硬件(C)…\u0026#34;\n然后点击\u0026#34;新CD/DVD (SATA)\u0026#34;，选择\u0026#34;使用ISO映像文件\u0026#34;，接着点击\u0026#34;浏览\u0026#34;，找到刚刚下载好的windows10映像文件，我将下载好的windows10映像文件移动到了虚拟机位置的上一级目录，此我为准备好的windows10映像的实际路径，路径建议不要包含中文字符，然后点击\u0026#34;关闭\u0026#34;，关闭当前页面\n设置完成后点击\u0026#34;完成\u0026#34;\n快照部分可跳过，鼠标右键虚拟机的标签页，给制作好的虚拟机做一个快照，这样如果安装过程中出现问题了可以恢复快照重新安装\n快照部分可跳过，添加描述信息后点击\u0026#34;拍摄快照\u0026#34;，添加描述信息是为了方便恢复快照的时候进行选择，恢复快照的时候可以选择恢复到哪个版本的快照\n快照部分可跳过，鼠标右键虚拟机标签页，打开快照管理器\n快照部分可跳过，选择要恢复的快照，然后点击\u0026#34;转到\u0026#34;即可恢复到对应的快照\n虚拟机配置好后就可以可以进行安装了，直接点击\u0026#34;开启此虚拟机\u0026#34;即可\n点击\u0026#34;开启此虚拟机\u0026#34;后经过加载进入到了windows10的安装界面，安装界面要求选择\u0026#34;要安装的语言(E)\u0026#34;、\u0026#34;时间和货币格式(T)\u0026#34;、\u0026#34;键盘和输入方法(K)\u0026#34;，这些都不用更改，默认即可，如果有不一样的使用习惯可以根据自己的使用习惯进行配置，然后点击\u0026#34;下一页\u0026#34;\n然后点击\u0026#34;现在安装\u0026#34;\n选择\u0026#34;我没有产品密钥(I)\u0026#34;，这样可以跳过输入产品密钥，等安装完windows10系统后再激活\n选择要安装的windows10系统版本，建议选择\u0026#34;windows 10 专业版\u0026#34;，因为家庭版会有一些功能限制，这是家庭版系统本身决定的，与虚拟机无关，而专业版会更方便配置，不像家庭版会有功能限制，选择了\u0026#34;windows 10 专业版\u0026#34;后点击\u0026#34;下一页(N)\u0026#34;\n同意条款后点击\u0026#34;下一页\u0026#34;\n选择\u0026#34;自定义\u0026#34;安装方式\n默认已经选中磁盘了，什么都不需要做，直接点击\u0026#34;下一页\u0026#34;\n然后系统就开始安装了，安装过程中会自动重启虚拟机，耐心等待即可\n系统重启直到加载到这个页面，默认区域设置选中为\u0026#34;中国\u0026#34;，不需要更改，点击\u0026#34;是\u0026#34;\n键盘布局默认选中\u0026#34;微软拼音\u0026#34;，也不需要更改，如果喜欢使用五笔拼音的可以自行选择，然后点击\u0026#34;是\u0026#34;\n询问是否添加\u0026#34;第二种键盘布局\u0026#34;，直接点击\u0026#34;跳过\u0026#34;即可\n加载一段时间后到这个页面，选择\u0026#34;针对个人使用进行设置\u0026#34;\n选择\u0026#34;脱机账户\u0026#34;\n选择\u0026#34;有限的体验\u0026#34;\n设置一个不包含中文字符的用户名，如果设置中文用户名的话，以后使用国外某些软件可能会报异常，国外某些软件会在用户目录下创建数据文件夹，如果国外软件不支持包含中文字符的用户目录就会报错，因此用户名建议不要包含中文字符，设置完用户名后点击\u0026#34;下一页\u0026#34;\n随便设置一个简单的密码，然后点击\u0026#34;下一页\u0026#34;\n确认密码后点击\u0026#34;下一页\u0026#34;\n接下来设置三个安全问题，自行设置\n申请访问数据选择\u0026#34;以后再说\u0026#34;\n取消这些隐私设置后点击\u0026#34;接受\u0026#34;\n跳过\u0026#34;自定义的体验\u0026#34;\n点击\u0026#34;以后再说\u0026#34;\n这里必须点击\u0026#34;下一步\u0026#34;，否则无法完成虚拟机的安装，事实上当你开始使用windows系统开始，你就默认\u0026#34;同意个人数据跨境传输\u0026#34;了，因此不必在意这个，直接点击\u0026#34;下一步\u0026#34;\n至此，windows10虚拟机安装完成\n接下来要想有更改的虚拟机体验，还需要安装vmware-tools，右键虚拟机标签页，点击\u0026#34;安装VMware Tools(T)…\u0026#34;\n这个时候打开虚拟机的\u0026#34;文件资源管理器\u0026#34;的\u0026#34;此电脑\u0026#34;就会发现多出来了一个\u0026#34;DVD驱动器(D:)VMware Tools\u0026#34;，鼠标左键双击运行该驱动器\n点击\u0026#34;是\u0026#34;继续运行\n默认\u0026#34;下一步(N)\u0026#34;\n选择\u0026#34;典型安装\u0026#34;，然后\u0026#34;下一步\u0026#34;\n最后点击\u0026#34;安装\u0026#34;进行安装\n最后点击\u0026#34;完成\u0026#34;，完成安装\n提示重启系统，按照提示点击\u0026#34;是\u0026#34;重启即可\n重启系统后，正常登录系统使用即可\n","date":"2024-03-26T00:24:24+08:00","permalink":"https://ynhugo.github.io/p/vmware%E5%AE%89%E8%A3%85windows10%E6%95%99%E7%A8%8B/","title":"vmware安装windows10教程"},{"content":" windows安装vmware教程 vmware 又叫 VMware Workstation 17 Pro\nvmware下载链接 点击该链接即可下载 Workstation 17 Pro for Windows\nhttps://download3.vmware.com/software/WKST-1750-WIN/VMware-workstation-full-17.5.0-22583795.exe\nvmware下载页面 直接访问下载页面可以下载最新版本，如果访问下载链接的话，对应的版本是写博客的时候提供的vmware某一版本的下载链接，版本是固定的\nhttps://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html\n安装步骤 双击运行\n下一步\n同意条款并下一步\n点击更改\n更改路径中的盘符，将C改成D，然后点击确定，接着点击下一步，这样vmware将会安装在D盘的指定路径下\n取消自动检查更改，取消加入体验计划，然后点击下一步\n不是同一个版本的vmware安装的虚拟操作系统会导致vmware与虚拟操作系统不兼容，比如新版本的vmware不能打开旧版本的虚拟操作系统\n取消加入体验计划是避免vmware收集产品信息\n勾选在\u0026#34;桌面\u0026#34;和\u0026#34;开始菜单程序文件夹\u0026#34;创建快捷方式\n点击安装\n安装中\n安装完成，点击\u0026#34;许可证\u0026#34;\n输入以下任一有效许可证密钥进行激活，有的可能失效，但是可以在以下找到有效的进行激活vmware，另外除了本博客提供的许可证密钥，如果想自己找vmware17许可证密钥匙，还可以在网上搜索\u0026#34;vmware17许可证密钥匙\u0026#34;进行查找\n4Y09U-AJK97-089Z0-A3054-83KLA\n4A4RR-813DK-M81A9-4U35H-06KND\nNZ4RR-FTK5H-H81C1-Q30QH-1V2LA\n4C21U-2KK9Q-M8130-4V2QH-CF810\nMC60H-DWHD5-H80U9-6V85M-8280D\nAC310-06X4M-M880Z-GZYNZ-YCRV0\nFZ31K-8JE81-H8EXZ-XEQQV-MAUYD\nVU39H-A9F1K-480JY-NMMGC-MZ2Z0\nZV3MH-8QZ1Q-H80LY-JENXV-YP8TA\nFF112-6TD0J-M81FY-7WWQE-N22T4\nVZ7JK-4RX95-M8DUP-XGWNG-NYURF\n输入许可证密钥后点击\u0026#34;输入\u0026#34;进行确认\n至此完成vmware的安装，点击\u0026#34;完成\u0026#34;关闭安装完成界面\nvmware安装成功后可以在桌面找到vmware\nvmware打开界面如下\n查找vmware激活状态\n可以看到vmware已经永久激活\n安装windows10教程 安装windows10教程的篇幅过长，安装windows10教程可以跳转到我的另一篇文章：vmware安装windows10教程/\n","date":"2024-03-26T00:24:24+08:00","permalink":"https://ynhugo.github.io/p/vmware%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","title":"vmware安装教程"},{"content":" 这是 VMware 的 bug，解决方法是关闭虚拟机并打开该虚拟机的目录，用记事本或 VSCode 打开虚拟机名 .vmx 文件，添加一行代码：\n1 mks.win32.useInjectedMagic=FALSE 保存后重新启动虚拟机，此时应该会恢复正常\n参考链接 请问虚拟机中Ubuntu系统大小写混乱该怎么解决?\n","date":"2024-03-26T00:24:24+08:00","permalink":"https://ynhugo.github.io/p/%E8%A7%A3%E5%86%B3vmware%E4%B8%ADubuntu%E5%A4%A7%E5%B0%8F%E5%86%99%E6%B7%B7%E4%B9%B1%E9%97%AE%E9%A2%98/","title":"解决vmware中Ubuntu大小写混乱问题"},{"content":" 方法一 打开终端，依次执行以下命令\n1 2 sudo apt-get autoremove open-vm-tools sudo apt-get install open-vm-tools-desktop 然后再重启Ubuntu即可。\n方法二 可以借助软件实现windows和linux共享文件\n例如\n参考链接 解决Windows与Ubuntu之间的文件拖放问题\n","date":"2024-03-26T00:24:24+08:00","permalink":"https://ynhugo.github.io/p/%E8%A7%A3%E5%86%B3windows%E4%B8%8Eubuntu%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%8B%96%E6%94%BE%E9%97%AE%E9%A2%98/","title":"解决Windows与Ubuntu之间的文件拖放问题"},{"content":" 参考链接：https://zhuanlan.zhihu.com/p/536805039 文叔叔 - 传文件，找文叔叔（大文件、永不限速） 官网：https://www.wenshushu.cn\n文叔叔是一个简单快速的文件分享网盘，无需注册登陆，一键分享/下载文件，而且号称“永不限速”。\n可以通过链接、二维码、取件码分享/获取文件，支持上传整个文件夹而无需压缩打包，设置访问密码、到期自动销毁等。\n上传、下载不限速 单文件最大 5GB 免费空间 40GB 批量传文件、文件夹 所有数据加密传输，同步永久销毁 支持移动客户端和微信小程序 钛盘 - 超好用的文件中转站 官网：https://tmp.link\n钛盘是一个不限速 \u0026amp; 无限空间的纯网页版临时文件分享网盘。\n可以通过链接、二维码分享和下载文件，而且支持使用 IDM 等第三方下载工具下载。\n无限空间、不限数量 单文件最大 10GB 文件保存时间 24h 支持 curl 和 wget 命令下载 纯网页版，无客户端 Send Anywhere 官网：https://send-anywhere.com\nSend Anywhere 是一款非常知名的跨平台文件传输工具，2012 年推出至今已经运营 10 年时间。\n可以通过密匙、二维码、链接、邮件分享和下载文件。而且使用密匙传输时直接在两台设备间传输文件，不会存储在服务器上，更安全可靠。\n有 Win、Mac、Linux、安卓、iOS、网页版和浏览器扩展等设备支持极全。\n密匙和二维码 10 分钟内有效，链接 48h 有效 普通用户 10GB 服务器空间（分享链接） 支持点对点无限制传输 Wi-Fi 直连传输 最全的平台客户端支持 Wormhole - 简单、私密的文件共享 官网：https://wormhole.app\nWormhole 是一个简单私密的文件分享网站，支持端到端加密传输文件。\n5GB 以下的文件，会在服务器上存储 24 小时；大于 5GB 的文件，通过点对点传输，直接发送给接收者，需要保持页面打开直到传输完毕。\n点对点加密传输 最大 10GB 文件分享 通过分享链接、二维码下载文件 免下载预览图像、音频和视频 设置过期时间和下载次数 手动删除文件 ","date":"2024-03-26T00:24:24+08:00","permalink":"https://ynhugo.github.io/p/%E5%85%8D%E8%B4%B9%E4%B8%B4%E6%97%B6%E4%BA%91%E7%9B%98/","title":"免费临时云盘"},{"content":" drow.io 支持在线画流程图，支持在保存在谷歌云盘、OneDrive、本地设备、Dropbox、GitHub、GitLab\n网站原链接是：https://draw.io/\nhttps://app.diagrams.net/\n","date":"2024-03-26T00:24:24+08:00","permalink":"https://ynhugo.github.io/p/%E5%9C%A8%E7%BA%BF%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/","title":"在线画流程图"},{"content":" Linux安装并启动Resilio 下载链接 https://download-cdn.resilio.com/2.7.3.1381/Debian/resilio-sync_2.7.3.1381-1_amd64.deb\n安装 1 sudo dpkg -i resilio-sync_2.7.3.1381-1_amd64.deb 配置 1 2 sudo usermod -aG ubt rslsync sudo usermod -aG rslsync ubt 建立同步文件夹 1 mkdir synced_folder 启动resilio 1 sudo service resilio-sync start 在浏览器中打开Resilio管理界面 Linux 上的 Resilio Sync 默认并没有 GUI 界面，但是提供了基于 Web 的界面。在通过上面的步骤启动了 Resilio Sync 之后，我们就可以在浏览器中输入如下地址打开 Resilio Sync 的 Web 管理界面\n1 https://127.0.0.1:8888/gui/ 注意事项 如果上面的地址打不开可以尝试检查一下是否有程序占用了 8888 端口\n然后重新启动Resilio并在浏览器访问\n1 2 3 netstat -apn | grep 8888 fuser -k -n tcp 8888 sudo service resilio-sync start 下载授权文件 Linux版本下载下来是专业版的，需要授权文件进行授权，要不然用不了Resilio\n下载链接1：https://www.123pan.com/s/ZAzA-6D8wh\n下载链接2：ResilioSyncPro.btskey.zip\n然后在web界面添加授权文件即可\n参考链接 保姆级教程:在Linux上安装配置Resilio Sync\nResilio Sync License 授权文件下载\n","date":"2024-03-26T00:24:22+08:00","permalink":"https://ynhugo.github.io/p/linux%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8resilio/","title":"Linux安装并启动Resilio"},{"content":" Qt Creator\u0026#34;不能使用中文 安装 \u0026#34;fcitx-frontend-qt5\u0026#34;\n然后将两个相关文件移动Qt安装目录的指定目录下\n接着重启QtCreator即可\n1 2 3 4 5 sudo apt-get install fcitx-frontend-qt5 -y sudo cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /opt/pkg/qt/qt5.8/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/ sudo cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /opt/pkg/qt/qt5.8/5.8/gcc_64/plugins/platforminputcontexts/ ","date":"2024-03-26T00:24:22+08:00","permalink":"https://ynhugo.github.io/p/qt-creator%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/","title":"Qt Creator\"不能使用中文"},{"content":" 参考链接 Qt中多线程的使用\nQt中多线程-线程池的使用-C/C++/qt\nQt中多线程的使用 默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新\n子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理\n主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制\n该博客涉及到三个工程，用到的是同一个ui界面，如下图\nQthread_1 mainwindow.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; #include \u0026#34;mythread.h\u0026#34; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); signals: void starting(int num); private: Ui::MainWindow *ui; }; #endif // MAINWINDOW_H mainwindow.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026#34;mainwindow.h\u0026#34; #include \u0026#34;ui_mainwindow.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); Generate* gen = new Generate; BubbleSort* bubble = new BubbleSort; QuickSort* quick = new QuickSort; connect(this, \u0026amp;MainWindow::starting, gen, \u0026amp;Generate::recvNum); connect(ui-\u0026gt;start, \u0026amp;QPushButton::clicked, this, [=]() { emit starting(10000); gen-\u0026gt;start(); }); connect(gen, \u0026amp;Generate::sendArray, bubble, \u0026amp;BubbleSort::recvArray); connect(gen, \u0026amp;Generate::sendArray, quick, \u0026amp;QuickSort::recvArray); connect(gen, \u0026amp;Generate::sendArray, this, [=](QVector\u0026lt;int\u0026gt; list) { bubble-\u0026gt;start(); quick-\u0026gt;start(); for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;randList-\u0026gt;addItem(QString::number(list.at(i))); } }); connect(bubble, \u0026amp;BubbleSort::finish, this, [=](QVector\u0026lt;int\u0026gt; list) { for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;bubbleList-\u0026gt;addItem(QString::number(list.at(i))); } }); connect(quick, \u0026amp;QuickSort::finish, this, [=](QVector\u0026lt;int\u0026gt; list) { for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;quickList-\u0026gt;addItem(QString::number(list.at(i))); } }); } MainWindow::~MainWindow() { delete ui; } mythread.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #ifndef MYTHREAD_H #define MYTHREAD_H #include \u0026lt;QThread\u0026gt; #include \u0026lt;QVector\u0026gt; #pragma execution_character_set(\u0026#34;utf-8\u0026#34;) class Generate : public QThread { Q_OBJECT public: explicit Generate(QObject *parent = nullptr); void recvNum(int num); protected: void run(); signals: void sendArray(QVector\u0026lt;int\u0026gt; list); private: int m_num; }; class BubbleSort : public QThread { Q_OBJECT public: explicit BubbleSort(QObject *parent = nullptr); void recvArray(QVector\u0026lt;int\u0026gt; list); protected: void run(); signals: void finish(QVector\u0026lt;int\u0026gt; num); private: QVector\u0026lt;int\u0026gt; m_list; }; class QuickSort : public QThread { Q_OBJECT public: explicit QuickSort(QObject *parent = nullptr); void recvArray(QVector\u0026lt;int\u0026gt; list); protected: void run(); private: void quickSort(QVector\u0026lt;int\u0026gt; \u0026amp;list, int l, int r); signals: void finish(QVector\u0026lt;int\u0026gt; num); private: QVector\u0026lt;int\u0026gt; m_list; }; #endif // MYTHREAD_H mythread.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 #include \u0026#34;mythread.h\u0026#34; #include \u0026lt;QRandomGenerator\u0026gt; #include \u0026lt;QElapsedTimer\u0026gt; #include \u0026lt;QDebug\u0026gt; Generate::Generate(QObject *parent) : QThread(parent) { } void Generate::recvNum(int num) { m_num = num; } void Generate::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;生成随机数的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QVector\u0026lt;int\u0026gt; list; QElapsedTimer time; time.start(); for(int i = 0; i \u0026lt; m_num; i++) { list.push_back(qrand() % 100000); } int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;生成\u0026#34; \u0026lt;\u0026lt; m_num \u0026lt;\u0026lt; \u0026#34;个随机数总共用时:\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit sendArray(list); } BubbleSort::BubbleSort(QObject *parent) : QThread(parent) { } void BubbleSort::recvArray(QVector\u0026lt;int\u0026gt; list) { m_list = list; } void BubbleSort::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;冒泡排序的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QElapsedTimer time; time.start(); int temp = 0; for(int i=0; i\u0026lt;m_list.size(); ++i) { for(int j=0; j\u0026lt;m_list.size()-i-1; ++j) { if(m_list[j] \u0026gt; m_list[j+1]) { temp = m_list[j]; m_list[j] = m_list[j+1]; m_list[j+1] = temp; } } } int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;冒泡排序用时\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit finish(m_list); } QuickSort::QuickSort(QObject *parent) : QThread(parent) { } void QuickSort::recvArray(QVector\u0026lt;int\u0026gt; list) { m_list = list; } void QuickSort::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;快速排序的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QElapsedTimer time; time.start(); quickSort(m_list, 0, m_list.size()-1); int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;快速排序用时\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit finish(m_list); } void QuickSort::quickSort(QVector\u0026lt;int\u0026gt; \u0026amp;s, int l, int r) { if(l \u0026lt; r) { int i = l, j = r; /* 拿出第一个元素，保存到x中，第一个位置成为一个坑 */ int x = s[l]; while(i \u0026lt; j) { /* 从右向左找小于x的数 */ while(i \u0026lt; j \u0026amp;\u0026amp; s[j] \u0026gt;= x) { /* 左移，直到遇到小于等于x的数 */ j--; } if(i \u0026lt; j) { /* 将右侧找到的小于x的元素放入左侧坑中，右侧出现一个坑 */ /* 左侧元素索引右移 */ s[i++] = s[j]; } /* 从左向右找大于等于x的数 */ while(i \u0026lt; j \u0026amp;\u0026amp; s[i] \u0026lt; x) { /* 左移，直到遇到大于x的数 */ i++; } if(i \u0026lt; j) { /* 将左侧找到的元素放入右侧坑中，左侧出现一个坑 */ /* 右侧元素索引向前移动 */ s[j--] = s[i]; } } /* 此时 i=j,将保存在x中的数值填入坑中 */ s[i] = x; quickSort(s, l, i-1);\t/* 递归调用 */ quickSort(s, i+1, r); } } Qthread_2 mainwindow.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; #include \u0026#34;mythread.h\u0026#34; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); signals: void starting(int num); private: Ui::MainWindow *ui; }; #endif // MAINWINDOW_H mainwindow.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026#34;mainwindow.h\u0026#34; #include \u0026#34;ui_mainwindow.h\u0026#34; #include \u0026lt;QThread\u0026gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); QThread* t1 = new QThread; QThread* t2 = new QThread; QThread* t3 = new QThread; Generate* gen = new Generate; BubbleSort* bubble = new BubbleSort; QuickSort* quick = new QuickSort; gen-\u0026gt;moveToThread(t1); bubble-\u0026gt;moveToThread(t2); quick-\u0026gt;moveToThread(t3); connect(this, \u0026amp;MainWindow::starting, gen, \u0026amp;Generate::working); connect(ui-\u0026gt;start, \u0026amp;QPushButton::clicked, this, [=]() { emit starting(10000); t1-\u0026gt;start(); }); connect(gen, \u0026amp;Generate::sendArray, bubble, \u0026amp;BubbleSort::working); connect(gen, \u0026amp;Generate::sendArray, quick, \u0026amp;QuickSort::working); connect(gen, \u0026amp;Generate::sendArray, this, [=](QVector\u0026lt;int\u0026gt; list) { t2-\u0026gt;start(); t3-\u0026gt;start(); for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;randList-\u0026gt;addItem(QString::number(list.at(i))); } }); connect(bubble, \u0026amp;BubbleSort::finish, this, [=](QVector\u0026lt;int\u0026gt; list) { for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;bubbleList-\u0026gt;addItem(QString::number(list.at(i))); } }); connect(quick, \u0026amp;QuickSort::finish, this, [=](QVector\u0026lt;int\u0026gt; list) { for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;quickList-\u0026gt;addItem(QString::number(list.at(i))); } }); } MainWindow::~MainWindow() { delete ui; } mythread.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #ifndef MYTHREAD_H #define MYTHREAD_H #include \u0026lt;QObject\u0026gt; #include \u0026lt;QVector\u0026gt; #pragma execution_character_set(\u0026#34;utf-8\u0026#34;) class Generate : public QObject { Q_OBJECT public: explicit Generate(QObject *parent = nullptr); void working(int num); signals: void sendArray(QVector\u0026lt;int\u0026gt; list); }; class BubbleSort : public QObject { Q_OBJECT public: explicit BubbleSort(QObject *parent = nullptr); void working(QVector\u0026lt;int\u0026gt; list); signals: void finish(QVector\u0026lt;int\u0026gt; num); }; class QuickSort : public QObject { Q_OBJECT public: explicit QuickSort(QObject *parent = nullptr); void working(QVector\u0026lt;int\u0026gt; list); private: void quickSort(QVector\u0026lt;int\u0026gt; \u0026amp;list, int l, int r); signals: void finish(QVector\u0026lt;int\u0026gt; num); }; #endif // MYTHREAD_H mythread.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include \u0026#34;mythread.h\u0026#34; #include \u0026lt;QRandomGenerator\u0026gt; #include \u0026lt;QElapsedTimer\u0026gt; #include \u0026lt;QDebug\u0026gt; #include \u0026lt;QThread\u0026gt; Generate::Generate(QObject *parent) : QObject(parent) { } void Generate::working(int num) { qDebug() \u0026lt;\u0026lt; \u0026#34;生成随机数的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QVector\u0026lt;int\u0026gt; list; QElapsedTimer time; time.start(); for(int i = 0; i \u0026lt; num; i++) { list.push_back(qrand() % 100000); } int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;生成\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;个随机数总共用时:\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit sendArray(list); } BubbleSort::BubbleSort(QObject *parent) : QObject(parent) { } void BubbleSort::working(QVector\u0026lt;int\u0026gt; list) { qDebug() \u0026lt;\u0026lt; \u0026#34;冒泡排序的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QElapsedTimer time; time.start(); int temp = 0; for(int i=0; i\u0026lt;list.size(); ++i) { for(int j=0; j\u0026lt;list.size()-i-1; ++j) { if(list[j] \u0026gt; list[j+1]) { temp = list[j]; list[j] = list[j+1]; list[j+1] = temp; } } } int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;冒泡排序用时\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit finish(list); } QuickSort::QuickSort(QObject *parent) : QObject(parent) { } void QuickSort::working(QVector\u0026lt;int\u0026gt; list) { qDebug() \u0026lt;\u0026lt; \u0026#34;快速排序的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QElapsedTimer time; time.start(); quickSort(list, 0, list.size()-1); int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;快速排序用时\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit finish(list); } void QuickSort::quickSort(QVector\u0026lt;int\u0026gt; \u0026amp;s, int l, int r) { if(l \u0026lt; r) { int i = l, j = r; /* 拿出第一个元素，保存到x中，第一个位置成为一个坑 */ int x = s[l]; while(i \u0026lt; j) { /* 从右向左找小于x的数 */ while(i \u0026lt; j \u0026amp;\u0026amp; s[j] \u0026gt;= x) { /* 左移，直到遇到小于等于x的数 */ j--; } if(i \u0026lt; j) { /* 将右侧找到的小于x的元素放入左侧坑中，右侧出现一个坑 */ /* 左侧元素索引右移 */ s[i++] = s[j]; } /* 从左向右找大于等于x的数 */ while(i \u0026lt; j \u0026amp;\u0026amp; s[i] \u0026lt; x) { /* 左移，直到遇到大于x的数 */ i++; } if(i \u0026lt; j) { /* 将左侧找到的元素放入右侧坑中，左侧出现一个坑 */ /* 右侧元素索引向前移动 */ s[j--] = s[i]; } } /* 此时 i=j,将保存在x中的数值填入坑中 */ s[i] = x; quickSort(s, l, i-1);\t/* 递归调用 */ quickSort(s, i+1, r); } } Qthreadpool mainwindow.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; #include \u0026#34;mythread.h\u0026#34; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); signals: void starting(int num); private: Ui::MainWindow *ui; }; #endif // MAINWINDOW_H mainwindow.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026#34;mainwindow.h\u0026#34; #include \u0026#34;ui_mainwindow.h\u0026#34; #include \u0026lt;QThreadPool\u0026gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); Generate* gen = new Generate; BubbleSort* bubble = new BubbleSort; QuickSort* quick = new QuickSort; connect(this, \u0026amp;MainWindow::starting, gen, \u0026amp;Generate::recvNum); connect(ui-\u0026gt;start, \u0026amp;QPushButton::clicked, this, [=]() { emit starting(10000); QThreadPool::globalInstance()-\u0026gt;start(gen); }); connect(gen, \u0026amp;Generate::sendArray, bubble, \u0026amp;BubbleSort::recvArray); connect(gen, \u0026amp;Generate::sendArray, quick, \u0026amp;QuickSort::recvArray); connect(gen, \u0026amp;Generate::sendArray, this, [=](QVector\u0026lt;int\u0026gt; list) { QThreadPool::globalInstance()-\u0026gt;start(bubble); QThreadPool::globalInstance()-\u0026gt;start(quick); for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;randList-\u0026gt;addItem(QString::number(list.at(i))); } }); connect(bubble, \u0026amp;BubbleSort::finish, this, [=](QVector\u0026lt;int\u0026gt; list) { for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;bubbleList-\u0026gt;addItem(QString::number(list.at(i))); } }); connect(quick, \u0026amp;QuickSort::finish, this, [=](QVector\u0026lt;int\u0026gt; list) { for(int i = 0; i \u0026lt; list.size(); i++) { ui-\u0026gt;quickList-\u0026gt;addItem(QString::number(list.at(i))); } }); } MainWindow::~MainWindow() { delete ui; } mythread.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #ifndef MYTHREAD_H #define MYTHREAD_H #include \u0026lt;QVector\u0026gt; #include \u0026lt;QObject\u0026gt; #include \u0026lt;QRunnable\u0026gt; #pragma execution_character_set(\u0026#34;utf-8\u0026#34;) class Generate : public QObject, public QRunnable { Q_OBJECT public: explicit Generate(QObject *parent = nullptr); void recvNum(int num); void run(); signals: void sendArray(QVector\u0026lt;int\u0026gt; list); private: int m_num; }; class BubbleSort : public QObject, public QRunnable { Q_OBJECT public: explicit BubbleSort(QObject *parent = nullptr); void recvArray(QVector\u0026lt;int\u0026gt; list); void run(); signals: void finish(QVector\u0026lt;int\u0026gt; num); private: QVector\u0026lt;int\u0026gt; m_list; }; class QuickSort : public QObject, public QRunnable { Q_OBJECT public: explicit QuickSort(QObject *parent = nullptr); void recvArray(QVector\u0026lt;int\u0026gt; list); void run(); private: void quickSort(QVector\u0026lt;int\u0026gt; \u0026amp;list, int l, int r); signals: void finish(QVector\u0026lt;int\u0026gt; num); private: QVector\u0026lt;int\u0026gt; m_list; }; #endif // MYTHREAD_H mythread.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #include \u0026#34;mythread.h\u0026#34; #include \u0026lt;QRandomGenerator\u0026gt; #include \u0026lt;QElapsedTimer\u0026gt; #include \u0026lt;QDebug\u0026gt; #include \u0026lt;QThread\u0026gt; Generate::Generate(QObject *parent) : QObject(parent), QRunnable() { setAutoDelete(true); } void Generate::recvNum(int num) { m_num = num; } void Generate::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;生成随机数的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QVector\u0026lt;int\u0026gt; list; QElapsedTimer time; time.start(); for(int i = 0; i \u0026lt; m_num; i++) { list.push_back(qrand() % 100000); } int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;生成\u0026#34; \u0026lt;\u0026lt; m_num \u0026lt;\u0026lt; \u0026#34;个随机数总共用时:\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit sendArray(list); } BubbleSort::BubbleSort(QObject *parent) : QObject(parent), QRunnable() { setAutoDelete(true); } void BubbleSort::recvArray(QVector\u0026lt;int\u0026gt; list) { m_list = list; } void BubbleSort::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;冒泡排序的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QElapsedTimer time; time.start(); int temp = 0; for(int i=0; i\u0026lt;m_list.size(); ++i) { for(int j=0; j\u0026lt;m_list.size()-i-1; ++j) { if(m_list[j] \u0026gt; m_list[j+1]) { temp = m_list[j]; m_list[j] = m_list[j+1]; m_list[j+1] = temp; } } } int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;冒泡排序用时\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit finish(m_list); } QuickSort::QuickSort(QObject *parent) : QObject(parent), QRunnable() { setAutoDelete(true); } void QuickSort::recvArray(QVector\u0026lt;int\u0026gt; list) { m_list = list; } void QuickSort::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;快速排序的线程的线程地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); QElapsedTimer time; time.start(); quickSort(m_list, 0, m_list.size()-1); int mlisec = time.elapsed(); qDebug() \u0026lt;\u0026lt; \u0026#34;快速排序用时\u0026#34; \u0026lt;\u0026lt; mlisec \u0026lt;\u0026lt; \u0026#34;毫秒\u0026#34;; emit finish(m_list); } void QuickSort::quickSort(QVector\u0026lt;int\u0026gt; \u0026amp;s, int l, int r) { if(l \u0026lt; r) { int i = l, j = r; /* 拿出第一个元素，保存到x中，第一个位置成为一个坑 */ int x = s[l]; while(i \u0026lt; j) { /* 从右向左找小于x的数 */ while(i \u0026lt; j \u0026amp;\u0026amp; s[j] \u0026gt;= x) { /* 左移，直到遇到小于等于x的数 */ j--; } if(i \u0026lt; j) { /* 将右侧找到的小于x的元素放入左侧坑中，右侧出现一个坑 */ /* 左侧元素索引右移 */ s[i++] = s[j]; } /* 从左向右找大于等于x的数 */ while(i \u0026lt; j \u0026amp;\u0026amp; s[i] \u0026lt; x) { /* 左移，直到遇到大于x的数 */ i++; } if(i \u0026lt; j) { /* 将左侧找到的元素放入右侧坑中，左侧出现一个坑 */ /* 右侧元素索引向前移动 */ s[j--] = s[i]; } } /* 此时 i=j,将保存在x中的数值填入坑中 */ s[i] = x; quickSort(s, l, i-1);\t/* 递归调用 */ quickSort(s, i+1, r); } } ","date":"2024-03-26T00:24:22+08:00","permalink":"https://ynhugo.github.io/p/qt%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Qt中多线程的使用"},{"content":" 安装SSHFS 在Ubuntu / Debian上安装 SSHFS是基于Linux的软件，需要安装在本地计算机上。在基于Ubuntu和Debian的系统上，它可以通过apt-get安装。\n1 sudo apt-get install sshfs 在Mac OSX上安装 您可以在Mac OSX上安装SSHFS。您需要从这里下载FUSE和SSHFS\n在Windows上安装 要在Windows中安装SSHFS，您需要从google代码存储库中获取最新的win-sshfs软件包。可以在下面找到下载链接。下载软件包后，双击以启动安装程序。系统可能会提示您下载其他文件，如果是这样，安装程序将下载.NETFramework 4.0并安装。\n下载地址：https://github.com/feo-cz/win-sshfs/releases\nLinux 挂载远程文件系统 以下说明适用于Ubuntu/Debian和OSX。有关Windows系统的说明，请参阅本教程的结尾。\n首先，我们需要创建一个本地目录来安装服务器的文件系统。\n1 sudo mkdir /mnt/droplet \u0026lt;--replace \u0026#34;droplet\u0026#34; whatever you prefer 现在我们可以使用sshfs命令在本地挂载文件系统。如果您的VPS是使用密码登录创建的，则以下命令将执行此操作。在此步骤中，系统将要求您提供虚拟服务器的root密码。\n1 sudo sshfs -o allow_other,defer_permissions root@xxx.xxx.xxx.xxx:/ /mnt/droplet 如果您的服务器配置为通过ssh密钥授权进行登录，则需要告诉sshfs命令使用您的公钥。系统会要求您输入在使用ssh-keygen创建密钥期间使用的密码。\n1 sudo sshfs -o allow_other,defer_permissions,IdentityFile=~/.ssh/id_rsa root@xxx.xxx.xxx.xxx:/ /mnt/droplet 现在，您可以使用服务器上的文件，就好像它是连接到本地计算机的物理设备一样。例如，如果移动到本地计算机上的/mnt /droplet目录，在本地创建文件，该文件将同步显示在虚拟服务器上。同样，您可以将文件复制到/mnt/droplet文件夹中，它们将在后台上传到您的服务器。\n请务必注意，此过程仅为您的服务器提供临时挂载点。如果虚拟服务器或本地计算机已关闭或重新启动，则需要使用相同的过程再次挂载它。\n卸载远程文件系统 当您不再需要安装点时，您只需使用该命令卸载它即可\n1 sudo umount /mnt/droplet 永久挂载远程文件系统 SSHFS还允许为远程文件系统设置永久挂载点。这将设置一个挂载点，就算你重新启动本地计算机和服务器它也持续存在。为了设置永久挂载点，我们需要编辑本地计算机上/etc/fstab文件，以便在每次启动系统时自动挂载文件系统。\n首先，我们需要用文本编辑器编辑/etc/fstab文件。\n1 sudo nano /etc/fstab 添加以下条目\n1 sshfs#root@xxx.xxx.xxx.xxx:/ /mnt/droplet 保存对/etc/fstab文件的更改并在重新启动。\n应该注意的是，在本地永久安装VPS文件系统存在潜在的安全风险。如果您的本地计算机受到攻击，它可能会直接感染到您的服务器。因此，建议不要在生产服务器上设置永久挂载。\n参考链接 通过SSHFS远程挂载文件夹，方便远程coding！原创\nwindows 方式一：winfsp + sshfs-win （推荐） 下载 直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。\nsshfs-win：https://github.com/billziss-gh/sshfs-win/releases winfsp：https://github.com/billziss-gh/winfsp/releases SSHFS-Win Manager：https://github.com/evsar3/sshfs-win-manager/releases (GUI，可选)\n快速使用 可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。\n方式A：使用GUI（推荐） 新建连接 安装好上述3个软件后，打开 GUI 界面添加连接，点击 Add Connection：\n依次填写每一项内容：\nNAME：给远程服务器取个名字 Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：SSH密钥管理及免密码登陆]） Remote：远程目录配置，挂载后将成为本地对应盘符的根目录 Local：本地盘符设置（注意不要与现有盘符冲突）\n点击 Save 保存。\n挂载远程目录 在主界面中点击连接按钮，即可将远程目录挂在到本地\n此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面连接按钮左边的打开文件夹按钮即可进入目录。\n长期使用建议在主界面的设置中打开开机自启\n方式B：手动挂载 挂载路径\nSSH 使用默认端口（22） 此时，对应的 ssh 登陆命令为 ssh username@remote_ip，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：\n1 2 3 4 5 6 7 # 根目录 \\\\sshfs.r\\username@remote_ip\\ # home 目录 \\\\sshfs\\username@remote_ip\\ # 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\ 例如：\\\\sshfs.r\\xieqk@10.168.9.87\\，注意路径里面的分隔符为 windows 使用的反斜杠 \\。 SSH 使用其它端口（外网端口转发连接内网服务器） 此时，ssh 登陆命令为 ssh -p port username@remote_ip，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 remote_ip 后加上 !port 即可：\n1 2 3 4 5 6 7 # 根目录 \\\\sshfs.r\\username@remote_ip!port\\ # home 目录 \\\\sshfs\\username@remote_ip!port\\ # 或者：\\\\sshfs.r\\username@remote_ip!port\\home\\username\\ 例如：\\\\sshfs.r\\xieqk@168.10.9.87!34567\\。 登陆挂载远程目录 将上述 sshfs 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（注意：弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 sshfs 路径之中，所以此处只需正常输入远程用户对应的密码即可。）\n对于常用的远程目录，建议通过 映射网络驱动器 长期挂载于本地。\n在 映射网络驱动器 中，可自行分配驱动器盘号，然后在 文件夹 处输入上述 sshfs 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。\n之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：\n详细参数（可跳过，需要时再查看） sshfs-win 具体语法形式如下，其中 [] 中的内容为选填项，若为默认值可不填：\n1 2 3 \\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH] \\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH] \\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH] REMUSER: 即 remote user，指 SSH 登陆远程主机时的用户名。\nHOST：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址\nPORT：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).\nPATH：进入的远程服务器路径，可按照如下设置:\n前缀 sshfs 对应为 HOST:~REMUSER/PATH，即远程服务器上相对于该用户 home 目录的相对路径：/home/remote_user/PATH。 前缀 sshfs.r 对应为 HOST:/PATH 即远程服务器上相对于根(root)目录的路径：/PATH。 前缀 sshfs.k 与第一项相同，对应为 HOST:~REMUSER/PATH，但它使用 Windows 本地当前用户位于 %USERPROFILE%/.ssh/id_rsa 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠SSH 密钥管理及免密码登陆），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可） LOCUSER windows本地用户名，可不填。\n方式二：win-sshfs + Dokan（旧，不推荐） 下载 win-sshfs 依赖 Dokan，所以先安装 Dokan 再正常安装 win-sshfs 即可：\nDokan：https://github.com/dokan-dev/dokany/releases win-sshfs：https://github.com/dokan-dev/dokany/releases\n使用 打开win-sshfs，点击Add，在界面输入要链接的服务器的地址、端口号和用户名密码等信息，并设置好要挂载的目录，点击save，在确保可以通过ssh链接的情况下，点击mount，就可以将该目录挂载到本地了，如下图所示：\n查看我的电脑，发现在 设备和驱动器 中多了一个存储设备（与方式一显示在网络位置中不同）\n参考链接 Windows 下使用 SSHFS 通过 SSH 协议挂载远程服务器目录\nWindows 下使用 SSHFS 通过 SSH 协议挂载远程服务器目录\n","date":"2024-03-26T00:24:22+08:00","permalink":"https://ynhugo.github.io/p/sshfs%E6%95%99%E7%A8%8B/","title":"sshfs教程"},{"content":" obs-studio_输出 obs-studio_视频 ","date":"2024-03-26T00:24:20+08:00","permalink":"https://ynhugo.github.io/p/obs-studio-config/","title":"OBS Studio Config"},{"content":" Qt Linux 播放视频教程 只需要两个模块、三个头文件、几行代码即可实现，不过在实现之前，还需要先在终端中安装一些文件才能实现播放视频，具体操作步骤如下\n配置系统环境 以下文件缺一不可\n1 2 3 4 5 6 # 安装 OpenGL 库 sudo apt-get install libgl1-mesa-dev -y # 安装开源媒体播放器 sudo apt-get install mplayer -y # 安装 GStreamer 插件，用于解码某些格式的音视频文件 sudo apt-get install -y gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav Qt中需要做的工作 用Qt创建一个 Mainwindow 或者 widget 工程，我创建的是 Mainwindow\nQt的.pro文件默认添加的只有两个模块如下\n1 QT += core gui 要想实现播放视频，还需要再添加两个媒体相关的模块\n1 multimedia multimediawidgets 添加后如下\n1 QT += core gui multimedia multimediawidgets 剩下的工作就完全可以在 mainwindow.cpp （如果是创建 Widget 工程，对应的文件是 widget.cpp） 中完成了\n在写代码之前，还需要在 mainwindow.cpp 添加三个头文件\n1 2 3 #include \u0026lt;QUrl\u0026gt; #include \u0026lt;QMediaPlayer\u0026gt; #include \u0026lt;QVideoWidget\u0026gt; 然后就可以添加代码，需要添加代码如下\n1 2 3 4 5 6 7 QMediaPlayer* player = new QMediaPlayer; QVideoWidget* videoWidget = new QVideoWidget; player-\u0026gt;setVideoOutput(videoWidget); player-\u0026gt;setMedia(QUrl::fromLocalFile(\u0026#34;/mnt/hgfs/share/source/Qt_Linux_Video_Player_Test/Qt_Linux_Video_Player_Test/videoList/test.mp4\u0026#34;)); videoWidget-\u0026gt;show(); player-\u0026gt;play(); this-\u0026gt;setCentralWidget(videoWidget); 实验工程 点击下载\n参考链接：https://blog.csdn.net/zhang669154/article/details/78781011 ","date":"2024-03-26T00:24:20+08:00","permalink":"https://ynhugo.github.io/p/qt-linux-%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/","title":"Qt Linux 播放视频教程"},{"content":" 参考链接 [已更新: 安装原生版微信] 超详细教程 - Ubuntu等Linux分支利用Docker安装并使用微信详细教程\n使用 Docker 运行微信 PC 客户端\nUbuntu等Linux分支利用Docker安装并使用微信详细教程 引言 通过Docker安装微信相比于wine和deepwine都稳定的多，毕竟整个环境是被测试过重新封装好的，所以这种又稳定又不占用太多内存的方式在我使用一段时间之后还是基本满意的。\n但是毕竟是第三方做的，肯定没有深度(deepin)或者windows那种官方维护的体验好，不过只要能解决基本通信使用的需求就谢天谢地了。\n安装Docker（已经有docker的直接跳过这部分，去看第二步） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #先来更新一下包管理库 sudo apt update #添加一下docker的包仓库的依赖文件 sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common #添加仓库钥匙 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - #把在线仓库连接加到你的更新源里 sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; #默认安装最新版docker sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io -y 检查一下docker状态：\n1 sudo systemctl status docker 输出大概会显示Active(running)这类的信息，其实还挺吃内存的：\n1 2 3 4 5 6 7 8 9 Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) TriggeredBy: ● docker.socket Docs: https://docs.docker.com Main PID: 1461 (dockerd) Tasks: 32 Memory: 1.0G CGroup: /system.slice/docker.service └─1461 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 下载并安装Docker微信 DoChat(盒装微信)是一个 Linux 下的 Docker 化的微信 PC Windows 客户端，项目地址：https://github.com/huan/docker-wechat，当然既然是容器化的，理论上运行多个客户端也是可行的。\n建议使用 Linux Ubuntu 发行版（DoChat 是使用 Ubuntu Desktop 19.10开发的）运行，当然也需要安装 Docker（运行sudo apt update \u0026amp;\u0026amp; apt install docker.io 以为 Ubuntu 用户安装 Docker）。\n要安装也很简单，通过运行以下单行命令，即可在 Linux 桌面上启动WeChat PC：\n1 curl -sL https://raw.githubusercontent.com/huan/docker-wechat/master/dochat.sh | bash 只需将上述单行命令复制/粘贴到你的终端，然后按 Enter，微信 PC 版本应该会很快出现在你的 XWindows 桌面中了。\n另外要注意上面的 dochat.sh 启动脚本不能用 uid 0（root用户）运行，用 uid 0 运行它将导致一个死循环，很难从终端上杀死。如果你的用户无权运行 docker，请将该用户添加到 docker group 中\n1 sudo usermod -aG docker $USER 可能需要重启才能进行更改。\n\u0026#34;另外需要注意有用户说使用该项目后，他的微信帐号会被封禁，虽然最终说明是看错了微信号，但是使用该项目是否会有封号风险需要自行评估，相关 issue 地址：https://github.com/huan/docker-wechat/issues/55\u0026#34;\n如果你想自己定制一些行为，比如在桌面上打开多个微信 PC 客户端；那么，你可以自行修改 dochat.sh 脚本，比如下面的 docker 命令可以将数据持久化到宿主机上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sudo docker run \\ --name DoChat \\ --rm \\ -i \\ \\ -v \u0026#34;$HOME/DoChat/WeChat Files/\u0026#34;:\u0026#39;/home/$USER/WeChat Files/\u0026#39; \\ -v \u0026#34;$HOME/DoChat/Applcation Data\u0026#34;:\u0026#39;/home/$USER/.wine/drive_c/users/user/Application Data/\u0026#39; \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ \\ -e DISPLAY \\ \\ -e XMODIFIERS=@im=fcitx \\ -e GTK_IM_MODULE=fcitx \\ -e QT_IM_MODULE=fcitx \\ -e GID=\u0026#34;$(id -g)\u0026#34; \\ -e UID=\u0026#34;$(id -u)\u0026#34; \\ \\ --ipc=host \\ --privileged \\ \\ zixia/wechat 直接通过脚本完成安装docker与运行微信 脚本被压缩成zip压缩包，如果是在linux中要解压zip压缩包需要安装\u0026#34;unzip\u0026#34;\n1 2 unzip docker_install.zip unzip docker_wechat.zip 如果在安装过程中失败了，可以再次尝试，甚至多次尝试，直到安装成功，因为docker的服务器是国外的，所以偶尔会安装失败\n脚本在执行前要先赋予脚本执行权限\n1 2 sudo chmod +x docker_install.sh sudo chmod +x docker_wechat.sh 安装docker与微信的脚本 点击下载脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #先来更新一下包管理库 sudo apt update #添加一下docker的包仓库的依赖文件 sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common #添加仓库钥匙 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - #把在线仓库连接加到你的更新源里 sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; #默认安装最新版docker sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io -y sudo systemctl status docker curl -sL https://raw.githubusercontent.com/huan/docker-wechat/master/dochat.sh | bash sudo usermod -aG docker $USER 运行微信的脚本 点击下载脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sudo docker run \\ --name DoChat \\ --rm \\ -i \\ \\ -v \u0026#34;$HOME/DoChat/WeChat Files/\u0026#34;:\u0026#39;/home/$USER/WeChat Files/\u0026#39; \\ -v \u0026#34;$HOME/DoChat/Applcation Data\u0026#34;:\u0026#39;/home/$USER/.wine/drive_c/users/user/Application Data/\u0026#39; \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ \\ -e DISPLAY \\ \\ -e XMODIFIERS=@im=fcitx \\ -e GTK_IM_MODULE=fcitx \\ -e QT_IM_MODULE=fcitx \\ -e GID=\u0026#34;$(id -g)\u0026#34; \\ -e UID=\u0026#34;$(id -u)\u0026#34; \\ \\ --ipc=host \\ --privileged \\ \\ zixia/wechat windows环境写的脚本不能在Linux环境运行的原因与解决方法 windows环境的换行符与lunix环境的换行符不一样，因此在windows环境导出的脚本的脚本直接拷贝到Linux环境的话是运行不了的，可以通过安装\u0026#34;dos2unix\u0026#34;工具解决\n安装\u0026#34;dos2unix\u0026#34; dos2unix可以将文件中的换行符转换成linux环境中的换行符\n1 sudo apt-get install dos2unix -y 使用方法 假设test.sh是windows环境写好的脚本，然后拷贝到了linux环境中，脚本不能运行，可能通过如下方法解决\n1 dos2unix test.sh ","date":"2024-03-26T00:24:20+08:00","permalink":"https://ynhugo.github.io/p/ubuntu16.04%E4%BD%BF%E7%94%A8docker%E8%BF%90%E8%A1%8C%E5%BE%AE%E4%BF%A1.org/","title":"ubuntu16.04使用docker运行微信.org"},{"content":" 搭建环境 本人工作的计算机电脑系统： Ubuntu18.04.3\n下载Wine环境包 Wine环境包下载地址： http://archive.ubuntukylin.com/software/pool/partner/ukylin-wine_70.6.3.25_amd64.deb\n什么是wine？ 总结：Wine 是一款在 Linux 和 macOS 上能够运行 Windows 应用程序的兼容层软件，它可以使得用户能够在非 Windows 系统中运行 Windows 程序，从而方便用户的跨平台操作。\n下载企业微信（wine）包 企业微信（wine）包下载地址： http://archive.ubuntukylin.com/software/pool/partner/ukylin-wxwork_1.0_amd64.deb\n下载微信（wine）包 微信（wine）包下载地址： https://archive.ubuntukylin.com/software/pool/partner/ukylin-wechat_3.0.0_amd64.deb\n安装 打开终端，进入下载文件所在目录，输入命令。\n1 2 3 4 5 sudo apt-get install -f -y ./ukylin-wine_70.6.3.25_amd64.deb sudo apt-get install -f -y ./ukylin-wxwork_1.0_amd64.deb sudo apt-get install -f -y ./ukylin-wechat_3.0.0_amd64.deb wine包下载地址 这个地址下面还有很多其他软件，需要的可以自行下载安装\nhttps://archive.ubuntukylin.com/software/pool/partner/\n参考链接 Ubuntu20.04安装微信，QQ，企业微信：https://www.cnblogs.com/pipci/p/16119792.html\nUbuntu22.04篇—安装微信，QQ，企业微信：https://blog.csdn.net/m0_46825740/article/details/128561661\n解决Ubuntu22.04.1上安装企业微信的问题：https://blog.csdn.net/qq_28680277/article/details/129293475\n","date":"2024-03-26T00:24:20+08:00","permalink":"https://ynhugo.github.io/p/ubuntu%E5%AE%89%E8%A3%85%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%92%8C%E5%BE%AE%E4%BF%A1/","title":"ubuntu安装企业微信和微信"},{"content":" yenao_xilinx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 在这里指定要下载的 xilinx 官方的 u-boot 和 linux-xlnx 版本，只需要修改这一处即可 xilinx_version=2018.3 u_boot=\u0026#34;u-boot-xlnx-xilinx-v${xilinx_version}\u0026#34; linux_xlnx=\u0026#34;linux-xlnx-xilinx-v${xilinx_version}\u0026#34; work_dir=\u0026#34;${HOME}/yenao_xilinx\u0026#34; mkdir -p $work_dir cd $work_dir result=$(curl ipinfo.io | grep \u0026#34;country\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) # 下载 u-boot if [ ! -f \u0026#34;${u_boot}.tar.gz\u0026#34; ]; then # 判断文件是否不存在，如果满足文件不存在的条件，则执行花括号中的语句 if [ ${result} != \u0026#34;CN\u0026#34; ]; then # wget https://codeload.github.com/Xilinx/u-boot-xlnx/tar.gz/refs/tags/xilinx-v2022.2 wget https://codeload.github.com/Xilinx/u-boot-xlnx/tar.gz/refs/tags/xilinx-v${xilinx_version} mv xilinx-v${xilinx_version}.tar.gz ${u_boot}.tar.gz else # wget https://archive.nuaa.cf/Xilinx/u-boot-xlnx/archive/refs/tags/xilinx-v2022.2.tar.gz wget https://archive.nuaa.cf/Xilinx/u-boot-xlnx/archive/refs/tags/xilinx-v${xilinx_version}.tar.gz mv xilinx-v${xilinx_version}.tar.gz ${u_boot}.tar.gz fi fi # 下载 linux-xlnx if [ ! -f \u0026#34;${linux_xlnx}.tar.gz\u0026#34; ]; then if [ ${result} != \u0026#34;CN\u0026#34; ]; then # wget https://codeload.github.com/Xilinx/linux-xlnx/tar.gz/refs/tags/xilinx-v2022.2 wget https://codeload.github.com/Xilinx/linux-xlnx/tar.gz/refs/tags/xilinx-v${xilinx_version} mv xilinx-v${xilinx_version}.tar.gz ${linux_xlnx}.tar.gz else # wget https://archive.nuaa.cf/Xilinx/linux-xlnx/archive/refs/tags/xilinx-v2022.2.tar.gz wget https://archive.nuaa.cf/Xilinx/linux-xlnx/archive/refs/tags/xilinx-v${xilinx_version}.tar.gz mv xilinx-v${xilinx_version}.tar.gz ${linux_xlnx}.tar.gz fi fi # 解压 u-boot if [ ! -d \u0026#34;${u_boot}\u0026#34; ]; then tar zxvf ${u_boot}.tar.gz fi # 解压 linux-xlnx if [ ! -d \u0026#34;${linux_xlnx}\u0026#34; ]; then tar zxvf ${linux_xlnx}.tar.gz fi ","date":"2024-03-26T00:24:20+08:00","permalink":"https://ynhugo.github.io/p/yenao_xilinx/","title":"yenao_xilinx"},{"content":" 假设已安装docker\n还需要安装fcitx，如果安装ibus的话需要将脚本中的输入法替换一下\nwechat微信 1 2 3 4 5 6 7 8 9 10 11 sudo docker run -d --name wechat --rm --device /dev/snd --ipc=\u0026#34;host\u0026#34; \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ -v /D/CACHE/docker/WeChatFiles:/WeChatFiles \\ -e DISPLAY=unix$DISPLAY \\ -e XMODIFIERS=@im=fcitx \\ -e QT_IM_MODULE=fcitx \\ -e GTK_IM_MODULE=fcitx \\ -e AUDIO_GID=`getent group audio | cut -d: -f3` \\ -e GID=`id -g` \\ -e UID=`id -u` \\ bestwu/wechat wxwork企业微信 linux环境登录的时候提示版本太低，因此登录不上去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sudo docker run -d --name wxwork --rm --device /dev/snd --ipc=\u0026#34;host\u0026#34; \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ -v $HOME/WXWork:/WXWork \\ -v $HOME:/HostHome \\ -v $HOME/wine-WXWork:/home/wechat/.deepinwine/Deepin-WXWork \\ -e DISPLAY=unix$DISPLAY \\ -e XMODIFIERS=@im=fcitx \\ -e QT_IM_MODULE=fcitx \\ -e GTK_IM_MODULE=fcitx \\ -e AUDIO_GID=`getent group audio | cut -d: -f3` \\ -e GID=`id -g` \\ -e UID=`id -u` \\ -e DPI=96 \\ -e WAIT_FOR_SLEEP=1 \\ boringcat/wechat:work 参考链接 docker安装wechat微信、wxwork企业微信脚本整理 原创\n","date":"2024-03-26T00:24:18+08:00","permalink":"https://ynhugo.github.io/p/docker%E5%AE%89%E8%A3%85wechat%E5%BE%AE%E4%BF%A1wxwork%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E8%84%9A%E6%9C%AC%E6%95%B4%E7%90%86%E8%BD%AC%E8%BD%BD/","title":"docker安装wechat微信、wxwork企业微信脚本整理(转载)"},{"content":" ubuntu18.04配置~/.bashrc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/bin/bash cat \u0026gt;\u0026gt; ~/.bashrc \u0026lt;\u0026lt;EOF find ./ -name \u0026#34;*~\u0026#34; | xargs rm ps -ef | grep \u0026#34;emacs --daemon\u0026#34; | grep -v \u0026#34;grep\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 if [ $? -ne 0 ] then nohup emacs --daemon \u0026amp; fi alias \u0026#39;emacs\u0026#39;=\u0026#39;emacsclient\u0026#39; if [ -e \u0026#34;/data/data/com.termux/files/home/null\u0026#34; ] then rm /data/data/com.termux/files/home/null fi if [ -e \u0026#34;/data/data/com.termux/files/home/nohup.out\u0026#34; ] then rm /data/data/com.termux/files/home/nohup.out fi EOF * ubuntu换源脚本 #!/bin/bash cp /etc/apt/sources.list /etc/apt/sources.list.bak cat /etc/apt/sources.list \u0026gt; /etc/apt/sources.list cat \u0026gt; /etc/apt/sources.list \u0026lt;\u0026lt;EOF ## 18.04LTS # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse EOF sudo apt update -y \u0026amp;\u0026amp; sudo apt upgrade -y * 卸载wsl-ubuntu18.04.6参考链接： [[https://blog.csdn.net/qq_39645262/article/details/125644647][Windows子系统(WSL2)中自定义安装Ubuntu并换源] [[https://blog.csdn.net/qq_38162575/article/details/116202725][Windows 10(WSL) 安装Linux发行版Ubuntu18.04] ","date":"2024-03-26T00:24:18+08:00","permalink":"https://ynhugo.github.io/p/linux_config/","title":"Linux_config"},{"content":" 记录ubuntu通过ssh密钥链接github仓库的遇到的问题\n原本是正常的生成密钥，然后将密钥的公钥添加到github仓库中的\n正常到这里就可以了，接下来只需要正常操作仓库就可以了，但是仓库拉取不下来分支\n但是遇到了问题，遇到了终端打印\u0026#34;sign_and_send_pubkey: signing failed: agent refused operation\u0026#34;的问题\nUbuntu下解决sign_and_send_pubkey: signing failed: agent refused operation问题\n解决方法，只需要如下操作即可\n1 2 3 eval \u0026#34;$(ssh-agent -s)\u0026#34; ssh-add ~/.ssh/github_id_rsa ssh -T git@github.com 然后重新去pull仓库就可以成功了\n","date":"2024-03-26T00:24:18+08:00","permalink":"https://ynhugo.github.io/p/%E8%AE%B0%E5%BD%95ubuntu%E9%80%9A%E8%BF%87ssh%E5%AF%86%E9%92%A5%E9%93%BE%E6%8E%A5github%E4%BB%93%E5%BA%93%E7%9A%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"记录ubuntu通过ssh密钥链接github仓库的遇到的问题"},{"content":" 节点转换 1 for i in $(cat nodes.txt | base64 -d); do echo $i | awk -F \u0026#34;//\u0026#34; \u0026#39;{print $2}\u0026#39; | base64 -d | jq; sleep 1; done ","date":"2024-03-14T23:04:02+08:00","permalink":"https://ynhugo.github.io/p/%E8%8A%82%E7%82%B9%E8%BD%AC%E6%8D%A2/","title":"节点转换"},{"content":" 开篇赘述 ARM 架构主要有两种不同的位数变体：ARM32 和 ARM64。\nARM32：也称为 ARMv7 架构，通常用于较旧的嵌入式系统和移动设备。ARM32 架构有 32 位寻址空间和指令集，适用于需要较低功耗和资源占用的场景。 ARM64：也称为 ARMv8 架构，是较新的 ARM 架构版本，提供了更高性能、更大内存寻址范围和更多的寄存器。ARM64 架构支持 64 位寻址空间和指令集，适用于需要更高性能和更大内存支持的系统，比如现代的智能手机、平板电脑和服务器等设备。 因此，当选择交叉编译工具链时，需要确保选用的工具链与目标设备的架构兼容，以确保生成的可执行文件能够在目标设备上正确运行。对于 ARM32 和 ARM64 架构，你会发现相应的工具链，比如 `gcc-arm-linux-gnueabi` 用于 ARM32 架构，而 `gcc-aarch64-linux-gnu` 则用于 ARM64 架构。\n方法一 官网页面：https://www.linaro.org/downloads/\n以下访问官网子页面\nARM-Linux交叉编译工具链下载 下载页面：https://snapshots.linaro.org/gnu-toolchain/14.0-2023.06-1/arm-linux-gnueabihf/\n下载链接：https://snapshots.linaro.org/gnu-toolchain/14.0-2023.06-1/arm-linux-gnueabihf/gcc-linaro-14.0.0-2023.06-x86_64_arm-linux-gnueabihf.tar.xz\naarch64-Linux交叉编译工具链下载 下载页面：https://snapshots.linaro.org/gnu-toolchain/14.0-2023.06-1/aarch64-linux-gnu/\n下载链接：https://snapshots.linaro.org/gnu-toolchain/14.0-2023.06-1/aarch64-linux-gnu/gcc-linaro-14.0.0-2023.06-x86_64_aarch64-linux-gnu.tar.xz\n方法二 如果要使用aarch64-linux-gnu-gcc 交叉编译器编译程序，且没有ARM 交叉编译环境，则使用如下命令安装：\n1 2 sudo apt-get install gcc-9-aarch64-linux-gnu sudo apt-get install gcc-aarch64-linux-gnu 查看aarch64-linux-gnu-gcc版本号\n1 aarch64-linux-gnu-gcc -v 不同的系统架构对应不同版本的gcc for arm编译工具 multiarch name syscall ABI instruction set endian­ness word size description spec documents aarch64-linux-gnu linux ARMv8 little 64 aarch64 Linux Platform AAPCS64 (ARM IHI 005A)1\\\\ ELF for the ARM 64-bit Architecture2 aarch64_be-linux-gnu linux ARMv8 big 64 aarch64 Linux Platform AAPCS64 (ARM IHI 005A)1\\\\ ELF for the ARM 64-bit Architecture2 aarch64-linux-gnu_ilp32 linux ARMv8 little 32 aarch64 Linux Platform aarch64_be-linux-gnu_ilp32 linux ARMv8 big 32 aarch64 Linux Platform arm-linux-gnu linux ARMv7 little 32 Old ARM ABI APCS (ARM DUI 0041 chapter 9)4 arm-linux-gnueabi linux ARMv7 little 32 ARM EABI, soft-float AAPCS (ARM IHI 0042D)5\\\\ ARM GNU/Linux ABI Supplement6 arm-linux-gnueabihf linux ARMv7 little 32 ARM EABI, hard-float AAPCS (ARM IHI 0042D)5 and\\\\ XXXXX (TBD) armeb-linux-gnueabi linux ARMv7 big 32 ARM EABI, soft-float AAPCS (ARM IHI 0042D)5\\\\ ARM GNU/Linux ABI Supplement6 armeb-linux-gnueabihf linux ARMv7 big 32 ARM EABI, hard-float AAPCS (ARM IHI 0042D)5 and\\\\ XXXXX (TBD) armv8l-linux-gnueabihf linux ARMv8 little 32 ARMv8 EABI, hard-float arm-eabi Bare-Metal ARMv7 little 32 ARM EABI, soft-float armeb-eabi Bare-Metal ARMv7 big 32 ARM EABI, soft-float aarch64-elf Bare-Metal ARMv8 little 64 ARMv8 EABI, hard-float aarch64_be-elf Bare-Metal ARMv8 big 64 ARMv8 EABI, hard-float 参考链接 ARM-Linux 交叉编译工具链安装\narm-linux-gnueabihf、aarch64-linux-gnu等ARM交叉编译GCC的区别\nFPGA Zynq MPSOC ZU5EV 下CAN 应用编程\n","date":"2023-12-19T00:27:56.33+08:00","permalink":"https://ynhugo.github.io/p/linux%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E4%B8%8B%E8%BD%BD/","title":"linux交叉编译工具链下载"},{"content":" 安装教程 1 2 3 4 5 6 7 8 # CentOS yum install screen # Debian/Ubuntu apt install screen # Cygwin 运行cygwin的setup程序进行安装 screen使用教程 screen常用命令，分屏 如果一个screen实例中有多个窗口，其他窗口也有人叫做区块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # 创建名字为test的实例 screen -S test # 左右分屏（‘或’的符号） \u0026#34;ctrl+a, |\u0026#34; # 上下分屏（以及改名，切换屏幕，创建新窗口） ctrl+a, S # 滚屏 ctrl+a，[ # 切换窗口 ctrl+a, tab # 查看所有窗口 ctrl+a, \u0026#34; # 查看所有区块，会在左下角显示 ctrl+w # 通过窗口切换，每个窗口都会有编号，可以通过编号切换过去 ctrl+a，id # 关闭当前焦点所在的屏幕区块 ctrl+a, X # 关闭除当前区块之外其他的所有区块 ctrl+a, Q # 关闭的区块中的窗口并不会关闭，还可以通过窗口切换(C-a 窗口id)找到它。 ctrl a + k 真正关闭当前窗口 # 创建新终端（以及改名） ctrl+a, c # 切换终端 ctrl+a ctrl+a # 切换终端 ctrl+a p/n # 改名 ctrl+a, A # 列出所有实例 screen -ls # 在当前screen下，输入Ctrl+D，删除该screen Ctrl+D # 在当前screen下，输入先后Ctrl+A，Ctrl+D，退出该screen Ctrl+A，Ctrl+D # attach一个Detached的实例 screen -r [name/pid] # attach一个已经Attached的实例 screen -x [name/pid] # Detached当前实例 ctrl+a, d # kill当前实例 ctrl+a, k exit # 连接状态为【Attached】的screen，解释：-D -r 先踢掉前一用户，再登陆 screen -D -r your_screen_name # 判断当前是否在screen中断下，Ubuntu系统中在/etc/screenrc文件末尾追加一行即可允许设置screen标题 echo \u0026#39;caption always \u0026#34;%{.bW}%-w%{.rW}%n %t%{-}%+w %=%H %Y/%m/%d \u0026#34;\u0026#39; # 删除指定screen, your_screen_name为待删除的screen name screen -S your_screen_name -X quit C/P模式和操作 screen的另一个很强大的功能就是可以在不同窗口之间进行复制粘贴了。使用快捷键C-a 或者C-a [可以进入copy/paste模式，这个模式下可以像在vi中一样移动光标，并可以使用空格键设置标记。其实在这个模式下有很多类似vi的操作，譬如使用/进行搜索，使用y快速标记一行，使用w快速标记一个单词等。关于C/P模式下的高级操作，其文档的这一部分有比较详细的说明。\n一般情况下，可以移动光标到指定位置，按下空格设置一个开头标记，然后移动光标到结尾位置，按下空格设置第二个标记，同时会将两个标记之间的部分储存在copy/paste buffer中，并退出copy/paste模式。在正常模式下，可以使用快捷键C-a ]将储存在buffer中的内容粘贴到当前窗口。\n参考链接 Screen下如何滚动窗口\n用法详解 语法 1 screen [-AmRvx -ls -wipe][-d \u0026lt;作业名称\u0026gt;][-h \u0026lt;行数\u0026gt;][-r \u0026lt;作业名称\u0026gt;][-s ][-S \u0026lt;作业名称\u0026gt;] 选项 1 2 3 4 5 6 7 8 9 10 11 12 -A 将所有的视窗都调整为目前终端机的大小。 -d \u0026lt;作业名称\u0026gt; 将指定的screen作业离线。 -h \u0026lt;行数\u0026gt; 指定视窗的缓冲区行数。 -m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。 -r \u0026lt;作业名称\u0026gt; 恢复离线的screen作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 -s 指定建立新视窗时，所要执行的shell。 -S \u0026lt;作业名称\u0026gt; 指定screen作业的名称。 -v 显示版本信息。 -x 恢复之前离线的screen作业。 -ls或--list 显示目前所有的screen作业。 -wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 C-a ? -\u0026gt; 显示所有键绑定信息 C-a c -\u0026gt; 创建一个新的运行shell的窗口并切换到该窗口 C-a n -\u0026gt; Next，切换到下一个 window C-a p -\u0026gt; Previous，切换到前一个 window C-a 0..9 -\u0026gt; 切换到第 0..9 个 window Ctrl+a [Space] -\u0026gt; 由视窗0循序切换到视窗9 C-a C-a -\u0026gt; 在两个最近使用的 window 间切换 C-a x -\u0026gt; 锁住当前的 window，需用用户密码解锁 C-a d -\u0026gt; dettach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 C-a z -\u0026gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。 C-a w -\u0026gt; 显示所有窗口列表 C-a t -\u0026gt; time，显示当前时间，和系统的 load C-a k -\u0026gt; kill window，强行关闭当前的 window C-a [ -\u0026gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样 C-b Backward，PageUp C-f Forward，PageDown H(大写) High，将光标移至左上角 L Low，将光标移至左下角 0 移到行首 $ 行末 w forward one word，以字为单位往前移 b backward one word，以字为单位往后移 Space 第一次按为标记区起点，第二次按为终点 Esc 结束 copy mode C-a ] -\u0026gt; paste，把刚刚在 copy mode 选定的内容贴上 screen配置 这段配置是在网上copy下来的，以我的使用需求不配置也不影响什么\nconfig there are two configure file of screen on linux, /etc/screenrc ~/.screenrc here is my .screenrc 1 2 3 4 5 6 7 defencoding en_US encoding UTF-8 en_US vbell off altscreen on hardstatus alwayslastline hardstatus string \u0026#39;%{= kG}[ %{G}%H %{g}][%= %{= kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B} %d/%m %{W}%c %{g}]\u0026#39; issues \u0026#34;Must be connected to a terminal\u0026#34; 执行 screen 的时候碰到这个错， 先执行 script /dev/null 或者在screen命令后加上 -d -m 参数即可执行不会报错.\n因由：因为服务器需要定时重启一个特定服务，该服务用screen命令启动，到时间执行的时候遇到报错：Must be connected to a terminal。\n参考链接 screen的一些常用命令和快捷键\nlinux下screen的新建、删除、退出等常见指令\n远程神器 screen命令的保姆级详解教程+举例\n如何用bash脚本创建screen并向其发送命令？ 1 screen -dmS test 1 2 3 4 screen -dmS test screen -S test -X stuff \u0026#34;ls -a\\n\u0026#34; 或 screen -S test -p 0 -X stuff \u0026#34;ls -a\\n\u0026#34; 解析命令-ChatGPT 这些命令是使用 screen 进行会话管理和自动化输入的示例。我们来逐个解析：\n1. screen -dmS test 各部分解析： screen：启动 screen 会话，screen 是一个终端多路复用器，允许在一个终端窗口内运行多个虚拟终端。 -d：这个选项告诉 screen 在后台启动会话。也就是说，screen 会话启动后不会占用当前的终端窗口，而是将其放在后台运行。 -m：强制启动一个新的会话，即使没有其他正在运行的 screen 会话。 -S test：指定会话的名称为 test。-S 选项后面的 test 是会话的标识符，通过这个名字，你可以后续对该会话进行操作（例如发送命令、分离等）。 作用： 这个命令的作用是：启动一个名为 test 的 screen 会话，并将其放在后台运行。此时会话没有关联到任何窗口（终端）。它是一个“分离模式”启动的 screen 会话。\n—\n2. screen -S test -X stuff \u0026#34;ls -a\\n\u0026#34; 各部分解析： screen：再次调用 screen，用于对已存在的 screen 会话进行操作。 -S test：指定要操作的会话名称为 test。 -X：执行对 screen 会话的命令。-X 选项让我们向 screen 会话发送命令。 stuff \u0026#34;ls -a\\n\u0026#34;：stuff 命令将 ls -a（列出当前目录的所有文件，包括隐藏文件）发送到指定会话的当前窗口中，并模拟按下回车键（\\n）。这等同于在该会话的终端中执行了 ls -a 命令。 作用： 该命令将 ls -a 这个命令发送到名为 test 的 screen 会话中的当前窗口，模拟在该窗口执行 ls -a。由于是后台操作，所以并不会直接在终端显示输出，命令的结果会被发送到该 screen 会话的输出流。\n—\n3. screen -S test -p 0 -X stuff \u0026#34;ls -a\\n\u0026#34; 各部分解析： screen：同样，调用 screen 来操作会话。 -S test：指定会话名称为 test。 -p 0：指定窗口编号为 0，即第一个窗口。screen 会话可以包含多个窗口，这个命令告诉 screen 要向编号为 0 的窗口发送命令。 -X stuff \u0026#34;ls -a\\n\u0026#34;：将 ls -a 发送到指定窗口，并模拟按下回车键。 作用： 该命令将 ls -a 命令发送到名为 test 的 screen 会话中的第一个窗口（编号为 0），并模拟按下回车键。这意味着，如果会话已经包含多个窗口，这个命令只会作用于第一个窗口，而不会影响其他窗口。\n—\n总结 screen -dmS test：在后台启动一个新的 screen 会话，命名为 test。 screen -S test -X stuff \u0026#34;ls -a\\n\u0026#34;：向名为 test 的 screen 会话的当前窗口发送 ls -a 命令并执行。 screen -S test -p 0 -X stuff \u0026#34;ls -a\\n\u0026#34;：向名为 test 的 screen 会话的第一个窗口（编号为 0）发送 ls -a 命令并执行。 这些命令组合起来，可以实现对后台 screen 会话的自动化控制和命令发送，适用于需要在后台运行的程序和脚本的自动化管理。\n参考链接 用bash脚本创建screen并向其发送命令\n","date":"2023-11-22T00:00:00Z","permalink":"https://ynhugo.github.io/p/screen%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"screen使用教程"},{"content":" 参考链接 Windows远程桌面连接（有密码和无密码连接）\nwin10 无用户名密码 实现mstsc远程桌面连接\nmstsc 教程 客户端设置 开始 \u0026gt; 运行 （win+R) \u0026gt; 输入secpol.msc，打开本地安全策略 本地策略 \u0026gt; 安全选项 \u0026gt; 使用空密码的本地账户只允许进行控制台登录 \u0026gt; 禁用 在这里插入图片描述\n服务端设置 控制面板 \u0026gt; 用户账户 \u0026gt; 用户账户 \u0026gt; 管理其他账户\n选择要更改的 账户 \u0026gt; 更改密码 \u0026gt; 填写当前密码不填新密码 \u0026gt; 点击更改密码\n再次打开mstsc远程桌面连接，输入ip和用户名后（或者输入ip无需输入用户名），点击连接即可远程过去\n","date":"2023-11-22T02:03:03+08:00","permalink":"https://ynhugo.github.io/p/mstsc%E6%95%99%E7%A8%8B/","title":"mstsc教程"},{"content":" 基本用法 启动与退出 在终端键入tmux命令，启动 Tmux\nCtrl+d或者输入exit命令，退出 Tmux\n前缀键 Tmux 窗口有大量的快捷键，默认的前缀键是Ctrl+b，即先按下Ctrl+b，然后再按下其他按键\n比如，帮助命令的快捷键是Ctrl+b ?。在Tmux窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息，然后，按下 ESC 键或q键，就可以退出帮助。\ntmux滚动窗口 按Ctrl+b，再按[，就可以用鼠标滑轮滚动了，按q退出。\n参考链接 tmux滚动窗口\ntmux调整多窗格比例 按Ctrl+b，再按方向键就可以调整窗格比例了，例如调整上下两个窗格的比例，按Ctrl+b，再按上下方向键就可以了，如果是调整左右两个窗格的比例，按Ctrl+b，再按左右方向键就可以了，\n会话管理 新建会话 第一个启动的 Tmux窗口，编号是0，第二个窗口的编号是1\n除默认运行tmux是以编号进行区分，还可以创建指定名称的会话。\n1 tmux new -s \u0026lt;session-name\u0026gt; 离线创建会话 1 2 3 tmux new -d 或 tmux new -d -s \u0026lt;session-name\u0026gt; 分离会话 Tmux 窗口中，按下Ctrl+b d或者输入\u0026#34;tmux detach\u0026#34;命令，就会将当前会话与窗口分离。 tmux ls命令可以查看当前所有的 Tmux 会话。\n1 2 3 tmux ls 或者 tmux list-session 接入会话 tmux attach命令用于重新接入某个已存在即之前分离的会话。\n通过会话编号接入会话\n1 tmux attach -t 0 通过会话名称接入会话\n1 tmux attach -t \u0026lt;session-name\u0026gt; 杀死会话 通过会话编号杀死会话\n1 tmux kill-session -t 0 通过会话名称杀死会话\n1 tmux kill-session -t \u0026lt;session-name\u0026gt; 切换会话 通过会话编号切换会话\n1 tmux switch -t 0 通过会话名称切换会话\n1 tmux switch -t \u0026lt;session-name\u0026gt; 重命名会话\n1 tmux rename-session -t 0 \u0026lt;new-name\u0026gt; 上面命令将0号会话重命名。\n会话快捷键 下面是一些会话相关的快捷键。\nCtrl+b d：分离当前会话。 Ctrl+b s：列出所有会话。 Ctrl+b $：重命名当前会话。 最简操作流程 综上所述，以下是 Tmux 的最简操作流程。\n新建会话tmux new -s my_session。 在 Tmux 窗口运行所需的程序。 按下快捷键Ctrl+b d将会话分离。 下次使用时，重新连接到会话tmux attach-session -t my_session。\n窗格操作 Tmux可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。\n划分上下两个窗格\n1 tmux split-window 划分左右两个窗格\n1 tmux split-window -h 移动光标 光标切换到上方窗格\n1 tmux select-pane -U 光标切换到下方窗格\n1 tmux select-pane -D 光标切换到左边窗格\n1 tmux select-pane -L 光标切换到右边窗格\n1 tmux select-pane -R 交换窗格位置 当前窗格上移\n1 tmux swap-pane -U 当前窗格下移\n1 tmux swap-pane -D 窗格快捷键 下面是一些窗格操作的快捷键。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Ctrl+b %：划分左右两个窗格。 Ctrl+b \u0026#34;：划分上下两个窗格。 Ctrl+b \u0026lt;arrow key\u0026gt;：光标切换到其他窗格。\u0026lt;arrow key\u0026gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。 Ctrl+b ;：光标切换到上一个窗格。 Ctrl+b o：光标切换到下一个窗格。 Ctrl+b {：当前窗格与上一个窗格交换位置。 Ctrl+b }：当前窗格与下一个窗格交换位置。 Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+\u0026lt;arrow key\u0026gt;：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号。 窗口管理 除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。\n新建一个指定名称的窗口\n1 tmux new-window -n \u0026lt;window-name\u0026gt; 切换窗口 切换到指定编号的窗口\n1 tmux select-window -t \u0026lt;window-number\u0026gt; 切换到指定名称的窗口\n1 tmux select-window -t \u0026lt;window-name\u0026gt; 重命名窗口 1 tmux rename-window \u0026lt;new-name\u0026gt; 窗口快捷键 下面是一些窗口操作的快捷键。\n1 2 3 4 5 6 7 Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。 Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n：切换到下一个窗口。 Ctrl+b \u0026lt;number\u0026gt;：切换到指定编号的窗口，其中的\u0026lt;number\u0026gt;是状态栏上的窗口编号。 Ctrl+b w：从列表中选择窗口。 Ctrl+b ,：窗口重命名。 其他命令 列出所有快捷键，及其对应的 Tmux 命令\n1 tmux list-keys 列出所有 Tmux 命令及其参数\n1 tmux list-commands 列出当前所有 Tmux 会话的信息\n1 tmux info 重新加载当前的 Tmux 配置\n1 tmux source-file ~/.tmux.conf tmux发送到某个会话指定命令/按键 1 tmux send-keys [-t \u0026lt;session-name\u0026gt;] \u0026lt;key\u0026gt; 例如，向会话mc发送指令ls并按回车执行\n1 tmux send-keys -t mc ls Enter 向会话mc发送bash start.sh并按回车执行\n1 tmux send-keys -t mc bash Space start.sh Enter 参考链接 tmux发送到某个会话指定命令/按键\n安装方法 安装 Tmux 一般需要自己安装。\ngit-bash安装tmux git bash中执行以下命令，即可安装tmux。如果以下操作完tmux没法使用，注意git升级到最新版，我遇到的坑就是git2.9版本安装完tmux后打tmux命令没反应。升级完git2.26后即可。\n1 2 3 4 git clone https://github.com/xnng/bash.git cd bash cp tmux/bin/* /usr/bin cp tmux/share/* /usr/share -r 配置tmux 新建tmux配置文件\n1 vim ~/.tmux.conf 复制如下配置到刚才新建的配置文件中即可 1 2 3 4 5 setw -g mouse set-option -g history-limit 20000 set-option -g mouse on bind -n WheelUpPane select-pane -t= \\; copy-mode -e \\; send-keys -M bind -n WheelDownPane select-pane -t= \\; send-keys -M 一键安装配置脚本 为便安装与配置tmux，特地将所有需要操作的内容都写到脚本里了，到时候只要打开git-bash，然后运行该脚本就可以了\n点击下载脚本\n执行脚本\n1 source install_tmux.sh Ubuntu 或 Debian 1 sudo apt-get install tmux CentOS 或 Fedora 1 sudo yum install tmux Mac 1 brew install tmux 参考链接 git bash安装tmux实现多标签\nTmux 使用教程\n","date":"2023-11-22T01:26:22+08:00","permalink":"https://ynhugo.github.io/p/tmux%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Tmux安装配置使用教程"},{"content":" 电脑安装环境 windows系统：windows11\n下载vmware版本：Workstation 17 Pro for Windows\nvmware简介 一 VMware简介\n1、VMware是一个虚拟PC的软件。\n2、可以在现有的操作系统上虚拟出一个新的硬件环境。\n3、相当于模拟出一台新的PC。\n4、实现在一台机器上真正同时运行两个独立的操作系统。\n5、VWware是收费的。\n二 VMware主要特点\n1、不需要分区或重新开机就能在同一台PC上使用两种以上的操作系统。\n2、本机系统可以与虚拟机系统网络通信。\n3、可以设定并且随时修改虚拟操作系统的硬件环境。\n三 建议的VMware配置\nCPU：建议主频为1GHz以上\n内存：建议1GB以上\n硬盘：建议分区空闲空间8GB以上。\n下载vmware 点击下载 Workstation 17 Pro for Windows\n安装vmware ","date":"2023-11-16T07:37:02+08:00","permalink":"https://ynhugo.github.io/p/vmware%E6%95%99%E7%A8%8B/","title":"vmware教程"},{"content":" 下载工具 WinDbg: GRMSDKX_EN_DVD.iso msvc版本下调试器，cdb，这个需要到ms去下载\n1 thunder://QUFodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC9GLzEvMC9GMTAxMTNGNS1CNzUwLTQ5NjktQTI1NS0yNzQzNDFBQzZCQ0UvR1JNU0RLWF9FTl9EVkQuaXNvWlo=/ 迅雷的下载链接，直接默认安装即可，选中其中的debug tool。\nVS2015下载 VS2015 社区版下载链接\n安装步骤 vs2015安装时只选择\u0026#34;编程语言\u0026#34;下的\u0026#34;Visual C++\u0026#34;\nWinDbg安装时只选择\u0026#34;Debugging Tools for Windows\u0026#34;即可\n配置步骤 在安装完QT之后，首先打开工具-选项-kits面板，查看\u0026#34;Debuggers\u0026#34;是否为空，自动检查有感叹号就为空，调试器有感叹号就为空\n在安装完VS2015和WinDbg后，在\u0026#34;Debuggers\u0026#34;中可以看到已经检查到安装的调试器了\n然后在构建套件中的调试器中添加检测到的编译器，然后在\u0026#34;编译器\u0026#34;右边添加\u0026#34;C\u0026#34;和\u0026#34;C++\u0026#34;的平台均为\u0026#34;Microsoft Visual C++ Compiler 14.0 (amd64)\u0026#34;\n参考链接 Qt5.7 + VS2015 环境搭建\nQt 5.7设置调试器\nVS2015社区版、企业版、专业版下载官网地址\n","date":"2023-11-15T23:07:34+08:00","permalink":"https://ynhugo.github.io/p/qt%E9%85%8D%E7%BD%AEmsvc2015-64bit%E7%BC%96%E8%AF%91%E5%99%A8/","title":"Qt配置msvc2015 64bit编译器"},{"content":" 二十四节气歌 春雨惊春清谷天，夏满芒夏暑相连。 秋处露秋寒霜降，冬雪雪冬小大寒。 每月两节不变更，最多相差一两天。 上半年来六廿一，下半年是八廿三。\n","date":"2023-11-13T19:52:31+08:00","permalink":"https://ynhugo.github.io/p/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94%E6%AD%8C/","title":"二十四节气歌"},{"content":" 问题-QString中文显示到界面上乱码 在\u0026#34;头文件\u0026#34;或者\u0026#34;cpp\u0026#34;文件中加入以下代码即可\n1 #pragma execution_character_set(\u0026#34;utf-8\u0026#34;) ","date":"2023-11-09T00:36:32+08:00","permalink":"https://ynhugo.github.io/p/%E8%A7%A3%E5%86%B3qt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","title":"解决Qt中文乱码问题"},{"content":" 在U盘上建立git仓库，移动的“私有云” 一、前言 Git作为版本管理工具，其功能之强大，已无需赘述。一般情况下，我们接触到的git都指远程操作，与远程git服务器协作，完成版本迭代管理。如果没有服务器，是否也能使用git呢？当然可以，这期文章，让我们一起来把git和我们的代码搬到U盘上，建立一个真正属于自己而又移动的“私有云”。\n二、环境搭建 1、安装好的git环境，参见Git官网。\n2、U盘一个，大小容量没有严格要求。\n三、命令行操作 1、在U盘上创建空仓库test.git(我的U盘盘符在PC端是I盘)。\n1 2 3 4 cd /I mkdir test cd test git init --bare 得到如下显示即表明git仓库创建成功\\\\\n1 Initialized empty Git repository in I:/test/ 2、现有git工程与U盘仓库关联(在git工程根目录下执行)\n1 git remote add usb /i/test 3、版本管理，仓库有了，剩下就是推送和拉取文件了\n1 2 git push usb master git pull usb master 4、在服务器切换到 master 分支，然后就可以看到仓库 push 过来的文件\n1 git checkout master 参考链接 在U盘上建立git仓库，移动的“私有云”\n","date":"2023-11-08T07:32:55+08:00","permalink":"https://ynhugo.github.io/p/%E5%9C%A8u%E7%9B%98%E4%B8%8A%E5%BB%BA%E7%AB%8Bgit%E4%BB%93%E5%BA%93_%E7%A7%BB%E5%8A%A8%E7%9A%84_%E7%A7%81%E6%9C%89%E4%BA%91/","title":"在U盘上建立git仓库_移动的_私有云"},{"content":" Qt-Creator-快速入门-第三版\n","date":"2023-11-07T08:03:57+08:00","permalink":"https://ynhugo.github.io/p/qt-creator-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%89%E7%89%88/","title":"Qt Creator 快速入门 第三版"},{"content":"在浏览器下载页面下载对应Ubuntu版本的浏览器，然后在Ubuntu终端安装即可 chromium下载页面 ","date":"2023-11-06T23:03:11+08:00","permalink":"https://ynhugo.github.io/p/ubuntu%E5%AE%89%E8%A3%85chromium%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%99%E7%A8%8B/","title":"Ubuntu安装chromium浏览器教程"},{"content":" Windows平台 PowerShell 用\u0026#34;PowerShell\u0026#34;处理时间戳通过管道命令创建目录后，目录名后带回车符，在\u0026#34;Bash Shell\u0026#34;通过\u0026#34;ls\u0026#34;命令可以查看出来\n1 (Get-Date -Format \u0026#34;yyyyMMddHHmmss\u0026#34;) 1 (Get-Date -Format \u0026#34;yyyyMMddHHmmss\u0026#34;) | Out-File timestamp.txt 1 date +%Y%m%d%H%M%S cmd 该脚本下载链接：timestamp.bat\n1 2 3 4 5 6 7 @echo off for /f \u0026#34;tokens=2 delims==\u0026#34; %%a in (\u0026#39;wmic OS Get localdatetime /value\u0026#39;) do set \u0026#34;dt=%%a\u0026#34; set \u0026#34;YY=%dt:~0,4%\u0026#34; \u0026amp; set \u0026#34;MM=%dt:~4,2%\u0026#34; \u0026amp; set \u0026#34;DD=%dt:~6,2%\u0026#34; set \u0026#34;HH=%dt:~8,2%\u0026#34; \u0026amp; set \u0026#34;Min=%dt:~10,2%\u0026#34; \u0026amp; set \u0026#34;Sec=%dt:~12,2%\u0026#34; set \u0026#34;timestamp=%YY%%MM%%DD%%HH%%Min%%Sec%\u0026#34; echo %timestamp% | clip 当我们理解每个参数时，我们可以更好地理解脚本的功能。下面是对每个参数的详细解释：\n`for /f \u0026#34;tokens=2 delims==\u0026#34; %%a in (\u0026#39;wmic OS Get localdatetime /value\u0026#39;) do set \u0026#34;dt=%%a\u0026#34;`\n`for /f` 是一个用于循环读取文件或命令输出的命令。 `\u0026#34;tokens=2 delims==\u0026#34;` 指定了分隔符为等号（\u0026#34;=\u0026#34;）并且提取第二个token（即等号后面的部分）。 `%%a` 是一个循环变量，用于存储每次循环中被提取的值。 `(\u0026#39;wmic OS Get localdatetime /value\u0026#39;)` 是要执行的命令，它使用`wmic`命令获取当前操作系统的本地日期和时间信息。 `do set \u0026#34;dt=%%a\u0026#34;` 是在循环每次迭代时执行的命令，它将提取的日期和时间值保存到变量`dt`中。 `set \u0026#34;YY=%dt:~0,4%\u0026#34; \u0026amp; set \u0026#34;MM=%dt:~4,2%\u0026#34; \u0026amp; set \u0026#34;DD=%dt:~6,2%\u0026#34;`\n`set` 命令用于设置变量的值。 `%dt:~0,4%` 是一个字符串切片操作，用于从变量`dt`中提取指定位置的字符。这里提取的是从索引0开始的4个字符，即年份部分。 `\u0026amp;` 是用于在一行中执行多个命令的分隔符。 `set \u0026#34;YY=%dt:~0,4%\u0026#34;` 将提取的年份值存储到变量`YY`中。 `set \u0026#34;HH=%dt:~8,2%\u0026#34; \u0026amp; set \u0026#34;Min=%dt:~10,2%\u0026#34; \u0026amp; set \u0026#34;Sec=%dt:~12,2%\u0026#34;`\n`%dt:~8,2%`、`%dt:~10,2%` 和 `%dt:~12,2%` 分别提取了从索引8开始的2个字符（小时）、从索引10开始的2个字符（分钟）和从索引12开始的2个字符（秒钟）。 这三个部分分别将提取的小时、分钟和秒钟值存储到变量`HH`、`Min`和`Sec`中。 `set \u0026#34;timestamp=%YY%%MM%%DD%%HH%%Min%%Sec%\u0026#34;`\n`%%YY%%MM%%DD%%HH%%Min%%Sec%` 将之前提取的年月日时分秒拼接起来，形成一个六位数的时间戳。 将拼接的结果保存到`timestamp`变量中。 `echo %timestamp% | clip`\n`echo` 命令用于在控制台输出文本。 `%timestamp%` 输出变量`timestamp`的值，即生成的时间戳。 `echo %timestamp% | clip` `echo` 命令用于在控制台输出文本。 `%timestamp%` 输出变量 `timestamp` 的值，即生成的时间戳。 `|` 是管道符号，用于将命令的输出发送到另一个命令作为输入。 `clip` 命令用于将输出文本复制到剪贴板中，这样可以方便地粘贴使用。\nLinxu平台 Shell 1 date +%Y%m%d%H%M%S 1 date +%Y%m%d%H%M%S | xargs mkdir 1 date +%Y%m%d%H%M%S \u0026gt; timestamp.txt ","date":"2023-11-04T20:06:22+08:00","permalink":"https://ynhugo.github.io/p/%E6%97%B6%E9%97%B4%E6%88%B3%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","title":"时间戳处理方法"},{"content":" 对于新买电脑的人来说，一般电脑预装的系统是家庭版或家庭中文版，其它版本都有的功能家庭版却没有。尤其是远程桌面，Windows最基本的功能它也没有,而重装系统又要花很多时间和精力。那么怎样才能更改系统版本呢？下面介绍常用方法（对Win11同样实用）\n输入产品密钥更改系统版本 Win10系统更换版本的方法很简单，如家庭版系统想要更换为专业版，只需要在\u0026#34;设置-\u0026gt;更新和安全-\u0026gt;激活-\u0026gt;更改产品密钥\u0026#34;里输入win10专业版的产品密钥即可，但需要有专业版的密钥才行。更换其他版本同理。\nWin11系统更换版本的方法很简单，同时按Win+i键打开设置，左侧点击“系统”，右侧点击“激活”，点击“更改产品密钥”，\u0026#34;更改产品密钥\u0026#34;里输入win11专业版的产品密钥即可，但需要有专业版的密钥才行。\n提供密钥 密钥参考 这里提供win10企业版密钥：\n1 NRTT2-86GJM-T969G-8BCBH-BDWXG 这里提供win11专业版密钥\n1 WMN7B-Y7TKF-Y49QB-TMQ8T-GMT6T 如果上面密钥失效了可以自己在网上再找，如果是win10系统要更改系统版本，那就找对应win10系统的专业版密钥，win11同样如此。\n密钥获取来源参考 永久激活Windows10系统的三种方式\n更改后如果电脑提示未激活需要再次激活 更改系统版本过程中系统会自动重启，如果重启之后系统提示没有激活，那么可以自己下载激活软件激活一下，这里提供一些我常用的激活方法\n软件激活 软件下载：windows激活工具下载\n脚本激活 脚本下载：Windows一键激活脚本.zip\n开源；单文件；数字激活、KMS38激活、KMS在线激活；可激活Windows和Office。\n推荐使用，开源脚本代码更安全，系统不会提示病毒危险，激活后即可删除。\n","date":"2023-11-04T17:40:37+08:00","permalink":"https://ynhugo.github.io/p/windows%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/","title":"Windows更改系统版本"},{"content":" 手动插入时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CREATE DATABASE test; USE test;\tCREATE TABLE goods( id INT(11) PRIMARY KEY, add_time DATETIME ); CREATE TABLE orders( o_id INT(11) PRIMARY KEY, add_time DATETIME, goods_id INT(11), CONSTRAINT goo_ord FOREIGN KEY(goods_id) REFERENCES goods(id) ); INSERT INTO goods (id, add_time) VALUES (123, \u0026#39;2023-10-06 12:34:56\u0026#39;); INSERT INTO orders (o_id, add_time, goods_id) VALUES (1, \u0026#39;2023-10-06 12:34:56\u0026#39;, 123); UPDATE orders SET add_time = \u0026#39;2023-10-07 09:00:00\u0026#39; WHERE o_id = 1; SELECT * FROM orders; 自动插入时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CREATE DATABASE test; USE test; CREATE TABLE goods( id INT(11) PRIMARY KEY, add_time DATETIME ); CREATE TABLE orders( o_id INT(11) PRIMARY KEY, add_time DATETIME, goods_id INT(11), CONSTRAINT goo_ord FOREIGN KEY(goods_id) REFERENCES goods(id) ); INSERT INTO goods (id, add_time) VALUES (123, NOW()); INSERT INTO orders (o_id, add_time, goods_id) VALUES (1, NOW(), 123); UPDATE orders SET add_time = NOW() WHERE o_id = 1; SELECT * FROM orders; ","date":"2023-10-07T22:18:24+08:00","permalink":"https://ynhugo.github.io/p/mysql%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B_1/","title":"Mysql应用案例_1"},{"content":" 先上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;作业\u0026lt;/title\u0026gt;\t\u0026lt;style\u0026gt; table { background-color:white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body text=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;table bgcolor=\u0026#34;cyan\u0026#34; border=\u0026#34;1\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; cellpadding=\u0026#34;0\u0026#34; cellspacing=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;!-- 表头 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;A\u0026lt;/th\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;B\u0026lt;/th\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;D\u0026lt;/th\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;E\u0026lt;/th\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;F\u0026lt;/th\u0026gt;\t\u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;G\u0026lt;/th\u0026gt;\t\u0026lt;/tr\u0026gt; \u0026lt;!-- 第一行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;1\u0026lt;/th\u0026gt;\t\u0026lt;td rowspan=\u0026#34;9\u0026#34; colspan=\u0026#34;2\u0026#34; bgcolor=\u0026#34;yellow\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34; colspan=\u0026#34;5\u0026#34; bgcolor=\u0026#34;#EFE6CF\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;\t\u0026lt;/tr\u0026gt; \u0026lt;!-- 第二行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;2\u0026lt;/th\u0026gt;\t\u0026lt;/tr\u0026gt; \u0026lt;!-- 第三行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;3\u0026lt;/th\u0026gt; \u0026lt;td bgcolor=\u0026#34;green\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;\t\u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34; colspan=\u0026#34;2\u0026#34; bgcolor=\u0026#34;purple\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;\t\u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;\t\u0026lt;/tr\u0026gt; \u0026lt;!-- 第四行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;4\u0026lt;/th\u0026gt;\t\u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第五行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;5\u0026lt;/th\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第六行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;6\u0026lt;/th\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34; colspan=\u0026#34;4\u0026#34; bgcolor=\u0026#34;#EFE6CF\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第七行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;7\u0026lt;/th\u0026gt; \u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第八行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;8\u0026lt;/th\u0026gt;\t\u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34; colspan=\u0026#34;4\u0026#34; bgcolor=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第九行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th bgcolor=\u0026#34;white\u0026#34;\u0026gt;9\u0026lt;/th\u0026gt;\t\u0026lt;td bgcolor=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考链接 【HTML】图像标签、文本、表格的颜色及其背景色\n菜鸟教程-CSS教程-表格颜色\n肉色调制方法 我是借助windows自带的\u0026#34;画图\u0026#34;工具，用调色器调制并添加了调出来的肉色，将肉色的颜色代码复制粘贴到html文件中使用\n","date":"2023-10-01T12:53:57+08:00","permalink":"https://ynhugo.github.io/p/%E6%BC%94%E7%A4%BA%E7%BD%91%E9%A1%B5%E8%A1%A8%E6%A0%BC%E9%A2%9C%E8%89%B2%E5%B8%83%E5%B1%80/","title":"演示网页表格颜色布局"},{"content":" nslookup 1 2 3 4 5 6 7 8 9 $nslookup 12306.cn Server: 114.114.114.114 Address: 114.114.114.114#53 Non-authoritative answer: Name: 12306.cn Address: 111.132.65.15 Name: 12306.cn Address: 2409:8c02:21c:60::f \u0026#34;Server\u0026#34;对应DNS，可以在 /etc/resolv.conf中看到，\u0026#34;#53\u0026#34;对应DNS用到的端口为53，\u0026#34;非权威性的答案\u0026#34;对应 Non-authoritative answer，\u0026#34;Name\u0026#34;对应的是别名\n命令行查看ip 1 curl ipinfo.io 除了查看ip，还显示经纬度\n","date":"2023-10-01T09:33:02+08:00","permalink":"https://ynhugo.github.io/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/","title":"网络安全笔记"},{"content":" termux ngrok 内网穿透 前言 这篇教程以termux为例，当然其他系统也可以使用以下方法。\n一、安装ngrok工具 安装ngrok工具建议去官网下载\nngrok官网链接\ntermux先在在命令行中输入uname -m确认内核\n1 2 ~ $ uname -m aarch64 arrch64也是ARM64，所以在官网中获取下载链接后输入到命令行中\n1 wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm64.tgz 解压，给予执行权限并移动到$PREFIX/bin文件夹下\n1 2 3 tar ngrok-stable-linux-arm64.tgz chomod +x ngrok mv ngrok $PREFIX/bin/ 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 .../usr/bin $ ngrok NAME: ngrok - tunnel local ports to public URLs and inspect traffic DESCRIPTION: ngrok exposes local networked services behinds NATs and firewalls to the public internet over a secure tunnel. Share local websites, build/test webhook consumers and self-host personal services. Detailed help for each command is available with \u0026#39;ngrok help \u0026lt;command\u0026gt;\u0026#39;. Open http://localhost:4040 for ngrok\u0026#39;s web interface to inspect traffic. EXAMPLES: ngrok http 80 # secure public URL for port 80 web server ngrok http -subdomain=baz 8080 # port 8080 available at baz.ngrok.io ngrok http foo.dev:80 # tunnel to host:port instead of localhost ngrok http https://localhost # expose a local https server ngrok tcp 22 # tunnel arbitrary TCP traffic to port 22 ngrok tls -hostname=foo.com 443 # TLS traffic for foo.com to port 443 ngrok start foo bar baz # start tunnels from the configuration file VERSION: 2.3.35 AUTHOR: inconshreveable - \u0026lt;alan@ngrok.com\u0026gt; COMMANDS: authtoken save authtoken to configuration file credits prints author and licensing information http start an HTTP tunnel start start tunnels by name from the configuration file tcp start a TCP tunnel tls start a TLS tunnel update update ngrok to the latest version version print the version string help Shows a list of commands or help for one command 安装完成\n二、使用 安装成功后要到官网注册一个账号或直接用GitHub账号登录\n然后在本地建立一个ssh密钥\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 .../usr/bin $ ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa Generating public/private rsa key pair. /data/data/com.termux/files/home/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /data/data/com.termux/files/home/.ssh/id_rsa Your public key has been saved in /data/data/com.termux/files/home/.ssh/id_rsa.pub The key fingerprint is: SHA256:IVPTTiVL0fQKi/g+iCkMzZO++VBDQsHd6ZV4wQqEOTQ u0_a345@localhost The key\u0026#39;s randomart image is: +---[RSA 2048]----+ | oE*.. ++++=o | | .=.o +.=ooo.. | | ...oo+.oo . | | o o+ o.o . | | o .o . S . . | |. =. . . | | +.. o .. | | +oo ... | | o+. .. | +----[SHA256]-----+ .../usr/bin $ 公钥路径\n1 ~ $ cat $HOME/.ssh/id_rsa.pub 将公钥粘贴到ngrok网站里\n点击Add SSH Key\nPublic Key：填入公钥\n到这里获取认证信息\n然后回到termux输入认Authoken\n1 ~ $ ngrok authtoken [Your Authoken] 完成\n实验 重点：在启动服务之前启动一下termux-chroot，不然可能连接不上\n测试不在同一网段使用ssh链接shell:\n在其他设备的命令行输入连接shell（以windows 10 为例）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 启动ngrok服务 ssh ~ $ ssh -R 0:localhost:8022 tunnel.us.ngrok.com tcp 8022 Enter passphrase for key \u0026#39;/data/data/com.termux/files/home/.ssh/id_rsa\u0026#39;: Allocated port 18594 for remote forward to localhost:8022 ngrok (via SSH) by @inconshreveable (Ctrl+C to quit) Account Alioth-yuheng (Plan: Free) Region us Forwarding tcp://0.tcp.ngrok.io:18594 # windows 10 cmd C:\\Users\\Administrator\u0026gt;ssh -p 18594 0.tcp.ngrok.io The authenticity of host \u0026#39;[0.tcp.ngrok.io]:18594 ([3.13.191.225]:18594)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:cmIJf1VfAU3B8o9bCq7czAC4rRDl7lRAy0A6ujAl/5g. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;[0.tcp.ngrok.io]:18594,[3.13.191.225]:18594\u0026#39; (ECDSA) to the list of known hosts. alioth@0.tcp.ngrok.io\u0026#39;s password: Welcome to Termux! Community forum: https://termux.com/community Gitter chat: https://gitter.im/termux/termux IRC channel: #termux on freenode Working with packages: ,* Search packages: pkg search \u0026lt;query\u0026gt; ,* Install a package: pkg install \u0026lt;package\u0026gt; ,* Upgrade packages: pkg upgrade Subscribing to additional repositories: ,* Root: pkg install root-repo ,* Unstable: pkg install unstable-repo ,* X11: pkg install x11-repo Report issues at https://termux.com/issues The Google Play version of the Termux app no longer receives updates. For more information, visit: https://wiki.termux.com/wiki/Termux_Google_Play ~ $ 解决遇到过的报错 启动服务后到127.0.0.1:4040点击了网页链接却报错：\n解决：端口要有服务在运行，比如在80端口配置了apache服务，命令就应该是 1 2 3 ~ $ ngrok http 80 # 或 ~ $ ngrok https 80 启动ngrok失败的可能性1\n没有安装两个软件 1 $ pkg install proot resolv-conf 启动ngrok失败的可能性2\n没有进入termux-chroot 1 $ termux-chroot 参考链接 link:https://blog.csdn.net/qq_23357159/article/details/115256330\n5 分钟，使用内网穿透快速实现远程手机桌面 参考链接 5 分钟，使用内网穿透快速实现远程手机桌面！\n","date":"2023-09-24T08:56:40+08:00","permalink":"https://ynhugo.github.io/p/termux_ngrok_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"termux_ngrok_内网穿透"},{"content":" mysql安装教程 我准备安装的是mysql-8.0.34，如果想安装其他版本可以在下载页面的归档里面进行更换，然后进入mysql的bin目录，然后复制当前路径，将路径添加到环境变量\n下载mysql 下载链接：https://dev.mysql.com/downloads/windows/installer/\n开始安装 在开始菜单搜索 cmd，然后以管理员身份运行 cmd 在cmd窗口执行以下命令进行安装\n1 mysqld --install 如果是重装mysql失败，明明已删除mysql可是在安装的时候提示已存在，可以如下操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 输入安装命令mysqld --install 出现问题The service already exists 这是由于之前已经安装过mysql并且没有删除干净 重新以管理员身份运行，输入\u0026#34;sc query mysql\u0026#34;，查看一下名为mysql的服务： 发现之前确实有安装过。 命令\u0026#34;sc delete mysql\u0026#34;，删除该mysql 之后继续安装，就能成功 初始化mysql，在这里，初始化会产生一个随机密码,如下图框框所示，记住这个密码，后面会用到\n1 mysqld --initialize --console 启动mysql服务\n1 net start mysql 如果提示：MySQL 服务正在启动 . MySQL 服务无法启动 服务没有报告任何错误 解决方案\n1 2 3 4 5 (1)找到MySQL的安装目录,将data删除 (注意该文件下会有一些你自己建立的数据库的数据!) (2)然后复制bin文件的路径 (3)从开始里搜索cmd 右键以管理员身份运行 (4)cd bin文件的路径 进入后输入mysqld --initialize (5)关闭cmd 重新启动 输入net start mysql即可启动成功! 修改密码，将密码设为 root\n1 alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;root\u0026#39; 不用的时候停止mysql服务\n1 net stop mysql 停止mysql服务，添加配置文件，在mysql的bin目录创建mysql.ini，添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 mysqld #设置MySQL默认端口号 port=3306 #设置mysql的安装目录-你的文件路径，如果mysql要存放的目录不存在，可以创建一下 basedir=D:\\ProgramFiles\\mysql-8.0.34-winx64 #mysql数据库的数据的存放目录 datadir=D:\\ProgramFiles\\mysql-8.0.34-winx64\\data #允许最大连接数 max_connections=200 #允许连接失败的次数。可防止有人从该主机试图攻击数据库系统 max_connect_errors=10 #服务端使用的字符集默认为UTF8 character-set-server=utf8 #创建新表时将使用的默认存储引擎 default-storage-engine=INNODB #默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password mysql #设置mysql客户端默认字符集 default-character-set=utf8 client #设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 登录验证 1 mysql -u root -p 参考链接 MySQL的安装与配置——详细教程\nMySQL修改、忘记root密码（8.0版本） 在修改MySQL数据库的root密码时很多老帖子的方式不成功\n1 2 3 mysql\u0026gt; set password for 用户名@localhost = password(\u0026#39;新密码\u0026#39;); 例如（将用户root的密码更改为root）： mysql\u0026gt; set password for root@localhost = password(\u0026#39;root\u0026#39;); 以及\n1 2 3 mysqladmin -u用户名 -p旧密码； password 新密码 例如： mysqladmin -uroot -proot password 123 以及用UPDATE直接编辑user表方法也是不管用的。\n这是由于版本在8.0以上已经不再支持。\n解决方法： 1、首先终止MySQL服务 1 2 3 4 1、右键此电脑-管理-服务-MySQL 或者 2、以管理员身份打开cmd,执行： net stop mysql 2、以管理员身份新开cmd，进入mysql安装的bin目录后执行： 1 mysqld --console --skip-grant-tables --shared-memory 此时，命令行框会处于持续运行状态：\n3、保持上述的窗口（切记），再以管理员身份新开cmd，执行： 1 mysql -uroot -p 这时就已经绕过密码登录进入mysql了。\n4、接下来修改root的密码为空 1 UPDATE mysql.user SET authentication_string=\u0026#39;\u0026#39; WHERE user=\u0026#39;root\u0026#39;; 5、此时关闭所有命令行界面，正常开启MySQL服务后进行登录，无需密码即可进入成功。 此时进行修改密码操作：\n1 2 3 use mysql ALTER user root@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; 密码修改成功，退出mysql,即可通过密码：123456登录.\n\\\\\n或者，修改当前用户的密码（最简单）：\n1 set password = ‘123456’; ","date":"2023-09-23T15:51:47+08:00","permalink":"https://ynhugo.github.io/p/windows%E5%AE%89%E8%A3%85mysql%E6%95%99%E7%A8%8B/","title":"Windows安装mysql教程"},{"content":" 安装Termux Termux 官网：https://termux.dev/cn/index.html\nTermux 下载页面：https://f-droid.org/zh_Hans/packages/xyz.zedler.patrick.grocy/\n安装Termux:API 1 pkg install termux-api -y 配置手机目录访问权限 1 termux-setup-storage 录音教程 第一次录音时，软件会请求录音权限，授权允许即可\n执行录音操作后，会在后台录制指定时间的脚本，本博客展示的录制音频时间为60秒，录音过程中产生的音频文件不能进行播放，执行录音操作后，会立刻在指定目录产生一个指定名字的音频文件，这个文件想要播放就必须得在执行录音操作后，后台录音达到指定的录音时长，这个产生的音频才能进行播放\n录音脚本只是验证录制效果，可以在此基础上进行丰富，让脚本更加灵活 录音命令 1 termux-microphone-record 录音命令选项介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -d 使用默认值开始录制 -f 开始录制到特定文件 -l 以指定的限制开始记录(以秒为单位，0 为无限制) -e 使用指定的编码器开始录制(aac、amr_wb、amr_nb) -b 以指定的比特率开始录制(以 kbps 为单位) -r 使用指定的采样率开始记录(以 Hz 为单位) -c 使用指定的 channel 数开始录制 (1, 2, ...) -i 获取有关当前录音的信息 -q 退出录音 录音操作方法 1 2 3 termux-microphone-record -e acc -l 60 -f test.acc 或者 termux-microphone-record -e acc -l 60 -f $HOME/storage/shared/Downloadtest.acc 录音脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package_1=\u0026#34;termux-api\u0026#34;; # package_1 result=$(pkg list-all | grep -w \u0026#34;$package_1\u0026#34; | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | grep --color=auto -w \u0026#34;installed\u0026#34; | xargs echo); if [ \u0026#34;$result\u0026#34; != \u0026#34;[installed]\u0026#34; ]; then pkg install $package_1 -y; fi record_time=\u0026#34;1800\u0026#34;; let delay=\u0026#34;$record_time+1\u0026#34;; savepath=\u0026#34;$HOME/storage/shared/Download\u0026#34;; while true do if [ $(ps aux | grep \u0026#34;com.termux.api\u0026#34; | grep -v \u0026#34;grep\u0026#34; | awk \u0026#39;{print $11}\u0026#39;) ]; then ps aux | grep \u0026#34;com.termux.api\u0026#34; | grep -v \u0026#34;grep\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | xargs killall; fi result=`df -h | grep \u0026#34;block\u0026#34; | awk \u0026#39;{print $5}\u0026#39; | tr \u0026#39;%\u0026#39; \u0026#39; \u0026#39;`; if [ \u0026#34;$result\u0026#34; -ge 90 ]; then find $savepath -mtime +30 -exec rm -rf \u0026#39;{}\u0026#39; \\; else filename=`date | tr \u0026#39; \u0026#39; \u0026#39;-\u0026#39; | tr \u0026#39;:\u0026#39; \u0026#39;-\u0026#39;`; if [ -d \u0026#34;$savepath\u0026#34; ]; then date_year=`date | awk \u0026#39;{print $6}\u0026#39;`; date_month=`date | awk \u0026#39;{print $2}\u0026#39;`; dir_1=$date_year-$date_month; if [ -d \u0026#34;$savepath/$dir_1\u0026#34; ]; then termux-microphone-record -e acc -l $record_time -f $savepath/$dir_1/$filename.acc; sleep $delay; echo \u0026#34;record complate!\u0026#34;; if [ $(ps aux | grep \u0026#34;com.termux.api\u0026#34; | grep -v \u0026#34;grep\u0026#34; | awk \u0026#39;{print $11}\u0026#39;) ]; then ps aux | grep \u0026#34;com.termux.api\u0026#34; | grep -v \u0026#34;grep\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | xargs killall; fi else mkdir -p $savepath/$dir_1; termux-microphone-record -e acc -l $record_time -f $savepath/$dir_1/$filename.acc; sleep $delay; echo \u0026#34;record complate!\u0026#34;; if [ $(ps aux | grep \u0026#34;com.termux.api\u0026#34; | grep -v \u0026#34;grep\u0026#34; | awk \u0026#39;{print $11}\u0026#39;) ]; then ps aux | grep \u0026#34;com.termux.api\u0026#34; | grep -v \u0026#34;grep\u0026#34; | awk \u0026#39;{print $11}\u0026#39; | xargs killall; fi fi else mkdir -p $savepath; fi fi done ","date":"2023-09-23T14:41:43+08:00","permalink":"https://ynhugo.github.io/p/termux%E5%BD%95%E9%9F%B3%E6%95%99%E7%A8%8B/","title":"Termux录音教程"},{"content":" 使用qemu搭建arm嵌入式linux开发环境 使用说明 该脚本只有在第一次运行的时候需要构建环境，花费时间长一些，构建完成以后自动启动环境，以后再运行该脚本的时候就不需要再次构建环境了，加载后进入开发环境，敲回车确认。\n退出时先按快捷键\u0026#34;Ctrl+x\u0026#34;，再按\u0026#34;x\u0026#34;即可退出环境。\n搭建脚本 调试启动脚本 推荐使用这个脚本，从头到尾自动化完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 cmdself=$0 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) package_array=(gcc-arm-linux-gnueabi python-dev qemu qemu-kvm libvirt-bin bridge-utils virt-manager uml-utilities bridge-utils u-boot-tools ed tftp-hpa tftpd-hpa xinetd nfs-kernel-server device-tree-compiler) # gcc-arm-linux-gnueabi 交叉编译工具链与 gcc-multilib 不能共存，因此如果电脑之前有安装并且需要 gcc-multilib 的话，可以再运行完脚本后重新安装 gcc-multilib package_array_size=${#package_array[@]} for ((i = 0; i \u0026lt; package_array_size; i++)) do # 软件安装 if [ ! \u0026#34;$(apt list --installed | grep -wo \u0026#34;${package_array[${i}]}\u0026#34; | head -n 1)\u0026#34; = \u0026#34;${package_array[${i}]}\u0026#34; ]; then echo -e \u0026#34;\\e[34m\u0026#34; sudo apt-get install ${package_array[${i}]} -y echo -e \u0026#34;\\e[0m\u0026#34; if [ ! \u0026#34;$(apt list --installed | grep -wo \u0026#34;${package_array[${i}]}\u0026#34; | head -n 1)\u0026#34; = \u0026#34;${package_array[${i}]}\u0026#34; ]; then echo -e \u0026#34;\\e[31m${package_array[${i}]} 未安装\\e[0m\u0026#34; else echo -e \u0026#34;\\e[32m${package_array[${i}]} 已安装\\e[0m\u0026#34; fi\telse echo -e \u0026#34;\\e[32m${package_array[${i}]} 已安装\\e[0m\u0026#34; fi done\t# 配置/etc/default/tftpd-hpa sudo chmod 777 /etc/default/tftpd-hpa; cat /etc/default/tftpd-hpa \u0026gt; /etc/default/tftpd-hpa sudo chown ${USER}:${USER} -R /etc/default/tftpd-hpa echo \u0026#39;TFTP_USERNAME=\u0026#34;tftp\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa echo \u0026#34;TFTP_DIRECTORY=\\\u0026#34;/tftpboot\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; /etc/default/tftpd-hpa # echo \u0026#34;TFTP_DIRECTORY=\\\u0026#34;/tftpboot /tftpboot/${work_dir_name}\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; /etc/default/tftpd-hpa echo \u0026#39;TFTP_ADDRESS=\u0026#34;0.0.0.0:69\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa echo \u0026#39;TFTP_OPTIONS=\u0026#34;-l -c -s\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa # 如果要设置多个目录就不能添加\u0026#34;-s\u0026#34;选项 # echo \u0026#39;TFTP_OPTIONS=\u0026#34;-l -c\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa sudo chown root:root -R /etc/default/tftpd-hpa # 判断/tftpboot是否存在 if [ -d \u0026#34;/tftpboot/\u0026#34; ]; then echo \u0026#34;tftpboot exists.\u0026#34;; tftpboot_access=$(stat /tftpboot/ | grep -w \u0026#34;Uid\u0026#34; | tr \u0026#39;(\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;/\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39;) if [ \u0026#34;$tftpboot_access\u0026#34; != \u0026#34;0777\u0026#34; ]; then sudo chmod 777 /tftpboot; echo \u0026#34;/tftpboot的权限已设置为0777\u0026#34; fi else sudo mkdir /tftpboot; sudo chmod 777 /tftpboot; echo \u0026#34;/tftpboot的权限已设置为0777\u0026#34; fi # 判断/tftpboot/${work_dir_name}是否存在，想要配置多个文件夹的话可以取消注释 # if [ -d \u0026#34;/tftpboot/${work_dir_name}\u0026#34; ]; then # echo \u0026#34;tftpboot/${work_dir_name} exists.\u0026#34;; # work_dir_name_access=$(stat /tftpboot/ | grep -w \u0026#34;Uid\u0026#34; | tr \u0026#39;(\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;/\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39;) # if [ \u0026#34;$work_dir_name_access\u0026#34; != \u0026#34;0777\u0026#34; ]; then # sudo chmod 777 /tftpboot/${work_dir_name}; # echo \u0026#34;/tftpboot/${work_dir_name}的权限已设置为0777\u0026#34; # fi # else # sudo mkdir /tftpboot/${work_dir_name}; # sudo chmod 777 /tftpboot/${work_dir_name}; # echo \u0026#34;/tftpboot/${work_dir_name}的权限已设置为0777\u0026#34; # fi # 允许开发板通过NFS访问Ubuntu的/home/${USER}目录，当然你可以加其他目录 result=$(grep -w \u0026#34;${work_dir} \\*(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\u0026#34; /etc/exports | grep -v \u0026#34;#\u0026#34;) if [ $? -eq 0 ]; then # 查找并注释匹配行 # sudo sed -i \u0026#34;s/${work_dir} \\*(rw,nohide,insecure,no_subtree_check,async,no_root_squash)/#\\/home\\/${USER} \\*(rw,nohide,insecure,no_subtree_check,async,no_root_squash)/g\u0026#34; /etc/exports # echo \u0026#34;已注释匹配行：$result\u0026#34; sudo /etc/init.d/nfs-kernel-server restart echo \u0026#34;匹配行已存在，并且重启了nfs服务\u0026#34; else power=$(ls -l /etc/exports | awk \u0026#39;{print $4}\u0026#39;) if [ \u0026#34;$power\u0026#34; == \u0026#34;root\u0026#34; ]; then sudo chown ${USER}:${USER} -R /etc/exports echo \u0026#34;${work_dir} *(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\u0026#34; \u0026gt;\u0026gt; /etc/exports sudo chown root:root -R /etc/exports else echo \u0026#34;${work_dir} *(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\u0026#34; \u0026gt;\u0026gt; /etc/exports sudo chown root:root -R /etc/exports fi sudo /etc/init.d/nfs-kernel-server restart echo \u0026#34;匹配行已添加，并且重启了nfs服务\u0026#34; fi # 判断linux内核是否准备好 while true; do result=$(curl ipinfo.io | grep \u0026#34;country\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) if [ -z \u0026#34;${result}\u0026#34; ]; then continue else echo -e \u0026#34;\\e[32mcountry: ${result}\\e[0m\u0026#34; break fi done while true; do if [ ! -f \u0026#34;${work_dir}/$file_linux\u0026#34; ]; then\techo -e \u0026#34;\\e[32m\u0026#34; if [ ${result} != \u0026#34;CN\u0026#34; ]; then\t# wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.232.tar.xz wget https://cdn.kernel.org/pub/linux/kernel/v4.x/${file_linux} else # wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/linux-4.4.232.tar.xz wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/${file_linux} fi else if [ \u0026#34;$(sha256sum ${file_linux})\u0026#34; != \u0026#34;4eae8865deaf03f0d13bf5056e258d451a468cabc5158757b247b0e43518fd34 ${file_linux}\u0026#34; ]; then rm -rf ${file_linux} continue else echo -e \u0026#34;\\e[32m${file_linux} 已下载\\e[0m\u0026#34; break; fi fi echo -e \u0026#34;\\e[0m\u0026#34; done # 判断busybox文件是否准备好 while true; do if [ ! -f \u0026#34;${work_dir}/$file_busybox\u0026#34; ]; then echo -e \u0026#34;\\e[33m\u0026#34; # wget --no-check-certificate https://busybox.net/downloads/busybox-1.32.0.tar.bz2 wget --no-check-certificate https://busybox.net/downloads/${file_busybox} echo -e \u0026#34;\\e[0m\u0026#34; else if [ \u0026#34;$(sha256sum ${file_busybox})\u0026#34; != \u0026#34;c35d87f1d04b2b153d33c275c2632e40d388a88f19a9e71727e0bbbff51fe689 ${file_busybox}\u0026#34; ]; then rm -rf ${file_busybo} continue else echo -e \u0026#34;\\e[32m$file_busybox 已下载\\e[0m\u0026#34; break; fi fi\tdone # 判断u-boot文件是否准备好 while true; do if [ ! -f \u0026#34;${work_dir}/$file_uboot\u0026#34; ]; then echo -e \u0026#34;\\e[34m\u0026#34; # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/u-boot-2017.05.tar.bz2 # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/u-boot-2020.07.tar.bz2 wget --no-check-certificate https://ftp.denx.de/pub/u-boot/${file_uboot} echo -e \u0026#34;\\e[0m\u0026#34; else if [ \u0026#34;$(sha256sum ${file_uboot})\u0026#34; != \u0026#34;c8373949d7f0de1059e507b83a655d4cea539f75dc66ccdbb27adbd38d83095e u-boot-2017.05.tar.bz2\u0026#34; ]; then rm -rf ${file_uboot} continue else echo -e \u0026#34;\\e[32m$file_uboot 已下载\\e[0m\u0026#34; break fi fi done # 临时配置交叉编译环境 export ARCH=arm \u0026amp;\u0026amp; export CROSS_COMPILE=arm-linux-gnueabi-; # 判断linux内核是否解压 echo -e \u0026#34;\\e[32m\u0026#34; # kernel if [ -d \u0026#34;${work_dir}/$linux\u0026#34; ]; then echo \u0026#34;$linux exists.\u0026#34; else tar xvf ${work_dir}/$file_linux -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; # 判断busybox文件是否解压 echo -e \u0026#34;\\e[33m\u0026#34; if [ -d \u0026#34;${work_dir}/$busybox\u0026#34; ]; then echo \u0026#34;$busybox exists.\u0026#34; else tar xvf ${work_dir}/$file_busybox -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; # 判断u-boot文件是否解压 echo -e \u0026#34;\\e[34m\u0026#34; if [ -d \u0026#34;${work_dir}/${uboot}\u0026#34; ]; then echo \u0026#34;$uboot exists.\u0026#34; else tar xvf ${work_dir}/$file_uboot -C ${work_dir}; if [ -f \u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old fi fi echo -e \u0026#34;\\e[0m\u0026#34; # 编译linux内核 echo -e \u0026#34;\\e[32m\u0026#34; cd ${work_dir}/${linux}; make distclean -j${jobs}; make vexpress_defconfig -j${jobs}; make zImage -j${jobs}; make modules -j${jobs}; make LOADADDR=0x60003000 uImage -j${jobs}; make dtbs -j${jobs}; # mkimage -n \u0026#39;mini2440\u0026#39; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d ${work_dir}/$linux/arch/arm/boot/zImage ${work_dir}/$linux/arch/arm/boot/uImage echo -e \u0026#34;\\e[0m\u0026#34; # 编译busybox，编译之后把\u0026#34;${busybox}/_install/*\u0026#34;拷贝到rootfs目录下 echo -e \u0026#34;\\e[33m\u0026#34; cd ${work_dir}/${busybox}; make distclean -j${jobs}; make defconfig -j${jobs}; make -j${jobs}; make install -j${jobs}; echo -e \u0026#34;\\e[0m\u0026#34; # 搭建网络开发环境 echo -e \u0026#34;\\e[95m\u0026#34; if [ ! -f \u0026#34;$Operate_Net_File\u0026#34; ]; then sudo touch ${Operate_Net_File} else echo \u0026#34;${uboot_config_file} is exists.\u0026#34; if [ ! -f \u0026#34;$Operate_Net_File.old\u0026#34; ]; then sudo cp ${Operate_Net_File} {$Operate_Net_File}.old else echo \u0026#34;${Operate_Net_File}.old is exists.\u0026#34; fi fi sudo chown ${USER}:${USER} ${Operate_Net_File} if [ ! \u0026#34;$(cat /etc/network/interfaces | grep -o \u0026#34;br0\u0026#34; | head -n 1)\u0026#34; = \u0026#34;br0\u0026#34; ]; then echo \u0026#34;debug_1\u0026#34; cat ${Operate_Net_File} \u0026gt; ${Operate_Net_File} if [ \u0026#34;$(ip addr | grep -o \u0026#34;ens33\u0026#34; | head -n 1)\u0026#34; = \u0026#34;ens33\u0026#34; ]; then echo \u0026#34;auto lo\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface lo inet loopback\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto ens33\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto br0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface br0 inet dhcp\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\tbridge_ports ens33\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} sudo chown ${root}:${root} ${Operate_Net_File} sudo /etc/init.d/networking restart else if [ \u0026#34;$(ip addr | grep -o \u0026#34;eth0\u0026#34;)\u0026#34; = \u0026#34;eth0\u0026#34; ]; then echo \u0026#34;auto lo\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface lo inet loopback\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto eth0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto br0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface br0 inet dhcp\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\tbridge_ports eth0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File}\tsudo /etc/init.d/networking restart fi fi else echo \u0026#34;br0 exists.\u0026#34; fi if [ \u0026#34;$(ifconfig | grep -wo \u0026#34;br0\u0026#34;)\u0026#34; = \u0026#34;br0\u0026#34; ]; then of_ip_var1=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;); echo ${of_ip_var1} of_ip_var2=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $2}\u0026#39;); echo ${of_ip_var2} of_ip_var3=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $3}\u0026#39;); echo ${of_ip_var3} of_ip_var4=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $4}\u0026#39;); echo ${of_ip_var4} else echo \u0026#34;The br0 not exists.\u0026#34; fi sudo chown ${USER}:${USER} ${Operate_Net_File} if [ ! -f \u0026#34;${uboot_config_file}.old\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old else cat ${uboot_config_file}.old \u0026gt; ${uboot_config_file} fi uboot_config_file_var1=$(grep -n \u0026#34;\\/\\* Basic environment settings \\*\\/\u0026#34; ${uboot_config_file}.old | tr \u0026#39;:\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $1}\u0026#39;) uboot_config_file_var2=$((uboot_config_file_var1 + 1)) cat ${uboot_config_file}.old \u0026gt; ${uboot_config_file} sed -i \u0026#39;/CONFIG_BOOTCOMMAND\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#39;/run distro_bootcmd\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#39;/run bootflash\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_SERVERIP ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.${of_ip_var4}\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_NETMASK 255.255.255.0\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_IPADDR ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.223\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\/* netmask */\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_BOOTCOMMAND \\\u0026#34;tftp 0x60003000 uImage;tftp 0x60500000 vexpress-v2p-ca9.dtb;setenv bootargs \u0026#39;root=/dev/mmcblk0 console=ttyAMA0\u0026#39;;bootm 0x60003000 - 0x60500000;\\\u0026#34; \\\\\u0026#34; ${uboot_config_file} echo -e \u0026#34;\\e[0m\u0026#34; # 编译u-boot，编译之后会在${uboot}目录下出现u-boot，传真u-boot示例：sudo qemu-system-arm -M vexpress-a9 -m 256 -kernel ./u-boot -nographic echo -e \u0026#34;\\e[34m\u0026#34; cd ${work_dir}/${uboot}; make distclean -j${jobs}; make vexpress_ca9x4_defconfig -j${jobs}; make -j${jobs}; echo -e \u0026#34;\\e[0m\u0026#34; # 准备根文件系统 echo -e \u0026#34;\\e[33m\u0026#34; cd ${work_dir}; mkdir -p ${work_dir}/rootfs/{dev,etc/init.d,lib,mnt}; sudo cp -vrf ${work_dir}/${busybox}/_install/* ${work_dir}/rootfs/; sudo cp -vrf /usr/arm-linux-gnueabi/lib/* ${work_dir}/rootfs/lib/; cd ${work_dir}/rootfs/dev; # 创建字符设备类型的设备节点，这些设备节点的主设备号为4,次设备号为1..11 sudo mknod -m 666 console c 4 1; sudo mknod -m 666 null c 4 2; sudo mknod -m 666 tty1 c 4 3; sudo mknod -m 666 tty2 c 4 4; sudo mknod -m 666 tty3 c 4 5; sudo mknod -m 666 tty4 c 4 6; sudo mknod -m 666 tty5 c 4 7; sudo mknod -m 666 tty6 c 4 8; sudo mknod -m 666 tty7 c 4 9; sudo mknod -m 666 tty8 c 4 10; sudo mknod -m 666 tty9 c 4 11; # 在rootfs目录下准备挂载NFS脚本 sudo touch ${work_dir}/rootfs/mountNFS.sh sudo chown ${USER}:${USER} ${work_dir}/rootfs/mountNFS.sh cat ${work_dir}/rootfs/mountNFS.sh \u0026gt; ${work_dir}/rootfs/mountNFS.sh echo \u0026#34;ifconfig eth0 ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.223\u0026#34; \u0026gt;\u0026gt; ${work_dir}/rootfs/mountNFS.sh echo \u0026#34;mount -t nfs -o nolock ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.${of_ip_var4}:${work_dir} /mnt\u0026#34; \u0026gt;\u0026gt; ${work_dir}/rootfs/mountNFS.sh sudo chown ${root}:${root} ${work_dir}/rootfs/mountNFS.sh # 进入qemu运行的虚拟机后通过以下命令运行脚本进行挂载nfs：\u0026#34;sh mountNFS.sh\u0026#34; cd ${work_dir}; # 制作rootfs.ext3，格式化rootfs.ext3为ext3文件系统类型，将rootfs.ext3挂载到/mnt，再将根文件系统拷贝到/mnt，然后解除/mnt挂载的rootfs.ext3，此时rootfs.ext3中已经有根文件系统了 sudo dd if=/dev/zero of=rootfs.ext3 bs=1M count=32 sudo mkfs.ext3 rootfs.ext3 sudo mount -t ext3 rootfs.ext3 /mnt -o loop sudo cp -vrf ${work_dir}/rootfs/* /mnt sudo umount /mnt echo -e \u0026#34;\\e[0m\u0026#34; # tftpboot echo -e \u0026#34;\\e[96m\u0026#34; # sudo chmod 775 $work_dir/$uboot/uImage; sudo rm -rf /tftpboot/* sudo cp -f ${work_dir}/${linux}/arch/arm/boot/zImage /tftpboot; sudo cp -f ${work_dir}/${linux}/arch/arm/boot/uImage /tftpboot; sudo cp -f ${work_dir}/${linux}/arch/arm/boot/dts/vexpress-v2p-ca9.dtb /tftpboot; sudo cp -f ${work_dir}/${uboot}/u-boot /tftpboot; sudo cp -f ${work_dir}/rootfs.ext3 /tftpboot; echo -e \u0026#34;\\e[0m\u0026#34; # QEMU运行虚拟机，通过sd卡加载linux内核 echo -e \u0026#34;\\e[92m\u0026#34; # qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd ${work_dir}/rootfs.ext3; # 在脚本外部执行，进入yenao_qemu_test目录执行下面的语句 # qemu-system-arm -M vexpress-a9 -m 512M -kernel linux-4.4.232/arch/arm/boot/zImage -dtb linux-4.4.232/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd rootfs.ext3 # QEMU运行虚拟机，只加载u-boot # qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/${uboot}/u-boot -nographic # 通过 u-boot 加载内核 # cd /tftpboot # sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 if [ \u0026#34;$1\u0026#34; = \u0026#34;sd\u0026#34; ]; then # QEMU运行虚拟机，通过sd卡加载linux内核\tsudo qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd ${work_dir}/rootfs.ext3;\telif [ \u0026#34;$1\u0026#34; = \u0026#34;u-boot\u0026#34; ]; then cd /tftpboot sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 elif [ \u0026#34;$1\u0026#34; = \u0026#34;help\u0026#34; ]; then echo \u0026#34;sd start: ${cmdself} sd\u0026#34; echo \u0026#34;u-boot start: ${cmdself} u-boot\u0026#34; echo \u0026#34;out sd start var: ${cmdself} out sd\u0026#34; echo \u0026#34;out u-boot start var: ${cmdself} out u-boot\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;out\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;sd\u0026#34; ]; then echo \u0026#34; qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \\\u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\\\u0026#34; -sd ${work_dir}/rootfs.ext3;\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;out\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;u-boot\u0026#34; ]; then echo \u0026#34;sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3\u0026#34; else # 默认通过u-boot加载linux内核 cd /tftpboot sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 fi echo -e \u0026#34;\\e[0m\u0026#34; # 部分参数说明 # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | 参数 | 含义 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | M vexpress-a9` | 指定虚拟机的机型为 `vexpress-a9`，即使用 ARMv7 架构的 Versatile Express 开发板模型。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | m 512M` | 设置虚拟机的内存大小为 512MB。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | kernel ${work_dir}/$linux/arch/arm/boot/zImage` | 指定 Linux 内核镜像的路径和文件名。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb` | 指定设备树二进制文件（Device Tree Blob）的路径和文件名。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | nographic` | 以无图形界面的方式运行虚拟机。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34;` | 指定 Linux 内核启动参数，包括根文件系统的设备路径、读写权限和控制台终端。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | sd ${work_dir}/rootfs.ext3` | 指定虚拟机的根文件系统镜像路径和文件名。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| 挂载NFS文件系统流程，待实现 1 2 3 4 5 6 7 8 9 10 11 12 13 export ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-; make vexpress_ca9x4_defconfig; make -j12 setenv ipaddr 192.168.1.223; setenv serverip 192.168.1.100; tftp 0x60003000 uImage; tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs \u0026#39;root=/dev/nfs rw nfsroot=192.168.1.100:/home/ubt init=/linuxrc ip=192.168.1.223 console=ttyAMA0\u0026#39;; bootm 0x60003000 - 0x60500000; 所需资源下载 linux-4.4.232.tar.xz\nbusybox-1.32.0.tar.bz2\nu-boot-2020.07.tar.bz2\n点击下载: qemu_deubg.zip\n综合调试 org 脚本 综合调试启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; vuboot=\u0026#34;v2017.05\u0026#34; git_uboot=\u0026#34;v\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; file_vuboot=\u0026#34;${vuboot}.tar.gz\u0026#34; bz2_uboot=\u0026#34;${file_uboot}\u0026#34; gz_uboot=\u0026#34;${file_vuboot}\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) package_array=(gcc-arm-linux-gnueabi python-dev qemu qemu-kvm libvirt-bin bridge-utils virt-manager uml-utilities bridge-utils u-boot-tools ed tftp-hpa tftpd-hpa xinetd nfs-kernel-server device-tree-compiler) # gcc-arm-linux-gnueabi 交叉编译工具链与 gcc-multilib 不能共存，因此如果电脑之前有安装并且需要 gcc-multilib 的话，可以再运行完脚本后重新安装 gcc-multilib package_array_size=${#package_array[@]} for ((i = 0; i \u0026lt; package_array_size; i++)) do # 软件安装 if [ ! \u0026#34;$(apt list --installed | grep -wo \u0026#34;${package_array[${i}]}\u0026#34; | head -n 1)\u0026#34; = \u0026#34;${package_array[${i}]}\u0026#34; ]; then echo -e \u0026#34;\\e[34m\u0026#34; sudo apt-get install ${package_array[${i}]} -y echo -e \u0026#34;\\e[0m\u0026#34; if [ ! \u0026#34;$(apt list --installed | grep -wo \u0026#34;${package_array[${i}]}\u0026#34; | head -n 1)\u0026#34; = \u0026#34;${package_array[${i}]}\u0026#34; ]; then echo -e \u0026#34;\\e[31m${package_array[${i}]} 未安装\\e[0m\u0026#34; else echo -e \u0026#34;\\e[32m${package_array[${i}]} 已安装\\e[0m\u0026#34; fi\telse echo -e \u0026#34;\\e[32m${package_array[${i}]} 已安装\\e[0m\u0026#34; fi done\t# 配置/etc/default/tftpd-hpa sudo chmod 777 /etc/default/tftpd-hpa; cat /etc/default/tftpd-hpa \u0026gt; /etc/default/tftpd-hpa sudo chown ${USER}:${USER} -R /etc/default/tftpd-hpa echo \u0026#39;TFTP_USERNAME=\u0026#34;tftp\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa echo \u0026#34;TFTP_DIRECTORY=\\\u0026#34;/tftpboot\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; /etc/default/tftpd-hpa # echo \u0026#34;TFTP_DIRECTORY=\\\u0026#34;/tftpboot /tftpboot/${work_dir_name}\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; /etc/default/tftpd-hpa echo \u0026#39;TFTP_ADDRESS=\u0026#34;0.0.0.0:69\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa echo \u0026#39;TFTP_OPTIONS=\u0026#34;-l -c -s\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa # 如果要设置多个目录就不能添加\u0026#34;-s\u0026#34;选项 # echo \u0026#39;TFTP_OPTIONS=\u0026#34;-l -c\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/default/tftpd-hpa sudo chown root:root -R /etc/default/tftpd-hpa # 判断/tftpboot是否存在 if [ -d \u0026#34;/tftpboot/\u0026#34; ]; then echo \u0026#34;tftpboot exists.\u0026#34;; tftpboot_access=$(stat /tftpboot/ | grep -w \u0026#34;Uid\u0026#34; | tr \u0026#39;(\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;/\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39;) if [ \u0026#34;$tftpboot_access\u0026#34; != \u0026#34;0777\u0026#34; ]; then sudo chmod 777 /tftpboot; echo \u0026#34;/tftpboot的权限已设置为0777\u0026#34; fi else sudo mkdir /tftpboot; sudo chmod 777 /tftpboot; echo \u0026#34;/tftpboot的权限已设置为0777\u0026#34; fi # 判断/tftpboot/${work_dir_name}是否存在，想要配置多个文件夹的话可以取消注释 # if [ -d \u0026#34;/tftpboot/${work_dir_name}\u0026#34; ]; then # echo \u0026#34;tftpboot/${work_dir_name} exists.\u0026#34;; # work_dir_name_access=$(stat /tftpboot/ | grep -w \u0026#34;Uid\u0026#34; | tr \u0026#39;(\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;/\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $2}\u0026#39;) # if [ \u0026#34;$work_dir_name_access\u0026#34; != \u0026#34;0777\u0026#34; ]; then # sudo chmod 777 /tftpboot/${work_dir_name}; # echo \u0026#34;/tftpboot/${work_dir_name}的权限已设置为0777\u0026#34; # fi # else # sudo mkdir /tftpboot/${work_dir_name}; # sudo chmod 777 /tftpboot/${work_dir_name}; # echo \u0026#34;/tftpboot/${work_dir_name}的权限已设置为0777\u0026#34; # fi # 允许开发板通过NFS访问Ubuntu的/home/${USER}目录，当然你可以加其他目录 result=$(grep -w \u0026#34;${work_dir} \\*(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\u0026#34; /etc/exports | grep -v \u0026#34;#\u0026#34;) if [ $? -eq 0 ]; then # 查找并注释匹配行 # sudo sed -i \u0026#34;s/${work_dir} \\*(rw,nohide,insecure,no_subtree_check,async,no_root_squash)/#\\/home\\/${USER} \\*(rw,nohide,insecure,no_subtree_check,async,no_root_squash)/g\u0026#34; /etc/exports # echo \u0026#34;已注释匹配行：$result\u0026#34; sudo /etc/init.d/nfs-kernel-server restart echo \u0026#34;匹配行已存在，并且重启了nfs服务\u0026#34; else power=$(ls -l /etc/exports | awk \u0026#39;{print $4}\u0026#39;) if [ \u0026#34;$power\u0026#34; == \u0026#34;root\u0026#34; ]; then sudo chown ${USER}:${USER} -R /etc/exports echo \u0026#34;${work_dir} *(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\u0026#34; \u0026gt;\u0026gt; /etc/exports sudo chown root:root -R /etc/exports else echo \u0026#34;${work_dir} *(rw,nohide,insecure,no_subtree_check,async,no_root_squash)\u0026#34; \u0026gt;\u0026gt; /etc/exports sudo chown root:root -R /etc/exports fi sudo /etc/init.d/nfs-kernel-server restart echo \u0026#34;匹配行已添加，并且重启了nfs服务\u0026#34; fi # 判断linux内核是否准备好 while true; do result=$(curl ipinfo.io | grep \u0026#34;country\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) if [ -z \u0026#34;${result}\u0026#34; ]; then continue else echo -e \u0026#34;\\e[32mcountry: ${result}\\e[0m\u0026#34; break fi done while true; do if [ ! -f \u0026#34;${work_dir}/$file_linux\u0026#34; ]; then\techo -e \u0026#34;\\e[32m\u0026#34; if [ ${result} != \u0026#34;CN\u0026#34; ]; then\t# wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.232.tar.xz wget https://cdn.kernel.org/pub/linux/kernel/v4.x/${file_linux} else # wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/linux-4.4.232.tar.xz wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/${file_linux} fi else if [ \u0026#34;$(sha256sum ${file_linux})\u0026#34; != \u0026#34;4eae8865deaf03f0d13bf5056e258d451a468cabc5158757b247b0e43518fd34 ${file_linux}\u0026#34; ]; then rm -rf ${file_linux} continue else echo -e \u0026#34;\\e[32m${file_linux} 已下载\\e[0m\u0026#34; break; fi fi echo -e \u0026#34;\\e[0m\u0026#34; done # 判断busybox文件是否准备好 while true; do if [ ! -f \u0026#34;${work_dir}/$file_busybox\u0026#34; ]; then echo -e \u0026#34;\\e[33m\u0026#34; # wget --no-check-certificate https://busybox.net/downloads/busybox-1.32.0.tar.bz2 wget --no-check-certificate https://busybox.net/downloads/${file_busybox} echo -e \u0026#34;\\e[0m\u0026#34; else if [ \u0026#34;$(sha256sum ${file_busybox})\u0026#34; != \u0026#34;c35d87f1d04b2b153d33c275c2632e40d388a88f19a9e71727e0bbbff51fe689 ${file_busybox}\u0026#34; ]; then rm -rf ${file_busybo} continue else echo -e \u0026#34;\\e[32m$file_busybox 已下载\\e[0m\u0026#34; break; fi fi\tdone # 判断u-boot文件是否准备好 while true; do result=$(curl ipinfo.io | grep \u0026#34;country\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) if [ -z \u0026#34;${result}\u0026#34; ]; then continue else echo -e \u0026#34;\\e[32mcountry: ${result}\\e[0m\u0026#34; break fi done file_uboot=${file_vuboot} # echo \u0026#34;https://codeload.github.com/u-boot/u-boot/tar.gz/refs/tags/v2017.05\u0026#34; | awk -F \u0026#39;/\u0026#39; \u0026#39;{print $5\u0026#34;-\u0026#34;$9\u0026#34;.\u0026#34;$6}\u0026#39; | tr -d \u0026#39;v\u0026#39; while true; do if [ ! -f \u0026#34;${work_dir}/$file_uboot\u0026#34; ]; then echo -e \u0026#34;\\e[34m\u0026#34; if [ ${result} != \u0026#34;CN\u0026#34; ]; then # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/u-boot-2017.05.tar.bz2 # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/u-boot-2020.07.tar.bz2 # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/${file_uboot} # wget https://github.com/u-boot/u-boot/archive/refs/tags/v2017.05.tar.gz wget https://github.com/u-boot/u-boot/archive/refs/tags/${file_uboot} else wget https://hub.nuaa.cf/u-boot/u-boot/archive/refs/tags/${file_uboot} fi else if [ \u0026#34;$(sha256sum ${file_uboot})\u0026#34; != \u0026#34;0f94a62c460fc136aeca9bcd9fde3bb1d3f25b953e1bee96be4497a06a39ae81 ${file_uboot}\u0026#34; ]; then rm -rf ${file_uboot} continue else echo -e \u0026#34;\\e[32m$file_uboot 已下载\\e[0m\u0026#34; break fi fi echo -e \u0026#34;\\e[0m\u0026#34; done # 临时配置交叉编译环境 export ARCH=arm \u0026amp;\u0026amp; export CROSS_COMPILE=arm-linux-gnueabi-; # 判断linux内核是否解压 echo -e \u0026#34;\\e[32m\u0026#34; # kernel if [ -d \u0026#34;${work_dir}/$linux\u0026#34; ]; then echo \u0026#34;$linux exists.\u0026#34; else tar xvf ${work_dir}/$file_linux -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; # 判断busybox文件是否解压 echo -e \u0026#34;\\e[33m\u0026#34; if [ -d \u0026#34;${work_dir}/$busybox\u0026#34; ]; then echo \u0026#34;$busybox exists.\u0026#34; else tar xvf ${work_dir}/$file_busybox -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; # 判断u-boot文件是否解压 echo -e \u0026#34;\\e[34m\u0026#34; if [ -d \u0026#34;${work_dir}/${uboot}\u0026#34; ]; then echo \u0026#34;$uboot exists.\u0026#34; else if [ -f \u0026#34;${bz2_uboot}\u0026#34; ]; then tar xvf ${work_dir}/$file_uboot -C ${work_dir}; if [ -f \u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old fi elif [ -f \u0026#34;${gz_uboot}\u0026#34; ]; then tar zxvf ${work_dir}/$file_uboot -C ${work_dir}; if [ -f \u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old fi fi echo -e \u0026#34;\\e[0m\u0026#34; fi # 编译linux内核 echo -e \u0026#34;\\e[32m\u0026#34; cd ${work_dir}/${linux}; make distclean -j${jobs}; make vexpress_defconfig -j${jobs}; make zImage -j${jobs}; make modules -j${jobs}; make LOADADDR=0x60003000 uImage -j${jobs}; make dtbs -j${jobs}; # mkimage -n \u0026#39;mini2440\u0026#39; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d ${work_dir}/$linux/arch/arm/boot/zImage ${work_dir}/$linux/arch/arm/boot/uImage echo -e \u0026#34;\\e[0m\u0026#34; # 编译busybox，编译之后把\u0026#34;${busybox}/_install/*\u0026#34;拷贝到rootfs目录下 echo -e \u0026#34;\\e[33m\u0026#34; cd ${work_dir}/${busybox}; make distclean -j${jobs}; make defconfig -j${jobs}; make -j${jobs}; make install -j${jobs}; echo -e \u0026#34;\\e[0m\u0026#34; # 搭建网络开发环境 echo -e \u0026#34;\\e[95m\u0026#34; if [ ! -f \u0026#34;$Operate_Net_File\u0026#34; ]; then sudo touch ${Operate_Net_File} else echo \u0026#34;${uboot_config_file} is exists.\u0026#34; if [ ! -f \u0026#34;$Operate_Net_File.old\u0026#34; ]; then sudo cp ${Operate_Net_File} {$Operate_Net_File}.old else echo \u0026#34;${Operate_Net_File}.old is exists.\u0026#34; fi fi sudo chown ${USER}:${USER} ${Operate_Net_File} if [ ! \u0026#34;$(cat /etc/network/interfaces | grep -o \u0026#34;br0\u0026#34; | head -n 1)\u0026#34; = \u0026#34;br0\u0026#34; ]; then echo \u0026#34;debug_1\u0026#34; cat ${Operate_Net_File} \u0026gt; ${Operate_Net_File} if [ \u0026#34;$(ip addr | grep -o \u0026#34;ens33\u0026#34; | head -n 1)\u0026#34; = \u0026#34;ens33\u0026#34; ]; then echo \u0026#34;auto lo\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface lo inet loopback\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto ens33\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto br0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface br0 inet dhcp\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\tbridge_ports ens33\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} sudo chown ${root}:${root} ${Operate_Net_File} sudo /etc/init.d/networking restart else if [ \u0026#34;$(ip addr | grep -o \u0026#34;eth0\u0026#34;)\u0026#34; = \u0026#34;eth0\u0026#34; ]; then echo \u0026#34;auto lo\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface lo inet loopback\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto eth0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto br0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface br0 inet dhcp\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\tbridge_ports eth0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File}\tsudo /etc/init.d/networking restart fi fi else echo \u0026#34;br0 exists.\u0026#34; fi if [ \u0026#34;$(ifconfig | grep -wo \u0026#34;br0\u0026#34;)\u0026#34; = \u0026#34;br0\u0026#34; ]; then of_ip_var1=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;); echo ${of_ip_var1} of_ip_var2=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $2}\u0026#39;); echo ${of_ip_var2} of_ip_var3=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $3}\u0026#39;); echo ${of_ip_var3} of_ip_var4=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $4}\u0026#39;); echo ${of_ip_var4} else echo \u0026#34;The br0 not exists.\u0026#34; fi sudo chown ${USER}:${USER} ${Operate_Net_File} if [ ! -f \u0026#34;${uboot_config_file}.old\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old else cat ${uboot_config_file}.old \u0026gt; ${uboot_config_file} fi uboot_config_file_var1=$(grep -n \u0026#34;\\/\\* Basic environment settings \\*\\/\u0026#34; ${uboot_config_file}.old | tr \u0026#39;:\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $1}\u0026#39;) uboot_config_file_var2=$((uboot_config_file_var1 + 1)) cat ${uboot_config_file}.old \u0026gt; ${uboot_config_file} sed -i \u0026#39;/CONFIG_BOOTCOMMAND\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#39;/run distro_bootcmd\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#39;/run bootflash\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_SERVERIP ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.${of_ip_var4}\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_NETMASK 255.255.255.0\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_IPADDR ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.223\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\/* netmask */\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_BOOTCOMMAND \\\u0026#34;tftp 0x60003000 uImage;tftp 0x60500000 vexpress-v2p-ca9.dtb;setenv bootargs \u0026#39;root=/dev/mmcblk0 console=ttyAMA0\u0026#39;;bootm 0x60003000 - 0x60500000;\\\u0026#34; \\\\\u0026#34; ${uboot_config_file} echo -e \u0026#34;\\e[0m\u0026#34; # 编译u-boot，编译之后会在${uboot}目录下出现u-boot，传真u-boot示例：sudo qemu-system-arm -M vexpress-a9 -m 256 -kernel ./u-boot -nographic echo -e \u0026#34;\\e[34m\u0026#34; cd ${work_dir}/${uboot}; make distclean -j${jobs}; make vexpress_ca9x4_defconfig -j${jobs}; make -j${jobs}; echo -e \u0026#34;\\e[0m\u0026#34; # 准备根文件系统 echo -e \u0026#34;\\e[33m\u0026#34; cd ${work_dir}; mkdir -p ${work_dir}/rootfs/{dev,etc/init.d,lib,mnt}; sudo cp -vrf ${work_dir}/${busybox}/_install/* ${work_dir}/rootfs/; sudo cp -vrf /usr/arm-linux-gnueabi/lib/* ${work_dir}/rootfs/lib/; cd ${work_dir}/rootfs/dev; # 创建字符设备类型的设备节点，这些设备节点的主设备号为4,次设备号为1..11 sudo mknod -m 666 console c 4 1; sudo mknod -m 666 null c 4 2; sudo mknod -m 666 tty1 c 4 3; sudo mknod -m 666 tty2 c 4 4; sudo mknod -m 666 tty3 c 4 5; sudo mknod -m 666 tty4 c 4 6; sudo mknod -m 666 tty5 c 4 7; sudo mknod -m 666 tty6 c 4 8; sudo mknod -m 666 tty7 c 4 9; sudo mknod -m 666 tty8 c 4 10; sudo mknod -m 666 tty9 c 4 11; # 在rootfs目录下准备挂载NFS脚本 sudo touch ${work_dir}/rootfs/mountNFS.sh sudo chown ${USER}:${USER} ${work_dir}/rootfs/mountNFS.sh cat ${work_dir}/rootfs/mountNFS.sh \u0026gt; ${work_dir}/rootfs/mountNFS.sh echo \u0026#34;ifconfig eth0 ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.223\u0026#34; \u0026gt;\u0026gt; ${work_dir}/rootfs/mountNFS.sh echo \u0026#34;mount -t nfs -o nolock ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.${of_ip_var4}:${work_dir} /mnt\u0026#34; \u0026gt;\u0026gt; ${work_dir}/rootfs/mountNFS.sh sudo chown ${root}:${root} ${work_dir}/rootfs/mountNFS.sh # 进入qemu运行的虚拟机后通过以下命令运行脚本进行挂载nfs：\u0026#34;sh mountNFS.sh\u0026#34; cd ${work_dir}; # 制作rootfs.ext3，格式化rootfs.ext3为ext3文件系统类型，将rootfs.ext3挂载到/mnt，再将根文件系统拷贝到/mnt，然后解除/mnt挂载的rootfs.ext3，此时rootfs.ext3中已经有根文件系统了 sudo dd if=/dev/zero of=rootfs.ext3 bs=1M count=32 sudo mkfs.ext3 rootfs.ext3 sudo mount -t ext3 rootfs.ext3 /mnt -o loop sudo cp -vrf ${work_dir}/rootfs/* /mnt sudo umount /mnt echo -e \u0026#34;\\e[0m\u0026#34; # tftpboot echo -e \u0026#34;\\e[96m\u0026#34; # sudo chmod 775 $work_dir/$uboot/uImage; sudo rm -rf /tftpboot/* sudo cp -f ${work_dir}/${linux}/arch/arm/boot/zImage /tftpboot; sudo cp -f ${work_dir}/${linux}/arch/arm/boot/uImage /tftpboot; sudo cp -f ${work_dir}/${linux}/arch/arm/boot/dts/vexpress-v2p-ca9.dtb /tftpboot; sudo cp -f ${work_dir}/${uboot}/u-boot /tftpboot; sudo cp -f ${work_dir}/rootfs.ext3 /tftpboot; echo -e \u0026#34;\\e[0m\u0026#34; # QEMU运行虚拟机，通过sd卡加载linux内核 echo -e \u0026#34;\\e[92m\u0026#34; # qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd ${work_dir}/rootfs.ext3; # 在脚本外部执行，进入yenao_qemu_test目录执行下面的语句 # qemu-system-arm -M vexpress-a9 -m 512M -kernel linux-4.4.232/arch/arm/boot/zImage -dtb linux-4.4.232/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd rootfs.ext3 # QEMU运行虚拟机，只加载u-boot # qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/${uboot}/u-boot -nographic # 通过 u-boot 加载内核 # cd /tftpboot # sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 if [ \u0026#34;$1\u0026#34; = \u0026#34;sd\u0026#34; ]; then # QEMU运行虚拟机，通过sd卡加载linux内核\tsudo qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd ${work_dir}/rootfs.ext3;\telif [ \u0026#34;$1\u0026#34; = \u0026#34;u-boot\u0026#34; ]; then cd /tftpboot sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 elif [ \u0026#34;$1\u0026#34; = \u0026#34;help\u0026#34; ]; then echo \u0026#34;sd start: ${cmdself} sd\u0026#34; echo \u0026#34;u-boot start: ${cmdself} u-boot\u0026#34; echo \u0026#34;out sd start var: ${cmdself} out sd\u0026#34; echo \u0026#34;out u-boot start var: ${cmdself} out u-boot\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;out\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;sd\u0026#34; ]; then echo \u0026#34; qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \\\u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\\\u0026#34; -sd ${work_dir}/rootfs.ext3;\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;out\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;u-boot\u0026#34; ]; then echo \u0026#34;sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3\u0026#34; else # 默认通过u-boot加载linux内核 cd /tftpboot sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 fi echo -e \u0026#34;\\e[0m\u0026#34; # 部分参数说明 # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | 参数 | 含义 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | M vexpress-a9` | 指定虚拟机的机型为 `vexpress-a9`，即使用 ARMv7 架构的 Versatile Express 开发板模型。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | m 512M` | 设置虚拟机的内存大小为 512MB。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | kernel ${work_dir}/$linux/arch/arm/boot/zImage` | 指定 Linux 内核镜像的路径和文件名。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb` | 指定设备树二进制文件（Device Tree Blob）的路径和文件名。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | nographic` | 以无图形界面的方式运行虚拟机。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34;` | 指定 Linux 内核启动参数，包括根文件系统的设备路径、读写权限和控制台终端。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| # | sd ${work_dir}/rootfs.ext3` | 指定虚拟机的根文件系统镜像路径和文件名。 | # |----------------------------------------------------------------+--------------------------------------------------------------------------------------| 内核编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 判断linux内核是否准备好 while true; do result=$(curl ipinfo.io | grep \u0026#34;country\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) if [ -z \u0026#34;${result}\u0026#34; ]; then continue else echo -e \u0026#34;\\e[32mcountry: ${result}\\e[0m\u0026#34; break fi done while true; do if [ ! -f \u0026#34;${work_dir}/$file_linux\u0026#34; ]; then\techo -e \u0026#34;\\e[32m\u0026#34; if [ ${result} != \u0026#34;CN\u0026#34; ]; then\t# wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.232.tar.xz wget https://cdn.kernel.org/pub/linux/kernel/v4.x/${file_linux} else # wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/linux-4.4.232.tar.xz wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/${file_linux} fi else if [ \u0026#34;$(sha256sum ${file_linux})\u0026#34; != \u0026#34;4eae8865deaf03f0d13bf5056e258d451a468cabc5158757b247b0e43518fd34 ${file_linux}\u0026#34; ]; then rm -rf ${file_linux} continue else echo -e \u0026#34;\\e[32m${file_linux} 已下载\\e[0m\u0026#34; break; fi fi echo -e \u0026#34;\\e[0m\u0026#34; done # 临时配置交叉编译环境 export ARCH=arm \u0026amp;\u0026amp; export CROSS_COMPILE=arm-linux-gnueabi-; # 判断linux内核是否解压 echo -e \u0026#34;\\e[34m\u0026#34; # kernel if [ -d \u0026#34;${work_dir}/$linux\u0026#34; ]; then echo \u0026#34;$linux exists.\u0026#34; else tar xvf ${work_dir}/$file_linux -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 编译linux内核 echo -e \u0026#34;\\e[32m\u0026#34; cd ${work_dir}/${linux}; make distclean -j${jobs}; make vexpress_defconfig -j${jobs}; make zImage -j${jobs}; make modules -j${jobs}; make LOADADDR=0x60003000 uImage -j${jobs}; make dtbs -j${jobs}; # mkimage -n \u0026#39;mini2440\u0026#39; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d ${work_dir}/$linux/arch/arm/boot/zImage ${work_dir}/$linux/arch/arm/boot/uImage echo -e \u0026#34;\\e[0m\u0026#34; sudo cp -vf ${work_dir}/${linux}/arch/arm/boot/zImage /tftpboot; sudo cp -vf ${work_dir}/${linux}/arch/arm/boot/uImage /tftpboot; sudo cp -vf ${work_dir}/${linux}/arch/arm/boot/dts/vexpress-v2p-ca9.dtb /tftpboot; busybox 编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 判断busybox文件是否准备好 while true; do if [ ! -f \u0026#34;${work_dir}/$file_busybox\u0026#34; ]; then echo -e \u0026#34;\\e[33m\u0026#34; # wget --no-check-certificate https://busybox.net/downloads/busybox-1.32.0.tar.bz2 wget --no-check-certificate https://busybox.net/downloads/${file_busybox} echo -e \u0026#34;\\e[0m\u0026#34; else if [ \u0026#34;$(sha256sum ${file_busybox})\u0026#34; != \u0026#34;c35d87f1d04b2b153d33c275c2632e40d388a88f19a9e71727e0bbbff51fe689 ${file_busybox}\u0026#34; ]; then rm -rf ${file_busybo} continue else echo -e \u0026#34;\\e[32m$file_busybox 已下载\\e[0m\u0026#34; break; fi fi\tdone # 临时配置交叉编译环境 export ARCH=arm \u0026amp;\u0026amp; export CROSS_COMPILE=arm-linux-gnueabi-; # 判断busybox文件是否解压 echo -e \u0026#34;\\e[33m\u0026#34; if [ -d \u0026#34;${work_dir}/$busybox\u0026#34; ]; then echo \u0026#34;$busybox exists.\u0026#34; else tar xvf ${work_dir}/$file_busybox -C ${work_dir}; fi echo -e \u0026#34;\\e[0m\u0026#34; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 编译busybox cd ${work_dir}/${busybox}; make distclean -j${jobs}; make defconfig -j${jobs}; make -j${jobs}; make install -j${jobs}; rootfs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) if [ $(ifconfig | grep -w \u0026#34;br0\u0026#34; | awk \u0026#39;{print $1}\u0026#39;) = \u0026#34;br0\u0026#34; ]; then of_ip_var1=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;); echo ${of_ip_var1} of_ip_var2=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $2}\u0026#39;); echo ${of_ip_var2} of_ip_var3=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $3}\u0026#39;); echo ${of_ip_var3} of_ip_var4=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $4}\u0026#39;); echo ${of_ip_var4} else echo \u0026#34;The br0 not exists.\u0026#34; fi # 准备根文件系统 cd ${work_dir}; mkdir -p ${work_dir}/rootfs/{dev,etc/init.d,lib,mnt}; sudo cp -vrf ${work_dir}/${busybox}/_install/* ${work_dir}/rootfs/; sudo cp -vrf /usr/arm-linux-gnueabi/lib/* ${work_dir}/rootfs/lib/; cd ${work_dir}/rootfs/dev; # 创建字符设备类型的设备节点，这些设备节点的主设备号为4,次设备号为1..11 sudo mknod -m 666 console c 4 1; sudo mknod -m 666 null c 4 2; sudo mknod -m 666 tty1 c 4 3; sudo mknod -m 666 tty2 c 4 4; sudo mknod -m 666 tty3 c 4 5; sudo mknod -m 666 tty4 c 4 6; sudo mknod -m 666 tty5 c 4 7; sudo mknod -m 666 tty6 c 4 8; sudo mknod -m 666 tty7 c 4 9; sudo mknod -m 666 tty8 c 4 10; sudo mknod -m 666 tty9 c 4 11; # 在rootfs目录下准备挂载NFS脚本 sudo touch ${work_dir}/rootfs/mountNFS.sh sudo chown ${USER}:${USER} ${work_dir}/rootfs/mountNFS.sh cat ${work_dir}/rootfs/mountNFS.sh \u0026gt; ${work_dir}/rootfs/mountNFS.sh echo \u0026#34;ifconfig eth0 ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.223\u0026#34; \u0026gt;\u0026gt; ${work_dir}/rootfs/mountNFS.sh echo \u0026#34;mount -t nfs -o nolock ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.${of_ip_var4}:${work_dir} /mnt\u0026#34; \u0026gt;\u0026gt; ${work_dir}/rootfs/mountNFS.sh sudo chown ${root}:${root} ${work_dir}/rootfs/mountNFS.sh # 进入qemu运行的虚拟机后通过以下命令运行脚本进行挂载nfs：\u0026#34;sh mountNFS.sh\u0026#34; cd ${work_dir}; # 制作rootfs.ext3，格式化rootfs.ext3为ext3文件系统类型，将rootfs.ext3挂载到/mnt，再将根文件系统拷贝到/mnt，然后解除/mnt挂载的rootfs.ext3，此时rootfs.ext3中已经有根文件系统了 sudo dd if=/dev/zero of=rootfs.ext3 bs=1M count=32 sudo mkfs.ext3 rootfs.ext3 sudo mount -t ext3 rootfs.ext3 /mnt -o loop sudo cp -vrf ${work_dir}/rootfs/* /mnt sudo umount /mnt sudo cp -vf ${work_dir}/rootfs.ext3 /tftpboot u-boot 编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; vuboot=\u0026#34;v2017.05\u0026#34; git_uboot=\u0026#34;v\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; file_vuboot=\u0026#34;${vuboot}.tar.gz\u0026#34; bz2_uboot=\u0026#34;${file_uboot}\u0026#34; gz_uboot=\u0026#34;${file_vuboot}\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 临时配置交叉编译环境 export ARCH=arm \u0026amp;\u0026amp; export CROSS_COMPILE=arm-linux-gnueabi-; # 判断u-boot文件是否准备好 while true; do result=$(curl ipinfo.io | grep \u0026#34;country\u0026#34; | tr \u0026#39;\u0026#34;\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $3}\u0026#39;) if [ -z \u0026#34;${result}\u0026#34; ]; then continue else echo -e \u0026#34;\\e[32mcountry: ${result}\\e[0m\u0026#34; break fi done file_uboot=${file_vuboot} # echo \u0026#34;https://codeload.github.com/u-boot/u-boot/tar.gz/refs/tags/v2017.05\u0026#34; | awk -F \u0026#39;/\u0026#39; \u0026#39;{print $5\u0026#34;-\u0026#34;$9\u0026#34;.\u0026#34;$6}\u0026#39; | tr -d \u0026#39;v\u0026#39; while true; do if [ ! -f \u0026#34;${work_dir}/$file_uboot\u0026#34; ]; then echo -e \u0026#34;\\e[34m\u0026#34; if [ ${result} != \u0026#34;CN\u0026#34; ]; then # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/u-boot-2017.05.tar.bz2 # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/u-boot-2020.07.tar.bz2 # wget --no-check-certificate https://ftp.denx.de/pub/u-boot/${file_uboot} # wget https://github.com/u-boot/u-boot/archive/refs/tags/v2017.05.tar.gz wget https://github.com/u-boot/u-boot/archive/refs/tags/${file_uboot} else wget https://hub.nuaa.cf/u-boot/u-boot/archive/refs/tags/${file_uboot} fi else if [ \u0026#34;$(sha256sum ${file_uboot})\u0026#34; != \u0026#34;0f94a62c460fc136aeca9bcd9fde3bb1d3f25b953e1bee96be4497a06a39ae81 ${file_uboot}\u0026#34; ]; then rm -rf ${file_uboot} continue else echo -e \u0026#34;\\e[32m$file_uboot 已下载\\e[0m\u0026#34; break fi fi echo -e \u0026#34;\\e[0m\u0026#34; done # 判断u-boot文件是否解压 echo -e \u0026#34;\\e[34m\u0026#34; if [ -d \u0026#34;${work_dir}/${uboot}\u0026#34; ]; then echo \u0026#34;$uboot exists.\u0026#34; else if [ -f \u0026#34;${bz2_uboot}\u0026#34; ]; then tar xvf ${work_dir}/$file_uboot -C ${work_dir}; if [ -f \u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old fi elif [ -f \u0026#34;${gz_uboot}\u0026#34; ]; then tar zxvf ${work_dir}/$file_uboot -C ${work_dir}; if [ -f \u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old fi fi echo -e \u0026#34;\\e[0m\u0026#34; fi cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 编译u-boot，编译之后会在${uboot}目录下出现u-boot，传真u-boot示例：sudo qemu-system-arm -M vexpress-a9 -m 256 -kernel ./u-boot -nographic cd ${work_dir}/${uboot}; make distclean -j${jobs}; make vexpress_ca9x4_defconfig -j${jobs}; make -j${jobs}; sudo cp -vf ${work_dir}/${uboot}/u-boot /tftpboot; 搭建网络开发环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) # 搭建网络开发环境 echo -e \u0026#34;\\e[95m\u0026#34; if [ ! -f \u0026#34;$Operate_Net_File\u0026#34; ]; then sudo touch ${Operate_Net_File} else echo \u0026#34;${uboot_config_file} is exists.\u0026#34; if [ ! -f \u0026#34;$Operate_Net_File.old\u0026#34; ]; then sudo cp ${Operate_Net_File} {$Operate_Net_File}.old else echo \u0026#34;${Operate_Net_File}.old is exists.\u0026#34; fi fi sudo chown ${USER}:${USER} ${Operate_Net_File} if [ ! \u0026#34;$(cat /etc/network/interfaces | grep -o \u0026#34;br0\u0026#34; | head -n 1)\u0026#34; = \u0026#34;br0\u0026#34; ]; then echo \u0026#34;debug_1\u0026#34; cat ${Operate_Net_File} \u0026gt; ${Operate_Net_File} if [ \u0026#34;$(ip addr | grep -o \u0026#34;ens33\u0026#34; | head -n 1)\u0026#34; = \u0026#34;ens33\u0026#34; ]; then echo \u0026#34;auto lo\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface lo inet loopback\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto ens33\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto br0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface br0 inet dhcp\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\tbridge_ports ens33\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} sudo chown ${root}:${root} ${Operate_Net_File} sudo /etc/init.d/networking restart else if [ \u0026#34;$(ip addr | grep -o \u0026#34;eth0\u0026#34;)\u0026#34; = \u0026#34;eth0\u0026#34; ]; then echo \u0026#34;auto lo\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface lo inet loopback\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto eth0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;auto br0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;iface br0 inet dhcp\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File} echo \u0026#34;\tbridge_ports eth0\u0026#34; \u0026gt;\u0026gt; ${Operate_Net_File}\tsudo /etc/init.d/networking restart fi fi else echo \u0026#34;br0 exists.\u0026#34; fi if [ \u0026#34;$(ifconfig | grep -wo \u0026#34;br0\u0026#34;)\u0026#34; = \u0026#34;br0\u0026#34; ]; then of_ip_var1=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;); echo ${of_ip_var1} of_ip_var2=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $2}\u0026#39;); echo ${of_ip_var2} of_ip_var3=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $3}\u0026#39;); echo ${of_ip_var3} of_ip_var4=$(ifconfig | grep -w -A 1 \u0026#34;br0\u0026#34; | grep -v \u0026#34;br0\u0026#34; | awk \u0026#39;$1==\u0026#34;inet\u0026#34; {print $2}\u0026#39; | grep -oE \u0026#34;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#34; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $4}\u0026#39;); echo ${of_ip_var4} else echo \u0026#34;The br0 not exists.\u0026#34; fi sudo chown ${USER}:${USER} ${Operate_Net_File} if [ ! -f \u0026#34;${uboot_config_file}.old\u0026#34; ]; then cp ${uboot_config_file} ${uboot_config_file}.old else cat ${uboot_config_file}.old \u0026gt; ${uboot_config_file} fi uboot_config_file_var1=$(grep -n \u0026#34;\\/\\* Basic environment settings \\*\\/\u0026#34; ${uboot_config_file}.old | tr \u0026#39;:\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{print $1}\u0026#39;) uboot_config_file_var2=$((uboot_config_file_var1 + 1)) cat ${uboot_config_file}.old \u0026gt; ${uboot_config_file} sed -i \u0026#39;/CONFIG_BOOTCOMMAND\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#39;/run distro_bootcmd\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#39;/run bootflash\\b/d\u0026#39; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_SERVERIP ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.${of_ip_var4}\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_NETMASK 255.255.255.0\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_IPADDR ${of_ip_var1}.${of_ip_var2}.${of_ip_var3}.223\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\/* netmask */\u0026#34; ${uboot_config_file} sed -i \u0026#34;${uboot_config_file_var2}i\\#define CONFIG_BOOTCOMMAND \\\u0026#34;tftp 0x60003000 uImage;tftp 0x60500000 vexpress-v2p-ca9.dtb;setenv bootargs \u0026#39;root=/dev/mmcblk0 console=ttyAMA0\u0026#39;;bootm 0x60003000 - 0x60500000;\\\u0026#34; \\\\\u0026#34; ${uboot_config_file} 启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 cmdself=$0 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) sudo rm -rf /tftpboot/* sudo cp -f ${work_dir}/${linux}/arch/arm/boot/zImage /tftpboot; sudo cp -f ${work_dir}/${linux}/arch/arm/boot/uImage /tftpboot; sudo cp -f ${work_dir}/${linux}/arch/arm/boot/dts/vexpress-v2p-ca9.dtb /tftpboot; sudo cp -f ${work_dir}/${uboot}/u-boot /tftpboot; sudo cp -f ${work_dir}/rootfs.ext3 /tftpboot; if [ \u0026#34;$1\u0026#34; = \u0026#34;sd\u0026#34; ]; then # QEMU运行虚拟机，通过sd卡加载linux内核\tsudo qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\u0026#34; -sd ${work_dir}/rootfs.ext3;\telif [ \u0026#34;$1\u0026#34; = \u0026#34;u-boot\u0026#34; ]; then cd /tftpboot sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 elif [ \u0026#34;$1\u0026#34; = \u0026#34;help\u0026#34; ]; then echo \u0026#34;sd start: ${cmdself} sd\u0026#34; echo \u0026#34;u-boot start: ${cmdself} u-boot\u0026#34; echo \u0026#34;out sd start var: ${cmdself} out sd\u0026#34; echo \u0026#34;out u-boot start var: ${cmdself} out u-boot\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;out\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;sd\u0026#34; ]; then echo \u0026#34; qemu-system-arm -M vexpress-a9 -m 256M -kernel ${work_dir}/$linux/arch/arm/boot/zImage -dtb ${work_dir}/$linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append \\\u0026#34;root=/dev/mmcblk0 rw console=ttyAMA0\\\u0026#34; -sd ${work_dir}/rootfs.ext3;\u0026#34; elif [ \u0026#34;$1\u0026#34; = \u0026#34;out\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$2\u0026#34; = \u0026#34;u-boot\u0026#34; ]; then echo \u0026#34;sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3\u0026#34; else # 默认通过u-boot加载linux内核 cd /tftpboot sudo qemu-system-arm -M vexpress-a9 -kernel u-boot -nographic -m 128M -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 -sd rootfs.ext3 fi 开发环境 1 2 # 临时配置交叉编译环境 export ARCH=arm \u0026amp;\u0026amp; export CROSS_COMPILE=arm-linux-gnueabi-; qemu_ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 linux=\u0026#34;linux-4.4.232\u0026#34;; # linux=\u0026#34;linux-4.4.76\u0026#34;; busybox=\u0026#34;busybox-1.32.0\u0026#34;; uboot=\u0026#34;u-boot-2017.05\u0026#34; # uboot=\u0026#34;u-boot-2020.07\u0026#34; file_linux=\u0026#34;${linux}.tar.xz\u0026#34;; file_busybox=\u0026#34;${busybox}.tar.bz2\u0026#34;; file_uboot=\u0026#34;${uboot}.tar.bz2\u0026#34; work_dir_name=\u0026#34;yenao_qemu_test\u0026#34;; work_dir=\u0026#34;${HOME}/${work_dir_name}\u0026#34;; Operate_Net_File=\u0026#34;/etc/network/interfaces\u0026#34; uboot_config_file=\u0026#34;${work_dir}/${uboot}/include/configs/vexpress_common.h\u0026#34; mkdir -p ${work_dir}; cd ${work_dir}; cpu_cores=$(nproc) jobs=$((cpu_cores * 2)) 参考链接 使用qemu搭建arm嵌入式linux开发环境\n使用QEMU搭建u-boot+Linux+NFS嵌入式开发环境\nZYNQ：加速 PetaLinux 工程编译、复制 PetaLinux 工程\n一步步教你：如何用Qemu来模拟ARM系统\n深入理解 Linux 启动过程 | QEMU 启动 linux 内核和自制根文件系统\nqemu安装及设备添加\nlinux内核设备树修改指南 / linux kernel device tree modify guide\nLinux设备树系列-GPIO驱动实践\nLinux内核设备驱动设备树概念与使用\n初学者教程：修改和理解设备树（dts）\n【嵌入式Linux驱动入门】一、基于QEMU的IMX6ULL虚拟开发环境搭建\n","date":"2023-09-14T07:37:20+08:00","permalink":"https://ynhugo.github.io/p/%E4%BD%BF%E7%94%A8qemu%E6%90%AD%E5%BB%BAarm%E5%B5%8C%E5%85%A5%E5%BC%8Flinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","title":"使用qemu搭建arm嵌入式linux开发环境"},{"content":" 1.卸载原有版本* 1 sudo apt-get remove docker docker-engine docker-ce docker.io 如果需要删除所有镜像，容器和卷（第一次安装请忽略）：\n1 sudo rm -rf /var/lib/docker 备注：apt-get remove会保留软件的配置文件如果想删除请执行以下操作\n查看相关软件包是否有残余：\n1 dpkg -l | grep docker 使用purage清除配置文件：\n1 sudo apt-get purge docker-ce 2.更新索引包* 1 sudo apt-get update 3.安装添加使用 HTTPS 传输的软件包* 1 sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common 4.添加软件源的GPG密钥（本人选择的中科大）* 中科大：\n1 curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 阿里云：\n1 curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 官方源：\n1 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 5.向 source.list 中添加Docker软件源（本人选择的中科大）* 中科大源：\n1 sudo add-apt-repository \u0026#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable\u0026#34; 阿里源：\n1 sudo add-apt-repository \u0026#34;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\u0026#34; 官方源：\n1 sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; 6.再次更新索引包* 1 sudo apt-get update 若想直接安装最新版本执行以下命令即可\n1 sudo apt-get install docker-ce 7.查看docker版本* 1 apt-cache madison docker-ce 8.安装指定版本* 格式为：\n1 sudo apt-get install docker-ce=\u0026lt;VERSION\u0026gt; 例如：\n1 sudo apt-get install docker-ce=18.06.3~ce~3-0~ubuntu 9.启动后台服务* 1 sudo service docker start 10.查看Docker版本信息* 1 docker version 11.镜像加速* 新版的 Docker 使用 /etc/docker/daemon.json 来配置 Daemon。\n请在该配置文件中加入（没有该文件的话，请先建一个）Docker中国官方加速：\n1 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.docker-cn.com\u0026#34;]} 重启Docker使之生效：\n1 sudo service docker restart 如果想添加其它加速源，请移步该博客查看：https://blog.csdn.net/M82_A1/article/details/91957886\n12.添加当前用户到docker组（可选）* 创建docker组：\n1 sudo groupadd docker 当前用户加入docker组：\n1 sudo usermod -aG docker $USER 检查创建是否有效：\n1 cat /etc/group 重启docker：\n1 sudo systemctl restart docker 参考链接 Ubuntu使用国内源安装指定Docker版本（完整教程）\n","date":"2023-09-10T16:19:32+08:00","permalink":"https://ynhugo.github.io/p/ubuntu%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%BA%90%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9Adocker%E7%89%88%E6%9C%AC%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/","title":"Ubuntu使用国内源安装指定docker版本完整教程"},{"content":" 将ubuntu打包成docker镜像 这种方法打包的镜像会特别大，如果 ubuntu 虚拟机进行这些操作，可能因为空间不足而失败。所以有条件情况下，从头做个对应的镜像会更舒服一些。\n第一步：进入系统，运行以下命令 1 2 3 sudo su cd / tar -cvpzf /media/system.tar --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/media / 压缩到最后会提示:\n1 tar: 由于前次错误，将以上次的错误状态退出 不会理会这个提示，正常下一步操作即可\n第二步：拷贝 system.tar 到目标主机 第三步：在目标主机上运行下行命令 1 docker import system.tar my_system_img 第四步：使用 my_system_img 镜像启动一个容器，参数为以命令行模式进入该容器 1 docker run -it my_system_img /bin/bash 第五步：Docker挂载本地目录和数据卷容器实现文件共享 1 docker run -it -v d:/share/docker:/data2 my_system_img /bin/bash 在容器启动后，容器内会自动创建/data2的目录。\n-v参数中，冒号\u0026#34;:\u0026#34;前面的目录是宿主机目录，后面的目录是容器内目录。\n冒号”:”前后的路径必须是绝对路径，以下斜线“/”开头。\n宿主机目录如果不存在，则会自动生成。\n现在镜像内就可以在宿主机和docker里互相共享文件了。\n参考链接： 将ubuntu打包成docker镜像\nDocker挂载本地目录和数据卷容器实现文件共享\n","date":"2023-09-09T23:43:26+08:00","permalink":"https://ynhugo.github.io/p/%E5%B0%86ubuntu%E6%89%93%E5%8C%85%E6%88%90docker%E9%95%9C%E5%83%8F/","title":"将ubuntu打包成docker镜像"},{"content":" windows server 2016 安装教程和镜像下载地址 阿里云盘包含： 以下两个文件下载链接：https://www.aliyundrive.com/s/jrbjUiWv5jD\n1 2 使用VMware 安装windows server 2016.md Windows Server 2016激活方法.md 镜像下载地址： Windows Server 2016 (Updated Feb 2018) (x64) – DVD (Chinese-Simplified) 文件名：cn_windows_server_2016_updated_feb_2018_x64_dvd_11636703.iso\nSHA1：8d1c867b19c4eae7dd79eb544fdd5dbfbd9812fe\n文件大小：5.86GB 发布时间：2018-02-15\n迅雷下载：\n1 ed2k://|file|cn_windows_server_2016_updated_feb_2018_x64_dvd_11636703.iso|6294265856|4077CEBEBB40AFA5A66017D2EC7A9CD5|/ Windows Server 2016 VL (x64) – DVD (Chinese-Simplified) 文件名：cn_windows_server_2016_vl_x64_dvd_11636695.iso\nSHA1：ddedf3ace182587baa268ab8ae0d9ea395a6da22\n文件大小：5.87GB 发布时间：2018-03-08\n迅雷下载：\n1 ed2k://|file|cn_windows_server_2016_vl_x64_dvd_11636695.iso|6302720000|44742A3D464B9765203E2A4DB73FF704|/ 破解版迅雷下载 秋刀鱼绿色精简版\n参考链接 windows server 2016 安装教程和镜像下载地址\n","date":"2023-09-09T21:53:23+08:00","permalink":"https://ynhugo.github.io/p/vmware%E5%AE%89%E8%A3%85windows_server_2016/","title":"Vmware安装windows_server_2016"},{"content":" 系统自带的内核树 有时，安装的系统已经自带了Linux内核树，足够用来编译驱动程序了。 自带的内核树通常位于\n1 /lib/modules/\u0026lt;系统内核版本\u0026gt;/build 其中，系统内核版本可以用uname -r来查看\n1 2 $ uname -r 5.11.0-41-generic 环境配置 初次配置内核树要先安装一些必要的环境\n1 sudo apt-get build-dep linux linux-image-$(uname -r) 如果报错Error :: You must put some ‘source‘ URIs in your sources.list，请按照如下操作进行。 解决方法 输入下面三行即可。\n1 2 3 sudo cp /etc/apt/sources.list /etc/apt/sources.list~ sudo sed -Ei \u0026#39;s/^# deb-src /deb-src /\u0026#39; /etc/apt/sources.list sudo apt-get update 除了上面的环境之外，还要安装这些\n1 sudo apt-get install libncurses-dev gawk flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf dwarves 下载源码 1 sudo apt-get source linux-image-unsigned-$(uname -r) 这一步结束之后，会多出三个文件（可以删除），\n1 2 3 linux-hwe-5.11_5.11.0-41.45~20.04.1.diff.gz linux-hwe-5.11_5.11.0-41.45~20.04.1.dsc linux-hwe-5.11_5.11.0.orig.tar.gz 以及一个文件夹（内核源码所在的文件夹）\n1 linux-hwe-5.11-5.11.0 （注：文件名称根据不同的系统版本会有所不同）\n构建准备 （注：任何时候，运行命令时遇见了permission denied，只需要在命令开头加上sudo后重新运行即可） 进入linux-hwe-5.11-5.11.0文件夹，输入\n1 make menuconfig 什么都不用修改，直接关闭界面即可（方向键选择Exit然后回车，或者连续按两下Esc就能退出），在退出的时候会提示是否保存，按照提示保存一下，这样会在当前目录下生成一个.config文件（输入ls -a就能找到这个文件），保证稍后的make能够顺利执行。\n构建内核 为了防止make中的make modules_install环节失败， 请先运行下面的命令\n1 sudo scripts/config --set-str SYSTEM_TRUSTED_KEYS \u0026#34;\u0026#34; 输入下面的命令开始构建（如遇见permission denied，在命令开头加上sudo后重新运行即可）\n1 make 这里要狠狠地等一会儿，一般要一到数个小时。可以通过-j \u0026lt;最大并发任务数\u0026gt;命令，使用并发来提速。最大并发任务数一般可以是CPU数量的两倍。 注：通过使用make help进行查阅可以发现，在输入make时，会自动执行 1）make vmlinux（构建原始内核） 2）make bzImage（构建压缩的内核）和 3） make modules（单独构建模块化的驱动）这三个动作）\n安装模块 最后，把模块安装到/lib/modules/$(uname -r)目录\n1 sudo make modules_install 参考链接： link:https://blog.csdn.net/weixin_39591031/article/details/121710076 link:https://blog.csdn.net/weixin_39591031/article/details/121696825\n","date":"2023-09-08T23:19:12+08:00","permalink":"https://ynhugo.github.io/p/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/","title":"Linux内核编译"},{"content":" Linux设备驱动程序-中文第三版\n","date":"2023-09-01T22:43:08+08:00","permalink":"https://ynhugo.github.io/p/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-%E4%B8%AD%E6%96%87%E7%AC%AC%E4%B8%89%E7%89%88/","title":"Linux设备驱动程序 中文第三版"},{"content":" 参考链接 Ubuntu tmux 配置\n创建tmux配置文件 touch ~/.tmux.conf\n配置文件代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Send prefix set-option -g prefix C-a unbind-key C-a bind-key C-a send-prefix # Use Alt-arrow keys to switch panes bind -n M-Left select-pane -L bind -n M-Right select-pane -R bind -n M-Up select-pane -U bind -n M-Down select-pane -D # Shift arrow to switch windows bind -n S-Left previous-window bind -n S-Right next-window # Mouse mode set -g mouse on # Set easier window split keys bind-key v split-window -h bind-key h split-window -v # Easy config reload bind-key r source-file ~/.tmux.conf \\; display-message \u0026#34;tmux.conf reloaded\u0026#34; 修改Tmux的Ctrl+B前缀快捷键 在电脑上ctrl+b是往前移动一个字符\n1.查看prefix现有绑定键：\n1 tmux show-options -g | grep prefix 2.要在tmux内置命令中修改及时生效，可在终端中输入以下命令：（只对当前这一次登录有效，关机后失效）其中第一个-g设置全局生效快捷键。其实一般第一个设置好后新的快捷键就可以生效，如果需要再使用第二个和第三个命令。\n1 2 3 4 5 tmux set -g prefix C-x tmux unbind C-b tmux bind C-x send-prefix 3.要永久生效，则在创建或修改系统级的/etc/tmux.conf或用户级的~/.tmux.conf 首先打开文件：\n1 vim ~/.tmux.conf 然后在文件中输入三个命令\n1 2 3 4 5 set -g prefix C-x unbind C-b bind C-x send-prefix 然后让他生效：\n1 source ~/.tmux.conf 或者重启也可以让他生效\n参考链接 修改Tmux的Ctrl+B前缀快捷键\n","date":"2023-08-31T07:10:08+08:00","permalink":"https://ynhugo.github.io/p/tmux_conf/","title":"Tmux_conf"},{"content":" Linux_From_Scratch_版本_11.3_中文翻译版_由_Gerard_Beekmans_原著和总编辑.pdf\n","date":"2023-08-29T23:15:52+08:00","permalink":"https://ynhugo.github.io/p/lfs/","title":"LFS"},{"content":"","date":"2023-07-30T15:01:00+08:00","permalink":"https://ynhugo.github.io/p/%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%E6%9C%AC/","title":"在线笔记本"},{"content":"我的OneDrive_应用(提取码：9527) 多个绿色软件下载站 破解软件 激活版 去广告 绿色版 免安装版 全网好资源 https://www.downgc.com/ http://www.downxia.com/ https://www.ghxi.com/ https://www.ypojie.com/ https://www.freedownloadmanager.org/zh/ https://www.onlinedown.net/ https://www.pcsoft.com.cn/ https://sourceforge.net/ keil使用技巧 1.在进行keil工程的Manage Project Items的分组设置时 方向键下新建分组并编辑 回车确认修改 Tab选择，空格编辑，回车确认 git ```C git config --global user.name \u0026quot;name\u0026quot; git config --global user.email \u0026quot;email\u0026quot; git branch 新建分支 git checkout branch 新建分支 git add .\t//添加内容 git commit -m \u0026quot;注释\u0026quot;\t//提交内容 git push -u origin 新建分支\t//推送分支到远程仓库 ``` hexo 该内容摘自别人的博客 附链接：[next主题添加站内搜索功能](https://blog.csdn.net/Awt_FuDongLai/article/details/107435633) 如何让hexo实现搜索功能 1 安装插件 npm install hexo-generator-search --save 1 2 更改主题配置文件 cd 博客目录 vim themes/next/_config.yml #将其设置为true即可，其余的保持默认值 #Local search #Dependencies: https://github.com/flashlab/hexo-generator-search local_search: enable: true #if auto, trigger search by changing input #if manual, trigger search by pressing enter key or search button trigger: auto #show top n results per article, show all results by setting to -1 top_n_per_article: 1 重新生成即可 hexo g 如何配置hexo博客的next主题 网上有很多的next的主题配置教程，但是真正能够简单快捷、一步到位的却很少，今天浏览了一遍掘金的文章关于如何配置hexo的next主题，尝试了一下，然后成功了，记录一下。\n教程链接\nHexo 及 NexT 基本配置与使用 这篇文章主要来介绍Hexo的主题及其配置以及如何来写自己的博客。\n主题下载与应用 Hexo提供各种各样的主题，我们可以进入官网去选择自己喜欢的主题，然后在GitHub上有其具体的介绍。\n接下来我们以NexT主题为例进行介绍。\n截至目前为止，NexT主题已经从v5.1.x更新至v6.6.0，仓库也从原来的老仓库迁移到这里。因此NexT主题的很多配置都和以前不一样了，我当时在网上看的时候全是老版本的配置方法，花费了不少时间。最后发现其实可以自己看着themes下的_config.yml进行配置，很多插件都在theme-next这个仓库有。\n下载 NexT 切换到主目录，然后克隆整个仓库到themes/next：\ncd hexo git clone https://github.com/theme-next/hexo-theme-next themes/next 之后我们会发现 themes下多了个next文件夹，即我们的主题文件夹。\n配置 整个 Hexo 博客有两个主要的配置文件，第一个是主目录下的_config.yml，另一个是我们的主题配置文件，是thems/next/_config.yml。\n现在我们开始将我们下载的主题应用到我们的博客中，我们只需修改主目录下的_config.yml，如下：\n# Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 然后hexo s启动博客即可。 需要注意的是：每当我们修改了主目录下的_config.yml，只有重启博客服务才能生效；而修改thems/next/_config.yml是不需要重启博客服务的。\n同样我们可以在主目录下的_config.yml进行其他设置，我们可以看到里面有网站基本设置，如下：\ntitle: Hexo subtitle: description: keywords: author: John Doe language: timezone: 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 作者名字 language 网站语言，NexT v6.0.3以后中文设为 zh-CN 具体全部配置参考官方文档。\n我们暂时不需要全部理解其意思，只要把网站的基本描述改为你自己的就好。\n主题设定 选择 Scheme Scheme 的切换通过更改主题配置文件，打开thems/next/_config.yml，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。\n# Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新\n选择对应的外观，刷新浏览器即可预览。\n设置菜单 打开 thems/next/_config.yml ，找到如下代码\nmenu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 这里是进行菜单配置，去掉哪个注释，就会多一个相应的菜单选项。\n当需要about、tags、categories 需要手动创建这个页面，如果不创建点击则不会出现相应页面。\n使用如下命令创建这些文件夹\nhexo new page \u0026quot;about\u0026quot; hexo new page \u0026quot;tags\u0026quot; hexo new page \u0026quot;categories\u0026quot; 之后source文件夹下就会出现三个这样的文件夹。\n设置头像 打开thems/next/_config.yml，找到如下代码\navatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: #/images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 修改字段 avatar， 值设置成头像的链接地址，参考这个链接。\n以上主题设置可以参考Next文档。\ntags 和 categories 设置 当菜单中有了 tags 和 categories 时，我们需要在 Front-matter 中添加 type 属性。所谓 Front-matter 是文件最上方以 \u0026mdash; 分隔的区域，用于指定个别文件的变量。\ntags/index.md --- title: 标签 date: 2018-12-05 10:00:29 type: \u0026quot;tags\u0026quot; --- categories/index.md 同理。\n只有这样当我们新建一篇博客时，指定的tags和categories才会同步，hexo才会识别出来你的 tags 和 categories。所以接下来我们看如何新建一篇博客。\n新建博客 新建博客很简单，使用如下命令\nhexo new \u0026quot;文章题目\u0026quot; 这样就会在source目录下自动创建一个名为 文章题目.md 的文件，我们只要在这个文件上写文章就行了。同样我们需要每篇文章指定一个或多个 tags 和 一个 categories。这样你的菜单中tags 页面 和categories页面就会有内容了。\n1 2 3 4 5 6 7 8 9 --- title: 文章题目 date: 2018-12-05 15:42:22 tags: - PS3 - Games categories: - Diary --- 参考链接配置好next主题之后在博客页面底部会有由什么什么强力驱动等等内容，我不想显示这些，或者我想修改文本及链接，可以采取如下操作\n删除该路径{博客文件路径}/themes/next/layout/_partials/footer.swig文件中的如下文本\n1 2 3 4 5 6 7 8 9 {%- if theme.footer.powered %} \u0026lt;div class=\u0026#34;powered-by\u0026#34;\u0026gt; {%- set next_site = \u0026#39;https://theme-next.org\u0026#39; %} {%- if theme.scheme !== \u0026#39;Gemini\u0026#39; %} {%- set next_site = \u0026#39;https://\u0026#39; + theme.scheme | lower + \u0026#39;.theme-next.org\u0026#39; %} {%- endif %} {{- __(\u0026#39;footer.powered\u0026#39;, next_url(\u0026#39;https://hexo.io\u0026#39;, \u0026#39;Hexo\u0026#39;, {class: \u0026#39;theme-link\u0026#39;}) + \u0026#39; \u0026amp; \u0026#39; + next_url(next_site, \u0026#39;NexT.\u0026#39; + theme.scheme, {class: \u0026#39;theme-link\u0026#39;})) }} \u0026lt;/div\u0026gt; {%- endif %} 修改链接 将如下文本中的网站关键词和网站链接改成自己想要的即可\n1 2 3 4 5 6 7 8 9 {%- if theme.footer.powered %} \u0026lt;div class=\u0026#34;powered-by\u0026#34;\u0026gt; {%- set next_site = \u0026#39;https://theme-next.org\u0026#39; %} {%- if theme.scheme !== \u0026#39;Gemini\u0026#39; %} {%- set next_site = \u0026#39;https://\u0026#39; + theme.scheme | lower + \u0026#39;.theme-next.org\u0026#39; %} {%- endif %} {{- __(\u0026#39;footer.powered\u0026#39;, next_url(\u0026#39;https://hexo.io\u0026#39;, \u0026#39;Hexo\u0026#39;, {class: \u0026#39;theme-link\u0026#39;}) + \u0026#39; \u0026amp; \u0026#39; + next_url(next_site, \u0026#39;NexT.\u0026#39; + theme.scheme, {class: \u0026#39;theme-link\u0026#39;})) }} \u0026lt;/div\u0026gt; {%- endif %} windows使用技巧 系统： 如何将kali linux安装在u盘上？ 进入kali.org官网下载Live Boot，然后用rufus刻录到u盘上，rufus界面默认设置，除高级选项显示外围硬盘，然后写入镜像模式为以DD镜像写入，制作完成。 如何将porteus linux发行版安装在u盘上，在porteus.org找到任意版本镜像下载下来后用rufus刻录到u盘上即可，之后重启电脑通过u盘进入系统即可。 如何将tiny core linux安装在u盘上，到http://tinycorelinux.net/找到镜像下载之后再通过Etcher刻录进u盘即可。 高级操作：1、打开regedit；2、打开msconfig.exe(安全模式)；3、gpedit; 查看电脑端口状态：win+r_cmd_netstat 任务栏程式切换：win+t和win+shitf+t(倒着切换) 文件强制删除(针对权限不高的文件)：shift+delete 注销：win+r_logoff 打开窗口设置：Alt + Space 打开文件属性：Alt + Enter 创建虚拟桌面：ctrl+win+d 虚拟桌面间切换：win+ctrl+方向键 关闭虚拟桌面：ctrl+win+F4 从程式切换到桌面：win+m 打开虚拟键盘：Ctrl + Win + o 打开投影：Win + p 查看桌面：win+逗号 一键回到桌面：win+d 任务栏打开新应用：win+1..9 多个应用程式分屏：win+方向键 应用切换：alt+tab 显示任务视窗：win+tab 任务管理器：ctrl+shift+esc 打开文档浏览器：win+e 新增视窗：ctrl+n 打开文档特定类型文件：ctrl+O 使用放大镜：win+加号键或减号键 捕捉屏幕：win+psr 快速截图：win+shift+s 使用操作中心：win+a 进入设置：win+i 与系统语音助手对话：win+c 使用系统游戏栏：win+g 锁住pc：win+L 退出桌面：ctrl+alt+delete 系统自带表情：win+句号 打印页面：ctrl+p 保存页面：ctrl+s 放大或缩小：ctrl+加号或等于键，ctrl+减号或杠键，ctrl+右括号或零键 资源监视器：Win+r_resmon/perfmon /res 打开设置的关于页面：Win+pouse 投影：ctrl+win+p 框选识别文字：ctrl+alt+o 框选翻译文字：ctrl+alt+f 打开键盘：ctrl+win+o 重新创建notepad：Ctrl + Shift + N 打印机设置：ctrl+shift+p 使用命令提示符来注册电脑上全部的dll文件：for %1 in (%windir%\\system32\\*.dll) do regsvr32.exe /s %1 查找计算机：ctrl+win+f 切换到windows powershell：win+x 快速启动：C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 一键关闭电脑所有软体：taskkill /F /FI \u0026quot;USERNAME eq Administrator\u0026quot; /FI \u0026quot;IMAGENAME ne explorer.exe\u0026quot; /FI \u0026quot;IMAGENAME ne dwm.exe\u0026quot; 一键关闭电脑所有软体：taskkill /F /FI \u0026quot;IMAGENAME ne explorer.exe\u0026quot; /FI \u0026quot;IMAGENAME ne dwm.exe\u0026quot; 查看电脑连接过的wifi的密码：netsh wlan show profiles name=wifi名字 key=clear 连接无线设备：win+k 显示系统信息：按Win键，输入 msinfo并回车或直接搜索 系统信息 高级菜单：win+x rss订阅：https://ynrss.herokuapp.com/ 用cmd命令装逼：先color a回车，再dir /s回车即可 查看端口排错：netstart -ano | findsrt 50524 阻止所有弹窗的相关设置方法：win+r_control.exe_网络和internet_internet选项_隐私_启用弹出窗口阻止程序(B)_阻止 级别(高)_win+e_此电脑_管理_点开任务计划程序小箭头_任务计划程序库_把所有程序状态改为禁用 远程转接：win+r_control.exe_系统的安全_允许远程访问_允许远程连接到此计算机(L)——win+r_mstsc_输入对方电脑ip 查看端口排错：netstart -ano | findsrt 50524 如何查看系统信息：win+r_control.exe_系统_查看RAM的大小和处理器的速度 修复电脑损坏文件：win+r_chkdsk(回车)_sfc /scannow 清理电脑垃圾文件：win+r_cmd_%temp%和win+r_cleanmgr 进入启动文件夹（开机自启动）：shell:startup 电脑截图的6种方法：ctrl+alt+a（qq截图）、alt+a（微信截图）、shift+alt+a（企业微信截图）、win+shift+a（花样截图）、ctrl+alt+x（wps截图）、电脑自带截图小工具 删除字符串快捷键：ctrl + backspace 关闭cmd：taskkill /f /im cmd.exe 计算机性能实时检测程序：perfmon.msc 查看或修改电脑程序状态：msconfig DirectX诊断工具也查询电脑具体配置：dxdiag 远程控制电脑，只需输入ip即可：mstsc 一键清理磁盘内垃圾：cleanmgr 在dos窗口查看当前路径：echo %pa% 下载网页视频的方法：F12_network(网络)_F5(刷新一下)_点击刷新出来的链接即可 上帝之眼(使用方法，把这串代码命名到一个新建的空文件夹之可)：GodMode.{ED7BA470-8E54-465E-825C-99712043E01C} 一键关闭cmd程式（bat文件）：start taskkill /f /im cmd.exe 电脑自带工具-哈希值校验：例如要校验 ideaIU-2018.1.exe ，正确做法是在文件所在文件夹输入 certutil -hashfile ideaIU-2018.1.exe sha256 ，即 certutil -hashfile + 文件名(包括后缀) + sha256 ;如果不加最后一个参数，则默认是这个 certutil -hashfile filename md5 ；还有一种方法是：Get-FileHash 文件路径 -Algorithm 校验的Hash值类型| Format-List 用vbs打开指定文件：createobject(\u0026quot;wscript.shell\u0026quot;).run \u0026quot;cmd /c start D:\\__easyHelper__\u0026quot; vbs设置循环次数： dim s do until s=999 s=s+1 msgbox\u0026quot;这里写窗口显示内容\u0026quot; loop 999是循环次数，可以修改 查看电脑vbs的环境变量：进入cmd，输入set即可 在cmd窗口无限循环输出自定义文字：for /l %a in (0,0,1) do echo 自定义 可用来尝试激活电脑：slmgr /skms kms.03k.org slmgr /ato 快捷方式关机：创建快捷方式，输入slidetoshutdown,确定后再将快捷方式的名字改为自定义的即可 修复(清空)u盘的方法：win+r_cmd_diskpart_list disk_select disk 1(所要操作的磁盘序号)_clean 创建分区的方法：win+r_cmd_create partition primary_select partition 1(对应清空的磁盘序号)_active_format fs=ntfs quick 查看磁盘的相关修改参数：lsit disk 掌握win7的快捷键，没有鼠标您也从容使用系统。 一、Win键相关的快捷键 Win + Home 将所有使用中窗口以外的窗口最小化（和摇动使用中窗口一样意思） Win + Space空格键 将所有桌面上的窗口透明化（和鼠标移到工作列的最右下角一样意思） Win + ↑上方向键 最大化使用中窗口（和将窗口用鼠标拖到屏幕上缘一样意思） Shift + Win + ↑上方向键 垂直最大化使用中窗口（但水平宽度不变） Win +↓下方向键 最小化窗口／还原先前最大化的使用中窗口 Win +左／右方向键 窗口靠到屏幕的左右两侧（和将窗口用鼠标拖到左右边缘一样意思） Shift + Win +左/右方向键 将窗口移到左、右屏幕（如果你有接双屏幕的话）工作列快速列 Win + 1~9 开启工作列上相对应的软件，从左到右依顺序为Win+1到Win+9 Shift + Win + 1~9 开启对应位置软件的一个新「分身」，例如firefox的话会是开新窗口（鼠标是Shift+点软件） Ctrl + Win + 1~9 在对应位置软件已开的分身中切换 Alt + Win + 1~9 开启对应位置软件的右键选单 Ctrl + Shift + 鼠标点软件以管理员权限开启该软件 WIN +点击任务栏快捷方式 在此程序中新建一个实例 Win + (+/-)：　打开Windows放大、缩小功能 Win + G 在屏幕上的Gadget间切换 Win + X 打开移动中心 Win + D 显示桌面，最小化所有窗口 Win + E 打开资源管理器 Win + F 打开资源管理器搜索结果 Win + L 锁定计算机，回到登陆窗口 Win + M 最小化当前窗口 Win + P 投影机输出设定（仅屏幕、同步显示、延伸、仅投影机） Win + R 打开运行窗口 Win + T 工作列的Alt+Tab Win + U 打开控制面板轻松访问中心 Win + Break 打开控制面板系统属性 Win + Tab 打开Flip3D任务切换功能 二、Windows基础快捷键 F1 帮助 Ctrl+C ( Ctrl+Insert) 复制选中项目 Ctrl+X 剪切选中项目 Ctrl+V ( Shift+Insert) 粘贴选中项目 Ctrl+Z 撤销 Ctrl+Y 重做 Delete ( Ctrl+D) 删除选中项目至回收站 Shift+Delete 直接删除选中项目 F2 重命名选中项目 Ctrl+A 全选 F3 搜索 Alt+Enter 显示选中项目属性 Alt+F4 关闭当前项目或退出当前程序 Alt+空格 打开当前窗口的快捷方式菜单 Alt+Tab 在当前运行的窗口中切换 Ctrl+Alt+Tab 使用方向键在当前运行的窗口中切换 Ctrl+滚轮 改变桌面图标大小 win+Tab 开启Aero Flip 3-D Ctrl+win +Tab 使用方向键在Aero Flip 3D程序中切换 Alt+Esc 在当前打开的程序间切换 F4 显示资源管理器的地址栏列表 Shift+F10 显示选中项目的快捷方式菜单 Ctrl+Esc 打开开始菜单 F10 激活当前窗口的菜单栏 F5 ( Ctrl+R) 刷新 Alt+↑ 资源管理区中返回文件夹的上一级菜单 Esc 取消当前操作 Ctrl+Shift+Esc 打开任务栏管理器 插入光盘时按住Shift 禁止CD/DVD的自动运行 右边或左边的Ctrl+Shift 改变阅读顺序 浏览器： 打开/关闭书签栏：Ctrl + Shift + B 批量提取一个网页里面的链接：可以先用正则表达式将链接提取出来，然后再用在线批量打开链接网站如a-site.cn/tool/kai 如何在网页上查看时间：点开F12，在控制台输入 document.write(document.lastModified); 指令即可 从新窗口打开链接：shift+D+鼠标左键点击链接进入跳转 分页之间切换：ctrl+1..8,ctrl+9到最后一个分布 从当前分布移动到下一个分页：ctrl+tab，反序切换：ctrl+shift+tab 关闭或新增分页：关闭分布ctrl+w,撤销关闭分布ctrl+shift+t，新增分页ctrl+t 快进、恢复、还原：ctrl+加号或等于键，ctrl+减号或杠键，ctrl+右括号或零键 跳到视频起始处：Fn+右括号或零键 视频进度起始或结尾切换以及页面滚动：Fn+方向键，空格配合shift反向滚动 添加书签：ctrl+d 书签管理：ctrl+shift+o 查看浏览记录：ctrl+h 查看下载：ctrl+j 移动到网址栏：ctrl+l 刷新页面：ctrl+r或F5 在同一页面切换链接：alt+左右方向键 网页查找：ctrl+f或F3 清除浏览器浏览数据：ctrl+shift+delete 查看网页原代码：ctrl+u 如何查看网站记录的密码：针对自动填入网站密码的网站，只需右键菜单点击检查选项查看关于密码的源代码，将密码的type=\u0026quot;原名字\u0026quot;改为text后再点击网页密码的位置即可查看密码 搜索的快捷方式：在地址栏中输入搜索引擎后按tab即可直接搜索 在浏览器中从新窗口打开链接：shift+左键点击链接 关闭所有打开的标签页和浏览器：Ctrl + Shift + w 退出Chrome浏览器： YouTube: 前一部：shift+p 后一部：shift+n 暂停：k 视频进度跳转：数字键(小跳转)、Fn+方向键(大跳转) 暂停：k 静音：m 油管的观看记录：youtube.com/feed/history 电影： 4个免费电影资源网站：imomoe.la、aiyy.tv、aidi.tv、cupfox.com 网站的访问技巧： b站：search.bilibili.com/all?keyword=搜索内容 油管：https://www.youtube.com/results?search_query=搜索内容 百度：https://baidu.com/s?\u0026amp;word=1 360搜索：m.so.com/s?q=1 谷歌：google.com/search?q=1 github：github.com/search?q=1 you.com(搜索引擎)：you.com/search?q=1 hosts文件： # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a '#' symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. #\t127.0.0.1 localhost #\t::1 localhost 当termux遇到了无线键盘，我发现的快捷键 ```C ctrl + alt + left/right //展示侧边栏 ctrl + shift + up/down //在vim中切换以多文件形式打开的窗口，如: vim * -p ``` vimrc for me ```C # vimrc for me set nu set ai set si set sw=4 set ts=4 set mouse=a noremap \u0026lt;C-a\u0026gt; \u0026lt;Esc\u0026gt;ggVG \u0026quot;全选 syntax enable syntax on ``` pdf文件本地显示正常，网站显示报错的解决方法 打开资源文件夹的功能 修改 hexo 目录下的 .config.yml 文件， 将 post_asset_folder: false 修改为 post_asset_folder: true。\n转载-醉酒后: 我作为高级工程师学到的东西 以下内容为网页翻译所得，因此某些地方与原英文要表达的意思有些不同，但是对于我这样英语不太好的人，翻译功能实在是太方便了，偷懒\\^_^/\n我提升职业生涯的最佳方式是更换公司。 技术堆栈并不重要，因为在我的领域有大约 15 种基本的软件工程模式适用。我从事数据工作，因此它与 webdev 或嵌入式不同。但是所有领域都有大约 10 到 20 条核心原则，而技术堆栈只是试图让这些事情变得更容易，所以不要担心过度。 人们推荐求职是有原因的。如果我对工作不满意，可能是时候继续前进了。 在与我合作过的公司里，我结交了一些很好的、终生的朋友。我不需要在我工作的每个地方都要求这样做。在我没有与同事建立友谊的地方工作我非常快乐，而在我结交了一些好朋友的地方我也很不快乐。 我学会了对我的经理诚实。不太诚实，但足够诚实，我可以在工作中保持真实。可能发生的更糟糕的情况是什么？他开除我？我将在 2 周内找到一份新工作。 如果我在凌晨 2 点从每季度一次以上的待命状态中醒来，那么就出现了严重错误，我要么修复它，要么退出。 再倒一杯 优秀经理的素质与优秀工程师的素质有很多相同之处。 当我刚开始时，我迷恋于技术、编程和计算机科学。我已经结束了。 好的代码是初级工程师可以理解的代码。大一的 CS 大一新生都能看懂代码。最好的代码是完全没有代码。 作为一名工程师，最被低估的技能是如何记录。操，请有人教我如何编写好的文档。说真的，如果有任何建议，我会认真支付一门课程的费用（可能是很多钱，如果能保证我能写出好的文档，一门课程可能需要 1k。） 与上述相关，为更改编写好的建议是一项很棒的技能。 几乎每场圣战（vim vs emacs，mac vs linux，等等）都无关紧要......除了一个。见下文。 年纪越大，我越喜欢动态语言。妈的，我说了算。和我战斗。 如果我发现自己认为自己是房间里最聪明的人，是时候离开了。 我不知道为什么全栈 webdev 的报酬如此之低。不，真的，他们应该得到半百万的年薪，只是基本工资。操，他们必须了解前端和后端，以及不同的浏览器是如何工作的，网络和数据库，缓存以及网络和移动设备之间的差异，天哪，还有公司想要使用的另一个框架是什么鬼？说真的，为什么 webdevs 的报酬这么少。 我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙乱搞他们的想法。当他们可以质疑或批评某事时，情况会更好。我喜欢实习生。 啜 不要遇见你的英雄。我花了 5k 参加了我的一位英雄的课程。他是一个才华横溢的人，但最后我意识到他正在编造它，因为他像我们其他人一样前进。 技术栈很重要。好的，我只是说技术堆栈无关紧要，但请听我说。如果您听到 Python 开发与 C++ 开发，您的想法会非常不同，对吧？那是因为某些工具确实擅长某些工作。如果你不确定你想做什么，那就去做 Java。这是一种糟糕的编程语言，几乎擅长所有方面。 有史以来最伟大的编程语言是 lisp。我应该学习lisp。 对于初学者来说，最赚钱的编程语言是 SQL。去他妈的所有其他语言。如果你只知道 SQL 而不会别的，你就可以赚钱。薪资专家？也许50k。懂 SQL 的薪资专家？90k。在大公司有组织能力的普通乔？4 万美元。具有组织能力和 sql 的普通乔？称自己为 PM 并赚取 15 万美元。 测试很重要，但 TDD 是一个该死的邪教。 轻松的政府工作并不是他们所吹捧的那样，至少对于职业生涯早期到中期的工程师来说是这样。当然，12 万美元 + 本尼 + 养老金听起来不错，但你会出卖你的灵魂来研究深奥的专有技术。非常尊重政府工作人员，但说真的，这些地方工程师的平均年龄是 50 岁以上是有原因的。建议不适用于政府承包商。 第三方招聘人员是水蛭。但是，如果您找到了一个好的，请认真与他们建立良好的关系。他们可以帮助引导您的职业生涯。你怎么知道你是否有一个好人？如果他们成为第三方招聘人员超过 3 年，他们可能很糟糕。好的招聘人员通常是大公司。 期权一文不值，或者可以让你成为百万富翁。除非工程人员超过 100 人，否则它们可能一文不值。那么在这十年内，它们可能会有所价值。 在家工作是山雀。但是缺乏白板很糟糕。 我从来没有在 FAANG 工作过，所以我不知道我错过了什么。但是我从 FAANGs 雇佣了（而不是雇佣）工程师，他们也不知道自己在做什么。 我的自我价值与我的总薪酬无关，也不与我的总薪酬相关。资本主义是确定自我价值的糟糕方式。 经理的权力比你想象的要小。少了点力气。如果你有事，为什么经理 XYZ 不解雇某人，那是因为他们不能。 标题大多无关紧要。来自任何公司的首席杰出员工首席工程师，无论什么。你做了什么，你完成了什么。这就是人们所关心的。 说到头衔：在你职业生涯的早期，头衔的变化很好。初中到中。中到高级。高级领导。在你职业生涯的后期，头衔的变化很好。这样，您可以获得相同的报酬，但在升职时会获得加薪。换句话说，在您职业生涯的早期（\u0026lt;10 年），头衔更改 UP 是好的，因为它可以让您提高技能和责任感。后来，标题更改很好，因为它可以让您增加薪水。 最大化我们的 401ks。 善待每一个人。不是因为它会帮助你的事业（它会），而是因为善良本身就是有益的。 如果上个月我没有从初级工程师或实习生那里学到一些东西，我就没有注意。 哎呀，我没酒了。 为课程、书籍、会议付费是值得的。我参加过几次会议、几门 1.5k 的课程、许多书籍和订阅。值得。这样，我可以更好地假装我在做什么。 说真的，为什么 webdevs 没有得到更多的报酬？他们什么都知道！！！ 腕管和背部问题可不是开玩笑的。现在花 1k 购买好的设备。 我工作过的最聪明的人是数学博士。我从那个人身上学到了很多。我希望他过得很好。 有一次，在高中时，有个东西女孩是我的好朋友。我的意思是，我们在几年内交谈、闲逛并分享了很多私人的东西。然后有一个谣言说我喜欢她或者我们要出去什么的。她没有接受太多，所以她开始不理我。那感觉不太好。我想这将是现代的“重影”等价物。不过我不希望她有任何恶意，我希望她过得很好。我很抱歉我没有处理得更好。 我有一个 8 年级的女朋友，尽管我不再喜欢她，但我不想分手，所以我开始不理她。那太操蛋了。对不起，莉娜。 你知道成为软件工程师最好的部分是什么吗？您可以结识和与您想法相同的人交谈。不一定像体育和电视节目等相同的兴趣。但他们思考问题的方式与你思考问题的方式相同。这很酷。 技术领域的女性不够多。什么鬼行业。这需要改变。我一直在努力为我们组织中的女性工程师提供更多鼓励和帮助，但我不知道还能做什么。 黑人工程师也一样。我勒个去？ 在我开始非常熟悉一种语言或技术之前，我从未真正开始讨厌它。另外，如果我讨厌某项技术，我认为它是好的，但我同时会将它推荐给客户。去他妈的詹金斯，但伙计，我认为我不会通过将软件推荐给新客户来解决软件不当行为。 话虽如此，git 很糟糕，我只能选择使用它。此外，GUI git 工具可以去地狱，随时给我命令行。大约有 7 个命令行要记住，其他的都可以用谷歌搜索。 由于我从事数据工作，因此我将提供针对数据的经验教训。去他妈的熊猫。 我的工作更轻松，因为我的团队中有半技术分析师。半技术，因为他们知道编程但不知道软件工程。这是一种祝福，因为如果某些东西对他们来说没有意义，那就意味着它可能设计得很糟糕。我喜欢团队中的分析师；与最杰出的工程师相比，他们帮助我成长了很多。 在您被迫使用浅色模式（网页或不受支持的应用程序）之前，深色模式非常棒。这就是我使用灯光模式的原因。 我对安全有足够的了解，知道我对安全一无所知。 废话，我没酒了。 成为一名优秀的工程师意味着了解最佳实践。成为高级工程师意味着知道何时打破最佳实践。 如果人们试图将责任归咎于错误或中断，那么是时候继续前进了。 很多进步的公司，尤其是初创公司，都在谈论带上你的“真实自我”。那么如果你真实的自我就是看色情片呢？是的，在工作和个人生活之间保持屏障是健康的。 我喜欢在欢乐时光和我的同事一起喝酒。我宁愿花时间与孩子、家人或朋友在一起。 伟大领导力的最好证明是当我的领导因为一个 100% 是我错的错误而跌倒时。你最好相信我会为她走火入魔。 同样，我有幸在其手下工作过的最优秀的领导者尽最大努力支持我的观点，并向我解释与我的观点相冲突的其他观点。我正在努力成为像他们一样的人。 他妈的副项目。如果你喜欢做它们，太好了！即使我有时间做副业，我也忙着在 reddit 上写醉酒的帖子 算法和数据限制在一定程度上很重要。我没有看到药剂师采访测试有关有机化学的琐事。我们行业的面试过程有些搞砸了。 该死的，那些 devops 的家伙和 gals 很聪明。至少那些 mofos 得到了报酬。 做我喜欢的事并不重要。做我不讨厌的事更重要。 我越接近产品，我就越接近推动收入，无论我的工作多么技术性，我都感到越受重视。即使是最先进的公司也是如此。 即使我在所有 Windows 中工作，Linux 也很重要。为什么？因为我最终在 Linux 中工作。很高兴那个周末我搞砸了安装 Arch。 我学会了对大数据等模棱两可的流行词保持警惕。WTF是“大”数据？我在 Spark 和 Kafka 中每 10 分钟处理 10k 行流式传输，在 Python 和 MySQL 中每小时处理 1B 行。那些标签可以去他妈的自己。 并非所有出色的工作都在硅谷。但很多都是。 最后，如果您真的想伤害我，请不要投反对票，我不在乎。直接忽略这个帖子。没有什么比我写了一篇很长的帖子然后没有人回复更让我难过的了。因此，如果您讨厌这篇文章，请忽略。 如何在hexo中嵌入歌单 参考链接\n1.示例：\n1 2 3 {% meting \u0026#34;3068013756\u0026#34; \u0026#34;netease\u0026#34; \u0026#34;playlist\u0026#34; %}\t//添加歌单 {% meting \u0026#34;157288\u0026#34; \u0026#34;netease\u0026#34; \u0026#34;song\u0026#34;%}\t//添加单曲 2.效果演示展示： {% meting \u0026ldquo;3068013756\u0026rdquo; \u0026ldquo;netease\u0026rdquo; \u0026ldquo;playlist\u0026rdquo; %}\t//添加歌单\n{% meting \u0026ldquo;157288\u0026rdquo; \u0026ldquo;netease\u0026rdquo; \u0026ldquo;song\u0026rdquo;%}\t//添加单曲\n如何在hexo中嵌入图片 嵌入本地图片 1.在 hexo 的站点目录的 source 目录下创建一个文件夹用来存放图片，如 image 文件夹 将图片存入此目录后，例如我存入了一个图片名称叫做 test.png 的图片，在博客中引入图片路径即可 示例：\n1 2 3 4 ![](/images/test.png) \u0026lt;img src=\u0026#34;/images/test.png\u0026#34;\u0026gt; ![](https://raw.githubusercontent.com/mytcrp/tc/main/20220830151304.png) \u0026lt;img src=\u0026#34;https://raw.githubusercontent.com/mytcrp/tc/main/20220830151304.png\u0026#34;\u0026gt; 效果展示：\t嵌入云端图片 1.在 hexo 的站点目录的 source 目录下创建一个文件夹用来存放图片，如 image 文件夹 将图片存入此目录后，例如我存入了一个图片名称叫做 test.png 的图片，在博客中引入图片路径即可 示例：\n1 2 3 4 ![](/images/test.png) \u0026lt;img src=\u0026#34;/images/test.png\u0026#34;\u0026gt; ![](https://raw.githubusercontent.com/mytcrp/tc/main/20220830151304.png) \u0026lt;img src=\u0026#34;https://raw.githubusercontent.com/mytcrp/tc/main/20220830151304.png\u0026#34;\u0026gt; 效果展示：\t视频教程：\n{% raw %} \u0026lt;iframe src=\u0026quot;//player.bilibili.com/player.html?aid=23204013\u0026amp;bvid=BV19p411f7x9\u0026amp;cid=38628219\u0026amp;page=1\u0026quot; scrolling=\u0026quot;no\u0026quot; border=\u0026quot;0\u0026quot; frameborder=\u0026quot;no\u0026quot; framespacing=\u0026quot;0\u0026quot; allowfullscreen=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt; {% endraw %} 如何在hexo中嵌入视频 这里以油管视频和b站视频为例： 1.获取要嵌入的代码 1)油管和b站都可以通过点击视频页面的分享中的嵌入 其实好多知名的视频网站都会人分享嵌入的功能，使用嵌入功能就可能得到自己想要的代码 2)b站(包括其他视频网站)还可以通过在视频页面按下 F12 键进入开发人员模式， 再按下 Ctrl + F 通过查找功能查找关键词 bvid 定位到要嵌入的代码的位置双击复制要嵌入的代码， 必须为以下示例代码格式，不能以其他格式复制出来，因此要双击复制 或者也可以搜索 \u0026lt;iframe 可能会出现好几条结果，确定自己要找的代码后复制下来 2.在博客页面中添加标签: 标签格式：\n{% raw %} {% endraw %} 使用方法： {% raw %} 要嵌入的视频代码 {% endraw %} 3.示例: HTML {% raw %} \u0026lt;iframe width=\u0026quot;560\u0026quot; height=\u0026quot;315\u0026quot; src=\u0026quot;https://www.youtube.com/embed/g4bMPT2wW4o\u0026quot; title=\u0026quot;YouTube video player\u0026quot; frameborder=\u0026quot;0\u0026quot; allow=\u0026quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026quot; allowfullscreen\u0026gt;\u0026lt;/iframe\u0026gt; {% endraw %} HTML {% raw %} \u0026lt;iframe src=\u0026quot;//player.bilibili.com/player.html?aid=23207325\u0026amp;bvid=BV1Xp411f7vh\u0026amp;cid=38634561\u0026amp;page=1\u0026quot; scrolling=\u0026quot;no\u0026quot; border=\u0026quot;0\u0026quot; frameborder=\u0026quot;no\u0026quot; framespacing=\u0026quot;0\u0026quot; allowfullscreen=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt; {% endraw %} 4.效果展示(转载)： {% raw %} {% endraw %} {% raw %} {% endraw %}\n如何为hexo提供下载文件功能 在站点目录的 source 目录建立一个用来存储资源的文件夹，名字自定义，接下来就可以在博客中提供文件下载功能了 示例： [点击下载树和二叉树](/images/04ds/树和二叉树.ppt) 点击下载 树和二叉树.ppt\n如何将手机作为电脑副屏 {% raw %}\n{% endraw %} ubuntu/linux下使用sed、echo进行文件操作总结 转载 一、sed进行数据操作 1、删除file.txt的第一行、最后一行 sed -i '1d' file.txt # 删除第一行 sed -i '$d' file.txt # 删除最后一行 2、删除file.txt的第N行、第M到N行 sed -i 'Nd' file.txt # N为具体数字，指第N行，如10 sed -i 'M,Nd' file.txt # 删除M到N行 sed -i 'M,$d' file.txt # 删除第M行到最后一行的所有行 3、删除file.txt中包含某个关键字开头的所有行 使用sed命令删除以a字符开头的所有行 sed -i ‘/^a/d’ abc.txt 删除包含特定字符的行 sed -i '/run distro_bootcmd\\b/d' ts.txt # \\b是正则表达式中的单词边界，用于确保只匹配关键词的完整单词，而不是部分匹配。 3、删除某文件的多行比如1、3、5行 sed -i '3d; 5d; 7d; 9d; 11d; 13d; 15d; 17d; 19d; 21d; 23d; 25d; 27d; 29d; 31d; 33d; 35d; 37d; 39d; 41d; 43d; 45d; 47d; 49d; 51d; 53d; 55d; 57d; 59d; 61d; 63d;' ts.c sed '/^abc/d' file.txt # \u0026quot;^abc\u0026quot;表示abc必须出现在行的开头，即删除abc开头的所有行 4、删除file.txt中包含某个关键字的所有行 sed '/abc/d' file.txt # 删除包含abc的所有行(任意位置) 5、替换字符串 sed -i 's/abc/ABC/' file.txt # 替换file.txt每一行的第一个abc为ABC sed -i 's/abc/ABC/g' file.txt # 使用后缀g，替换file.txt每一行的所有abc为ABC sed -i 's/^/ABC/' file.txt # 在file.txt每一行的行首追加字符串ABC sed -i 's/$/ABC/' file.txt # 在file.txt每一行的行尾追加字符串ABC sed '3s/line/row/' file.txt # 使用sed命令替换文本文件指定行的指定关键词 6、追加行 sed -i 'Na hello_world' file.txt # 在file.txt第N行后面追加一行\u0026quot;hello_world\u0026quot;，a表示追加 sed -i 'Ni hello_world' file.txt # 在file.txt第N行前面插入一行\u0026quot;hello_world\u0026quot;，i表示插入 sed -i '/hello/a hello_world' file.txt # 在file.txt包含\u0026quot;hello\u0026quot;的所有行后面追加一行\u0026quot;hello_world\u0026quot; 7、在指定行首添加字符串 sed -i '3{s/^/aa/}' a.txt //aa为要在第3行行首添加内容，a.txt为要操作的文件 8、在连续几行行尾添加： sed -i '1,2{s/$/bb/}' a.txt（在1-2行行尾添加bb） 在特定行，行前添加数据 sed -i ‘N;2 i 111’ c.txt（在第一行行前添加111） 在特定行，行后添加数据 sed -i 'N; 2 i 111' c.txt（在第二行行后添加111）\t指定多行批量添加字符串至行首 sed -i '1{s/^/## /}' 1.c\t//将字符串\u0026quot;## \u0026quot;添加到文件1.c的第1行 sed -i '2{s/^/## /}' 1.c sed -i '4{s/^/## /}' 1.c sed -i '6{s/^/## /}' 1.c\t//将字符串\u0026quot;## \u0026quot;添加到文件1.c的第6行 *备注：以上所有命令中 -i 指在原文件上操作，操作后的结果保存到原文件；当然也可以用 - e 关键字输出操作结果到新文件。 sed -e '1d' file.txt \u0026gt; new_file.txt # 删除文件file.txt的第一行，将操作后的结果保存到new_file.txt 其余命令类似 查看文件指定行 要仅显示文件中的特定行，可以使用以下命令：\n1 cat 文件名 | sed -n \u0026#39;行号p\u0026#39; 例如，要显示文件 test.txt 的第 5 行，可以运行以下命令：\n1 cat test.txt | sed -n \u0026#39;5p\u0026#39; 这将只显示文件 test.txt 中的第 5 行内容。请注意，行号是从 1 开始计数的。\n二、echo进行数据操作 1、显示行 echo \u0026quot;hello world\u0026quot; # 在终端打印\u0026quot;hello world\u0026quot; 2、写入行 echo \u0026quot;hello world\u0026quot; \u0026gt;\u0026gt; file.txt # 在文件file.txt末尾写入行\u0026quot;hello world\u0026quot; 3、覆盖写入 echo \u0026quot;hello world\u0026quot; \u0026gt; file.txt # 文件file.txt中原来内容会被覆盖，只保存\u0026quot;hello world\u0026quot;，无论操作多少次，file.txt只保存最新写入的一行 4、写入包含引号的行（特别注意） #比如，写入line = 你好，\u0026quot;老王\u0026quot;，你今天真帅！ #注意，这里line的内容包含双引号\u0026quot;\u0026quot;,属于特殊符号，需要使用转义符号 echo \u0026quot;你好，\\\u0026quot;老王\\\u0026quot;，你今天真帅！\u0026quot; file.txt Cygwin添加到有右键菜单 转载 系统：windows 10 目标：在空白处点击右键菜单，显示如图菜单项，点击后可以打开 cygwin 并切换到当前所在目录 方法一： 步骤： 1. 开始菜单运行 regedit 打开注册表 2. 定位到 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Cygwin\\command 3. 新建项和字符串到如下图所示 4. 默认值填写 C:\\cygwin64\\bin\\mintty.exe -e /bin/bash --login -i -c \u0026quot;cd '%V';exec bash 方法二： 重新运行 cygwin 安装程序，勾选 chere 安装包。 安装完成后，使用管理员身份运行 cygwin。 chere -i -t mintty -s bash 1 此时右键菜单应该有 “Bash Prompt Here” 菜单选项。 Win10 系统中，更改此处注册表， 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cygwin64_bash 增加 Icon 字符串，并更改中文描述，达到上图菜单效果。 点击浏览 nodeConfig.html K210-数字识别 pyAI-K210资料下载 点击下载 数字识别.zip 转载-使用 V831 AI检测数字卡片（2021电赛F题智能送药小车数字识别）速成教程（附带k210识别模型） Pycharm激活码,Pycharm稳定专属激活码（全网最新） Python中33个保留字的用法 网盘资源搜索终极大法 #百度网盘 #阿里云盘 #夸克网盘 网盘搜索引擎： https://yunso.net/ https://www.alipansou.com/ https://www.upyunso.com/ https://www.toplinks.cc/s 网盘分享社区： https://www.ood.one/ 资源聚合网站 https://www.nbwz.com/ https://newxiaozhan.com/ https://search.chongbuluo.com/ https://www.wangzhiku.com/ 云盘搜索助手，30个搜索引擎，涉及多个知名云盘资源，海量资源，双击跳转下载页面 https://wwi.lanzouq.com/iZJHZ01nohof 磁力搜 https://cilishenqi.com/ https://cilitiantang.top/ 转载-Bash 批量重命名文件 我在同一个目录中有一堆文件，名称如下: IMG_20160824_132614.jpgIMG_20160824_132658.jpgIMG_20160824_132738.jpg 中间部分是日期，最后部分是照片拍摄时间。因此，如果我按名称对这些文件进行排序，结果将与按修改的日期/时间排序相同 我想使用 bash 将这些文件批量重命名为以下形式: 1-x-3.jpg 凡x表示文件在顺序排序中的位置(按名称/修改时间排序) 因此，上面的 3 个示例将重命名为: 1-1-3.jpg1-2-3.jpg1-3-3.jpg 是否有可以实现此目的的 bash 命令？还是需要脚本？ 最佳答案 尝试: i=1; for f in *.jpg; do mv \u0026quot;$f\u0026quot; \u0026quot;1-$((i++))-3.jpg\u0026quot;; done 例如，使用您的文件名: $ ls IMG_20160824_132614.jpg IMG_20160824_132658.jpg IMG_20160824_132738.jpg $ i=1; for f in *.jpg; do mv \u0026quot;$f\u0026quot; \u0026quot;1-$((i++))-3.jpg\u0026quot;; done $ ls 1-1-3.jpg 1-2-3.jpg 1-3-3.jpg 笔记: 扩展时*.jpg ，shell 按字母数字顺序列出文件。这似乎是你想要的。但请注意，字母数字顺序可能取决于语言环境。 顺序编号是用 $((i++)) 完成的.在这里，$((...))表示算术展开。 ++只是意味着将变量增加 1。 关于Bash 批量重命名文件，我们在Stack Overflow上找到一个类似的问题： https://stackoverflow.com/questions/39133172/ 转载-【笔记】从零开始制作自己的Pascal VOC数据集 转载-【[教程]从0自制模型，实现多物体识别（以k210多数字识别举例）】 相关资料 提取码：9527 转载-STM32系列芯片命名规则——简明 DIRECTORY STM32系列芯片命名规则 1.产品系列： 2.产品类型： 3.产品子系列： 4.管脚数： 5.Flash存储容量： 6.封装： 7.温度范围： STM32系列芯片命名规则 例图： 1.产品系列： STM32代表ST品牌Cortex-Mx系列内核（ARM）的32位MCU 2.产品类型： F ：通用快闪（FlashMemory） L：低电压（1.65～3.6V） F类型中F0xx和F1xx系列为2.0～3.6V;F2xx和F4xx系列为1.8～3.6V W：无线系统芯片，开发版 3.产品子系列： 050：ARMCortex-M0内核 051：ARMCortex-M0内核 100：ARMCortex-M3内核，超值型 101：ARMCortex-M3内核，基本型 102：ARMCortex-M3内核，USB基本型 103：ARMCortex-M3内核，增强型 105：ARMCortex-M3内核，USB互联网型 107：ARMCortex-M3内核，USB互联网型、以太网型 108：ARMCortex-M3内核，IEEE802.15.4标准 151：ARMCortex-M3内核，不带LCD 152/162：ARMCortex-M3内核，带LCD 205/207：ARMCortex-M3内核，不加密模块（备注：150DMIPS，高达1MB闪存/128+4KBRAM，USBOTGHS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头） 215/217：ARMCortex-M3内核，加密模块（备注：150DMIPS，高达1MB闪存/128+4KBRAM，USBOTGHS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头） 405/407：ARMCortex-M4内核，不加密模块（备注：MCU+FPU，210DMIPS，高达1MB闪存/192+4KBRAM，USBOTGHS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头） 415/417：ARMCortex-M4内核，加密模块（备注：MCU+FPU，210DMIPS，高达1MB闪存/192+4KBRAM，USBOTGHS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头） 4.管脚数： F：20PIN； G：28PIN； K：32PIN； T：36PIN； H：40PIN； C：48PIN； U：63PIN； R：64PIN； O：90PIN； V：100PIN Q：132PIN； Z：144PIN； I ：176PIN； 5.Flash存储容量： 4：16KB flash（小容量） 6：32KB flash（小容量） 8：64KB flash（中容量） B：128KB flash（中容量） C：256KB flash（大容量） D：384KB flash（大容量） E：512KB flash（大容量） F：768KB flash（大容量） G：1MKB flash（大容量） 6.封装： T：LQFP H：BGA U：VFQFPN Y：WLCSP/WLCSP64 7.温度范围： 6：-40℃-85℃ 7：-40℃-105℃ 转载-三种方案解决：npm WARN config global \u0026ndash;global, \u0026ndash;local are deprecated. Use \u0026ndash;location=global instead 找到nodejs安装目录 编辑四个名为npm, npm.cmd, npx,npx.cmd的文件 在文件中替换prefix -g为prefix --location=global 管理员权限保存 nodejs提示不安全执行命令 npm audit fix --force 正点原子_STM32F103ZET6_战舰_V3 STM32F1开发指南-库函数版本_V3.3.pdf STM32F1开发指南-寄存器版本_V3.3.pdf\ncpolar教程 按照官网提示进行安装 本地的web管理页面：localhost:9200 在隧道列表启动远程桌面，在状态的在线隧道列表中复制公网地址中的tcp://需要复制内容 然后在电脑或手机的远程桌面连接工具中输入复制下来的地址，连接过程中输入电脑的用户名和密码即可连接 hexo如何自定义菜单图标 进入这个网站[fontawesome](https://fontawesome.com/v4/icons/)，找到自己喜欢的图标，在主题配置文件的菜单后直接直接添加即可 #〖Linux〗不知谁写的，很实用的Linux命令\n第一部分 . sudo 运行上一条命令 sudo !! . HTTP方式共享当前目录 python -m SimpleHTTPServer . vim保存一个root用户文件 :w !sudo tee % . 快速切换至旧的目录 cd - . 替换上一条命令中的一个短语 ^foo^bar^ . 快速备份一个文件 cp filename{,.bak} filename{,.bak} 会被展开为filename filename.bak . 排列，大括号在bash中是排列的意义 echo {a,b,c}{a,b,c}{a,b,c} 得到一个全排列 . 免密码ssh登录主机 ssh-copy-id remote-machine . 抓取Linux桌面的视频 ffmpeg -f x11grab -s wxga -r -i :0.0 -sameq /tmp/out.mpg ffmpeg 可以直接解码X11的图形，并转换输出格式 -f x11grab 指定输入类型 -s wxga 设置抓取区域的大小，wxga是1366*768的大小，也可以是-s 800x600 -r 设置帧频率，每秒抓取的画面数 -i :0.0 设置输入源，本地X默认在0. -sameq 保持与输入流一样的图像质量 第二部分 . 用你最喜欢的编辑器来敲命令 command \u0026lt;C-X C-E\u0026gt; . 清空或创建一个文件 \u0026gt; file.txt . 用ssh创建端口转发通道 ssh -N -L2001:remotehost: user@somemachine 在本机打开了2001端口， 对本机2001端口的请求， 通过somemachine作为跳板， 转到remotehost的80端口上。 举例： ssh -f -N -L 0.0.0.0::twitter.com: shell.cjb.net ssh -f -N -L 0.0.0.0::twitter.com: shell.cjb.net 然后在/etc/hosts里边添加 127.0.0.1 twitter.com . 重置终端 reset 对于终端显示有乱码，不能正常显示时很有用。 . 在午夜时候执行某命令 echo \u0026quot;cmd\u0026quot; | at midnight at 调用定时任务 . 远程传送麦克风语音 dd if=/dev/dsp | ssh user@host dd of=/dev/dsp #新系统上可能已失效 arecord | ssh user@host aplay #本地录音，远程播放 arecord | aplay #本地直接回放 . 映射一个内存目录 mount -t tmpfs -o size=1024m tmpfs /mnt/ram 开了一1G内存当目录使用 /dev/shm 也是内存目录，可直接使用 . 使用diff对比远程文件与本地文件 ssh user@host cat /path/to/remotefile | diff /path/to/localfile - 学会善用ssh，可减少开发工作量，比如 sshfs [user@]host:[dir] mountpoint [options] 可以挂载远程的目录至本地(卸载fusermount -u mountpoint) . 查看系统中占用端口的进程 netstat -tulnp -t 显示tcp连接 -u 显示udp连接 -l 显示监听状态 -n 显示ip，不作名称转换 -p 显示相应的pid以及名称(root) 第三部分 . 以友好的方式显示当前挂载的文件系统 mount | column -t column 用于格式化输出的信息 . !!:gs/foo/bar !!表示上一条命令 gs/foo/bar 用bar替换foo再执行 . 实时查看某目录最新变化 watch -d -n ls -l . 通过ssh挂载远程主机上文件夹 sshfs user@host:remotedir localdir 卸载使用fusermount或是umount . 通过DNS读取Wikipedia的词条 dig +short txt \u0026lt;keyword\u0026gt;.wp.dg.cx dig +short txt hacker.wp.dg.cx #可能已失效 . 使用wget递归下载整个网站 wget --random-wait -r -p -e robots=off -U Mozilla www.example.com --random-wait 等待0.~.5秒的时间进行下一次请求 -r 递归下载 -e robots=off 忽略robots.txt -U Mozilla 设置User-Agent头为Mozilla 其他实用的参数： --limit-rate=20k 限定下载速度为20k -o logfile.txt 记录下载日志 -l 删除深度（默认为5） -wait=1h 每下载一个文件后等待1小时 . 复制最后使用的命令的参数 \u0026lt;Alt +.\u0026gt; . 执行一条命令但不保存至history中 \u0026lt;space\u0026gt; command . 显示当前子目录下所有子目录下的大小 du -h --max-depth= . 以使用内存量排序查看进程 ps aux | sork -nk + | tail sork -nk + 用sort排序列出4栏 此外可以使用htop或是top . 用python快速开启一个SMTP服务 python -m smtpd -n -c DebuggingServer localhost: -m smtpd 指定smtp服务 localhost:1025运行1025端口 -n 不用setuid为nobody，而直接使用你的uid运行 -c DebuggingServer 在屏幕上输出信息 第四部分 . 查看ASCII码表 man ascii 或 man ascii man intro - Linux简明教程 man syscalls - 内核提供的系统调用 man select_tut - 关于select()系统调用的教程 man string - 在头文件内的所有函数 man stdio - 关于头文件的使用，标准输入输出的库说明 man errno - 所有errorno取值及说明 man console_codes - Linux终端控制码及使用解释 man full - 介绍总是处理“满”状态的/dev/full（对应有/dev/null） man proc - 介绍/proc下文件系统 man filesystems - 各种Linux文件系统 man bootparam - 详细解释内核启动参数 man charsets - 解释各种语言的编码集 man glob - 解释glob文件名管理机制的工作过程 man hier - 解释Linux文件系统结构各个部分的作用 man operator - C语言运行符的列表 man regex - 介绍正则表达式 man suffixes - 常见文件后缀名的列表跟解释 man time - Linux的时钟机制解释 man units - 数值单位及其数值的解释 man utf8 - 描述UTF-8编码 man url - 解释URL、URI、URN等的标准 . 简易计时器 time real . 远程关掉一台Windows机器 net rpc shutdown -I IP_ADDRESS -U user%passwd . 在一个子Shell中运行一个命令 (cd /tmp \u0026amp;\u0026amp; ls) 其中的好处是不会修改当前shell目录 . 利用中间管道嵌套使用SSH ssh -t host_A ssh host_B 使用情况： host_B 网络繁忙，本机不可直达 host_A 网络空闲，本机可直达 . 清空屏幕 \u0026lt;C-L\u0026gt; 或是 clear 或是 tput clear . 得知一台机器什么时间重启完毕 ping -a IP 一但ping通，发出警报声音 . 列出你最常用的10行命令 history | awk '{a[$2]++}END{for(i in a){print a[i] \u0026quot; \u0026quot; i}}' | sort -rn | head . 使用Telnet查看《星球大战》 telnet towel.blinkenlights.nl From: http://wenku.baidu.com/view/4724041fa8114431b90dd82b.html\n批量处理不同文件夹的笔记： 首先将不同文件夹的同类型文件找到复制到指定文件夹 find ./ -name *.txt -exec cp '{}' ~/ts/note_dir/ ';' 然后在每个文件的首行(即第一行)都加入多行星号(*)用以区分稍后所加的内容 sed -i '1i\\************************************************************************************************************************\\ ************************************************************************************************************************\\ ************************************************************************************************************************\\' *.txt 接着将按顺序命名的文件批量到第一个文件复制并重命名后的文件中 cp day01.txt allday.txt \u0026amp;\u0026amp; cat day02.txt day03.txt day04.txt day05.txt day06.txt day07.txt day08.txt day09.txt day10.txt day11.txt day12.txt day13.txt day14.txt day15.txt \u0026gt;\u0026gt; day01.txt 查找文件关键词并替换 方法一： sed -i \u0026quot;s/fda/adf/g\u0026quot; `grep -rl \u0026quot;fda\u0026quot; ./1.c` fda是要查找的字符串，将查找到的字符串fda替换为adf 方法二： grep -rl -w \u0026quot;adf\u0026quot; ./1.c | xargs sed -i 's/adf/fda/g' adf是要查找的字符串，将查找到的字符串adf替换为fda 方法三： 写一个makefile文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var1=\\ test var2=\\ test var3=\\ test var4=\\ test var5=\\ test rep : @grep -rnl \u0026#34;\\\u0026lt;$(var1).h\\\u0026gt;\u0026#34; ./* --include \u0026#34;*.c\u0026#34; --include \u0026#34;*.h\u0026#34; | xargs sed -i \u0026#34;s/\\\u0026lt;$(var1)\\\u0026gt;.h/$(var2).h/g\u0026#34; var : @grep -rnl \u0026#34;\\\u0026lt;$(var4)\\\u0026gt;\u0026#34; ./* --include \u0026#34;*.c\u0026#34; --include \u0026#34;*.h\u0026#34; | xargs sed -i \u0026#34;s/\\\u0026lt;$(var4)\\\u0026gt;/$(var5)/g\u0026#34; rvar : @grep -rnl \u0026#34;\\\u0026lt;$(var5)\\\u0026gt;\u0026#34; ./* --include \u0026#34;*.c\u0026#34; --include \u0026#34;*.h\u0026#34; | xargs sed -i \u0026#34;s/\\\u0026lt;$(var5)\\\u0026gt;/$(var4)/g\u0026#34; find : @grep -ran \u0026#34;\\\u0026lt;$(var3)\\\u0026gt;\u0026#34; ./* --include \u0026#34;*.c\u0026#34; --include \u0026#34;*.h\u0026#34; --color=auto 巧用谷歌云的终端shell 激活cloud shell后之后输入以下代码，安装完成以后网页预览 docker run -p 8080:80 dorowu/ubuntu-desktop-lxde-vnc 如果我真的想学习Lisp，那么我应该把它放在这里 ANSI_Common_Lisp_中文版.epub\n这个命令的详细作用：wget -r -p -np -k（答案来自chatgpt） 这个命令是用于递归地下载一个网站的所有资源，包括 HTML 页面、图像、样式表、JavaScript 文件等。下面是这些选项的详细说明： -r 选项表示递归下载。这个选项会让 wget 下载整个网站的资源，而不仅仅是指定的 URL。 -p 选项表示下载页面所需的所有元素。这个选项会下载 HTML 页面所需的所有资源，包括图像、样式表和 JavaScript 文件。 -np 选项表示不跟随链接到上一级目录。这个选项会防止 wget 下载其他网站的资源，以及不必要的上级目录。 -k 选项表示将链接转换为本地文件名。这个选项会让 wget 修改下载的 HTML 文件中的链接，以便它们指向本地下载的文件。这样，即使您将下载的文件移动到其他位置，链接也会正确地指向本地文件。 综上所述，这个命令的作用是将指定网站的所有资源下载到本地，并将 HTML 文件中的链接转换为本地文件名。 nrm同时对多个镜像网站测速 nrm test npm \u0026amp; nrm test yarn \u0026amp; nrm test tencent \u0026amp; nrm test cnpm \u0026amp; nrm test npmMirror 一个不错的项目？ https://hamibot.com/marketplace 免登录临时网盘 https://www.jetdrop.net/ https://transfer.pcloud.com/ https://anonfiles.com/ https://filechan.org/ https://bayfiles.com/ AutoHotkey中文文档 AutoHotkey中文文档\nAutoHotkey拾取坐标点击屏幕某处 ; 按 A 和 D 分别对应点击两个单独的屏幕坐标 ; 按 Q 和 E 分别对应重新设置两个单独的屏幕坐标位置 xpos := 618 ; 要点击位置的横坐标（默认值） ypos := 186 ; 要点击位置的纵坐标（默认值） xpos2 := 52 ; 要点击位置的横坐标（默认值） ypos2 := 214 ; 要点击位置的纵坐标（默认值） xpos3 := 52 ; 要点击位置的横坐标（默认值） ypos3 := 214 ; 要点击位置的纵坐标（默认值） xpos4 := 52 ; 要点击位置的横坐标（默认值） ypos4 := 214 ; 要点击位置的纵坐标（默认值） ; 快捷键：^F1 ^F1:: { MouseGetPos, xpos, ypos ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos%,y:%ypos% return } ; 快捷键：^F2 ^F2:: { MouseClick, left, %xpos%, %ypos%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：^F3 ^F3:: { MouseGetPos, xpos2, ypos2 ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos2%,y:%ypos2% return } ; 快捷键：^F4 ^F4:: { MouseClick, left, %xpos2%, %ypos2%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：^F5 ^F5:: { MouseGetPos, xpos3, ypos3 ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos3%,y:%ypos3% return } ; 快捷键：^F6 ^F6:: { MouseClick, left, %xpos3%, %ypos3%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：^F7 ^F7:: { MouseGetPos, xpos4, ypos4 ; 更新位置坐标 MsgBox,拾取光标坐标x:%xpos4%,y:%ypos4% return } ; 快捷键：^F8 ^F8:: { MouseClick, left, %xpos4%, %ypos4%, 1, 0 ; 在指定坐标处点击鼠标左键 return } AutoHotkey控制我的某电脑的触摸板是否打开 ; 按 A 和 D 分别对应点击两个单独的屏幕坐标 ; 按 Q 和 E 分别对应重新设置两个单独的屏幕坐标位置 xpos := 300 ; 要点击位置的横坐标（默认值） ypos := 120 ; 要点击位置的纵坐标（默认值） xpos2 := 50 ; 要点击位置的横坐标（默认值） ypos2 := 220 ; 要点击位置的纵坐标（默认值） xpos3 := 1280 ; 要点击位置的横坐标（默认值） ypos3 := 850 ; 要点击位置的纵坐标（默认值） xpos4 := 1320 ; 要点击位置的横坐标（默认值） ypos4 := 10 ; 要点击位置的纵坐标（默认值） ; 快捷键：^F2 ^F2:: { MouseClick, left, %xpos%, %ypos%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：^F4 ^F4:: { MouseClick, left, %xpos2%, %ypos2%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：^F6 ^F6:: { MouseClick, left, %xpos3%, %ypos3%, 1, 0 ; 在指定坐标处点击鼠标左键 return } ; 快捷键：^F8 ^F8:: { MouseClick, left, %xpos4%, %ypos4%, 1, 0 ; 在指定坐标处点击鼠标左键 return } windows环境使用cygwin匹配ip 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/usr/bin/bash set +m ip=`ipconfig | awk \u0026#39;{print $14}\u0026#39; | grep \u0026#34;192\u0026#34; | tr \u0026#39;\\r\\n\u0026#39; \u0026#39; \u0026#39; ` echo $ip echo $ip | awk -F \u0026#39; \u0026#39; \u0026#39;{print $1}\u0026#39; echo $ip | awk -F \u0026#39; \u0026#39; \u0026#39;{print $2}\u0026#39; echo $ip | awk -F \u0026#39; \u0026#39; \u0026#39;{print $3}\u0026#39; for i in $ip do ping $i done windows环境cmd使用ping局域网所有ip for /L %i in (10,1,80) do ping -n 1 -w 60 172.24.240.%i | find \u0026quot;回复\u0026quot; \u0026gt;\u0026gt;pingall.txt 这一条命令是ping局域网内地址范围在172.24.240.10~172.24.240.80的所有主机。ping的结果会输出到执行命令的目录里面的pingAll.txt文件。 for /L %i in (start,step,end) do command %i：循环变量，用于迭代循环中的值。在命令提示符中，需要使用单个百分号 %，而不是双百分号 %%。 start：循环的起始值。 step：每次迭代递增或递减的步长。 end：循环的结束值。 command：在每次迭代中要执行的命令。 linux环境ping局域网所有ip 1 for((i = 1; i \u0026lt; 10; i++)); do ping -n 1 -w 60 192.168.1.$((i)); done | grep \u0026#34;from\u0026#34; | awk \u0026#39;{print $3}\u0026#39; | tr \u0026#39;:\u0026#39; \u0026#39;\\n\u0026#39; \u0026gt;\u0026gt; pingall.txt 在linux环境ping局域网ip并进行ssh连接的bash shell脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/bash set +m #ip=`ipconfig | awk \u0026#39;{print $14}\u0026#39; | grep \u0026#34;192\u0026#34; | tr \u0026#39;\\r\\n\u0026#39; \u0026#39; \u0026#39; ` ip=`for((i = 1; i \u0026lt; 10; i++)); do ping -n 1 -w 60 192.168.1.$((i)); done | grep \u0026#34;from\u0026#34; | awk \u0026#39;{print $3}\u0026#39; | tr \u0026#39;:\u0026#39; \u0026#39; \u0026#39; | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;` #ip=`arp -a | awk \u0026#39;{print $1}\u0026#39; | grep \u0026#34;192\u0026#34; | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;` #查看变量ip中的内容 #echo $ip #echo $ip | awk -F \u0026#39; \u0026#39; \u0026#39;{print $1}\u0026#39; #echo $ip | awk -F \u0026#39; \u0026#39; \u0026#39;{print $2}\u0026#39; #echo $ip | awk -F \u0026#39; \u0026#39; \u0026#39;{print $3}\u0026#39; for i in $ip do ssh u0_a731@$i -p 8022 done 命令arp -a 在使用 arp -a 命令时，它将显示计算机的 ARP（地址解析协议）缓存中的条目，该缓存用于将 IP 地址映射到 MAC 地址。这些条目可以是动态的或静态的。 linux环境获取进程id并kill掉 ps aux | grep \u0026quot;5901\u0026quot; | grep -v grep | awk '{print $2}' | xargs kill TigerVNC 详解 一 在linux vnc客户端shell下运行\u0026quot;ssh -L 5901:localhost:5901 vncserverhost\u0026quot;命令，输入用户名密码。即完成通过shh安全通道，将远程的5901端口转发到本机的5901端口。然后在shell下运行\u0026quot;vncviewer 127.0.0.1:1\u0026quot;命令即可以连接到远程的VNC Server。 通过Termux和VNC实现以手机为服务器的桌面办公 使用 input-overlay 工具在 OBS Studio 中展示鼠标和按键操作 ","date":"2023-07-30T14:52:08+08:00","permalink":"https://ynhugo.github.io/p/note/","title":"note"},{"content":" 学习git-bash的网站 廖雪峰的官方网站-git教程\n菜鸟教程-git\nw3cschool-git教程\ngit-简易指南\ncsdn-git\ngitee-git\ngit的核心概念\n博客园-git\ngit-scm教程\ngitee-git命令学习\ngit初始化本地仓库和基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 mkdir cangku\t# 建一个空文件夹 cd cangku\t# 进入创建的文件夹 git init # 将该文件夹初始化为本地仓库 git config --global user.name \u0026#34;name\u0026#34; # \u0026#34;name\u0026#34;对应github注册时的用户名 git config --global user.email \u0026#34;email\u0026#34; # \u0026#34;email\u0026#34;对应github注册时的用户名 git remote add origin \u0026lt;远程仓库地址\u0026gt; # 添加远程仓库地址 git remote set-url --add origin \u0026lt;远程仓库地址\u0026gt; # 添加第二个远程仓库地址 echo \u0026#34;Hello\u0026#34; \u0026gt;\u0026gt; newFile\t# 创建一个\u0026#34;newFile\u0026#34;文件并添加\u0026#34;Hello\u0026#34; git add .\t# 添加本地仓库所有文件到暂存区 git commit -m \u0026#34;Commit a file.\u0026#34;\t# 对添加到文件暂存区的内容添加文件描述 git checkout -b main\t# 创建本地分支 git push -u origin main\t# 将文件暂存区的内容推送到远程的\u0026#34;main\u0026#34;分支 git checkout -b develop master\t# 创建一个基于 master 的叫做 develop 的新分支 git checkout main # 切换到 main 分支 git merge --no-ff develop\t# Git执行\u0026#34;快进式合并\u0026#34;（fast-farward merge），会直接将 Master 分支指向 Develop 分支 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke # 将一个仓库克隆到某一子目录下，并且会添加子模块到当前目录，这样的操作不会影响主目录的 git 仓库操作 git log 或 git reflog\t# 查看提交记录 git reset --hard 894bece\t# 版本回退到该提前记录 git push -f\t# 强制推送 git rebase -i HEAD~n # 使用 git rebase -i HEAD~5 压缩5个commit为1个，或者git rebase -i 51efaef517abdbf674478de6073c12239d78a56a （第一个commit的id），然后在vim编辑器中，按i编辑，将后4个commit的pick修改为fixup，保留第一个pick。按esc键，输入:wq保存退出。 .gitmodules 内容展示 1 2 3 [submodule \u0026#34;hugo1/themes/hugo-theme-stack\u0026#34;] path = hugo1/themes/hugo-theme-stack url = https://github.com/CaiJimmy/hugo-theme-stack/ 参考链接 git进行版本回退（文件恢复、恢复误提交、已提交）\n[Git] 两种方法合并多个commit为一个\n一个项目设置两个git地址，并最终实现一次性同时推送到到两个git地址上的方法总结\n推送和拉取 推送 push -u 推送到远程分支时与远程分支内容合并 push -f 推送到远程分支时与覆盖远程分支内容 1 2 3 git push -u origin master 或 git pull -f origin master 拉取 pull 拉取远程分支内容 1 git pull origin master git fatal: 拒绝合并无关的历史的错误解决方法\n1 git pull origin master --allow-unrelated-histories git pull 命令时出现了冲突 这通常是因为远程仓库和本地仓库的历史记录不一致导致的。\n执行 git status 命令查看当前的状态，确认哪些文件存在冲突。 手动编辑冲突的文件，解决冲突。冲突通常会被标记为类似以下内容的标记： 1 2 3 4 5 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD // 本地仓库中的代码 ======= // 远程仓库中的代码 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; FETCH_HEAD 您需要手动选择保留哪些代码，并删除冲突标记，直到文件中所有的冲突都得到解决。\n解决冲突后，执行 git add \u0026lt;冲突文件\u0026gt; 将已解决冲突的文件标记为已解决。 最后执行 git commit 提交解决冲突后的修改。 【Git】 如何将一个分支的某个提交合并到另一个分支 在使用 Git 进行版本控制时，常常会遇到这样的需求：将某个分支的特定提交合并到另一个分支中。这种情况下，我们可以使用 cherry-pick 命令来实现。本文将详细介绍 cherry-pick 命令的使用方法，并介绍一些 cherry-pick 的高级用法。\n什么是 git cherry-pick git cherry-pick 命令可以将某个分支上的特定提交应用到当前分支上。与 merge 或 rebase 不同，cherry-pick 只关注指定的提交，而不处理整个分支的变更历史。\n基本用法 以下是使用 git cherry-pick 将一个分支的某个提交合并到另一个分支的具体步骤：\n切换到目标分支 首先，切换到你希望将提交合并到的目标分支。\n1 git checkout 目标分支 例如，如果目标分支是 main，则执行：\n1 git checkout main 找到提交的哈希值 在源分支中找到你想要合并的那个提交的哈希值（SHA-1）。你可以通过以下命令查看提交日志：\n1 git log 源分支 例如：\n1 git log feature 找到你需要的提交的哈希值，例如 abc123。\nCherry-pick 提交 使用 cherry-pick 命令将该提交合并到当前分支。\n1 git cherry-pick 提交的哈希值 例如：\n1 git cherry-pick abc123 解决冲突 在 cherry-pick 过程中可能会遇到冲突。此时需要手动解决冲突，然后继续 cherry-pick 过程。\n解决冲突后，添加解决冲突后的文件：\ngit add 解决冲突后的文件\n继续 cherry-pick 过程：\n1 git cherry-pick --continue 如果想要放弃这次 cherry-pick，可以使用以下命令：\n1 git cherry-pick --abort cherry-pick 的其他用法 合并多个提交 如果需要一次性合并多个提交，可以在 cherry-pick 后面指定多个提交的哈希值：\n1 git cherry-pick 哈希值1 哈希值2 哈希值3 也可以使用提交范围：\n1 git cherry-pick 哈希值A..哈希值B 编辑提交信息 在 cherry-pick 的时候，可以使用 -e 选项来编辑提交信息：\n1 git cherry-pick -e 提交的哈希值 保留提交信息 使用 -x 选项可以在提交信息中加入原始提交的引用信息，方便追溯：\n1 git cherry-pick -x 提交的哈希值 忽略空提交 使用 –skip 选项可以跳过空的提交（即已经应用的变更）：\n1 git cherry-pick --skip 总结一下 git cherry-pick 是一个非常有用的命令，可以帮助我们将特定的提交从一个分支应用到另一个分支。在使用过程中，遇到冲突时需要手动解决，并可以利用一些高级选项来增强 cherry-pick 的功能。通过掌握这些技巧，能够更灵活地管理项目的版本控制。\n查看和删除分支 1 2 3 4 5 6 7 8 9 10 11 git branch\t#查看本地分支 git branch -r\t#查看远程分支 git branch -a\t#查看本地和远程分支 git branch -d 本地分支名\t#删除本地分支 git push origin --delete 远程分支名 #删除远程分支 git push origin 远程分支名\t#推送空分支到远程(删除远程分支的另一种实现) 修改远程仓库地址 方法1 1 2 3 4 5 git remote set-url origin \u0026lt;url\u0026gt; git remote rm origin git remote add origin \u0026lt;url\u0026gt; 方法2(先删后加) 1 2 3 git remote rm origin #删除远程仓库地址 git remote add origin \u0026lt;url\u0026gt; #添加远程仓库地址 方法3(直接修改配置文件) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 进入git的根目录，编辑config文件，将文件中的内容修改成自己的 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly [remote \u0026#34;origin\u0026#34;] url = \u0026lt;仓库地址\u0026gt; fetch = +refs/heads/*:refs/remotes/origin/* Git 仓库的远程列表 查看远程列表 要查看 Git 仓库的远程列表，我们可以使用 git remote 命令。这个命令会列出所有远程仓库的名称。\n1 2 git remote origin 如果仓库有多个远程仓库，我们可以使用 -v 选项查看更详细的信息，包括每个远程仓库的 URL。\n1 git remote -v 参考链接 Git 仓库的远程列表\n构建github代码文件链接的方法 1 2 3 4 5 6 7 对于 GitHub 上的代码文件,可以通过以下方式构建它的 raw 格式链接: https://raw.githubusercontent.com/:owner/:repo/:branch/:path/to/file 其中: - :owner - 仓库所属的用户或组织名 - :repo - 仓库的名称 - :branch - 代码所在的分支,通常是 master - :path/to/file - 仓库内文件的路径 其他操作 1 2 3 4 5 git fetch origin \u0026#34;远程分支名\u0026#34; # 将指定的远程分支与本地建立链接 git remote add \u0026#34;test\u0026#34; \u0026#34;远程仓库链接\u0026#34; # 用git将\u0026#34;远程仓库\u0026#34;起别名为\u0026#34;test\u0026#34; git fetch test master:dev\t# pull取远程仓库最新代码（需要新分支来储存），test为远程仓库名，默认为origin git diff dev\t# 查看远程最新分支与本地最新分支的区别，这里dev是新建分支 git merge dev\t# 将远程最新分支与本地最新分支合并 参考链接 https://blog.csdn.net/xiaoxgongzs/article/details/105099281\n要将一个 Git 仓库作为子模块添加到另一个 Git 仓库中，你可以按照以下步骤操作： 在父项目中初始化子模块： 在父项目的根目录下打开命令行或终端，并执行以下命令： 1 git submodule add \u0026lt;子模块的远程仓库地址\u0026gt; \u0026lt;子模块的存放路径\u0026gt; 例如：\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 这将把 hugo-theme-stack 作为子模块添加到 themes/hugo-theme-stack 路径中。\n提交更新： 添加子模块后，父项目会有一些变动，需要提交到版本控制系统中： 1 git commit -m \u0026#34;Add hugo-theme-stack submodule\u0026#34; 初始化子模块（如果有必要）： 在父项目的根目录下执行以下命令来初始化子模块： 1 git submodule update --init --recursive 这会将子模块的代码拉取到本地，使得父项目能够使用它。\n提交更新： 如果你初始化了子模块，那么子模块的代码也会被拉取到本地，需要将这些变动提交到版本控制系统中： 1 git commit -m \u0026#34;Initialize hugo-theme-stack submodule\u0026#34; 推送更新（可选）： 如果需要，将父项目的更新推送到远程仓库： 1 git push 以上步骤将会在父项目中成功添加一个子模块。在执行这些步骤之前，请确保你对子模块的路径和远程仓库地址有正确的了解，并且你有权限访问这些仓库。\n子模块索引过，如何再次索引 如果你已经删除了相关的索引文件（比如.gitmodules文件）并且配置文件中也不包含索引信息，但仍然无法添加子模块，可能是由于Git仓库中还存在一些缓存或其他问题导致的。\n你可以尝试以下步骤来清除可能导致无法添加子模块的问题：\n**清除子模块缓存**：\n1 git rm --cached hugo1/themes/hugo-theme-stack **删除子模块目录**：\n1 rm -rf hugo1/themes/hugo-theme-stack **提交更改**：\n1 2 3 git add . git commit -m \u0026#34;Remove submodule hugo-theme-stack\u0026#34; git push 完成以上步骤后，你可以尝试重新添加子模块：\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ hugo1/themes/hugo-theme-stack 以上步骤来源于 chatgpt，而我实际操作的时候只执行了第一步，即清除子模块缓存，然后执行最后一步，即重新添加子模块\nGit 如何解决从GitHub克隆仓库时出现的SSL证书自签名问题 解决方案 在解决SSL证书自签名问题前，我们先要了解一下Git配置中和SSL有关的几个关键属性：\nhttp.sslVerify：该属性用于指定是否验证SSL证书，默认值为true，表示验证证书。 http.sslCAInfo：该属性用于指定SSL证书的位置，提供自定义的CA证书进行验证。 http.sslCAPath：该属性用于指定SSL证书的路径，提供自定义的CA证书进行验证。 方案一：忽略SSL证书验证 当您确定从GitHub上克隆仓库的过程中，SSL证书问题不会对仓库的安全性产生威胁时，您可以选择忽略SSL证书验证。在使用Git命令进行克隆操作时，可以添加-c选项，并指定http.sslVerify=false参数\n操作方式 1 git -c http.sslVerify=false clone https://github.com/username/repo.git 通过设置http.sslVerify为false，Git会跳过证书验证，并将通信与GitHub建立起来。\n使用实例 1 git -c Http.sslVerify=false clone https://hub.nuaa.cf/hexgio/emacs_config.git 参考链接 Git 如何解决从GitHub克隆仓库时出现的SSL证书自签名问题\ngit reset –hard git reset –hard 是一个Git命令，其作用是将当前的工作目录和索引（即暂存区）都重置为指定的提交（commit），并且丢弃所有未提交的修改。 具体来说，它的作用如下：\n重置工作目录和暂存区： 使用 –hard 选项会将工作目录和暂存区完全重置为指定的提交状态。这意味着当前的工作目录中的所有未提交的修改都会被删除，包括未添加到暂存区的文件修改和已经添加到暂存区但未提交的更改。 丢弃所有本地修改： 如果你在工作目录中进行了一些修改（比如编辑文件、添加新文件等），但是还没有提交这些更改，运行 git reset –hard 将会丢弃所有这些修改，使工作目录变成指定提交的状态。 慎重使用： 由于 git reset –hard 会永久丢弃所有未提交的工作，因此在使用时需要特别小心。确保你真的希望丢弃所有本地修改并将工作目录恢复到指定提交的状态。 总之，git reset –hard 是一个强制性的命令，可以帮助你彻底清理和重置本地工作目录和暂存区，回到指定提交的状态。\n在 Git 中，reset 和 –hard 是两个不同的命令和选项，它们分别具有以下作用： git reset git reset 命令用于将当前分支的 HEAD 指针重置为指定的状态，并且可以选择是否更新暂存区和工作目录。\n作用： 主要用于撤销提交、重置当前分支的位置或者在不同的模式之间切换。 常见用法：\ngit reset \u0026lt;commit\u0026gt;：将当前分支的 HEAD 指针移动到 \u0026lt;commit\u0026gt;，并且不更改暂存区和工作目录。这个命令通常用于撤销提交或者移动到不同的提交上。 git reset –soft \u0026lt;commit\u0026gt;：将 HEAD 指针移动到 \u0026lt;commit\u0026gt;，并且保留暂存区和工作目录的更改。这个命令通常用于撤销最近的一次提交，并且保留更改以便重新提交。 git reset –mixed \u0026lt;commit\u0026gt;（默认行为）：将 HEAD 指针移动到 \u0026lt;commit\u0026gt;，并且重置暂存区，但是保留工作目录的更改。这个命令通常用于取消暂存的更改或者将暂存区和工作目录的状态与指定提交保持一致。 git reset –hard \u0026lt;commit\u0026gt;：将 HEAD 指针移动到 \u0026lt;commit\u0026gt;，并且重置暂存区和工作目录，使它们与指定提交完全一致。这个命令通常用于彻底清理工作目录并重置到指定的提交状态。 –hard 选项 –hard 是 git reset 命令的一个选项，用于指定重置的模式之一。它的作用是：\n作用： 在执行 git reset 时，–hard 选项会重置当前分支的 HEAD 指针，并且彻底重置暂存区和工作目录，使它们与指定的提交完全一致。 注意事项： 使用 git reset –hard 时要非常小心，因为它会永久删除未提交的工作目录中的所有更改。任何未提交的更改都将被彻底清除。 综上所述，git reset 是一个多功能命令，可以用来移动 HEAD 指针和管理暂存区、工作目录的状态。而 –hard 是 git reset 命令的一种选项，用于彻底重置工作目录和暂存区，以使它们与指定的提交完全一致。\ngit reset 命令在 Git 中有三种常见的重置模式，它们是： –soft 模式：\ngit reset –soft \u0026lt;commit\u0026gt;：在这种模式下，Git 会将 HEAD 指针移动到 \u0026lt;commit\u0026gt;，但是不会重置暂存区和工作目录。这意味着所有的更改都会保留在工作目录中，并且保留在暂存区，因此你可以随时使用 git commit 命令来提交这些更改。 典型用途：用于取消上一次提交，并将更改保留在工作目录和暂存区，以便进一步调整或重新提交。 –mixed 模式：\ngit reset –mixed \u0026lt;commit\u0026gt; 或 git reset \u0026lt;commit\u0026gt;（默认模式）：这种模式是 git reset 的默认行为。在这种模式下，Git 会将 HEAD 指针移动到 \u0026lt;commit\u0026gt;，同时重置暂存区的状态，但是保留工作目录中的更改。 典型用途：用于取消暂存的更改，或者将暂存区和工作目录的状态与指定的提交保持一致。 –hard 模式：\ngit reset –hard \u0026lt;commit\u0026gt;：这是最强制的重置模式。在这种模式下，Git 会将 HEAD 指针移动到 \u0026lt;commit\u0026gt;，并且彻底重置暂存区和工作目录，使它们与指定的提交完全一致。 典型用途：用于完全丢弃工作目录中的所有未提交更改，并将工作目录恢复到指定提交的状态。 这些模式允许你根据需要选择不同级别的重置操作。在选择使用 –soft、–mixed 或 –hard 时，务必注意其影响范围，以免意外丢失或保留不必要的更改。\nGit在检出代码时遇到了问题，可能是由于网络问题或Git版本不兼容 异常现象 1 2 3 4 5 6 7 8 9 10 11 12 $ git clone https://www.modelscope.cn/pzc163/chatTTS.git 正克隆到 \u0026#39;chatTTS\u0026#39;... remote: Enumerating objects: 49, done. remote: Counting objects: 100% (49/49), done. remote: Compressing objects: 100% (39/39), done. remote: Total 49 (delta 15), reused 29 (delta 8), pack-reused 0 接收对象中: 100% (49/49), 6.23 KiB | 398.00 KiB/s, 完成. 处理 delta 中: 100% (15/15), 完成. 致命错误：协议错误：错误的行长度字符串：Not 警告：克隆成功，但是检出失败。 您可以通过 \u0026#39;git status\u0026#39; 检查哪些已被检出，然后使用命令 \u0026#39;git restore --source=HEAD :/\u0026#39; 重试 解决方式 1 git restore --source=HEAD :/ github的一些快捷键和在线编辑器 github的一些常用快捷键 按键 说明 s 跳转到搜索框 t 用于仓库内的文件搜索 l 在仓库文件显示页，键入l后在弹处窗口输入行号，表示跳转到该文件的指定行 b 查看文件改动进度 ctrl+k 快速定位查看内容模块 . 进入在线编辑器模式 GitHub 看代码神器 只需将github网页地址中github.com改为github1s.com (增加的字符是123的\u0026#34;1\u0026#34;和\u0026#34;s\u0026#34;） GitHub 官方出的 Online VSCode 编辑器：输入.键（句号键），相当于把仓库地址中github.com改为github.dev 1 参考：https://blog.csdn.net/cqcre/article/details/120398001 地址前加上 (https://) gitpod.io/#/,，即把地址中gihub.com改为gitpod.io/#/github.com，直接进入gitpod。 1 2 可在线运行脚本，里面有安装的依赖包。 可直接一键构建docker镜像。 参考链接 github的一些快捷键和在线编辑器\nGit 如何使用一条命令来获取Git根目录 在本文中，我们将介绍如何使用一条命令来获取Git根目录。在Git中，根目录是指包含.git文件夹的顶级目录，它是整个Git仓库的起始点。\n使用git rev-parse命令获取Git根目录 Git提供了一个名为git rev-parse的命令，可以用来解析、处理Git对象以及获取与之相关的信息。通过使用git rev-parse命令，我们可以获取Git根目录的绝对路径。\n要获取Git根目录的绝对路径，可以在命令行中输入以下命令：\n1 git rev-parse --show-toplevel 这将返回Git根目录的绝对路径。例如，假设我们的Git仓库位于/Users/username/git-repo目录中，那么以上命令将返回/Users/username/git-repo。你可以在自己的Git仓库中尝试该命令，看看它是否返回了正确的根目录路径。\n示例 让我们通过一个示例来进一步说明如何使用git rev-parse命令获取Git根目录。\n首先，我们在命令行中切换到我们的Git仓库所在的目录。\n1 cd /path/to/git-repo 接下来，我们可以使用git rev-parse –show-toplevel命令来获取Git根目录的路径。\n1 git rev-parse --show-toplevel 结果将会显示Git根目录的绝对路径。\n1 /path/to/git-repo 通过执行以上命令，我们成功地获取了Git根目录的路径。\n其他方法 除了使用git rev-parse命令之外，还有一些其他方法可以获取Git根目录的路径。这些方法可能更简洁或更适合特定的情况，但可能不如git rev-parse命令灵活。\n使用git rev-parse –show-cdup命令可以返回到Git根目录所需的相对路径。 使用git rev-parse –git-dir命令可以返回相对于当前目录的.git文件夹的路径。\n在Git的钩子脚本中，可以使用git rev-parse命令获取Git根目录以及其他相关信息，用于自定义的处理逻辑。\n请注意，使用这些方法时需要切换到Git仓库所在的目录。\n总结 通过使用git rev-parse命令，我们可以方便地获取Git根目录的路径。该命令对于构建自定义的Git工具或在Git钩子脚本中进行自定义处理非常有用。除了git rev-parse命令之外，还有一些其他方法可以获取Git根目录的路径，但可能不如git rev-parse命令灵活。希望本文对你理解如何获取Git根目录有所帮助。\n参考链接 Git 如何使用一条命令来获取Git根目录\n我的push与pull脚本 push脚本 upload.sh\n1 2 3 4 5 6 7 cd $(git rev-parse --show-toplevel) git add . git commit -m \u0026#34;test\u0026#34; git push -u origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) pull脚本 pull.sh\n1 2 3 cd $(git rev-parse --show-toplevel) git pull origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) 强制push脚本 force_upload.sh\n1 2 3 4 5 6 7 cd $(git rev-parse --show-toplevel) git add . git commit -m \u0026#34;test\u0026#34; git push -f origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) 强制pull脚本 force_pull.sh\n1 2 3 4 5 6 7 cd $(git rev-parse --show-toplevel) git fetch origin git reset --hard origin/$(git branch | awk \u0026#39;{print $2}\u0026#39;) git pull origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) 将脚本整合到一起 git_push_pull.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 case $1 in push) cd $(git rev-parse --show-toplevel) git add . git commit -m \u0026#34;test\u0026#34; git push -u origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) ;; force_push) cd $(git rev-parse --show-toplevel) git add . git commit -m \u0026#34;test\u0026#34; git push -f origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) ;; pull) cd $(git rev-parse --show-toplevel) git pull origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) ;; force_pull) cd $(git rev-parse --show-toplevel) git fetch origin git reset --hard origin/$(git branch | awk \u0026#39;{print $2}\u0026#39;) git pull origin $(git branch | awk \u0026#39;{print $2}\u0026#39;) ;; ,*) echo \u0026#34;Usage:\u0026#34; echo \u0026#34;$0 push|force_push|pull|force_pull\u0026#34;\t;; esac 在执行 git pull 操作时，本地的某些文件发生了修改，而这些修改未被提交。git pull 操作会试图将远程分支的更改合并到本地分支，但这会导致你本地的修改被覆盖，从而产生了冲突 为了解决这个问题，你可以采取以下几种方法之一：\n1. 提交本地更改 如果你希望保留你本地的修改，最简单的做法是先将本地更改提交，再进行合并操作。步骤如下：\n1 2 3 4 5 6 7 8 9 10 11 # 查看当前文件修改的状态 git status # 将文件添加到暂存区 git add filename # 提交更改 git commit -m \u0026#34;保存本地修改\u0026#34; # 进行拉取操作 git pull 2. 暂存本地更改 如果你暂时不想提交本地更改，可以使用 git stash 来存储本地更改，再进行拉取操作。步骤如下：\n1 2 3 4 5 6 7 8 # 暂存本地更改 git stash # 拉取远程代码 git pull # 恢复本地更改 git stash pop 3. 丢弃本地更改 如果你确定不需要保留本地的更改，可以直接丢弃这些修改。步骤如下：\n1 2 3 4 5 # 丢弃本地更改 git checkout -- filename # 拉取远程代码 git pull 选择合适的方式取决于你是否需要保留本地的修改。如果你不确定如何操作，可以先用 git status 查看当前本地的修改情况，然后决定是否提交、暂存或丢弃这些修改。\n当前分支 Master 没有对应的上游分支 为推送当前分支并建立与远程上游的跟踪，使用:\n1 git push --set-upstream origin Master ","date":"2023-07-29T11:15:46+08:00","permalink":"https://ynhugo.github.io/p/github_study/","title":"Github_study"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://ynhugo.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://ynhugo.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://ynhugo.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://ynhugo.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://ynhugo.github.io/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://ynhugo.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://ynhugo.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://ynhugo.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://ynhugo.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://ynhugo.github.io/p/emoji-support/","title":"Emoji Support"}]