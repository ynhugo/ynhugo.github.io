<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" Linux下基于ffmpeg音视频解码 FFmpeg开发环境配置参考：Ubuntu 20.04LTS FFmpeg 环境配置\n工程示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 #include &lt;stdio.h&gt; #include &#34;libavcodec/avcodec.h&#34; #include &#34;libavformat/avformat.h&#34; #include &#34;libswscale/swscale.h&#34; #include &lt;libswresample/swresample.h&gt; #include &lt;libavutil/mathematics.h&gt; #include &lt;libavutil/timestamp.h&gt; #include &lt;stdio.h&gt; #include &lt;linux/fb.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; #include &lt;poll.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;wchar.h&gt; #include &lt;pthread.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;SDL.h&gt; #define FILE_NAME &#34;123.flv&#34; typedef unsigned char u8; typedef unsigned short u16; typedef unsigned int u32; typedef enum { false, true, }bool; uint8_t *out_buffer; #define MAX_AUDIO_FRAME_SIZE 1024*100 static Uint8* audio_chunk; static unsigned int audio_len=0; static unsigned char *audio_pos; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//互斥锁 //保存音频数据链表 struct AUDIO_DATA { unsigned char* audio_buffer; int audio_size; struct AUDIO_DATA *next; }; //定义一个链表头 struct AUDIO_DATA *list_head=NULL; struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head);//创建链表头 void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size);//添加节点 void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer);//删除节点 int List_GetNodeCnt(struct AUDIO_DATA *head);//遍历 int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size); int file_stat=1; void AudioCallback(void *userdata, Uint8 * stream,int len) { SDL_memset(stream, 0,len); if(audio_len&lt;=0) { return ; } len=(len&gt;audio_len?audio_len:len); SDL_MixAudio(stream,audio_pos,len,SDL_MIX_MAXVOLUME); audio_pos+=len; audio_len-=len; //printf(&#34;len=%d\\n&#34;,len); } void *Audio_decode(void *arg) { int res; int audio_size; char audio_buff[4096*3]; while(1) { res=List_GetNode(list_head,audio_buff,&amp;audio_size); if(res==0) { audio_chunk = audio_buff; //指向音频数据 (PCM data) while(audio_len&gt;0){}//等待数据处理完 audio_len =audio_size;//音频长度 audio_pos = audio_buff;//当前播放位置 } } } int main(int argc,char *argv[]) { if(argc!=2) { printf(&#34;格式:./app 文件名\\n&#34;); return 0; } char *file_name=argv[1]; /*SDL初始化*/ SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_TIMER); printf(&#34;pth:%s\\n&#34;,avcodec_configuration());/*获取ffmpeg配置信息*/ /*初始化所有组件*/ //av_register_all(); /*打开文件*/ AVCodecContext *pCodecCtx;//解码器上下文 AVFormatContext *ps=NULL;//音视频封装格式结构体信息 printf(&#34;name:%s\\n&#34;,file_name); int res=avformat_open_input(&amp;ps,file_name,NULL,NULL); if(res!=0) { printf(&#34;open err: %d\\n&#34;,res); return 0; } /*寻找解码信息*/ avformat_find_stream_info(ps,NULL); int64_t time=ps-&gt;duration; printf(&#34;time:%ld s\\n&#34;,time/1000000); /*打印有关输入或输出格式的详细信息*/ av_dump_format(ps,0,file_name,0); /*寻找视频流信息*/ int videostream=-1; int audiostream=-1; AVCodec *vcodec; videostream=av_find_best_stream(ps,AVMEDIA_TYPE_VIDEO,-1,-1,NULL, 0); printf(&#34;video=%d\\n&#34;,videostream); /*寻找音频流信息*/ audiostream=av_find_best_stream(ps,AVMEDIA_TYPE_AUDIO,-1,-1,NULL, 0); printf(&#34;audio=%d\\n&#34;,audiostream); AVStream *stream; int frame_rate; if(videostream!=-1)//判断是否找到视频流数据 { /*寻找视频解码器*/ AVStream *stream = ps-&gt;streams[videostream]; vcodec=avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id); if(!vcodec) { printf(&#34;未找到视频解码器\\n&#34;); return -1; }/*申请AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ res=avcodec_open2(stream-&gt;codec,vcodec,NULL); if(res) { printf(&#34;打开解码器失败\\n&#34;); return -1; } frame_rate=stream-&gt;avg_frame_rate.num/stream-&gt;avg_frame_rate.den;//每秒多少帧 printf(&#34;fps=%d\\n&#34;,frame_rate); printf(&#34;视频流ID=%#x\\n&#34;,vcodec-&gt;id);//音频流 } /*音频流数据处理*/ AVCodec *audcodec; AVStream *audstream; SwrContext *swrCtx;//保存重采样数据，即解码的信息 uint64_t out_channel_layout;//声道 int out_sample_fmt;//采样格式 int out_sample_rate;//采样率 int out_nb_samples;//样本数量 int out_channels;//通道数量 uint64_t in_channel_layout;//输入音频声道 SDL_AudioSpec desired;//SDL音频格式信息 AVFrame *audioframe;//保存音频数据 int out_buffer_size;//音频缓冲区大小 if(audiostream&gt;=0)//判断是否有音频流 { /*寻找音频解码器*/ audstream = ps-&gt;streams[audiostream]; audcodec=avcodec_find_decoder(audstream-&gt;codecpar-&gt;codec_id); if(!audcodec) { printf(&#34;audcodec failed\\n&#34;); return -1; } /*申请音频AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ pCodecCtx=audstream-&gt;codec;//解码器上下文 res=avcodec_open2(audstream-&gt;codec,audcodec,NULL); if(res) { printf(&#34;未找到音频解码器\\n&#34;); return -1; } printf(&#34;音频流ID=%#x\\n&#34;,audcodec-&gt;id);//音频流 printf(&#34;配置音频参数\\n&#34;); //输出音频参数 out_channel_layout = AV_CH_LAYOUT_STEREO; //声道格式 out_sample_fmt=AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S32;//;//采样格式 printf(&#34;pCodecCtx-&gt;sample_rate=%d\\n&#34;,pCodecCtx-&gt;sample_rate); out_sample_rate =pCodecCtx-&gt;sample_rate;//采样率，多为44100 /*样本数量*/ printf(&#34;frame_size=%d\\n&#34;,pCodecCtx-&gt;frame_size); if(pCodecCtx-&gt;frame_size&gt;0)out_nb_samples=pCodecCtx-&gt;frame_size; else if(audcodec-&gt;id == AV_CODEC_ID_AAC) out_nb_samples=1024;/*样本数量nb_samples: AAC-1024 MP3-1152 格式大小 */ else if(audcodec-&gt;id == AV_CODEC_ID_MP3)out_nb_samples=1152; else out_nb_samples=1024; out_channels=av_get_channel_layout_nb_channels(out_channel_layout);//通道个数 out_buffer_size=av_samples_get_buffer_size(NULL,out_channels,out_nb_samples,out_sample_fmt,1);//获取缓冲区大小 out_buffer=(uint8_t*)av_malloc(MAX_AUDIO_FRAME_SIZE); memset(out_buffer,0,out_buffer_size); printf(&#34;声道格式:%d\\n&#34;,out_channel_layout); printf(&#34;采样格式:%d\\n&#34;,out_sample_fmt);\tprintf(&#34;样本数量:%d\\n&#34;,out_nb_samples);\tprintf(&#34;采样率:%d\\n&#34;,out_sample_rate); printf(&#34;通道个数:%d\\n&#34;,out_channels); printf(&#34;缓冲区大小:%d\\n&#34;,out_buffer_size); //输入音频参数 in_channel_layout=av_get_default_channel_layout(pCodecCtx-&gt;channels);//输入声道格式 swrCtx = swr_alloc(); /*对解码数据进行重采样*/ swrCtx=swr_alloc_set_opts(swrCtx,out_channel_layout,out_sample_fmt,out_sample_rate,/*输入音频格式*/ in_channel_layout,pCodecCtx-&gt;sample_fmt,pCodecCtx-&gt;sample_rate,/*输出音频格式*/ 0,NULL);\tswr_init(swrCtx);//初始化swrCtx printf(&#34;输入音频格式:%d\\n&#34;,in_channel_layout); printf(&#34;输入采样格式:%d\\n&#34;,pCodecCtx-&gt;sample_fmt); printf(&#34;输入采样率:%d\\n&#34;,pCodecCtx-&gt;sample_rate); /*设置音频数据格式*/ desired.freq=out_sample_rate;/*采样率*/ desired.format=AUDIO_S16SYS;/*无符号16位*/ desired.channels=out_channels;/*声道*/ desired.samples=out_nb_samples;/*样本数1024*/ desired.silence=0;/*静音值*/ desired.callback=AudioCallback; SDL_OpenAudio(&amp;desired,NULL); SDL_PauseAudio(0);/*开始播放音频，1为播放静音值*/ //分配内存 audioframe=av_frame_alloc();/*分配音频帧*/ printf(&#34;音频数据初始化完成&#34;); } //视频解码 AVFrame *frame=av_frame_alloc();/*分配视频帧*/ AVFrame *frameYUV=av_frame_alloc();/*申请yuv空间*/ /*分配空间，进行图像转换*/ int width=ps-&gt;streams[videostream]-&gt;codecpar-&gt;width; int height=ps-&gt;streams[videostream]-&gt;codecpar-&gt;height; int fmt=ps-&gt;streams[videostream]-&gt;codecpar-&gt;format;/*流格式*/ printf(&#34;fmt=%d\\n&#34;,fmt); int size=avpicture_get_size(AV_PIX_FMT_RGB24, width,height); unsigned char *buff=NULL; printf(&#34;w=%d,h=%d,size=%d\\n&#34;,width,height,size); buff=av_malloc(size); /*计算一帧空间大小*/ avpicture_fill((AVPicture *)frameYUV,buff,AV_PIX_FMT_RGB24,width,height); /*转换上下文*/ struct SwsContext *swsctx=sws_getContext(width,height, fmt,width,height, AV_PIX_FMT_RGB24,SWS_BICUBIC,NULL,NULL,NULL); /*读帧*/ int go=0; int go_audio;\tlist_head=List_CreateHead(list_head);//创建链表头 /*创建音频处理线程*/ pthread_t pthid; pthread_create(&amp;pthid,NULL,Audio_decode,(void *)ps); pthread_detach(pthid);//设置为分离属性 /*创建窗口*/ SDL_Window *window=SDL_CreateWindow(&#34;SDL_VIDEO&#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,1280,720,SDL_WINDOW_SHOWN); /*创建渲染器*/ SDL_Renderer *render=SDL_CreateRenderer(window,-1,SDL_RENDERER_ACCELERATED); /*清空渲染器*/ SDL_RenderClear(render);\t/*创建纹理*/ SDL_Texture *sdltext=SDL_CreateTexture(render,SDL_PIXELFORMAT_RGB24,SDL_TEXTUREACCESS_STREAMING,width,height);\tbool quit=true; SDL_Event event; printf(&#34;read fream buff\\n&#34;); //初始化转码器 AVPacket *packet=av_malloc(sizeof(AVPacket));/*分配包*/ av_init_packet(packet);//初始化 int i=0; int index=0; long video_pts_time=0; long audio_pts_time=0;//音频解码时间 time=(1000000/frame_rate-10000);//时间 printf(&#34;time=%d\\n&#34;,time); while((av_read_frame(ps,packet)&gt;=0) &amp;&amp; (quit)) { SDL_PollEvent(&amp;event); if(event.type==SDL_QUIT) { quit=false; continue; } if(packet-&gt;stream_index == videostream)/*判断是否为视频*/ { res=avcodec_send_packet(ps-&gt;streams[videostream]-&gt;codec,packet); if(res) { av_packet_unref(packet);//释放这个pkt continue; } res=avcodec_receive_frame(ps-&gt;streams[videostream]-&gt;codec,frame); if(res) { av_packet_unref(packet);//释放这个pkt\tcontinue; } sws_scale(swsctx,(const uint8_t **)frame-&gt;data,frame-&gt;linesize,0,height,(const uint8_t **)frameYUV-&gt;data,frameYUV-&gt;linesize); video_pts_time=packet-&gt;pts; //printf(&#34;视频=%ld\\n&#34;,video_pts_time); SDL_UpdateTexture(sdltext,NULL,buff, width*3); SDL_RenderCopy(render, sdltext, NULL, NULL); // 拷贝纹理到渲染器 SDL_RenderPresent(render); //渲染 usleep(time); } if(packet-&gt;stream_index == audiostream) //如果为音频标志 { if(audiostream&lt;0)continue; res=avcodec_send_packet(pCodecCtx,packet); if(res) { printf(&#34;avcodec_send_packet failed,res=%d\\n&#34;,res); av_packet_unref(packet);//释放这个pkt\tcontinue; } res=avcodec_receive_frame(pCodecCtx,audioframe); if(res) { printf(&#34;avcodec_receive_frame failed,res=%d\\n&#34;,res); av_packet_unref(packet);//释放这个pkt continue; } //数据格式转换 res=swr_convert(swrCtx,&amp;out_buffer,out_buffer_size,/*重采样之后的数据*/ (const uint8_t **)audioframe-&gt;data,audioframe-&gt;nb_samples/*重采样之前数据*/ ); audio_pts_time=packet-&gt;pts; //printf(&#34;音频：%ld\\n&#34;,audio_pts_time); if(res&gt;0) { //audio_chunk =out_buffer; //指向音频数据 (PCM data) //while(audio_len&gt;0){}//等待数据处理完 //audio_len =audioframe-&gt;nb_samples;//out_buffer_size;//音频长度 //audio_pos =out_buffer;//当前播放位置 List_AddNode(list_head,out_buffer,out_buffer_size);//添加节点 } } //释放数据包 av_packet_unref(packet); } sws_freeContext(swsctx); av_frame_free(&amp;frame); av_frame_free(&amp;frameYUV); avformat_free_context(ps); return 0; } /*创建链表头*/ struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head) { if(head==NULL) { head=malloc(sizeof(struct AUDIO_DATA)); head-&gt;next=NULL; } return head;\t} /*添加节点*/ void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *new_node; pthread_mutex_lock(&amp;mutex); /*找到链表尾部*/ while(tmp-&gt;next) { tmp=tmp-&gt;next; } /*插入新的节点*/ new_node=malloc(sizeof(struct AUDIO_DATA)); new_node-&gt;audio_size=audio_size; new_node-&gt;audio_buffer=malloc(audio_size);//分配保存音频数据大小空间 memcpy(new_node-&gt;audio_buffer,audio_buffer,audio_size); new_node-&gt;next=NULL; /*将新节点接入到链表*/ tmp-&gt;next=new_node;\tpthread_mutex_unlock(&amp;mutex); } /* 函数功能:删除节点 */ void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *p; /*找到链表中要删除的节点*/ pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next) { p=tmp; tmp=tmp-&gt;next; if(tmp-&gt;audio_buffer==audio_buffer) { p-&gt;next=tmp-&gt;next; free(tmp-&gt;audio_buffer); free(tmp); break; } } pthread_mutex_unlock(&amp;mutex); } /* 函数功能:遍历链表，得到节点总数量 */ int List_GetNodeCnt(struct AUDIO_DATA *head) { int cnt=0; struct AUDIO_DATA *tmp=head; pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next) { tmp=tmp-&gt;next; cnt++; } pthread_mutex_unlock(&amp;mutex); return cnt; } /* 从链表头取数据 */ int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *ptemp=head; pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next!=NULL) { ptemp=tmp; tmp=tmp-&gt;next; if(tmp!=NULL) { *audio_size=tmp-&gt;audio_size; memcpy(audio_buff,tmp-&gt;audio_buffer,tmp-&gt;audio_size); ptemp-&gt;next=tmp-&gt;next; free(tmp-&gt;audio_buffer); free(tmp); pthread_mutex_unlock(&amp;mutex); return 0; } } pthread_mutex_unlock(&amp;mutex); return -1; } Makefile文件 注意Makefile文件中涉及到的路径要跟系统环境相匹配，如果路径不一致会编译报错\n">
<title>Linux下基于ffmpeg音视频解码</title>

<link rel='canonical' href='https://ynhugo.github.io/p/linux%E4%B8%8B%E5%9F%BA%E4%BA%8Effmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/'>

<link rel="stylesheet" href="/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="Linux下基于ffmpeg音视频解码">
<meta property='og:description' content=" Linux下基于ffmpeg音视频解码 FFmpeg开发环境配置参考：Ubuntu 20.04LTS FFmpeg 环境配置\n工程示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 #include &lt;stdio.h&gt; #include &#34;libavcodec/avcodec.h&#34; #include &#34;libavformat/avformat.h&#34; #include &#34;libswscale/swscale.h&#34; #include &lt;libswresample/swresample.h&gt; #include &lt;libavutil/mathematics.h&gt; #include &lt;libavutil/timestamp.h&gt; #include &lt;stdio.h&gt; #include &lt;linux/fb.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; #include &lt;poll.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;wchar.h&gt; #include &lt;pthread.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;SDL.h&gt; #define FILE_NAME &#34;123.flv&#34; typedef unsigned char u8; typedef unsigned short u16; typedef unsigned int u32; typedef enum { false, true, }bool; uint8_t *out_buffer; #define MAX_AUDIO_FRAME_SIZE 1024*100 static Uint8* audio_chunk; static unsigned int audio_len=0; static unsigned char *audio_pos; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//互斥锁 //保存音频数据链表 struct AUDIO_DATA { unsigned char* audio_buffer; int audio_size; struct AUDIO_DATA *next; }; //定义一个链表头 struct AUDIO_DATA *list_head=NULL; struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head);//创建链表头 void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size);//添加节点 void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer);//删除节点 int List_GetNodeCnt(struct AUDIO_DATA *head);//遍历 int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size); int file_stat=1; void AudioCallback(void *userdata, Uint8 * stream,int len) { SDL_memset(stream, 0,len); if(audio_len&lt;=0) { return ; } len=(len&gt;audio_len?audio_len:len); SDL_MixAudio(stream,audio_pos,len,SDL_MIX_MAXVOLUME); audio_pos+=len; audio_len-=len; //printf(&#34;len=%d\\n&#34;,len); } void *Audio_decode(void *arg) { int res; int audio_size; char audio_buff[4096*3]; while(1) { res=List_GetNode(list_head,audio_buff,&amp;audio_size); if(res==0) { audio_chunk = audio_buff; //指向音频数据 (PCM data) while(audio_len&gt;0){}//等待数据处理完 audio_len =audio_size;//音频长度 audio_pos = audio_buff;//当前播放位置 } } } int main(int argc,char *argv[]) { if(argc!=2) { printf(&#34;格式:./app 文件名\\n&#34;); return 0; } char *file_name=argv[1]; /*SDL初始化*/ SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_TIMER); printf(&#34;pth:%s\\n&#34;,avcodec_configuration());/*获取ffmpeg配置信息*/ /*初始化所有组件*/ //av_register_all(); /*打开文件*/ AVCodecContext *pCodecCtx;//解码器上下文 AVFormatContext *ps=NULL;//音视频封装格式结构体信息 printf(&#34;name:%s\\n&#34;,file_name); int res=avformat_open_input(&amp;ps,file_name,NULL,NULL); if(res!=0) { printf(&#34;open err: %d\\n&#34;,res); return 0; } /*寻找解码信息*/ avformat_find_stream_info(ps,NULL); int64_t time=ps-&gt;duration; printf(&#34;time:%ld s\\n&#34;,time/1000000); /*打印有关输入或输出格式的详细信息*/ av_dump_format(ps,0,file_name,0); /*寻找视频流信息*/ int videostream=-1; int audiostream=-1; AVCodec *vcodec; videostream=av_find_best_stream(ps,AVMEDIA_TYPE_VIDEO,-1,-1,NULL, 0); printf(&#34;video=%d\\n&#34;,videostream); /*寻找音频流信息*/ audiostream=av_find_best_stream(ps,AVMEDIA_TYPE_AUDIO,-1,-1,NULL, 0); printf(&#34;audio=%d\\n&#34;,audiostream); AVStream *stream; int frame_rate; if(videostream!=-1)//判断是否找到视频流数据 { /*寻找视频解码器*/ AVStream *stream = ps-&gt;streams[videostream]; vcodec=avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id); if(!vcodec) { printf(&#34;未找到视频解码器\\n&#34;); return -1; }/*申请AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ res=avcodec_open2(stream-&gt;codec,vcodec,NULL); if(res) { printf(&#34;打开解码器失败\\n&#34;); return -1; } frame_rate=stream-&gt;avg_frame_rate.num/stream-&gt;avg_frame_rate.den;//每秒多少帧 printf(&#34;fps=%d\\n&#34;,frame_rate); printf(&#34;视频流ID=%#x\\n&#34;,vcodec-&gt;id);//音频流 } /*音频流数据处理*/ AVCodec *audcodec; AVStream *audstream; SwrContext *swrCtx;//保存重采样数据，即解码的信息 uint64_t out_channel_layout;//声道 int out_sample_fmt;//采样格式 int out_sample_rate;//采样率 int out_nb_samples;//样本数量 int out_channels;//通道数量 uint64_t in_channel_layout;//输入音频声道 SDL_AudioSpec desired;//SDL音频格式信息 AVFrame *audioframe;//保存音频数据 int out_buffer_size;//音频缓冲区大小 if(audiostream&gt;=0)//判断是否有音频流 { /*寻找音频解码器*/ audstream = ps-&gt;streams[audiostream]; audcodec=avcodec_find_decoder(audstream-&gt;codecpar-&gt;codec_id); if(!audcodec) { printf(&#34;audcodec failed\\n&#34;); return -1; } /*申请音频AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ pCodecCtx=audstream-&gt;codec;//解码器上下文 res=avcodec_open2(audstream-&gt;codec,audcodec,NULL); if(res) { printf(&#34;未找到音频解码器\\n&#34;); return -1; } printf(&#34;音频流ID=%#x\\n&#34;,audcodec-&gt;id);//音频流 printf(&#34;配置音频参数\\n&#34;); //输出音频参数 out_channel_layout = AV_CH_LAYOUT_STEREO; //声道格式 out_sample_fmt=AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S32;//;//采样格式 printf(&#34;pCodecCtx-&gt;sample_rate=%d\\n&#34;,pCodecCtx-&gt;sample_rate); out_sample_rate =pCodecCtx-&gt;sample_rate;//采样率，多为44100 /*样本数量*/ printf(&#34;frame_size=%d\\n&#34;,pCodecCtx-&gt;frame_size); if(pCodecCtx-&gt;frame_size&gt;0)out_nb_samples=pCodecCtx-&gt;frame_size; else if(audcodec-&gt;id == AV_CODEC_ID_AAC) out_nb_samples=1024;/*样本数量nb_samples: AAC-1024 MP3-1152 格式大小 */ else if(audcodec-&gt;id == AV_CODEC_ID_MP3)out_nb_samples=1152; else out_nb_samples=1024; out_channels=av_get_channel_layout_nb_channels(out_channel_layout);//通道个数 out_buffer_size=av_samples_get_buffer_size(NULL,out_channels,out_nb_samples,out_sample_fmt,1);//获取缓冲区大小 out_buffer=(uint8_t*)av_malloc(MAX_AUDIO_FRAME_SIZE); memset(out_buffer,0,out_buffer_size); printf(&#34;声道格式:%d\\n&#34;,out_channel_layout); printf(&#34;采样格式:%d\\n&#34;,out_sample_fmt);\tprintf(&#34;样本数量:%d\\n&#34;,out_nb_samples);\tprintf(&#34;采样率:%d\\n&#34;,out_sample_rate); printf(&#34;通道个数:%d\\n&#34;,out_channels); printf(&#34;缓冲区大小:%d\\n&#34;,out_buffer_size); //输入音频参数 in_channel_layout=av_get_default_channel_layout(pCodecCtx-&gt;channels);//输入声道格式 swrCtx = swr_alloc(); /*对解码数据进行重采样*/ swrCtx=swr_alloc_set_opts(swrCtx,out_channel_layout,out_sample_fmt,out_sample_rate,/*输入音频格式*/ in_channel_layout,pCodecCtx-&gt;sample_fmt,pCodecCtx-&gt;sample_rate,/*输出音频格式*/ 0,NULL);\tswr_init(swrCtx);//初始化swrCtx printf(&#34;输入音频格式:%d\\n&#34;,in_channel_layout); printf(&#34;输入采样格式:%d\\n&#34;,pCodecCtx-&gt;sample_fmt); printf(&#34;输入采样率:%d\\n&#34;,pCodecCtx-&gt;sample_rate); /*设置音频数据格式*/ desired.freq=out_sample_rate;/*采样率*/ desired.format=AUDIO_S16SYS;/*无符号16位*/ desired.channels=out_channels;/*声道*/ desired.samples=out_nb_samples;/*样本数1024*/ desired.silence=0;/*静音值*/ desired.callback=AudioCallback; SDL_OpenAudio(&amp;desired,NULL); SDL_PauseAudio(0);/*开始播放音频，1为播放静音值*/ //分配内存 audioframe=av_frame_alloc();/*分配音频帧*/ printf(&#34;音频数据初始化完成&#34;); } //视频解码 AVFrame *frame=av_frame_alloc();/*分配视频帧*/ AVFrame *frameYUV=av_frame_alloc();/*申请yuv空间*/ /*分配空间，进行图像转换*/ int width=ps-&gt;streams[videostream]-&gt;codecpar-&gt;width; int height=ps-&gt;streams[videostream]-&gt;codecpar-&gt;height; int fmt=ps-&gt;streams[videostream]-&gt;codecpar-&gt;format;/*流格式*/ printf(&#34;fmt=%d\\n&#34;,fmt); int size=avpicture_get_size(AV_PIX_FMT_RGB24, width,height); unsigned char *buff=NULL; printf(&#34;w=%d,h=%d,size=%d\\n&#34;,width,height,size); buff=av_malloc(size); /*计算一帧空间大小*/ avpicture_fill((AVPicture *)frameYUV,buff,AV_PIX_FMT_RGB24,width,height); /*转换上下文*/ struct SwsContext *swsctx=sws_getContext(width,height, fmt,width,height, AV_PIX_FMT_RGB24,SWS_BICUBIC,NULL,NULL,NULL); /*读帧*/ int go=0; int go_audio;\tlist_head=List_CreateHead(list_head);//创建链表头 /*创建音频处理线程*/ pthread_t pthid; pthread_create(&amp;pthid,NULL,Audio_decode,(void *)ps); pthread_detach(pthid);//设置为分离属性 /*创建窗口*/ SDL_Window *window=SDL_CreateWindow(&#34;SDL_VIDEO&#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,1280,720,SDL_WINDOW_SHOWN); /*创建渲染器*/ SDL_Renderer *render=SDL_CreateRenderer(window,-1,SDL_RENDERER_ACCELERATED); /*清空渲染器*/ SDL_RenderClear(render);\t/*创建纹理*/ SDL_Texture *sdltext=SDL_CreateTexture(render,SDL_PIXELFORMAT_RGB24,SDL_TEXTUREACCESS_STREAMING,width,height);\tbool quit=true; SDL_Event event; printf(&#34;read fream buff\\n&#34;); //初始化转码器 AVPacket *packet=av_malloc(sizeof(AVPacket));/*分配包*/ av_init_packet(packet);//初始化 int i=0; int index=0; long video_pts_time=0; long audio_pts_time=0;//音频解码时间 time=(1000000/frame_rate-10000);//时间 printf(&#34;time=%d\\n&#34;,time); while((av_read_frame(ps,packet)&gt;=0) &amp;&amp; (quit)) { SDL_PollEvent(&amp;event); if(event.type==SDL_QUIT) { quit=false; continue; } if(packet-&gt;stream_index == videostream)/*判断是否为视频*/ { res=avcodec_send_packet(ps-&gt;streams[videostream]-&gt;codec,packet); if(res) { av_packet_unref(packet);//释放这个pkt continue; } res=avcodec_receive_frame(ps-&gt;streams[videostream]-&gt;codec,frame); if(res) { av_packet_unref(packet);//释放这个pkt\tcontinue; } sws_scale(swsctx,(const uint8_t **)frame-&gt;data,frame-&gt;linesize,0,height,(const uint8_t **)frameYUV-&gt;data,frameYUV-&gt;linesize); video_pts_time=packet-&gt;pts; //printf(&#34;视频=%ld\\n&#34;,video_pts_time); SDL_UpdateTexture(sdltext,NULL,buff, width*3); SDL_RenderCopy(render, sdltext, NULL, NULL); // 拷贝纹理到渲染器 SDL_RenderPresent(render); //渲染 usleep(time); } if(packet-&gt;stream_index == audiostream) //如果为音频标志 { if(audiostream&lt;0)continue; res=avcodec_send_packet(pCodecCtx,packet); if(res) { printf(&#34;avcodec_send_packet failed,res=%d\\n&#34;,res); av_packet_unref(packet);//释放这个pkt\tcontinue; } res=avcodec_receive_frame(pCodecCtx,audioframe); if(res) { printf(&#34;avcodec_receive_frame failed,res=%d\\n&#34;,res); av_packet_unref(packet);//释放这个pkt continue; } //数据格式转换 res=swr_convert(swrCtx,&amp;out_buffer,out_buffer_size,/*重采样之后的数据*/ (const uint8_t **)audioframe-&gt;data,audioframe-&gt;nb_samples/*重采样之前数据*/ ); audio_pts_time=packet-&gt;pts; //printf(&#34;音频：%ld\\n&#34;,audio_pts_time); if(res&gt;0) { //audio_chunk =out_buffer; //指向音频数据 (PCM data) //while(audio_len&gt;0){}//等待数据处理完 //audio_len =audioframe-&gt;nb_samples;//out_buffer_size;//音频长度 //audio_pos =out_buffer;//当前播放位置 List_AddNode(list_head,out_buffer,out_buffer_size);//添加节点 } } //释放数据包 av_packet_unref(packet); } sws_freeContext(swsctx); av_frame_free(&amp;frame); av_frame_free(&amp;frameYUV); avformat_free_context(ps); return 0; } /*创建链表头*/ struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head) { if(head==NULL) { head=malloc(sizeof(struct AUDIO_DATA)); head-&gt;next=NULL; } return head;\t} /*添加节点*/ void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *new_node; pthread_mutex_lock(&amp;mutex); /*找到链表尾部*/ while(tmp-&gt;next) { tmp=tmp-&gt;next; } /*插入新的节点*/ new_node=malloc(sizeof(struct AUDIO_DATA)); new_node-&gt;audio_size=audio_size; new_node-&gt;audio_buffer=malloc(audio_size);//分配保存音频数据大小空间 memcpy(new_node-&gt;audio_buffer,audio_buffer,audio_size); new_node-&gt;next=NULL; /*将新节点接入到链表*/ tmp-&gt;next=new_node;\tpthread_mutex_unlock(&amp;mutex); } /* 函数功能:删除节点 */ void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *p; /*找到链表中要删除的节点*/ pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next) { p=tmp; tmp=tmp-&gt;next; if(tmp-&gt;audio_buffer==audio_buffer) { p-&gt;next=tmp-&gt;next; free(tmp-&gt;audio_buffer); free(tmp); break; } } pthread_mutex_unlock(&amp;mutex); } /* 函数功能:遍历链表，得到节点总数量 */ int List_GetNodeCnt(struct AUDIO_DATA *head) { int cnt=0; struct AUDIO_DATA *tmp=head; pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next) { tmp=tmp-&gt;next; cnt++; } pthread_mutex_unlock(&amp;mutex); return cnt; } /* 从链表头取数据 */ int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *ptemp=head; pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next!=NULL) { ptemp=tmp; tmp=tmp-&gt;next; if(tmp!=NULL) { *audio_size=tmp-&gt;audio_size; memcpy(audio_buff,tmp-&gt;audio_buffer,tmp-&gt;audio_size); ptemp-&gt;next=tmp-&gt;next; free(tmp-&gt;audio_buffer); free(tmp); pthread_mutex_unlock(&amp;mutex); return 0; } } pthread_mutex_unlock(&amp;mutex); return -1; } Makefile文件 注意Makefile文件中涉及到的路径要跟系统环境相匹配，如果路径不一致会编译报错\n">
<meta property='og:url' content='https://ynhugo.github.io/p/linux%E4%B8%8B%E5%9F%BA%E4%BA%8Effmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/'>
<meta property='og:site_name' content='ynhugo'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='ffmpeg' /><meta property='article:published_time' content='2024-09-09T17:14:47&#43;08:00'/><meta property='article:modified_time' content='2024-09-09T17:14:47&#43;08:00'/>
<meta name="twitter:title" content="Linux下基于ffmpeg音视频解码">
<meta name="twitter:description" content=" Linux下基于ffmpeg音视频解码 FFmpeg开发环境配置参考：Ubuntu 20.04LTS FFmpeg 环境配置\n工程示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 #include &lt;stdio.h&gt; #include &#34;libavcodec/avcodec.h&#34; #include &#34;libavformat/avformat.h&#34; #include &#34;libswscale/swscale.h&#34; #include &lt;libswresample/swresample.h&gt; #include &lt;libavutil/mathematics.h&gt; #include &lt;libavutil/timestamp.h&gt; #include &lt;stdio.h&gt; #include &lt;linux/fb.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; #include &lt;poll.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;wchar.h&gt; #include &lt;pthread.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;SDL.h&gt; #define FILE_NAME &#34;123.flv&#34; typedef unsigned char u8; typedef unsigned short u16; typedef unsigned int u32; typedef enum { false, true, }bool; uint8_t *out_buffer; #define MAX_AUDIO_FRAME_SIZE 1024*100 static Uint8* audio_chunk; static unsigned int audio_len=0; static unsigned char *audio_pos; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//互斥锁 //保存音频数据链表 struct AUDIO_DATA { unsigned char* audio_buffer; int audio_size; struct AUDIO_DATA *next; }; //定义一个链表头 struct AUDIO_DATA *list_head=NULL; struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head);//创建链表头 void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size);//添加节点 void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer);//删除节点 int List_GetNodeCnt(struct AUDIO_DATA *head);//遍历 int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size); int file_stat=1; void AudioCallback(void *userdata, Uint8 * stream,int len) { SDL_memset(stream, 0,len); if(audio_len&lt;=0) { return ; } len=(len&gt;audio_len?audio_len:len); SDL_MixAudio(stream,audio_pos,len,SDL_MIX_MAXVOLUME); audio_pos+=len; audio_len-=len; //printf(&#34;len=%d\\n&#34;,len); } void *Audio_decode(void *arg) { int res; int audio_size; char audio_buff[4096*3]; while(1) { res=List_GetNode(list_head,audio_buff,&amp;audio_size); if(res==0) { audio_chunk = audio_buff; //指向音频数据 (PCM data) while(audio_len&gt;0){}//等待数据处理完 audio_len =audio_size;//音频长度 audio_pos = audio_buff;//当前播放位置 } } } int main(int argc,char *argv[]) { if(argc!=2) { printf(&#34;格式:./app 文件名\\n&#34;); return 0; } char *file_name=argv[1]; /*SDL初始化*/ SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_TIMER); printf(&#34;pth:%s\\n&#34;,avcodec_configuration());/*获取ffmpeg配置信息*/ /*初始化所有组件*/ //av_register_all(); /*打开文件*/ AVCodecContext *pCodecCtx;//解码器上下文 AVFormatContext *ps=NULL;//音视频封装格式结构体信息 printf(&#34;name:%s\\n&#34;,file_name); int res=avformat_open_input(&amp;ps,file_name,NULL,NULL); if(res!=0) { printf(&#34;open err: %d\\n&#34;,res); return 0; } /*寻找解码信息*/ avformat_find_stream_info(ps,NULL); int64_t time=ps-&gt;duration; printf(&#34;time:%ld s\\n&#34;,time/1000000); /*打印有关输入或输出格式的详细信息*/ av_dump_format(ps,0,file_name,0); /*寻找视频流信息*/ int videostream=-1; int audiostream=-1; AVCodec *vcodec; videostream=av_find_best_stream(ps,AVMEDIA_TYPE_VIDEO,-1,-1,NULL, 0); printf(&#34;video=%d\\n&#34;,videostream); /*寻找音频流信息*/ audiostream=av_find_best_stream(ps,AVMEDIA_TYPE_AUDIO,-1,-1,NULL, 0); printf(&#34;audio=%d\\n&#34;,audiostream); AVStream *stream; int frame_rate; if(videostream!=-1)//判断是否找到视频流数据 { /*寻找视频解码器*/ AVStream *stream = ps-&gt;streams[videostream]; vcodec=avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id); if(!vcodec) { printf(&#34;未找到视频解码器\\n&#34;); return -1; }/*申请AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ res=avcodec_open2(stream-&gt;codec,vcodec,NULL); if(res) { printf(&#34;打开解码器失败\\n&#34;); return -1; } frame_rate=stream-&gt;avg_frame_rate.num/stream-&gt;avg_frame_rate.den;//每秒多少帧 printf(&#34;fps=%d\\n&#34;,frame_rate); printf(&#34;视频流ID=%#x\\n&#34;,vcodec-&gt;id);//音频流 } /*音频流数据处理*/ AVCodec *audcodec; AVStream *audstream; SwrContext *swrCtx;//保存重采样数据，即解码的信息 uint64_t out_channel_layout;//声道 int out_sample_fmt;//采样格式 int out_sample_rate;//采样率 int out_nb_samples;//样本数量 int out_channels;//通道数量 uint64_t in_channel_layout;//输入音频声道 SDL_AudioSpec desired;//SDL音频格式信息 AVFrame *audioframe;//保存音频数据 int out_buffer_size;//音频缓冲区大小 if(audiostream&gt;=0)//判断是否有音频流 { /*寻找音频解码器*/ audstream = ps-&gt;streams[audiostream]; audcodec=avcodec_find_decoder(audstream-&gt;codecpar-&gt;codec_id); if(!audcodec) { printf(&#34;audcodec failed\\n&#34;); return -1; } /*申请音频AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/ pCodecCtx=audstream-&gt;codec;//解码器上下文 res=avcodec_open2(audstream-&gt;codec,audcodec,NULL); if(res) { printf(&#34;未找到音频解码器\\n&#34;); return -1; } printf(&#34;音频流ID=%#x\\n&#34;,audcodec-&gt;id);//音频流 printf(&#34;配置音频参数\\n&#34;); //输出音频参数 out_channel_layout = AV_CH_LAYOUT_STEREO; //声道格式 out_sample_fmt=AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S32;//;//采样格式 printf(&#34;pCodecCtx-&gt;sample_rate=%d\\n&#34;,pCodecCtx-&gt;sample_rate); out_sample_rate =pCodecCtx-&gt;sample_rate;//采样率，多为44100 /*样本数量*/ printf(&#34;frame_size=%d\\n&#34;,pCodecCtx-&gt;frame_size); if(pCodecCtx-&gt;frame_size&gt;0)out_nb_samples=pCodecCtx-&gt;frame_size; else if(audcodec-&gt;id == AV_CODEC_ID_AAC) out_nb_samples=1024;/*样本数量nb_samples: AAC-1024 MP3-1152 格式大小 */ else if(audcodec-&gt;id == AV_CODEC_ID_MP3)out_nb_samples=1152; else out_nb_samples=1024; out_channels=av_get_channel_layout_nb_channels(out_channel_layout);//通道个数 out_buffer_size=av_samples_get_buffer_size(NULL,out_channels,out_nb_samples,out_sample_fmt,1);//获取缓冲区大小 out_buffer=(uint8_t*)av_malloc(MAX_AUDIO_FRAME_SIZE); memset(out_buffer,0,out_buffer_size); printf(&#34;声道格式:%d\\n&#34;,out_channel_layout); printf(&#34;采样格式:%d\\n&#34;,out_sample_fmt);\tprintf(&#34;样本数量:%d\\n&#34;,out_nb_samples);\tprintf(&#34;采样率:%d\\n&#34;,out_sample_rate); printf(&#34;通道个数:%d\\n&#34;,out_channels); printf(&#34;缓冲区大小:%d\\n&#34;,out_buffer_size); //输入音频参数 in_channel_layout=av_get_default_channel_layout(pCodecCtx-&gt;channels);//输入声道格式 swrCtx = swr_alloc(); /*对解码数据进行重采样*/ swrCtx=swr_alloc_set_opts(swrCtx,out_channel_layout,out_sample_fmt,out_sample_rate,/*输入音频格式*/ in_channel_layout,pCodecCtx-&gt;sample_fmt,pCodecCtx-&gt;sample_rate,/*输出音频格式*/ 0,NULL);\tswr_init(swrCtx);//初始化swrCtx printf(&#34;输入音频格式:%d\\n&#34;,in_channel_layout); printf(&#34;输入采样格式:%d\\n&#34;,pCodecCtx-&gt;sample_fmt); printf(&#34;输入采样率:%d\\n&#34;,pCodecCtx-&gt;sample_rate); /*设置音频数据格式*/ desired.freq=out_sample_rate;/*采样率*/ desired.format=AUDIO_S16SYS;/*无符号16位*/ desired.channels=out_channels;/*声道*/ desired.samples=out_nb_samples;/*样本数1024*/ desired.silence=0;/*静音值*/ desired.callback=AudioCallback; SDL_OpenAudio(&amp;desired,NULL); SDL_PauseAudio(0);/*开始播放音频，1为播放静音值*/ //分配内存 audioframe=av_frame_alloc();/*分配音频帧*/ printf(&#34;音频数据初始化完成&#34;); } //视频解码 AVFrame *frame=av_frame_alloc();/*分配视频帧*/ AVFrame *frameYUV=av_frame_alloc();/*申请yuv空间*/ /*分配空间，进行图像转换*/ int width=ps-&gt;streams[videostream]-&gt;codecpar-&gt;width; int height=ps-&gt;streams[videostream]-&gt;codecpar-&gt;height; int fmt=ps-&gt;streams[videostream]-&gt;codecpar-&gt;format;/*流格式*/ printf(&#34;fmt=%d\\n&#34;,fmt); int size=avpicture_get_size(AV_PIX_FMT_RGB24, width,height); unsigned char *buff=NULL; printf(&#34;w=%d,h=%d,size=%d\\n&#34;,width,height,size); buff=av_malloc(size); /*计算一帧空间大小*/ avpicture_fill((AVPicture *)frameYUV,buff,AV_PIX_FMT_RGB24,width,height); /*转换上下文*/ struct SwsContext *swsctx=sws_getContext(width,height, fmt,width,height, AV_PIX_FMT_RGB24,SWS_BICUBIC,NULL,NULL,NULL); /*读帧*/ int go=0; int go_audio;\tlist_head=List_CreateHead(list_head);//创建链表头 /*创建音频处理线程*/ pthread_t pthid; pthread_create(&amp;pthid,NULL,Audio_decode,(void *)ps); pthread_detach(pthid);//设置为分离属性 /*创建窗口*/ SDL_Window *window=SDL_CreateWindow(&#34;SDL_VIDEO&#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,1280,720,SDL_WINDOW_SHOWN); /*创建渲染器*/ SDL_Renderer *render=SDL_CreateRenderer(window,-1,SDL_RENDERER_ACCELERATED); /*清空渲染器*/ SDL_RenderClear(render);\t/*创建纹理*/ SDL_Texture *sdltext=SDL_CreateTexture(render,SDL_PIXELFORMAT_RGB24,SDL_TEXTUREACCESS_STREAMING,width,height);\tbool quit=true; SDL_Event event; printf(&#34;read fream buff\\n&#34;); //初始化转码器 AVPacket *packet=av_malloc(sizeof(AVPacket));/*分配包*/ av_init_packet(packet);//初始化 int i=0; int index=0; long video_pts_time=0; long audio_pts_time=0;//音频解码时间 time=(1000000/frame_rate-10000);//时间 printf(&#34;time=%d\\n&#34;,time); while((av_read_frame(ps,packet)&gt;=0) &amp;&amp; (quit)) { SDL_PollEvent(&amp;event); if(event.type==SDL_QUIT) { quit=false; continue; } if(packet-&gt;stream_index == videostream)/*判断是否为视频*/ { res=avcodec_send_packet(ps-&gt;streams[videostream]-&gt;codec,packet); if(res) { av_packet_unref(packet);//释放这个pkt continue; } res=avcodec_receive_frame(ps-&gt;streams[videostream]-&gt;codec,frame); if(res) { av_packet_unref(packet);//释放这个pkt\tcontinue; } sws_scale(swsctx,(const uint8_t **)frame-&gt;data,frame-&gt;linesize,0,height,(const uint8_t **)frameYUV-&gt;data,frameYUV-&gt;linesize); video_pts_time=packet-&gt;pts; //printf(&#34;视频=%ld\\n&#34;,video_pts_time); SDL_UpdateTexture(sdltext,NULL,buff, width*3); SDL_RenderCopy(render, sdltext, NULL, NULL); // 拷贝纹理到渲染器 SDL_RenderPresent(render); //渲染 usleep(time); } if(packet-&gt;stream_index == audiostream) //如果为音频标志 { if(audiostream&lt;0)continue; res=avcodec_send_packet(pCodecCtx,packet); if(res) { printf(&#34;avcodec_send_packet failed,res=%d\\n&#34;,res); av_packet_unref(packet);//释放这个pkt\tcontinue; } res=avcodec_receive_frame(pCodecCtx,audioframe); if(res) { printf(&#34;avcodec_receive_frame failed,res=%d\\n&#34;,res); av_packet_unref(packet);//释放这个pkt continue; } //数据格式转换 res=swr_convert(swrCtx,&amp;out_buffer,out_buffer_size,/*重采样之后的数据*/ (const uint8_t **)audioframe-&gt;data,audioframe-&gt;nb_samples/*重采样之前数据*/ ); audio_pts_time=packet-&gt;pts; //printf(&#34;音频：%ld\\n&#34;,audio_pts_time); if(res&gt;0) { //audio_chunk =out_buffer; //指向音频数据 (PCM data) //while(audio_len&gt;0){}//等待数据处理完 //audio_len =audioframe-&gt;nb_samples;//out_buffer_size;//音频长度 //audio_pos =out_buffer;//当前播放位置 List_AddNode(list_head,out_buffer,out_buffer_size);//添加节点 } } //释放数据包 av_packet_unref(packet); } sws_freeContext(swsctx); av_frame_free(&amp;frame); av_frame_free(&amp;frameYUV); avformat_free_context(ps); return 0; } /*创建链表头*/ struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head) { if(head==NULL) { head=malloc(sizeof(struct AUDIO_DATA)); head-&gt;next=NULL; } return head;\t} /*添加节点*/ void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *new_node; pthread_mutex_lock(&amp;mutex); /*找到链表尾部*/ while(tmp-&gt;next) { tmp=tmp-&gt;next; } /*插入新的节点*/ new_node=malloc(sizeof(struct AUDIO_DATA)); new_node-&gt;audio_size=audio_size; new_node-&gt;audio_buffer=malloc(audio_size);//分配保存音频数据大小空间 memcpy(new_node-&gt;audio_buffer,audio_buffer,audio_size); new_node-&gt;next=NULL; /*将新节点接入到链表*/ tmp-&gt;next=new_node;\tpthread_mutex_unlock(&amp;mutex); } /* 函数功能:删除节点 */ void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *p; /*找到链表中要删除的节点*/ pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next) { p=tmp; tmp=tmp-&gt;next; if(tmp-&gt;audio_buffer==audio_buffer) { p-&gt;next=tmp-&gt;next; free(tmp-&gt;audio_buffer); free(tmp); break; } } pthread_mutex_unlock(&amp;mutex); } /* 函数功能:遍历链表，得到节点总数量 */ int List_GetNodeCnt(struct AUDIO_DATA *head) { int cnt=0; struct AUDIO_DATA *tmp=head; pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next) { tmp=tmp-&gt;next; cnt++; } pthread_mutex_unlock(&amp;mutex); return cnt; } /* 从链表头取数据 */ int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size) { struct AUDIO_DATA *tmp=head; struct AUDIO_DATA *ptemp=head; pthread_mutex_lock(&amp;mutex); while(tmp-&gt;next!=NULL) { ptemp=tmp; tmp=tmp-&gt;next; if(tmp!=NULL) { *audio_size=tmp-&gt;audio_size; memcpy(audio_buff,tmp-&gt;audio_buffer,tmp-&gt;audio_size); ptemp-&gt;next=tmp-&gt;next; free(tmp-&gt;audio_buffer); free(tmp); pthread_mutex_unlock(&amp;mutex); return 0; } } pthread_mutex_unlock(&amp;mutex); return -1; } Makefile文件 注意Makefile文件中涉及到的路径要跟系统环境相匹配，如果路径不一致会编译报错\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_f509edb42ecc0ebd.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">ynhugo</a></h1>
            <h2 class="site-description">ynhugo.github.io</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://x.com'
                        target="_blank"
                        title="x"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/book/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" fill="none" stroke="#808080" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="m443.6,11h-321c-35.4,0-64.6,26.1-64.6,59.4v371.1c0,33.4 26.1,59.4 59.4,59.4h326.2c6.3,0 10.4-4.2 10.4-11.5v-468c0-6.2-4.2-10.4-10.4-10.4zm-321,20.9h310.5v350.3h-315.7c-14.9,0-28.3,5.2-38.6,13.9v-325.7c-1.42109e-14-21.9 19.8-38.5 43.8-38.5zm310.6,449.3h-315.8c-21.9,0-38.6-16.7-38.6-38.6 0-21.9 17.7-38.6 38.6-38.6l315.8,.1v77.1z"/>
</svg>
                
                <span>Book</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://ynhugo.github.io/en/" >English</option>
                                
                                    <option value="https://ynhugo.github.io/" selected>中文</option>
                                
                                    <option value="https://ynhugo.github.io/ar/" >عربي</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">Linux下基于ffmpeg音视频解码</a>
<ul>
<li><a href="#headline-2">工程示例</a>
<ul>
<li><a href="#headline-3">Makefile文件</a>
</li>
<li><a href="#headline-4">运行程序</a>
<ul>
<li><a href="#headline-5">先准备一个视频</a>
</li>
<li><a href="#headline-6">运行示例</a>
</li>
<li><a href="#headline-7">运行示例效果</a>
</li>
</ul>
</li>
<li><a href="#headline-8">ChatGPT分析代码</a>
<ul>
<li><a href="#headline-9">1. 头文件与库引入</a>
</li>
<li><a href="#headline-10">2. 常量与全局变量</a>
</li>
<li><a href="#headline-11">3. 音频数据链表</a>
</li>
<li><a href="#headline-12">4. 音频回调函数</a>
</li>
<li><a href="#headline-13">5. 音频解码线程</a>
</li>
<li><a href="#headline-14">6. 主程序 main</a>
</li>
<li><a href="#headline-15">7. 链表管理</a>
</li>
<li><a href="#headline-16">总结</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-17">打开一个媒体文件并输出其格式信息</a>
<ul>
<li><a href="#headline-18">示例说明</a>
</li>
<li><a href="#headline-19">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-20">查找视频和音频流示例-1</a>
<ul>
<li><a href="#headline-21">示例说明</a>
</li>
</ul>
</li>
<li><a href="#headline-22">查找视频和音频流示例-2</a>
<ul>
<li><a href="#headline-23">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-24">查看音视频流的格式，同时获得解码器</a>
<ul>
<li><a href="#headline-25">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-26">查看视频帧率</a>
<ul>
<li><a href="#headline-27">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-28">正确获取和处理流索引、解码器、以及正确释放资源 - ChatGPT</a>
</li>
<li><a href="#headline-29">打开一个多媒体文件，查找其中的视频和音频流，并打印每个流的相关信息</a>
<ul>
<li><a href="#headline-30">示例说明</a>
</li>
<li><a href="#headline-31">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-32">decode_video_mp4 - ChatGPT</a>
<ul>
<li><a href="#headline-33">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-34">encode_video_mp4 - ChatGPT</a>
</li>
<li><a href="#headline-35">Linux下基于FFmpeg，通过C语言调用API函数解码mp4视频后再合并成一个新的视频，要求分辨率、颜色跟解码之前一样 - ChatGPT</a>
<ul>
<li><a href="#headline-36">编码函数定义</a>
<ul>
<li><a href="#headline-37">内部变量</a>
</li>
<li><a href="#headline-38">发送帧进行编码</a>
</li>
<li><a href="#headline-39">接收编码后数据</a>
</li>
<li><a href="#headline-40">时间基准转换和写入帧</a>
</li>
<li><a href="#headline-41">释放数据包</a>
</li>
<li><a href="#headline-42">总结</a>
</li>
</ul>
</li>
<li><a href="#headline-43">完整代码解析</a>
<ul>
<li><a href="#headline-44">encode 函数</a>
<ul>
<li><a href="#headline-45">功能</a>
</li>
<li><a href="#headline-46">参数解释</a>
</li>
<li><a href="#headline-47">过程解释</a>
</li>
</ul>
</li>
<li><a href="#headline-48">main 函数</a>
<ul>
<li><a href="#headline-49">参数解释</a>
</li>
<li><a href="#headline-50">核心步骤：</a>
</li>
<li><a href="#headline-51">结论</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-52">参考链接</a>
</li>
</ul>
</li>
</ul>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/linux%E4%B8%8B%E5%9F%BA%E4%BA%8Effmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/">Linux下基于ffmpeg音视频解码</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 09, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 28 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Linux下基于ffmpeg音视频解码
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
FFmpeg开发环境配置参考：<a href="https://ynhugo.github.io/p/ubuntu-20.04lts-ffmpeg-环境配置/">Ubuntu 20.04LTS FFmpeg 环境配置</a></p>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
工程示例
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavcodec/avcodec.h&#34;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">#include &#34;libswscale/swscale.h&#34;
</span></span><span class="line"><span class="cl">#include &lt;libswresample/swresample.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavutil/mathematics.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavutil/timestamp.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;linux/fb.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;poll.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;time.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wchar.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;pthread.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;signal.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;SDL.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define FILE_NAME &#34;123.flv&#34;
</span></span><span class="line"><span class="cl">typedef unsigned char u8;
</span></span><span class="line"><span class="cl">typedef unsigned short u16;
</span></span><span class="line"><span class="cl">typedef unsigned int u32;
</span></span><span class="line"><span class="cl">typedef enum
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	false,
</span></span><span class="line"><span class="cl">	true,
</span></span><span class="line"><span class="cl">}bool;
</span></span><span class="line"><span class="cl">uint8_t *out_buffer;
</span></span><span class="line"><span class="cl">#define MAX_AUDIO_FRAME_SIZE 1024*100 
</span></span><span class="line"><span class="cl">static Uint8* audio_chunk; 
</span></span><span class="line"><span class="cl">static unsigned int audio_len=0;
</span></span><span class="line"><span class="cl">static unsigned char *audio_pos;
</span></span><span class="line"><span class="cl">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//互斥锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//保存音频数据链表
</span></span><span class="line"><span class="cl">struct AUDIO_DATA
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	unsigned char* audio_buffer;
</span></span><span class="line"><span class="cl">	int audio_size;
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *next;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">//定义一个链表头
</span></span><span class="line"><span class="cl">struct AUDIO_DATA *list_head=NULL;
</span></span><span class="line"><span class="cl">struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head);//创建链表头
</span></span><span class="line"><span class="cl">void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size);//添加节点
</span></span><span class="line"><span class="cl">void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer);//删除节点
</span></span><span class="line"><span class="cl">int List_GetNodeCnt(struct AUDIO_DATA *head);//遍历
</span></span><span class="line"><span class="cl">int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int file_stat=1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void  AudioCallback(void *userdata, Uint8 * stream,int len)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	SDL_memset(stream, 0,len);
</span></span><span class="line"><span class="cl">	if(audio_len&lt;=0)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		return ;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	len=(len&gt;audio_len?audio_len:len);
</span></span><span class="line"><span class="cl">	SDL_MixAudio(stream,audio_pos,len,SDL_MIX_MAXVOLUME);
</span></span><span class="line"><span class="cl">	audio_pos+=len;
</span></span><span class="line"><span class="cl">	audio_len-=len;
</span></span><span class="line"><span class="cl">	//printf(&#34;len=%d\n&#34;,len);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void *Audio_decode(void *arg)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	int res;
</span></span><span class="line"><span class="cl">	int audio_size;
</span></span><span class="line"><span class="cl">	char audio_buff[4096*3];
</span></span><span class="line"><span class="cl">	while(1)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		res=List_GetNode(list_head,audio_buff,&amp;audio_size);
</span></span><span class="line"><span class="cl">		if(res==0)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			audio_chunk = audio_buff; //指向音频数据 (PCM data)
</span></span><span class="line"><span class="cl">			while(audio_len&gt;0){}//等待数据处理完
</span></span><span class="line"><span class="cl">			audio_len =audio_size;//音频长度
</span></span><span class="line"><span class="cl">			audio_pos = audio_buff;//当前播放位置
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">int main(int argc,char *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if(argc!=2)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		printf(&#34;格式:./app 文件名\n&#34;);
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	char *file_name=argv[1];
</span></span><span class="line"><span class="cl">	/*SDL初始化*/
</span></span><span class="line"><span class="cl">	SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_TIMER);
</span></span><span class="line"><span class="cl">	printf(&#34;pth:%s\n&#34;,avcodec_configuration());/*获取ffmpeg配置信息*/
</span></span><span class="line"><span class="cl">	/*初始化所有组件*/
</span></span><span class="line"><span class="cl">	//av_register_all();
</span></span><span class="line"><span class="cl">	/*打开文件*/
</span></span><span class="line"><span class="cl">	AVCodecContext  *pCodecCtx;//解码器上下文
</span></span><span class="line"><span class="cl">	AVFormatContext *ps=NULL;//音视频封装格式结构体信息
</span></span><span class="line"><span class="cl">	printf(&#34;name:%s\n&#34;,file_name);
</span></span><span class="line"><span class="cl">	int res=avformat_open_input(&amp;ps,file_name,NULL,NULL);
</span></span><span class="line"><span class="cl">	if(res!=0)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		printf(&#34;open err: %d\n&#34;,res);
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	/*寻找解码信息*/
</span></span><span class="line"><span class="cl">	avformat_find_stream_info(ps,NULL);
</span></span><span class="line"><span class="cl">	int64_t time=ps-&gt;duration;
</span></span><span class="line"><span class="cl">	printf(&#34;time:%ld s\n&#34;,time/1000000);
</span></span><span class="line"><span class="cl">	/*打印有关输入或输出格式的详细信息*/
</span></span><span class="line"><span class="cl">	av_dump_format(ps,0,file_name,0);
</span></span><span class="line"><span class="cl">	/*寻找视频流信息*/
</span></span><span class="line"><span class="cl">	int videostream=-1;
</span></span><span class="line"><span class="cl">	int audiostream=-1;
</span></span><span class="line"><span class="cl">	AVCodec *vcodec;
</span></span><span class="line"><span class="cl">	videostream=av_find_best_stream(ps,AVMEDIA_TYPE_VIDEO,-1,-1,NULL, 0);
</span></span><span class="line"><span class="cl">	printf(&#34;video=%d\n&#34;,videostream);
</span></span><span class="line"><span class="cl">	/*寻找音频流信息*/
</span></span><span class="line"><span class="cl">	audiostream=av_find_best_stream(ps,AVMEDIA_TYPE_AUDIO,-1,-1,NULL, 0);
</span></span><span class="line"><span class="cl">	printf(&#34;audio=%d\n&#34;,audiostream);
</span></span><span class="line"><span class="cl">	AVStream *stream;
</span></span><span class="line"><span class="cl">	int frame_rate;
</span></span><span class="line"><span class="cl">	if(videostream!=-1)//判断是否找到视频流数据
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		/*寻找视频解码器*/
</span></span><span class="line"><span class="cl">		AVStream *stream = ps-&gt;streams[videostream];
</span></span><span class="line"><span class="cl">		vcodec=avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);
</span></span><span class="line"><span class="cl">		if(!vcodec)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			printf(&#34;未找到视频解码器\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}/*申请AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/
</span></span><span class="line"><span class="cl">		res=avcodec_open2(stream-&gt;codec,vcodec,NULL);
</span></span><span class="line"><span class="cl">		if(res)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			printf(&#34;打开解码器失败\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		frame_rate=stream-&gt;avg_frame_rate.num/stream-&gt;avg_frame_rate.den;//每秒多少帧
</span></span><span class="line"><span class="cl">		printf(&#34;fps=%d\n&#34;,frame_rate);
</span></span><span class="line"><span class="cl">		printf(&#34;视频流ID=%#x\n&#34;,vcodec-&gt;id);//音频流
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	/*音频流数据处理*/
</span></span><span class="line"><span class="cl">	AVCodec *audcodec;
</span></span><span class="line"><span class="cl">	AVStream *audstream;
</span></span><span class="line"><span class="cl">	SwrContext *swrCtx;//保存重采样数据，即解码的信息
</span></span><span class="line"><span class="cl">	uint64_t out_channel_layout;//声道
</span></span><span class="line"><span class="cl">	int out_sample_fmt;//采样格式
</span></span><span class="line"><span class="cl">	int out_sample_rate;//采样率
</span></span><span class="line"><span class="cl">	int out_nb_samples;//样本数量
</span></span><span class="line"><span class="cl">	int out_channels;//通道数量
</span></span><span class="line"><span class="cl">	uint64_t in_channel_layout;//输入音频声道
</span></span><span class="line"><span class="cl">	SDL_AudioSpec desired;//SDL音频格式信息
</span></span><span class="line"><span class="cl">	AVFrame *audioframe;//保存音频数据
</span></span><span class="line"><span class="cl">	int out_buffer_size;//音频缓冲区大小
</span></span><span class="line"><span class="cl">	if(audiostream&gt;=0)//判断是否有音频流
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		/*寻找音频解码器*/
</span></span><span class="line"><span class="cl">		audstream = ps-&gt;streams[audiostream];
</span></span><span class="line"><span class="cl">		audcodec=avcodec_find_decoder(audstream-&gt;codecpar-&gt;codec_id);
</span></span><span class="line"><span class="cl">		if(!audcodec)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			printf(&#34;audcodec failed\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		/*申请音频AVCodecContext空间。需要传递一个编码器，也可以不传，但不会包含编码器。*/
</span></span><span class="line"><span class="cl">		pCodecCtx=audstream-&gt;codec;//解码器上下文
</span></span><span class="line"><span class="cl">		res=avcodec_open2(audstream-&gt;codec,audcodec,NULL);
</span></span><span class="line"><span class="cl">		if(res)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			printf(&#34;未找到音频解码器\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		printf(&#34;音频流ID=%#x\n&#34;,audcodec-&gt;id);//音频流
</span></span><span class="line"><span class="cl">		printf(&#34;配置音频参数\n&#34;);
</span></span><span class="line"><span class="cl">		//输出音频参数
</span></span><span class="line"><span class="cl">		out_channel_layout  = AV_CH_LAYOUT_STEREO;  //声道格式
</span></span><span class="line"><span class="cl">		out_sample_fmt=AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S32;//;//采样格式
</span></span><span class="line"><span class="cl">		printf(&#34;pCodecCtx-&gt;sample_rate=%d\n&#34;,pCodecCtx-&gt;sample_rate);
</span></span><span class="line"><span class="cl">		out_sample_rate =pCodecCtx-&gt;sample_rate;//采样率，多为44100
</span></span><span class="line"><span class="cl">		/*样本数量*/
</span></span><span class="line"><span class="cl">		printf(&#34;frame_size=%d\n&#34;,pCodecCtx-&gt;frame_size);
</span></span><span class="line"><span class="cl">		if(pCodecCtx-&gt;frame_size&gt;0)out_nb_samples=pCodecCtx-&gt;frame_size;
</span></span><span class="line"><span class="cl">		else if(audcodec-&gt;id == AV_CODEC_ID_AAC) out_nb_samples=1024;/*样本数量nb_samples: AAC-1024 MP3-1152  格式大小 */
</span></span><span class="line"><span class="cl">		else if(audcodec-&gt;id == AV_CODEC_ID_MP3)out_nb_samples=1152;
</span></span><span class="line"><span class="cl">		else out_nb_samples=1024;
</span></span><span class="line"><span class="cl">		out_channels=av_get_channel_layout_nb_channels(out_channel_layout);//通道个数
</span></span><span class="line"><span class="cl">		out_buffer_size=av_samples_get_buffer_size(NULL,out_channels,out_nb_samples,out_sample_fmt,1);//获取缓冲区大小
</span></span><span class="line"><span class="cl">		out_buffer=(uint8_t*)av_malloc(MAX_AUDIO_FRAME_SIZE);
</span></span><span class="line"><span class="cl">		memset(out_buffer,0,out_buffer_size);
</span></span><span class="line"><span class="cl">		printf(&#34;声道格式:%d\n&#34;,out_channel_layout);
</span></span><span class="line"><span class="cl">		printf(&#34;采样格式:%d\n&#34;,out_sample_fmt);	
</span></span><span class="line"><span class="cl">		printf(&#34;样本数量:%d\n&#34;,out_nb_samples);	
</span></span><span class="line"><span class="cl">		printf(&#34;采样率:%d\n&#34;,out_sample_rate);
</span></span><span class="line"><span class="cl">		printf(&#34;通道个数:%d\n&#34;,out_channels);
</span></span><span class="line"><span class="cl">		printf(&#34;缓冲区大小:%d\n&#34;,out_buffer_size);
</span></span><span class="line"><span class="cl">		//输入音频参数
</span></span><span class="line"><span class="cl">		in_channel_layout=av_get_default_channel_layout(pCodecCtx-&gt;channels);//输入声道格式
</span></span><span class="line"><span class="cl">		swrCtx = swr_alloc();
</span></span><span class="line"><span class="cl">		/*对解码数据进行重采样*/
</span></span><span class="line"><span class="cl">		swrCtx=swr_alloc_set_opts(swrCtx,out_channel_layout,out_sample_fmt,out_sample_rate,/*输入音频格式*/
</span></span><span class="line"><span class="cl">								in_channel_layout,pCodecCtx-&gt;sample_fmt,pCodecCtx-&gt;sample_rate,/*输出音频格式*/
</span></span><span class="line"><span class="cl">								0,NULL);				
</span></span><span class="line"><span class="cl">		swr_init(swrCtx);//初始化swrCtx
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		printf(&#34;输入音频格式:%d\n&#34;,in_channel_layout);
</span></span><span class="line"><span class="cl">		printf(&#34;输入采样格式:%d\n&#34;,pCodecCtx-&gt;sample_fmt);
</span></span><span class="line"><span class="cl">		printf(&#34;输入采样率:%d\n&#34;,pCodecCtx-&gt;sample_rate);
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		/*设置音频数据格式*/
</span></span><span class="line"><span class="cl">		desired.freq=out_sample_rate;/*采样率*/
</span></span><span class="line"><span class="cl">		desired.format=AUDIO_S16SYS;/*无符号16位*/
</span></span><span class="line"><span class="cl">		desired.channels=out_channels;/*声道*/
</span></span><span class="line"><span class="cl">		desired.samples=out_nb_samples;/*样本数1024*/
</span></span><span class="line"><span class="cl">		desired.silence=0;/*静音值*/
</span></span><span class="line"><span class="cl">		desired.callback=AudioCallback;
</span></span><span class="line"><span class="cl">		SDL_OpenAudio(&amp;desired,NULL);
</span></span><span class="line"><span class="cl">		SDL_PauseAudio(0);/*开始播放音频，1为播放静音值*/
</span></span><span class="line"><span class="cl">		//分配内存
</span></span><span class="line"><span class="cl">		audioframe=av_frame_alloc();/*分配音频帧*/
</span></span><span class="line"><span class="cl">		printf(&#34;音频数据初始化完成&#34;);
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	//视频解码
</span></span><span class="line"><span class="cl">	AVFrame *frame=av_frame_alloc();/*分配视频帧*/
</span></span><span class="line"><span class="cl">	AVFrame *frameYUV=av_frame_alloc();/*申请yuv空间*/
</span></span><span class="line"><span class="cl">	/*分配空间，进行图像转换*/
</span></span><span class="line"><span class="cl">	int width=ps-&gt;streams[videostream]-&gt;codecpar-&gt;width;
</span></span><span class="line"><span class="cl">	int height=ps-&gt;streams[videostream]-&gt;codecpar-&gt;height;
</span></span><span class="line"><span class="cl">	int fmt=ps-&gt;streams[videostream]-&gt;codecpar-&gt;format;/*流格式*/
</span></span><span class="line"><span class="cl">	printf(&#34;fmt=%d\n&#34;,fmt);
</span></span><span class="line"><span class="cl">	int size=avpicture_get_size(AV_PIX_FMT_RGB24, width,height);
</span></span><span class="line"><span class="cl">	unsigned char *buff=NULL;
</span></span><span class="line"><span class="cl">	printf(&#34;w=%d,h=%d,size=%d\n&#34;,width,height,size);
</span></span><span class="line"><span class="cl">	buff=av_malloc(size);
</span></span><span class="line"><span class="cl">	/*计算一帧空间大小*/
</span></span><span class="line"><span class="cl">	avpicture_fill((AVPicture *)frameYUV,buff,AV_PIX_FMT_RGB24,width,height);
</span></span><span class="line"><span class="cl">	/*转换上下文*/
</span></span><span class="line"><span class="cl">	struct SwsContext *swsctx=sws_getContext(width,height, fmt,width,height, AV_PIX_FMT_RGB24,SWS_BICUBIC,NULL,NULL,NULL);
</span></span><span class="line"><span class="cl">	/*读帧*/
</span></span><span class="line"><span class="cl">	int go=0;
</span></span><span class="line"><span class="cl">	int go_audio;	
</span></span><span class="line"><span class="cl">	list_head=List_CreateHead(list_head);//创建链表头
</span></span><span class="line"><span class="cl">	/*创建音频处理线程*/
</span></span><span class="line"><span class="cl">	pthread_t pthid;
</span></span><span class="line"><span class="cl">	pthread_create(&amp;pthid,NULL,Audio_decode,(void *)ps);
</span></span><span class="line"><span class="cl">	pthread_detach(pthid);//设置为分离属性
</span></span><span class="line"><span class="cl">	/*创建窗口*/
</span></span><span class="line"><span class="cl">	SDL_Window *window=SDL_CreateWindow(&#34;SDL_VIDEO&#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,1280,720,SDL_WINDOW_SHOWN);
</span></span><span class="line"><span class="cl">	/*创建渲染器*/
</span></span><span class="line"><span class="cl">	SDL_Renderer *render=SDL_CreateRenderer(window,-1,SDL_RENDERER_ACCELERATED);
</span></span><span class="line"><span class="cl">	/*清空渲染器*/
</span></span><span class="line"><span class="cl">	SDL_RenderClear(render);	
</span></span><span class="line"><span class="cl">	/*创建纹理*/
</span></span><span class="line"><span class="cl">	SDL_Texture *sdltext=SDL_CreateTexture(render,SDL_PIXELFORMAT_RGB24,SDL_TEXTUREACCESS_STREAMING,width,height);		
</span></span><span class="line"><span class="cl">	bool quit=true;
</span></span><span class="line"><span class="cl">	SDL_Event event;
</span></span><span class="line"><span class="cl">	printf(&#34;read fream buff\n&#34;);
</span></span><span class="line"><span class="cl">	//初始化转码器
</span></span><span class="line"><span class="cl">	AVPacket *packet=av_malloc(sizeof(AVPacket));/*分配包*/
</span></span><span class="line"><span class="cl">	av_init_packet(packet);//初始化
</span></span><span class="line"><span class="cl">	int i=0;
</span></span><span class="line"><span class="cl">	int index=0;
</span></span><span class="line"><span class="cl">	long video_pts_time=0;
</span></span><span class="line"><span class="cl">	long audio_pts_time=0;//音频解码时间
</span></span><span class="line"><span class="cl">	time=(1000000/frame_rate-10000);//时间
</span></span><span class="line"><span class="cl">	printf(&#34;time=%d\n&#34;,time);
</span></span><span class="line"><span class="cl">	while((av_read_frame(ps,packet)&gt;=0) &amp;&amp; (quit))
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		SDL_PollEvent(&amp;event);
</span></span><span class="line"><span class="cl">		if(event.type==SDL_QUIT)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			quit=false;
</span></span><span class="line"><span class="cl">			continue;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if(packet-&gt;stream_index == videostream)/*判断是否为视频*/
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			res=avcodec_send_packet(ps-&gt;streams[videostream]-&gt;codec,packet);
</span></span><span class="line"><span class="cl">			if(res)
</span></span><span class="line"><span class="cl">			{
</span></span><span class="line"><span class="cl">				av_packet_unref(packet);//释放这个pkt
</span></span><span class="line"><span class="cl">				continue;
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			res=avcodec_receive_frame(ps-&gt;streams[videostream]-&gt;codec,frame);
</span></span><span class="line"><span class="cl">			if(res)
</span></span><span class="line"><span class="cl">			{
</span></span><span class="line"><span class="cl">				av_packet_unref(packet);//释放这个pkt	
</span></span><span class="line"><span class="cl">				continue;
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			sws_scale(swsctx,(const uint8_t **)frame-&gt;data,frame-&gt;linesize,0,height,(const uint8_t **)frameYUV-&gt;data,frameYUV-&gt;linesize);
</span></span><span class="line"><span class="cl">			video_pts_time=packet-&gt;pts;
</span></span><span class="line"><span class="cl">			//printf(&#34;视频=%ld\n&#34;,video_pts_time);
</span></span><span class="line"><span class="cl">			SDL_UpdateTexture(sdltext,NULL,buff, width*3);
</span></span><span class="line"><span class="cl">			SDL_RenderCopy(render, sdltext, NULL, NULL); // 拷贝纹理到渲染器
</span></span><span class="line"><span class="cl">			SDL_RenderPresent(render); //渲染
</span></span><span class="line"><span class="cl">			usleep(time);
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if(packet-&gt;stream_index == audiostream)  //如果为音频标志
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			if(audiostream&lt;0)continue;
</span></span><span class="line"><span class="cl">			res=avcodec_send_packet(pCodecCtx,packet);
</span></span><span class="line"><span class="cl">			if(res)
</span></span><span class="line"><span class="cl">			{
</span></span><span class="line"><span class="cl">				printf(&#34;avcodec_send_packet failed,res=%d\n&#34;,res);
</span></span><span class="line"><span class="cl">				av_packet_unref(packet);//释放这个pkt	
</span></span><span class="line"><span class="cl">				continue;
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			res=avcodec_receive_frame(pCodecCtx,audioframe);
</span></span><span class="line"><span class="cl">			if(res)
</span></span><span class="line"><span class="cl">			{
</span></span><span class="line"><span class="cl">				printf(&#34;avcodec_receive_frame failed,res=%d\n&#34;,res);
</span></span><span class="line"><span class="cl">				av_packet_unref(packet);//释放这个pkt
</span></span><span class="line"><span class="cl">				continue;
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			//数据格式转换
</span></span><span class="line"><span class="cl">			res=swr_convert(swrCtx,&amp;out_buffer,out_buffer_size,/*重采样之后的数据*/
</span></span><span class="line"><span class="cl">						(const uint8_t **)audioframe-&gt;data,audioframe-&gt;nb_samples/*重采样之前数据*/
</span></span><span class="line"><span class="cl">						);
</span></span><span class="line"><span class="cl">			audio_pts_time=packet-&gt;pts;
</span></span><span class="line"><span class="cl">			//printf(&#34;音频：%ld\n&#34;,audio_pts_time);
</span></span><span class="line"><span class="cl">			if(res&gt;0)
</span></span><span class="line"><span class="cl">			{
</span></span><span class="line"><span class="cl">				//audio_chunk =out_buffer; //指向音频数据 (PCM data)
</span></span><span class="line"><span class="cl">				//while(audio_len&gt;0){}//等待数据处理完
</span></span><span class="line"><span class="cl">				//audio_len =audioframe-&gt;nb_samples;//out_buffer_size;//音频长度
</span></span><span class="line"><span class="cl">				//audio_pos =out_buffer;//当前播放位置
</span></span><span class="line"><span class="cl">				List_AddNode(list_head,out_buffer,out_buffer_size);//添加节点
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		//释放数据包
</span></span><span class="line"><span class="cl">		av_packet_unref(packet);
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	sws_freeContext(swsctx);
</span></span><span class="line"><span class="cl">	av_frame_free(&amp;frame);
</span></span><span class="line"><span class="cl">	av_frame_free(&amp;frameYUV);
</span></span><span class="line"><span class="cl">	avformat_free_context(ps);
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">/*创建链表头*/
</span></span><span class="line"><span class="cl">struct AUDIO_DATA *List_CreateHead(struct AUDIO_DATA *head)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if(head==NULL)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		head=malloc(sizeof(struct AUDIO_DATA));
</span></span><span class="line"><span class="cl">		head-&gt;next=NULL;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return head;	
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/*添加节点*/
</span></span><span class="line"><span class="cl">void List_AddNode(struct AUDIO_DATA *head,unsigned char* audio_buffer,int audio_size)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *tmp=head;
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *new_node;
</span></span><span class="line"><span class="cl">	pthread_mutex_lock(&amp;mutex);
</span></span><span class="line"><span class="cl">	/*找到链表尾部*/
</span></span><span class="line"><span class="cl">	while(tmp-&gt;next)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		tmp=tmp-&gt;next;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	/*插入新的节点*/
</span></span><span class="line"><span class="cl">	new_node=malloc(sizeof(struct AUDIO_DATA));
</span></span><span class="line"><span class="cl">	new_node-&gt;audio_size=audio_size;
</span></span><span class="line"><span class="cl">	new_node-&gt;audio_buffer=malloc(audio_size);//分配保存音频数据大小空间
</span></span><span class="line"><span class="cl">	memcpy(new_node-&gt;audio_buffer,audio_buffer,audio_size);
</span></span><span class="line"><span class="cl">	new_node-&gt;next=NULL;
</span></span><span class="line"><span class="cl">	/*将新节点接入到链表*/
</span></span><span class="line"><span class="cl">	tmp-&gt;next=new_node;	
</span></span><span class="line"><span class="cl">	pthread_mutex_unlock(&amp;mutex);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl">函数功能:删除节点
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">void List_DelNode(struct AUDIO_DATA *head,unsigned char* audio_buffer)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *tmp=head;
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *p;
</span></span><span class="line"><span class="cl">	/*找到链表中要删除的节点*/
</span></span><span class="line"><span class="cl">	pthread_mutex_lock(&amp;mutex);
</span></span><span class="line"><span class="cl">	while(tmp-&gt;next)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		p=tmp;
</span></span><span class="line"><span class="cl">		tmp=tmp-&gt;next;
</span></span><span class="line"><span class="cl">		if(tmp-&gt;audio_buffer==audio_buffer)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			p-&gt;next=tmp-&gt;next;
</span></span><span class="line"><span class="cl">			free(tmp-&gt;audio_buffer);
</span></span><span class="line"><span class="cl">			free(tmp);
</span></span><span class="line"><span class="cl">			break;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	pthread_mutex_unlock(&amp;mutex);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl">函数功能:遍历链表，得到节点总数量
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">int List_GetNodeCnt(struct AUDIO_DATA *head)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	int cnt=0;
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *tmp=head;
</span></span><span class="line"><span class="cl">	pthread_mutex_lock(&amp;mutex);
</span></span><span class="line"><span class="cl">	while(tmp-&gt;next)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		tmp=tmp-&gt;next;
</span></span><span class="line"><span class="cl">		cnt++;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	pthread_mutex_unlock(&amp;mutex);
</span></span><span class="line"><span class="cl">	return cnt;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl">从链表头取数据
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">int List_GetNode(struct AUDIO_DATA *head,char *audio_buff,int *audio_size)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *tmp=head;
</span></span><span class="line"><span class="cl">	struct AUDIO_DATA *ptemp=head;
</span></span><span class="line"><span class="cl">	pthread_mutex_lock(&amp;mutex);
</span></span><span class="line"><span class="cl">	while(tmp-&gt;next!=NULL)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		ptemp=tmp;
</span></span><span class="line"><span class="cl">		tmp=tmp-&gt;next;
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		if(tmp!=NULL)
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			*audio_size=tmp-&gt;audio_size;
</span></span><span class="line"><span class="cl">			memcpy(audio_buff,tmp-&gt;audio_buffer,tmp-&gt;audio_size);
</span></span><span class="line"><span class="cl">			ptemp-&gt;next=tmp-&gt;next;
</span></span><span class="line"><span class="cl">			free(tmp-&gt;audio_buffer);
</span></span><span class="line"><span class="cl">			free(tmp);
</span></span><span class="line"><span class="cl">			pthread_mutex_unlock(&amp;mutex);
</span></span><span class="line"><span class="cl">			return 0;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	pthread_mutex_unlock(&amp;mutex);
</span></span><span class="line"><span class="cl">	return -1;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-3" class="outline-4">
<h4 id="headline-3">
Makefile文件
</h4>
<div id="outline-text-headline-3" class="outline-text-4">
<p>
注意Makefile文件中涉及到的路径要跟系统环境相匹配，如果路径不一致会编译报错</p>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">OBJ=main.o
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ffmpeg_dir=&#34;${HOME}/ffmpeg/ffmpeg-4.3.1&#34;
</span></span><span class="line"><span class="cl">sdl_dir=&#34;/usr&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CFLAGS=-I$(ffmpeg_dir)/_install/include -LI$(ffmpeg_dir)/_install/lib\
</span></span><span class="line"><span class="cl">-I$(sdl_dir)/include -I$(sdl_dir)/include/SDL2 -L$(sdl_dir)/lib \
</span></span><span class="line"><span class="cl">-lSDL2 -lpthread -lm -ldl  -lavcodec -lavfilter -lavutil -lswresample -lavdevice -lavformat -lpostproc -lswscale -lpthread -lstdc++ -lm -lasound -lx264
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">app:$(OBJ)
</span></span><span class="line"><span class="cl">	gcc -o $@ $^ $(CFLAGS)  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">clean:
</span></span><span class="line"><span class="cl">	rm -rf app main.o</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
运行程序
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<div id="outline-container-headline-5" class="outline-5">
<h5 id="headline-5">
先准备一个视频
</h5>
<div id="outline-text-headline-5" class="outline-text-5">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  ffmpeg -f alsa -i default -f x11grab -r <span class="m">25</span> -s <span class="k">$(</span>xdpyinfo <span class="p">|</span> grep <span class="s1">&#39;dimensions:&#39;</span><span class="p">|</span>awk <span class="s1">&#39;{print $2;}&#39;</span><span class="k">)</span> -i :0.0 -t <span class="m">5</span> -c:v libx264 -preset ultrafast -c:a aac -tune fastdecode -y output.mp4</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-5">
<h5 id="headline-6">
运行示例
</h5>
<div id="outline-text-headline-6" class="outline-text-5">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  ./app output.mp4</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7" class="outline-5">
<h5 id="headline-7">
运行示例效果
</h5>
<div id="outline-text-headline-7" class="outline-text-5">
<p>
运行示例会播放视频，并在终端打印视频相关参数信息</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">video</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">  <span class="nv">audio</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="nv">fps</span><span class="o">=</span><span class="m">25</span>
</span></span><span class="line"><span class="cl">  <span class="nv">视频流ID</span><span class="o">=</span>0x1b
</span></span><span class="line"><span class="cl">  <span class="nv">音频流ID</span><span class="o">=</span>0x15002
</span></span><span class="line"><span class="cl">  配置音频参数
</span></span><span class="line"><span class="cl">  pCodecCtx-&gt;sample_rate<span class="o">=</span><span class="m">48000</span>
</span></span><span class="line"><span class="cl">  <span class="nv">frame_size</span><span class="o">=</span><span class="m">1024</span>
</span></span><span class="line"><span class="cl">  声道格式:3
</span></span><span class="line"><span class="cl">  采样格式:1
</span></span><span class="line"><span class="cl">  样本数量:1024
</span></span><span class="line"><span class="cl">  采样率:48000
</span></span><span class="line"><span class="cl">  通道个数:2
</span></span><span class="line"><span class="cl">  缓冲区大小:4096
</span></span><span class="line"><span class="cl">  输入音频格式:3
</span></span><span class="line"><span class="cl">  输入采样格式:8
</span></span><span class="line"><span class="cl">  输入采样率:48000
</span></span><span class="line"><span class="cl">  <span class="nv">音频数据初始化完成fmt</span><span class="o">=</span><span class="m">5</span>
</span></span><span class="line"><span class="cl">  <span class="nv">w</span><span class="o">=</span>1918,h<span class="o">=</span>926,size<span class="o">=</span><span class="m">5328204</span>
</span></span><span class="line"><span class="cl">  <span class="nb">read</span> fream buff
</span></span><span class="line"><span class="cl">  <span class="nv">time</span><span class="o">=</span><span class="m">30000</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-4">
<h4 id="headline-8">
ChatGPT分析代码
</h4>
<div id="outline-text-headline-8" class="outline-text-4">
<p>
这个代码主要实现了通过FFmpeg和SDL库对FLV格式视频文件进行音频和视频的解码和播放，使用了线程和链表对音频数据进行处理。以下是对代码的详细分析：</p>
<div id="outline-container-headline-9" class="outline-5">
<h5 id="headline-9">
1. 头文件与库引入
</h5>
<div id="outline-text-headline-9" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;libavcodec/avcodec.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;libavformat/avformat.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;libswscale/swscale.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;libswresample/swresample.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;libavutil/mathematics.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;libavutil/timestamp.h&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>FFmpeg库：用于音视频的编解码处理，包括 avcodec、avformat、swscale、swresample 等库，分别处理编解码、封装格式、视频格式转换、音频重采样等。</li>
<li>SDL库：用于处理音频和视频的输出，负责创建窗口和播放音频。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-10" class="outline-5">
<h5 id="headline-10">
2. 常量与全局变量
</h5>
<div id="outline-text-headline-10" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define FILE_NAME &#34;123.flv&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX_AUDIO_FRAME_SIZE 1024*100 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="n">Uint8</span><span class="o">*</span> <span class="n">audio_chunk</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_len</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">audio_pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>FILE_NAME 是测试用的 FLV 文件名，实际运行时通过命令行参数指定文件。</li>
<li>audio_chunk 是用于存储音频数据的指针，audio_len 和 audio_pos 用于管理音频缓冲区的状态。</li>
<li>mutex 是一个互斥锁，用于音频数据链表的并发访问控制。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-11" class="outline-5">
<h5 id="headline-11">
3. 音频数据链表
</h5>
<div id="outline-text-headline-11" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">AUDIO_DATA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">audio_buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">audio_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">AUDIO_DATA</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>这段代码定义了一个用于存储音频数据的链表结构 AUDIO_DATA，每个节点包含音频数据的大小和指向下一节点的指针。</li>
<li>链表操作函数包括创建链表头 List_CreateHead，添加节点 List_AddNode，删除节点 List_DelNode，获取节点数量 List_GetNodeCnt 和从链表中获取数据 List_GetNode。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-12" class="outline-5">
<h5 id="headline-12">
4. 音频回调函数
</h5>
<div id="outline-text-headline-12" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">AudioCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span> <span class="n">Uint8</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_memset</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>  <span class="c1">// 清零音频缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">audio_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">audio_len</span><span class="p">)</span> <span class="o">?</span> <span class="nl">audio_len</span> <span class="p">:</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SDL_MixAudio</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">audio_pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">SDL_MIX_MAXVOLUME</span><span class="p">);</span>  <span class="c1">// 将音频数据混入播放缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">audio_pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">audio_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>SDL 使用该回调函数在音频缓冲区为空时拉取数据，通过 SDL_MixAudio 函数混合音频数据。</li>
<li>当 audio_len 为 0 时，表示当前没有音频数据可播放。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-13" class="outline-5">
<h5 id="headline-13">
5. 音频解码线程
</h5>
<div id="outline-text-headline-13" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">Audio_decode</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">audio_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">audio_buff</span><span class="p">[</span><span class="mi">4096</span><span class="o">*</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">List_GetNode</span><span class="p">(</span><span class="n">list_head</span><span class="p">,</span> <span class="n">audio_buff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audio_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">audio_chunk</span> <span class="o">=</span> <span class="n">audio_buff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">audio_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 等待数据被播放完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">audio_len</span> <span class="o">=</span> <span class="n">audio_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">audio_pos</span> <span class="o">=</span> <span class="n">audio_buff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>该函数为一个线程，用于持续从链表中取出音频数据，并在播放缓冲区为空时将新数据填入。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-14" class="outline-5">
<h5 id="headline-14">
6. 主程序 main
</h5>
<div id="outline-text-headline-14" class="outline-text-5">
<ul>
<li>
<p>初始化：</p>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span> <span class="o">|</span> <span class="n">SDL_INIT_AUDIO</span> <span class="o">|</span> <span class="n">SDL_INIT_TIMER</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>初始化 SDL，指定需要使用的视频、音频和定时器子系统。</p>
</li>
<li>
<p>打开媒体文件：</p>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">avformat_find_stream_info</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>使用 FFmpeg 打开指定的视频文件，并解析其流信息。</p>
</li>
<li>
<p>视频流和音频流解码器初始化：</p>
<ul>
<li>视频：找到视频流后，使用 avcodec_find_decoder 查找合适的解码器，并打开解码器上下文 avcodec_open2。</li>
<li>音频：找到音频流后，类似地初始化音频解码器上下文，并设置音频的重采样参数 SwrContext。</li>
</ul>
</li>
<li>
<p>创建音频播放：</p>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">SDL_AudioSpec</span> <span class="n">desired</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">desired</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">AudioCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">SDL_OpenAudio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desired</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">SDL_PauseAudio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>使用 SDL 创建音频播放，指定音频回调函数 AudioCallback，并启动音频播放。</p>
</li>
<li>
<p>解码与播放循环：</p>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nf">av_read_frame</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">packet</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">videostream</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 视频解码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">avcodec_send_packet</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">videostream</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">avcodec_receive_frame</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">videostream</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 视频缩放并更新纹理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sws_scale</span><span class="p">(</span><span class="n">swsctx</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_UpdateTexture</span><span class="p">(</span><span class="n">sdltext</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">width</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_RenderCopy</span><span class="p">(</span><span class="n">render</span><span class="p">,</span> <span class="n">sdltext</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SDL_RenderPresent</span><span class="p">(</span><span class="n">render</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">audiostream</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 音频解码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">avcodec_send_packet</span><span class="p">(</span><span class="n">pCodecCtx</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">avcodec_receive_frame</span><span class="p">(</span><span class="n">pCodecCtx</span><span class="p">,</span> <span class="n">audioframe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">swr_convert</span><span class="p">(</span><span class="n">swrCtx</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">List_AddNode</span><span class="p">(</span><span class="n">list_head</span><span class="p">,</span> <span class="n">out_buffer</span><span class="p">,</span> <span class="n">out_buffer_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">av_packet_unref</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>视频部分：读取视频帧，使用 sws_scale 进行图像格式转换，更新 SDL 纹理并显示。</li>
<li>音频部分：读取音频帧，重采样后将数据添加到链表，供回调函数消费。</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-15" class="outline-5">
<h5 id="headline-15">
7. 链表管理
</h5>
<div id="outline-text-headline-15" class="outline-text-5">
<p>音频数据使用链表存储，这样可以缓冲更多的数据，防止播放过程中音频数据不足造成的卡顿。</p>
<p>
在你提供的代码中，链表的类型是 单向链表。这是因为每个节点只包含一个指向下一个节点的指针，没有指向前一个节点的指针。</p>
<p>
链表的定义如下：</p>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">AUDIO_DATA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">audio_buffer</span><span class="p">;</span>  <span class="c1">// 音频数据指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">audio_size</span><span class="p">;</span>               <span class="c1">// 音频数据大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">AUDIO_DATA</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>      <span class="c1">// 指向下一个节点的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
每个 AUDIO_DATA 结构体中包含三个成员：</p>
<ol>
<li>audio_buffer：指向保存音频数据的缓冲区。</li>
<li>audio_size：保存当前音频数据的大小。</li>
<li>next：指向下一个 AUDIO_DATA 节点。如果这是链表的最后一个节点，则 next 为 NULL。</li>
</ol>
<p>这是一个典型的 单向链表，因为它的节点只通过 next 指针连接到下一个节点，而无法访问前一个节点。这种链表的操作（如添加、删除节点）只需处理单个方向的指针，不涉及双向连接。</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-5">
<h5 id="headline-16">
总结
</h5>
<div id="outline-text-headline-16" class="outline-text-5">
<ul>
<li>该程序通过 FFmpeg 实现音频和视频的解码，通过 SDL 实现音视频的播放。</li>
<li>使用了链表和线程处理音频数据，保证了音频播放的连续性。</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
打开一个媒体文件并输出其格式信息
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if (argc != 2)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		printf(&#34;格式:./app 文件名\n&#34;);
</span></span><span class="line"><span class="cl">	    return 1;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	AVFormatContext *ps = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int res = avformat_open_input(&amp;ps, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">	if (res != 0) {				
</span></span><span class="line"><span class="cl">		printf(&#34;open err: %d\n&#34;, res);
</span></span><span class="line"><span class="cl">		return 1;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	av_dump_format(ps, 0, file_name, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	av_dump_format(ps, 0, file_name, 0);
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">	avformat_close_input(&amp;ps);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-18" class="outline-4">
<h4 id="headline-18">
示例说明
</h4>
<div id="outline-text-headline-18" class="outline-text-4">
<p>
这段代码的功能是打开一个指定的视频或音频文件并打印其格式信息。具体步骤如下：</p>
<ol>
<li>检查命令行参数：确保提供了一个文件名作为参数。</li>
<li>打开文件：使用 avformat_open_input 打开指定的媒体文件，并将文件的格式信息存储在 AVFormatContext 结构体中。</li>
<li>打印格式信息：使用 av_dump_format 打印文件的详细格式信息。</li>
<li>关闭文件：调用 avformat_close_input 释放资源并关闭文件。</li>
</ol>
<p>代码的最终目的是用来查看指定媒体文件的格式信息。</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-4">
<h4 id="headline-19">
参考链接
</h4>
<div id="outline-text-headline-19" class="outline-text-4">
<p>
<a href="https://blog.csdn.net/weixin_42877471/article/details/139929421">【FFmpeg】avformat_open_input函数</a></p>
<p>
<a href="https://blog.csdn.net/u012587637/article/details/122804997">ffmpeg_av_dump_format</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
查找视频和音频流示例-1
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if (argc != 2) {
</span></span><span class="line"><span class="cl">		printf(&#34;Usage:./app filename\n&#34;);
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	AVFormatContext *ps = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int res = avformat_open_input(&amp;ps, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">	if (res) {
</span></span><span class="line"><span class="cl">		printf(&#34;Open error:%d\n&#34;, res);
</span></span><span class="line"><span class="cl">		return -1;		
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	avformat_find_stream_info(ps, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	av_dump_format(ps, 0, file_name, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int videostream = -1, audiostream = -1;
</span></span><span class="line"><span class="cl">	AVStream *stream = NULL, *audstream = NULL;
</span></span><span class="line"><span class="cl">	AVCodec *vcodec = NULL, *audcodec = NULL;
</span></span><span class="line"><span class="cl">	int frame_rate = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	videostream = av_find_best_stream(ps, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
</span></span><span class="line"><span class="cl">	printf(&#34;video = %d\n&#34;, videostream);
</span></span><span class="line"><span class="cl">	audiostream = av_find_best_stream(ps, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0);
</span></span><span class="line"><span class="cl">	printf(&#34;audio = %d\n&#34;, audiostream);
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	if (videostream &gt;= 0) {
</span></span><span class="line"><span class="cl">		stream = ps-&gt;streams[videostream];
</span></span><span class="line"><span class="cl">		vcodec = avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);
</span></span><span class="line"><span class="cl">		if (!vcodec) {
</span></span><span class="line"><span class="cl">			printf(&#34;Not find video decoder.\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		res = avcodec_open2(stream-&gt;codec, vcodec, NULL);
</span></span><span class="line"><span class="cl">		if (res) {
</span></span><span class="line"><span class="cl">			printf(&#34;Open decoder failed.\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	printf(&#34;Video Stream ID = %#X\n&#34;, vcodec-&gt;id);
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	frame_rate = stream-&gt;avg_frame_rate.num / stream-&gt;avg_frame_rate.den;
</span></span><span class="line"><span class="cl">	printf(&#34;FPS = %d\n&#34;, frame_rate);
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	if (audiostream &gt;= 0) {
</span></span><span class="line"><span class="cl">	    audstream = ps-&gt;streams[audiostream];
</span></span><span class="line"><span class="cl">		audcodec = avcodec_find_decoder(audstream-&gt;codecpar-&gt;codec_id);
</span></span><span class="line"><span class="cl">		if (!audcodec) {
</span></span><span class="line"><span class="cl">			printf(&#34;Not find audio deocder.\n&#34;);
</span></span><span class="line"><span class="cl">			return  -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		res = avcodec_open2(audstream-&gt;codec, audcodec, NULL);
</span></span><span class="line"><span class="cl">		if (res) {
</span></span><span class="line"><span class="cl">			printf(&#34;Open decoder failed.\n&#34;);
</span></span><span class="line"><span class="cl">			return -1;
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	printf(&#34;Audio Stream ID = %#X\n&#34;, audcodec-&gt;id);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	avformat_close_input(&amp;ps);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-21" class="outline-4">
<h4 id="headline-21">
示例说明
</h4>
<div id="outline-text-headline-21" class="outline-text-4">
<p>
这段代码的功能是：</p>
<ol>
<li>初始化：使用 SDL 库进行视频、音频和计时器的初始化。</li>
<li>打开媒体文件：通过 FFmpeg 的 avformat_open_input 函数打开用户指定的媒体文件，并检查是否成功。</li>
<li>获取流信息：调用 avformat_find_stream_info 函数获取媒体文件中的流信息，并使用 av_dump_format 打印流的详细信息。</li>
<li>查找流：使用 av_find_best_stream 函数查找视频流和音频流的索引，并输出这些流的索引。</li>
<li>
<p>解码器处理：</p>
<ul>
<li>对视频流：查找并打开对应的视频解码器，计算帧率并打印。</li>
<li>对音频流：查找并打开对应的音频解码器，打印音频解码器的 ID。</li>
</ul>
</li>
<li>清理：关闭媒体文件的输入流。</li>
</ol>
<p>总体来说，这段代码的目的是初始化 SDL，打开并分析指定的媒体文件，查找视频和音频流，并尝试打开相应的解码器。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
查找视频和音频流示例-2
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if (argc != 2) {
</span></span><span class="line"><span class="cl">		printf(&#34;Usage:./app filename\n&#34;);
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	AVFormatContext *ps = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int res = avformat_open_input(&amp;ps, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">	if (res) {
</span></span><span class="line"><span class="cl">		printf(&#34;Open error:%d\n&#34;, res);
</span></span><span class="line"><span class="cl">		return -1;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	avformat_find_stream_info(ps, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	av_dump_format(ps, 0, file_name, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for(int i=0; i&lt;ps-&gt;nb_streams; i++){
</span></span><span class="line"><span class="cl">		AVStream *stream = ps-&gt;streams[i];
</span></span><span class="line"><span class="cl">		AVCodecParameters *codec_par = stream-&gt;codecpar;
</span></span><span class="line"><span class="cl">		av_log(NULL, AV_LOG_INFO, &#34;find audio/video stream index=%d, type=%s, codec id=%#X&#34;,  
</span></span><span class="line"><span class="cl">			   i, av_get_media_type_string(codec_par-&gt;codec_type), codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">		printf(&#34;\n&#34;);
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;ps);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-23" class="outline-4">
<h4 id="headline-23">
参考链接
</h4>
<div id="outline-text-headline-23" class="outline-text-4">
<p>
<a href="https://segmentfault.com/a/1190000017980746">一步步进行ffmpeg的C语言音视频编程</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
查看音视频流的格式，同时获得解码器
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if (argc != 2) {
</span></span><span class="line"><span class="cl">		printf(&#34;Usage:./app filename\n&#34;);
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	AVFormatContext *ps = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int res = avformat_open_input(&amp;ps, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">	if (res) {
</span></span><span class="line"><span class="cl">		printf(&#34;Open error:%d\n&#34;, res);
</span></span><span class="line"><span class="cl">		return -1;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	avformat_find_stream_info(ps, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	av_dump_format(ps, 0, file_name, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	AVStream *stream = NULL;
</span></span><span class="line"><span class="cl">	AVCodecParameters *codec_par = NULL;
</span></span><span class="line"><span class="cl">	AVCodec *decodec = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for(int i = 0; i &lt; ps-&gt;nb_streams; i++){
</span></span><span class="line"><span class="cl">	    stream = ps-&gt;streams[i];
</span></span><span class="line"><span class="cl">		codec_par = stream-&gt;codecpar;
</span></span><span class="line"><span class="cl">		decodec = avcodec_find_decoder(codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		av_log(NULL, AV_LOG_INFO, &#34;find audio/video stream index = %d, type = %s, codec id = %#X\n&#34;, i, av_get_media_type_string(codec_par-&gt;codec_type), codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">		av_log(NULL, AV_LOG_INFO, &#34;find codec name = %s\t%s\n&#34;, decodec-&gt;name, decodec-&gt;long_name);
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;ps);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-25" class="outline-4">
<h4 id="headline-25">
参考链接
</h4>
<div id="outline-text-headline-25" class="outline-text-4">
<p>
<a href="https://segmentfault.com/a/1190000017980746">一步步进行ffmpeg的C语言音视频编程</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-26" class="outline-3">
<h3 id="headline-26">
查看视频帧率
</h3>
<div id="outline-text-headline-26" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	if (argc != 2) {
</span></span><span class="line"><span class="cl">		printf(&#34;Usage:./app filename\n&#34;);
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	AVFormatContext *ps = NULL;
</span></span><span class="line"><span class="cl">	AVRational framerate;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int res = avformat_open_input(&amp;ps, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">	if (res) {
</span></span><span class="line"><span class="cl">		printf(&#34;Open error:%d\n&#34;, res);
</span></span><span class="line"><span class="cl">		return -1;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	avformat_find_stream_info(ps, NULL);   	
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	framerate = av_guess_frame_rate(ps, ps-&gt;streams[0], NULL);
</span></span><span class="line"><span class="cl">	av_log(NULL, AV_LOG_INFO, &#34;video framerate=%d/%d\n&#34;, framerate.num, framerate.den);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;ps);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-27" class="outline-4">
<h4 id="headline-27">
参考链接
</h4>
<div id="outline-text-headline-27" class="outline-text-4">
<p>
<a href="https://segmentfault.com/a/1190000017980746">一步步进行ffmpeg的C语言音视频编程</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
正确获取和处理流索引、解码器、以及正确释放资源 - ChatGPT
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavformat/avformat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavcodec/avcodec.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[]) {
</span></span><span class="line"><span class="cl">    if (argc != 2) {
</span></span><span class="line"><span class="cl">        printf(&#34;Usage: ./app filename\n&#34;);
</span></span><span class="line"><span class="cl">        return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    AVFormatContext *ps = NULL;
</span></span><span class="line"><span class="cl">    int res = avformat_open_input(&amp;ps, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">    if (res) {
</span></span><span class="line"><span class="cl">        printf(&#34;Open error: %d\n&#34;, res);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_find_stream_info(ps, NULL);
</span></span><span class="line"><span class="cl">    av_dump_format(ps, 0, file_name, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    AVStream *stream = NULL;
</span></span><span class="line"><span class="cl">    AVCodecParameters *codec_par = NULL;
</span></span><span class="line"><span class="cl">    AVCodec *codec = NULL;
</span></span><span class="line"><span class="cl">    AVCodecContext *video_codec_ctx = NULL, *audio_codec_ctx = NULL;
</span></span><span class="line"><span class="cl">    int video_stream_idx = -1, audio_stream_idx = -1;
</span></span><span class="line"><span class="cl">    AVRational framerate;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; ps-&gt;nb_streams; i++) {
</span></span><span class="line"><span class="cl">        stream = ps-&gt;streams[i];
</span></span><span class="line"><span class="cl">        codec_par = stream-&gt;codecpar;
</span></span><span class="line"><span class="cl">        codec = avcodec_find_decoder(codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (codec == NULL) {
</span></span><span class="line"><span class="cl">            av_log(NULL, AV_LOG_WARNING, &#34;Unsupported codec with id %d\n&#34;, codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">            continue;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        av_log(NULL, AV_LOG_INFO, &#34;Stream index = %d, type = %s, codec id = %#X\n&#34;, i, av_get_media_type_string(codec_par-&gt;codec_type), codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">        av_log(NULL, AV_LOG_INFO, &#34;Codec name = %s\t%s\n&#34;, codec-&gt;name, codec-&gt;long_name);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (codec_par-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
</span></span><span class="line"><span class="cl">            video_stream_idx = i;
</span></span><span class="line"><span class="cl">            video_codec_ctx = avcodec_alloc_context3(codec);
</span></span><span class="line"><span class="cl">            avcodec_parameters_to_context(video_codec_ctx, codec_par);
</span></span><span class="line"><span class="cl">            if (avcodec_open2(video_codec_ctx, codec, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">                av_log(NULL, AV_LOG_ERROR, &#34;Failed to open video codec\n&#34;);
</span></span><span class="line"><span class="cl">                return -1;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else if (codec_par-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
</span></span><span class="line"><span class="cl">            audio_stream_idx = i;
</span></span><span class="line"><span class="cl">            audio_codec_ctx = avcodec_alloc_context3(codec);
</span></span><span class="line"><span class="cl">            avcodec_parameters_to_context(audio_codec_ctx, codec_par);
</span></span><span class="line"><span class="cl">            if (avcodec_open2(audio_codec_ctx, codec, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">                av_log(NULL, AV_LOG_ERROR, &#34;Failed to open audio codec\n&#34;);
</span></span><span class="line"><span class="cl">                return -1;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (video_stream_idx &gt;= 0) {
</span></span><span class="line"><span class="cl">        framerate = av_guess_frame_rate(ps, ps-&gt;streams[video_stream_idx], NULL);
</span></span><span class="line"><span class="cl">        av_log(NULL, AV_LOG_INFO, &#34;Video framerate = %d/%d\n&#34;, framerate.num, framerate.den);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    AVPacket *pkt = av_packet_alloc();
</span></span><span class="line"><span class="cl">    AVFrame *frame = av_frame_alloc();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (av_read_frame(ps, pkt) &gt;= 0) {
</span></span><span class="line"><span class="cl">        if (pkt-&gt;size) {
</span></span><span class="line"><span class="cl">            if (pkt-&gt;stream_index == video_stream_idx) {
</span></span><span class="line"><span class="cl">                printf(&#34;Video stream index = %d\n&#34;, video_stream_idx);
</span></span><span class="line"><span class="cl">                avcodec_send_packet(video_codec_ctx, pkt);
</span></span><span class="line"><span class="cl">                while (avcodec_receive_frame(video_codec_ctx, frame) == 0) {
</span></span><span class="line"><span class="cl">                    printf(&#34;Decoded video frame\n&#34;);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } else if (pkt-&gt;stream_index == audio_stream_idx) {
</span></span><span class="line"><span class="cl">                printf(&#34;Audio stream index = %d\n&#34;, audio_stream_idx);
</span></span><span class="line"><span class="cl">                avcodec_send_packet(audio_codec_ctx, pkt);
</span></span><span class="line"><span class="cl">                while (avcodec_receive_frame(audio_codec_ctx, frame) == 0) {
</span></span><span class="line"><span class="cl">                    printf(&#34;Decoded audio frame\n&#34;);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        av_packet_unref(pkt);
</span></span><span class="line"><span class="cl">        av_frame_unref(frame);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avcodec_free_context(&amp;video_codec_ctx);
</span></span><span class="line"><span class="cl">    avcodec_free_context(&amp;audio_codec_ctx);
</span></span><span class="line"><span class="cl">    av_frame_free(&amp;frame);
</span></span><span class="line"><span class="cl">    av_packet_free(&amp;pkt);
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;ps);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-29" class="outline-3">
<h3 id="headline-29">
打开一个多媒体文件，查找其中的视频和音频流，并打印每个流的相关信息
</h3>
<div id="outline-text-headline-29" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavformat/avformat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavcodec/avcodec.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[]) {
</span></span><span class="line"><span class="cl">    if (argc != 2) {
</span></span><span class="line"><span class="cl">        printf(&#34;Usage: ./app filename\n&#34;);
</span></span><span class="line"><span class="cl">        return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    const char *file_name = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    AVFormatContext *fmt_ctx = NULL;
</span></span><span class="line"><span class="cl">    int ret = avformat_open_input(&amp;fmt_ctx, file_name, NULL, NULL);
</span></span><span class="line"><span class="cl">    if (ret) {
</span></span><span class="line"><span class="cl">        printf(&#34;Open error: %d\n&#34;, ret);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_find_stream_info(fmt_ctx, NULL);
</span></span><span class="line"><span class="cl">    av_dump_format(fmt_ctx, 0, file_name, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// find codec
</span></span><span class="line"><span class="cl">    int video_stream_idx = -1, audio_stream_idx = -1;
</span></span><span class="line"><span class="cl">    AVStream *video_stream = NULL, *audio_stream = NULL;
</span></span><span class="line"><span class="cl">    AVCodecContext *video_decodec_ctx=NULL, *audio_decodec_ctx=NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // AVFormatContext.nb_stream 记录了该 URL 中包含有几路流
</span></span><span class="line"><span class="cl">    for(int i=0; i&lt;fmt_ctx-&gt;nb_streams; i++){
</span></span><span class="line"><span class="cl">        AVStream *stream = fmt_ctx-&gt;streams[i];
</span></span><span class="line"><span class="cl">        AVCodecParameters *codec_par = stream-&gt;codecpar;
</span></span><span class="line"><span class="cl">        AVCodec *decodec = NULL;
</span></span><span class="line"><span class="cl">        AVCodecContext *decodec_ctx = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        av_log(NULL, AV_LOG_INFO, &#34;find audio/video stream index=%d, type=%s, codec id=%#X\n&#34;,
</span></span><span class="line"><span class="cl">			   i, av_get_media_type_string(codec_par-&gt;codec_type), codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 获得解码器
</span></span><span class="line"><span class="cl">        decodec = avcodec_find_decoder(codec_par-&gt;codec_id);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        av_log(NULL, AV_LOG_INFO, &#34;find codec name=%s\t%s\n&#34;, decodec-&gt;name, decodec-&gt;long_name);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 分配解码器上下文句柄
</span></span><span class="line"><span class="cl">        decodec_ctx = avcodec_alloc_context3(decodec);
</span></span><span class="line"><span class="cl">        if(!decodec_ctx){
</span></span><span class="line"><span class="cl">            av_log(NULL, AV_LOG_ERROR, &#34;fail to allocate codec context\n&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 复制流信息到解码器上下文
</span></span><span class="line"><span class="cl">        if(avcodec_parameters_to_context(decodec_ctx, codec_par) &lt; 0){
</span></span><span class="line"><span class="cl">            av_log(NULL, AV_LOG_ERROR, &#34;fail to copy codec parameters to decoder context\n&#34;);
</span></span><span class="line"><span class="cl">            avcodec_free_context(&amp;decodec_ctx);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 初始化解码器
</span></span><span class="line"><span class="cl">        if ((ret = avcodec_open2(decodec_ctx, decodec, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">            av_log(NULL, AV_LOG_ERROR, &#34;Failed to open %s codec\n&#34;, decodec-&gt;name);
</span></span><span class="line"><span class="cl">            return ret;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if( stream-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO){
</span></span><span class="line"><span class="cl">            // 视频的属性，帧率，这里 av_guess_frame_rate() 非必须，看业务是否需要使用帧率参数
</span></span><span class="line"><span class="cl">            decodec_ctx-&gt;framerate = av_guess_frame_rate(fmt_ctx, stream, NULL);
</span></span><span class="line"><span class="cl">            av_log(NULL, AV_LOG_INFO, &#34;video framerate=%d/%d\n&#34;, decodec_ctx-&gt;framerate.num, decodec_ctx-&gt;framerate.den);
</span></span><span class="line"><span class="cl">            video_stream_idx = i;
</span></span><span class="line"><span class="cl">            video_stream = stream;
</span></span><span class="line"><span class="cl">            video_decodec_ctx = decodec_ctx;
</span></span><span class="line"><span class="cl">        } else if( stream-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO){
</span></span><span class="line"><span class="cl">            audio_stream_idx = i;
</span></span><span class="line"><span class="cl">            audio_stream = stream;
</span></span><span class="line"><span class="cl">            audio_decodec_ctx = decodec_ctx;
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;fmt_ctx);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-30" class="outline-4">
<h4 id="headline-30">
示例说明
</h4>
<div id="outline-text-headline-30" class="outline-text-4">
<p>
这段代码的功能是打开一个多媒体文件，查找其中的视频和音频流，并打印每个流的相关信息。具体步骤如下：</p>
<ol>
<li>打开文件：通过 avformat_open_input 打开指定的多媒体文件。</li>
<li>获取流信息：调用 avformat_find_stream_info 获取流的详细信息，并用 av_dump_format 打印所有流的基本信息。</li>
<li>
<p>查找和初始化解码器：</p>
<ul>
<li>遍历文件中的所有流，识别音频和视频流。</li>
<li>为每个流找到对应的解码器，并为其分配和初始化解码器上下文。</li>
<li>打印每个流的类型、编解码器 ID 和名称。</li>
</ul>
</li>
<li>处理视频流：对于视频流，尝试获取帧率信息并打印。</li>
<li>关闭文件：最后，关闭输入文件并释放相关资源。</li>
</ol>
<p>总结：这段代码用于分析多媒体文件的流结构和编解码器信息。</p>
</div>
</div>
<div id="outline-container-headline-31" class="outline-4">
<h4 id="headline-31">
参考链接
</h4>
<div id="outline-text-headline-31" class="outline-text-4">
<p>
<a href="https://segmentfault.com/a/1190000017980746">一步步进行ffmpeg的C语言音视频编程</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-32" class="outline-3">
<h3 id="headline-32">
decode_video_mp4 - ChatGPT
</h3>
<div id="outline-text-headline-32" class="outline-text-3">
<p>
解码视频</p>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;libavcodec/avcodec.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavformat/avformat.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define INBUF_SIZE 4096
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void pgm_save(unsigned char *buf, int wrap, int xsize, int ysize,
</span></span><span class="line"><span class="cl">                     char *filename)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    FILE *f;
</span></span><span class="line"><span class="cl">    int i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    f = fopen(filename, &#34;wb&#34;);
</span></span><span class="line"><span class="cl">    fprintf(f, &#34;P5\n%d %d\n%d\n&#34;, xsize, ysize, 255);
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; ysize; i++)
</span></span><span class="line"><span class="cl">        fwrite(buf + i * wrap, 1, xsize, f);
</span></span><span class="line"><span class="cl">    fclose(f);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt,
</span></span><span class="line"><span class="cl">                   const char *filename)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    char buf[1024];
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = avcodec_send_packet(dec_ctx, pkt);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Error sending a packet for decoding\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (ret &gt;= 0) {
</span></span><span class="line"><span class="cl">        ret = avcodec_receive_frame(dec_ctx, frame);
</span></span><span class="line"><span class="cl">        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        else if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Error during decoding\n&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        printf(&#34;saving frame %3&#34;PRId64&#34;\n&#34;, dec_ctx-&gt;frame_number);
</span></span><span class="line"><span class="cl">        fflush(stdout);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        snprintf(buf, sizeof(buf), &#34;%s-%&#34;PRId64, filename, dec_ctx-&gt;frame_number);
</span></span><span class="line"><span class="cl">        pgm_save(frame-&gt;data[0], frame-&gt;linesize[0], frame-&gt;width, frame-&gt;height, buf);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char **argv)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    const char *filename, *outfilename;
</span></span><span class="line"><span class="cl">    const AVCodec *codec;
</span></span><span class="line"><span class="cl">    AVCodecContext *c = NULL;
</span></span><span class="line"><span class="cl">    AVFormatContext *fmt_ctx = NULL;
</span></span><span class="line"><span class="cl">    AVFrame *frame;
</span></span><span class="line"><span class="cl">    AVPacket *pkt;
</span></span><span class="line"><span class="cl">    int video_stream_index;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (argc &lt;= 2) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Usage: %s &lt;input file&gt; &lt;output file&gt;\n&#34;, argv[0]);
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    filename = argv[1];
</span></span><span class="line"><span class="cl">    outfilename = argv[2];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avformat_open_input(&amp;fmt_ctx, filename, NULL, NULL);
</span></span><span class="line"><span class="cl">    if (!fmt_ctx) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not open input file %s\n&#34;, filename);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (avformat_find_stream_info(fmt_ctx, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed to retrieve input stream information\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    video_stream_index = -1;
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; fmt_ctx-&gt;nb_streams; i++) {
</span></span><span class="line"><span class="cl">        if (fmt_ctx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
</span></span><span class="line"><span class="cl">            video_stream_index = i;
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (video_stream_index == -1) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;No video stream found in input file\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    AVCodecParameters *codecpar = fmt_ctx-&gt;streams[video_stream_index]-&gt;codecpar;
</span></span><span class="line"><span class="cl">    codec = avcodec_find_decoder(codecpar-&gt;codec_id);
</span></span><span class="line"><span class="cl">    if (!codec) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Codec not found\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    c = avcodec_alloc_context3(codec);
</span></span><span class="line"><span class="cl">    if (!c) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not allocate video codec context\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    avcodec_parameters_to_context(c, codecpar);
</span></span><span class="line"><span class="cl">    avcodec_open2(c, codec, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    frame = av_frame_alloc();
</span></span><span class="line"><span class="cl">    pkt = av_packet_alloc();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (av_read_frame(fmt_ctx, pkt) &gt;= 0) {
</span></span><span class="line"><span class="cl">        if (pkt-&gt;stream_index == video_stream_index) {
</span></span><span class="line"><span class="cl">            decode(c, frame, pkt, outfilename);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        av_packet_unref(pkt);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    decode(c, frame, NULL, outfilename);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    av_packet_free(&amp;pkt);
</span></span><span class="line"><span class="cl">    avcodec_free_context(&amp;c);
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;fmt_ctx);
</span></span><span class="line"><span class="cl">    av_frame_free(&amp;frame);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-33" class="outline-4">
<h4 id="headline-33">
参考链接
</h4>
<div id="outline-text-headline-33" class="outline-text-4">
<p>
<a href="https://github.com/FFmpeg/FFmpeg/blob/master/doc/examples/decode_video.c">decode_video.c</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-34" class="outline-3">
<h3 id="headline-34">
encode_video_mp4 - ChatGPT
</h3>
<div id="outline-text-headline-34" class="outline-text-3">
<p>
多个视频帧通过编码恢复成视频</p>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavcodec/avcodec.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libavformat/avformat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;libswscale/swscale.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVFormatContext *ofmt_ctx, AVStream *out_stream) {
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">    AVPacket *pkt = av_packet_alloc();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Send frame to encoder
</span></span><span class="line"><span class="cl">    ret = avcodec_send_frame(enc_ctx, frame);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Error sending a frame for encoding\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Receive encoded packet
</span></span><span class="line"><span class="cl">    while (ret &gt;= 0) {
</span></span><span class="line"><span class="cl">        ret = avcodec_receive_packet(enc_ctx, pkt);
</span></span><span class="line"><span class="cl">        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        else if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Error during encoding\n&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // Rescale packet timestamp from codec to output stream timebase
</span></span><span class="line"><span class="cl">        av_packet_rescale_ts(pkt, enc_ctx-&gt;time_base, out_stream-&gt;time_base);
</span></span><span class="line"><span class="cl">        pkt-&gt;stream_index = out_stream-&gt;index;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // Write packet to output
</span></span><span class="line"><span class="cl">        ret = av_interleaved_write_frame(ofmt_ctx, pkt);
</span></span><span class="line"><span class="cl">        if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Error writing frame\n&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        av_packet_unref(pkt);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    av_packet_free(&amp;pkt);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char **argv) {
</span></span><span class="line"><span class="cl">    const char *output_filename;
</span></span><span class="line"><span class="cl">    const AVCodec *encoder;
</span></span><span class="line"><span class="cl">    AVCodecContext *enc_ctx = NULL;
</span></span><span class="line"><span class="cl">    AVFormatContext *ofmt_ctx = NULL;
</span></span><span class="line"><span class="cl">    AVStream *out_stream;
</span></span><span class="line"><span class="cl">    AVFrame *frame;
</span></span><span class="line"><span class="cl">    int ret, frame_count;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (argc &lt; 2) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Usage: %s &lt;output file&gt;\n&#34;, argv[0]);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    output_filename = argv[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Initialize libavformat and register all formats and codecs
</span></span><span class="line"><span class="cl">    av_register_all();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Initialize output format context
</span></span><span class="line"><span class="cl">    avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, output_filename);
</span></span><span class="line"><span class="cl">    if (!ofmt_ctx) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not create output context\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Find H.264 encoder for output video stream
</span></span><span class="line"><span class="cl">    encoder = avcodec_find_encoder(AV_CODEC_ID_H264);
</span></span><span class="line"><span class="cl">    if (!encoder) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;H.264 encoder not found\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Create new video stream for output
</span></span><span class="line"><span class="cl">    out_stream = avformat_new_stream(ofmt_ctx, NULL);
</span></span><span class="line"><span class="cl">    if (!out_stream) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed allocating output stream\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Initialize codec context for the encoder
</span></span><span class="line"><span class="cl">    enc_ctx = avcodec_alloc_context3(encoder);
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;bit_rate = 400000;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;width = 1280;  // Frame width
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;height = 720;  // Frame height
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;time_base = (AVRational){1, 25};  // Framerate: 25 fps
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;framerate = (AVRational){25, 1};
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;gop_size = 10;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;max_b_frames = 1;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Open encoder
</span></span><span class="line"><span class="cl">    if (avcodec_open2(enc_ctx, encoder, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not open encoder\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Copy the codec parameters from the encoder context to the output stream
</span></span><span class="line"><span class="cl">    ret = avcodec_parameters_from_context(out_stream-&gt;codecpar, enc_ctx);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed to copy encoder parameters to output stream\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Open output file
</span></span><span class="line"><span class="cl">    if (!(ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) {
</span></span><span class="line"><span class="cl">        if (avio_open(&amp;ofmt_ctx-&gt;pb, output_filename, AVIO_FLAG_WRITE) &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Could not open output file %s\n&#34;, output_filename);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Write output file header
</span></span><span class="line"><span class="cl">    if (avformat_write_header(ofmt_ctx, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Error occurred when writing header to output file\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Allocate frame
</span></span><span class="line"><span class="cl">    frame = av_frame_alloc();
</span></span><span class="line"><span class="cl">    if (!frame) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not allocate video frame\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    frame-&gt;format = enc_ctx-&gt;pix_fmt;
</span></span><span class="line"><span class="cl">    frame-&gt;width  = enc_ctx-&gt;width;
</span></span><span class="line"><span class="cl">    frame-&gt;height = enc_ctx-&gt;height;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Allocate buffer for frame
</span></span><span class="line"><span class="cl">    ret = av_frame_get_buffer(frame, 32);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not allocate the frame data\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Generate frames (this part is where you can insert your own frames)
</span></span><span class="line"><span class="cl">    frame_count = 100;  // Example: encoding 100 frames
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; frame_count; i++) {
</span></span><span class="line"><span class="cl">        // Make sure the frame is writable
</span></span><span class="line"><span class="cl">        ret = av_frame_make_writable(frame);
</span></span><span class="line"><span class="cl">        if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // Fill the frame with your data (for demonstration purposes, here we&#39;re setting all YUV planes to constant values)
</span></span><span class="line"><span class="cl">        for (int y = 0; y &lt; enc_ctx-&gt;height; y++) {
</span></span><span class="line"><span class="cl">            for (int x = 0; x &lt; enc_ctx-&gt;width; x++) {
</span></span><span class="line"><span class="cl">                frame-&gt;data[0][y * frame-&gt;linesize[0] + x] = i + y + x;  // Y plane
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        for (int y = 0; y &lt; enc_ctx-&gt;height / 2; y++) {
</span></span><span class="line"><span class="cl">            for (int x = 0; x &lt; enc_ctx-&gt;width / 2; x++) {
</span></span><span class="line"><span class="cl">                frame-&gt;data[1][y * frame-&gt;linesize[1] + x] = 128;  // U plane
</span></span><span class="line"><span class="cl">                frame-&gt;data[2][y * frame-&gt;linesize[2] + x] = 128;  // V plane
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        frame-&gt;pts = i;  // Set the frame presentation timestamp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // Encode the frame
</span></span><span class="line"><span class="cl">        encode(enc_ctx, frame, ofmt_ctx, out_stream);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Flush the encoder
</span></span><span class="line"><span class="cl">    encode(enc_ctx, NULL, ofmt_ctx, out_stream);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Write trailer and clean up
</span></span><span class="line"><span class="cl">    av_write_trailer(ofmt_ctx);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    av_frame_free(&amp;frame);
</span></span><span class="line"><span class="cl">    avcodec_free_context(&amp;enc_ctx);
</span></span><span class="line"><span class="cl">    if (!(ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) {
</span></span><span class="line"><span class="cl">        avio_closep(&amp;ofmt_ctx-&gt;pb);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    avformat_free_context(ofmt_ctx);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-35" class="outline-3">
<h3 id="headline-35">
Linux下基于FFmpeg，通过C语言调用API函数解码mp4视频后再合并成一个新的视频，要求分辨率、颜色跟解码之前一样 - ChatGPT
</h3>
<div id="outline-text-headline-35" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &#34;libavformat/avformat.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVFormatContext *ofmt_ctx, AVStream *out_stream) {
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">    AVPacket *pkt = av_packet_alloc();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = avcodec_send_frame(enc_ctx, frame);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Error sending frame to encoder\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (ret &gt;= 0) {
</span></span><span class="line"><span class="cl">        ret = avcodec_receive_packet(enc_ctx, pkt);
</span></span><span class="line"><span class="cl">        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        else if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Error during encoding\n&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        av_packet_rescale_ts(pkt, enc_ctx-&gt;time_base, out_stream-&gt;time_base);
</span></span><span class="line"><span class="cl">        pkt-&gt;stream_index = out_stream-&gt;index;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ret = av_interleaved_write_frame(ofmt_ctx, pkt);
</span></span><span class="line"><span class="cl">        if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Error writing frame\n&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        av_packet_unref(pkt);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    av_packet_free(&amp;pkt);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char **argv) {
</span></span><span class="line"><span class="cl">    const char *input_filename, *output_filename = NULL;
</span></span><span class="line"><span class="cl">    AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL;
</span></span><span class="line"><span class="cl">    AVCodecContext *dec_ctx = NULL, *enc_ctx = NULL;
</span></span><span class="line"><span class="cl">    AVStream *in_stream = NULL, *out_stream = NULL;
</span></span><span class="line"><span class="cl">    const AVCodec *decoder, *encoder;
</span></span><span class="line"><span class="cl">    AVFrame *frame = NULL;
</span></span><span class="line"><span class="cl">    AVPacket pkt;
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (argc &lt; 3) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Usage: %s &lt;input.mp4&gt; &lt;output.mp4&gt;\n&#34;, argv[0]);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    input_filename = argv[1];
</span></span><span class="line"><span class="cl">    output_filename = argv[2];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    av_register_all();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 打开输入文件并获取格式上下文
</span></span><span class="line"><span class="cl">    if ((ret = avformat_open_input(&amp;ifmt_ctx, input_filename, NULL, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not open input file &#39;%s&#39;\n&#34;, input_filename);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 查找流信息
</span></span><span class="line"><span class="cl">    if ((ret = avformat_find_stream_info(ifmt_ctx, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed to retrieve input stream information\n&#34;);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 打开输出文件格式上下文
</span></span><span class="line"><span class="cl">    avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, output_filename);
</span></span><span class="line"><span class="cl">    if (!ofmt_ctx) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not create output context\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR_UNKNOWN;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 查找视频流
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) {
</span></span><span class="line"><span class="cl">        AVStream *stream = ifmt_ctx-&gt;streams[i];
</span></span><span class="line"><span class="cl">        if (stream-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
</span></span><span class="line"><span class="cl">            in_stream = stream;
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (!in_stream) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not find video stream in input file\n&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 查找解码器
</span></span><span class="line"><span class="cl">    decoder = avcodec_find_decoder(in_stream-&gt;codecpar-&gt;codec_id);
</span></span><span class="line"><span class="cl">    if (!decoder) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Decoder not found\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR_DECODER_NOT_FOUND;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 分配解码器上下文
</span></span><span class="line"><span class="cl">    dec_ctx = avcodec_alloc_context3(decoder);
</span></span><span class="line"><span class="cl">    if (!dec_ctx) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not allocate decoder context\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR(ENOMEM);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化解码器上下文
</span></span><span class="line"><span class="cl">    if ((ret = avcodec_parameters_to_context(dec_ctx, in_stream-&gt;codecpar)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed to copy decoder parameters to input context\n&#34;);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 打开解码器
</span></span><span class="line"><span class="cl">    if ((ret = avcodec_open2(dec_ctx, decoder, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed to open decoder\n&#34;);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 为输出流添加一个视频流
</span></span><span class="line"><span class="cl">    out_stream = avformat_new_stream(ofmt_ctx, NULL);
</span></span><span class="line"><span class="cl">    if (!out_stream) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed allocating output stream\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR_UNKNOWN;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 查找编码器（使用与解码器相同的格式）
</span></span><span class="line"><span class="cl">    encoder = avcodec_find_encoder(dec_ctx-&gt;codec_id);
</span></span><span class="line"><span class="cl">    if (!encoder) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Encoder not found\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR_ENCODER_NOT_FOUND;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 分配编码器上下文
</span></span><span class="line"><span class="cl">    enc_ctx = avcodec_alloc_context3(encoder);
</span></span><span class="line"><span class="cl">    if (!enc_ctx) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not allocate encoder context\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR(ENOMEM);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 设置编码器上下文的属性
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;height = dec_ctx-&gt;height;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;width = dec_ctx-&gt;width;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;pix_fmt = dec_ctx-&gt;pix_fmt;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;time_base = in_stream-&gt;time_base;
</span></span><span class="line"><span class="cl">    enc_ctx-&gt;framerate = av_guess_frame_rate(ifmt_ctx, in_stream, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 打开编码器
</span></span><span class="line"><span class="cl">    if ((ret = avcodec_open2(enc_ctx, encoder, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not open encoder\n&#34;);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 复制编码器参数到输出流
</span></span><span class="line"><span class="cl">    if ((ret = avcodec_parameters_from_context(out_stream-&gt;codecpar, enc_ctx)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Failed to copy encoder parameters to output stream\n&#34;);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    out_stream-&gt;time_base = enc_ctx-&gt;time_base;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 打开输出文件
</span></span><span class="line"><span class="cl">    if (!(ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) {
</span></span><span class="line"><span class="cl">        if ((ret = avio_open(&amp;ofmt_ctx-&gt;pb, output_filename, AVIO_FLAG_WRITE)) &lt; 0) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Could not open output file &#39;%s&#39;\n&#34;, output_filename);
</span></span><span class="line"><span class="cl">            return ret;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 写文件头
</span></span><span class="line"><span class="cl">    if ((ret = avformat_write_header(ofmt_ctx, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Error occurred when opening output file\n&#34;);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 解码并重新编码视频帧
</span></span><span class="line"><span class="cl">    frame = av_frame_alloc();
</span></span><span class="line"><span class="cl">    if (!frame) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Could not allocate video frame\n&#34;);
</span></span><span class="line"><span class="cl">        return AVERROR(ENOMEM);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (av_read_frame(ifmt_ctx, &amp;pkt) &gt;= 0) {
</span></span><span class="line"><span class="cl">        if (pkt.stream_index == in_stream-&gt;index) {
</span></span><span class="line"><span class="cl">            ret = avcodec_send_packet(dec_ctx, &amp;pkt);
</span></span><span class="line"><span class="cl">            if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">                fprintf(stderr, &#34;Error sending packet to decoder\n&#34;);
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            while (ret &gt;= 0) {
</span></span><span class="line"><span class="cl">                ret = avcodec_receive_frame(dec_ctx, frame);
</span></span><span class="line"><span class="cl">                if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                else if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">                    fprintf(stderr, &#34;Error during decoding\n&#34;);
</span></span><span class="line"><span class="cl">                    return ret;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                frame-&gt;pts = frame-&gt;best_effort_timestamp;
</span></span><span class="line"><span class="cl">                encode(enc_ctx, frame, ofmt_ctx, out_stream);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        av_packet_unref(&amp;pkt);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Flush encoder
</span></span><span class="line"><span class="cl">    encode(enc_ctx, NULL, ofmt_ctx, out_stream);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 写文件尾部
</span></span><span class="line"><span class="cl">    av_write_trailer(ofmt_ctx);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 释放资源
</span></span><span class="line"><span class="cl">    av_frame_free(&amp;frame);
</span></span><span class="line"><span class="cl">    avcodec_free_context(&amp;dec_ctx);
</span></span><span class="line"><span class="cl">    avcodec_free_context(&amp;enc_ctx);
</span></span><span class="line"><span class="cl">    avformat_close_input(&amp;ifmt_ctx);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (!(ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE))
</span></span><span class="line"><span class="cl">        avio_closep(&amp;ofmt_ctx-&gt;pb);
</span></span><span class="line"><span class="cl">    avformat_free_context(ofmt_ctx);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-36" class="outline-4">
<h4 id="headline-36">
编码函数定义
</h4>
<div id="outline-text-headline-36" class="outline-text-4">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">encode</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">ofmt_ctx</span><span class="p">,</span> <span class="n">AVStream</span> <span class="o">*</span><span class="n">out_stream</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>enc_ctx: 编码上下文，包含编码器的相关设置。</li>
<li>frame: 需要编码的输入帧。</li>
<li>ofmt_ctx: 输出格式上下文，表示输出文件的格式。</li>
<li>out_stream: 输出流，表示在输出文件中要写入的流。</li>
</ul>
<div id="outline-container-headline-37" class="outline-5">
<h5 id="headline-37">
内部变量
</h5>
<div id="outline-text-headline-37" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">AVPacket</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="nf">av_packet_alloc</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>ret: 用于存储函数调用的返回值。</li>
<li>pkt: 分配一个 AVPacket，用于存储编码后的数据。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-38" class="outline-5">
<h5 id="headline-38">
发送帧进行编码
</h5>
<div id="outline-text-headline-38" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_send_frame</span><span class="p">(</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error sending frame to encoder</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>调用 avcodec_send_frame 将帧发送到编码器。</li>
<li>如果返回值小于零，表示出错，打印错误信息并退出。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-39" class="outline-5">
<h5 id="headline-39">
接收编码后数据
</h5>
<div id="outline-text-headline-39" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_receive_packet</span><span class="p">(</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="nf">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR_EOF</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error during encoding</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		  <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>通过 avcodec_receive_packet 接收编码后的数据包。</li>
<li>如果返回 EAGAIN 或 EOF，说明没有更多的数据可接收，直接返回。</li>
<li>如果返回值小于零，表示出错，打印错误信息并退出。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-40" class="outline-5">
<h5 id="headline-40">
时间基准转换和写入帧
</h5>
<div id="outline-text-headline-40" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">av_packet_rescale_ts</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">enc_ctx</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">,</span> <span class="n">out_stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">=</span> <span class="n">out_stream</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ret</span> <span class="o">=</span> <span class="nf">av_interleaved_write_frame</span><span class="p">(</span><span class="n">ofmt_ctx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error writing frame</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>av_packet_rescale_ts: 将数据包的时间戳从编码上下文的时间基准转换为输出流的时间基准。</li>
<li>设置数据包的流索引。</li>
<li>使用 av_interleaved_write_frame 写入编码后的数据包到输出格式上下文中。</li>
<li>如果写入失败，打印错误信息并退出。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-41" class="outline-5">
<h5 id="headline-41">
释放数据包
</h5>
<div id="outline-text-headline-41" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>释放 pkt，以准备下一次使用。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-42" class="outline-5">
<h5 id="headline-42">
总结
</h5>
<div id="outline-text-headline-42" class="outline-text-5">
<p>整体上，这段代码实现了视频帧的编码并写入到文件的功能，通过调用 FFmpeg 提供的 API 处理编码和输出。每一步都包含错误检查，以确保程序在发生错误时能够及时反馈并退出。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-43" class="outline-4">
<h4 id="headline-43">
完整代码解析
</h4>
<div id="outline-text-headline-43" class="outline-text-4">
<p>
让我们分解并逐步解释代码的各个部分，包括其功能、参数以及工作机制。该代码的主要目的是在 Linux 下基于 FFmpeg，通过 C 语言解码一个 MP4 视频文件，然后将解码后的帧重新编码为另一个 MP4 文件。</p>
<div id="outline-container-headline-44" class="outline-5">
<h5 id="headline-44">
encode 函数
</h5>
<div id="outline-text-headline-44" class="outline-text-5">
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">encode</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">ofmt_ctx</span><span class="p">,</span> <span class="n">AVStream</span> <span class="o">*</span><span class="n">out_stream</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVPacket</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="nf">av_packet_alloc</span><span class="p">();</span> <span class="c1">// 分配一个新的 AVPacket
</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-45" class="outline-6">
<h6 id="headline-45">
功能
</h6>
<div id="outline-text-headline-45" class="outline-text-6">
<p>encode 函数的作用是将视频帧通过编码器进行编码，并将编码后的数据写入输出文件。</p>
</div>
</div>
<div id="outline-container-headline-46" class="outline-6">
<h6 id="headline-46">
参数解释
</h6>
<div id="outline-text-headline-46" class="outline-text-6">
<ul>
<li>AVCodecContext *enc_ctx: 编码器上下文，包含编码器的相关参数和状态。</li>
<li>AVFrame *frame: 待编码的帧。</li>
<li>AVFormatContext *ofmt_ctx: 输出格式上下文，管理输出文件的格式和流。</li>
<li>AVStream *out_stream: 输出流，代表输出文件中的单个流（视频流）。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-47" class="outline-6">
<h6 id="headline-47">
过程解释
</h6>
<div id="outline-text-headline-47" class="outline-text-6">
<ol>
<li>发送帧到编码器：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_send_frame</span><span class="p">(</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>将 frame 发送到编码器。如果 frame 为 NULL，则意味着需要刷新编码器，处理剩余未编码的帧。</p>
<ol>
<li>从编码器接收已编码的包：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_receive_packet</span><span class="p">(</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>通过 avcodec_receive_packet 获取编码后的数据包 pkt。返回 EAGAIN 表示编码器还在等待输入帧；返回 AVERROR_EOF 表示编码器已完成。</p>
<ol>
<li>写入文件：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">av_interleaved_write_frame</span><span class="p">(</span><span class="n">ofmt_ctx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>编码后的数据包 pkt 被写入输出文件。</p>
<ol>
<li>清理：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">av_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>使用 av_packet_unref 清理包内容并释放分配的 AVPacket。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-48" class="outline-5">
<h5 id="headline-48">
main 函数
</h5>
<div id="outline-text-headline-48" class="outline-text-5">
<p>
main 函数是程序的入口点，它负责打开输入文件、初始化解码器和编码器、逐帧解码并重新编码、最后将编码后的数据写入输出文件。</p>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input_filename</span><span class="p">,</span> <span class="o">*</span><span class="n">output_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">ifmt_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">ofmt_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">dec_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">enc_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVStream</span> <span class="o">*</span><span class="n">in_stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">out_stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">decoder</span><span class="p">,</span> <span class="o">*</span><span class="n">encoder</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVPacket</span> <span class="n">pkt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-49" class="outline-6">
<h6 id="headline-49">
参数解释
</h6>
<div id="outline-text-headline-49" class="outline-text-6">
<ul>
<li>argc: 命令行参数的数量。</li>
<li>argv: 命令行参数数组，argv[1] 为输入视频文件路径，argv[2] 为输出视频文件路径。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-50" class="outline-6">
<h6 id="headline-50">
核心步骤：
</h6>
<div id="outline-text-headline-50" class="outline-text-6">
<ol>
<li>输入参数验证：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Usage: %s &lt;input.mp4&gt; &lt;output.mp4&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">input_filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">output_filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>检查命令行参数是否足够，确保用户提供了输入和输出文件路径。</p>
<ol>
<li>注册所有编解码器：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">av_register_all</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>FFmpeg 初始化函数，注册所有支持的编解码器、文件格式等。</p>
<ol>
<li>打开输入文件并获取格式上下文：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifmt_ctx</span><span class="p">,</span> <span class="n">input_filename</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Could not open input file &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_filename</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>通过 avformat_open_input 打开输入文件，并填充 ifmt_ctx 结构体，其中包含输入文件的信息。</p>
<ol>
<li>查找输入文件流信息：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="nf">avformat_find_stream_info</span><span class="p">(</span><span class="n">ifmt_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to retrieve input stream information</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>使用 avformat_find_stream_info 获取输入文件的所有流信息（视频流、音频流等）。</p>
<ol>
<li>查找视频流：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ifmt_ctx</span><span class="o">-&gt;</span><span class="n">nb_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="n">AVStream</span> <span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">ifmt_ctx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_type</span> <span class="o">==</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		  <span class="n">in_stream</span> <span class="o">=</span> <span class="n">stream</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>遍历所有流，找到类型为视频的流并赋值给 in_stream。</p>
<ol>
<li>查找解码器并初始化解码器上下文：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="n">decoder</span> <span class="o">=</span> <span class="nf">avcodec_find_decoder</span><span class="p">(</span><span class="n">in_stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">dec_ctx</span> <span class="o">=</span> <span class="nf">avcodec_alloc_context3</span><span class="p">(</span><span class="n">decoder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avcodec_parameters_to_context</span><span class="p">(</span><span class="n">dec_ctx</span><span class="p">,</span> <span class="n">in_stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avcodec_open2</span><span class="p">(</span><span class="n">dec_ctx</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>根据输入视频的编码格式查找相应的解码器，并初始化解码器上下文 dec_ctx。然后，打开解码器以准备解码。</p>
<ol>
<li>创建输出文件并初始化输出流：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofmt_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">output_filename</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">out_stream</span> <span class="o">=</span> <span class="nf">avformat_new_stream</span><span class="p">(</span><span class="n">ofmt_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">encoder</span> <span class="o">=</span> <span class="nf">avcodec_find_encoder</span><span class="p">(</span><span class="n">dec_ctx</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">enc_ctx</span> <span class="o">=</span> <span class="nf">avcodec_alloc_context3</span><span class="p">(</span><span class="n">encoder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avcodec_open2</span><span class="p">(</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">encoder</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>为输出文件分配格式上下文，并创建一个新的视频流 out_stream。随后，查找对应的编码器并初始化编码器上下文 enc_ctx。</p>
<ol>
<li>逐帧解码和编码：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nf">av_read_frame</span><span class="p">(</span><span class="n">ifmt_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">in_stream</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		  <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_send_packet</span><span class="p">(</span><span class="n">dec_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		  <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			  <span class="n">ret</span> <span class="o">=</span> <span class="nf">avcodec_receive_frame</span><span class="p">(</span><span class="n">dec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			  <span class="nf">encode</span><span class="p">(</span><span class="n">enc_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">ofmt_ctx</span><span class="p">,</span> <span class="n">out_stream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		  <span class="p">}</span>
</span></span><span class="line"><span class="cl">	  <span class="p">}</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">av_packet_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>通过 av_read_frame 读取视频帧数据包 pkt。</li>
<li>使用 avcodec_send_packet 发送数据包到解码器。</li>
<li>从解码器获取解码后的 frame，然后通过 encode 函数将其编码并写入输出文件。</li>
</ul>
<ol>
<li>写入文件尾并释放资源：</li>
</ol>
<div class="src src-c">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="nf">av_write_trailer</span><span class="p">(</span><span class="n">ofmt_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avcodec_free_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dec_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avcodec_free_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enc_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avformat_close_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifmt_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avio_closep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofmt_ctx</span><span class="o">-&gt;</span><span class="n">pb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">avformat_free_context</span><span class="p">(</span><span class="n">ofmt_ctx</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-51" class="outline-6">
<h6 id="headline-51">
结论
</h6>
<div id="outline-text-headline-51" class="outline-text-6">
<p>该程序逐步完成视频的解码和编码，将输入 MP4 文件中的视频流解码为帧，然后将每一帧重新编码为新的 MP4 文件，确保解码后的视频重新编码为同样的格式。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-52" class="outline-3">
<h3 id="headline-52">
参考链接
</h3>
<div id="outline-text-headline-52" class="outline-text-3">
<p>
<a href="https://blog.csdn.net/weixin_44453694/article/details/127098011">Linux下基于ffmpeg音视频解码</a></p>
<p>
<a href="https://blog.csdn.net/weixin_42877471/article/details/139929421">【FFmpeg】avformat_open_input函数</a></p>
<p>
<a href="https://blog.csdn.net/qq_51282224/article/details/130993130">ffmpeg之avformat_find_stream_info函数详细解释</a></p>
<p>
<a href="https://blog.csdn.net/leixiaohua1020/article/details/41181155">FFmpeg源代码简单分析：常见结构体的初始化和销毁（AVFormatContext，AVFrame等）</a></p>
<p>
<a href="https://segmentfault.com/a/1190000017980746">一步步进行ffmpeg的C语言音视频编程</a></p>
</div>
</div>
</div>
</div>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/ffmpeg/">Ffmpeg</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Sep 09, 2024 17:14 &#43;0800
        </span>
    </section></footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
