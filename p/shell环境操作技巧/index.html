<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" 在shell环境提取书签文件中某一链接的技巧 1 cat bookmarks_2023_7_12.html | grep &#34;emacs&#34; | grep &#34;https&#34; | awk &#39;{print $2}&#39; | tr &#39;&#34;&#39; &#39; &#39; | awk &#39;{print $2}&#39; 使某命令在后台运行的方法，但是我没有感受到效果 1 2 3 4 if [[ &#34;$@&#34; == *&#34;syncthing&#34;* ]]; then nohup &#34;$@&#34; &amp; fi 查找某项目所有文件包含的头文件并排序去重 1 2 grep --color=auto -rain &#34;#include&#34; ./ | tr &#39;:&#39; &#39; &#39; | awk &#39;{print $4}&#39; | sort | uniq ;; 如果要查看有多少个结果，可以在上面命令的最后以管道的形式加上 wc -l linux如何只复制目录结构而不复制数据 1 find ./ -type d | xargs tar -cvf anna.tar --no-recursion 将目录结构压缩到指定目录，然后手动解压即可得到目录结构\n&#34;–no-recursion&#34;表示不递归\nfind + grep 查找关键词 这个命令是在当前目录及其子目录中查找所有扩展名为 .h 或 .cpp 的文件，并在找到的文件中搜索包含 &#34;sigToTh&#34; 的内容\n1 find ./ -name &#34;*.cpp&#34; -o -name &#34;*.h&#34; | xargs grep --color=auto -rwin &#34;keyword&#34; 查看Zynq各工程版本的命令 1 find ./ -maxdepth 2 -name &#34;*.xpr&#34; | xargs head -5 linux命令将&#34;./&#34;替换为空格 1 find ./ -maxdepth 1 -type f | sed -e &#39;s/\\.\\//\\ /g&#39; linux命令将&#34;./&#34;删除 在sed命令中，替换操作的分隔符可以使用除了反斜杠 (\\)、换行符以及所选字符之一以外的任何字符。在上面的命令中，我们使用了竖线 (|) 作为分隔符，因为这个字符不太可能出现在文件路径中，以避免干扰正则表达式的匹配。\n">
<title>shell环境操作技巧</title>

<link rel='canonical' href='https://ynhugo.github.io/p/shell%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/'>

<link rel="stylesheet" href="/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="shell环境操作技巧">
<meta property='og:description' content=" 在shell环境提取书签文件中某一链接的技巧 1 cat bookmarks_2023_7_12.html | grep &#34;emacs&#34; | grep &#34;https&#34; | awk &#39;{print $2}&#39; | tr &#39;&#34;&#39; &#39; &#39; | awk &#39;{print $2}&#39; 使某命令在后台运行的方法，但是我没有感受到效果 1 2 3 4 if [[ &#34;$@&#34; == *&#34;syncthing&#34;* ]]; then nohup &#34;$@&#34; &amp; fi 查找某项目所有文件包含的头文件并排序去重 1 2 grep --color=auto -rain &#34;#include&#34; ./ | tr &#39;:&#39; &#39; &#39; | awk &#39;{print $4}&#39; | sort | uniq ;; 如果要查看有多少个结果，可以在上面命令的最后以管道的形式加上 wc -l linux如何只复制目录结构而不复制数据 1 find ./ -type d | xargs tar -cvf anna.tar --no-recursion 将目录结构压缩到指定目录，然后手动解压即可得到目录结构\n&#34;–no-recursion&#34;表示不递归\nfind + grep 查找关键词 这个命令是在当前目录及其子目录中查找所有扩展名为 .h 或 .cpp 的文件，并在找到的文件中搜索包含 &#34;sigToTh&#34; 的内容\n1 find ./ -name &#34;*.cpp&#34; -o -name &#34;*.h&#34; | xargs grep --color=auto -rwin &#34;keyword&#34; 查看Zynq各工程版本的命令 1 find ./ -maxdepth 2 -name &#34;*.xpr&#34; | xargs head -5 linux命令将&#34;./&#34;替换为空格 1 find ./ -maxdepth 1 -type f | sed -e &#39;s/\\.\\//\\ /g&#39; linux命令将&#34;./&#34;删除 在sed命令中，替换操作的分隔符可以使用除了反斜杠 (\\)、换行符以及所选字符之一以外的任何字符。在上面的命令中，我们使用了竖线 (|) 作为分隔符，因为这个字符不太可能出现在文件路径中，以避免干扰正则表达式的匹配。\n">
<meta property='og:url' content='https://ynhugo.github.io/p/shell%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/'>
<meta property='og:site_name' content='ynhugo'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='shell' /><meta property='article:published_time' content='2025-06-15T12:28:46&#43;08:00'/><meta property='article:modified_time' content='2025-06-15T12:28:46&#43;08:00'/>
<meta name="twitter:title" content="shell环境操作技巧">
<meta name="twitter:description" content=" 在shell环境提取书签文件中某一链接的技巧 1 cat bookmarks_2023_7_12.html | grep &#34;emacs&#34; | grep &#34;https&#34; | awk &#39;{print $2}&#39; | tr &#39;&#34;&#39; &#39; &#39; | awk &#39;{print $2}&#39; 使某命令在后台运行的方法，但是我没有感受到效果 1 2 3 4 if [[ &#34;$@&#34; == *&#34;syncthing&#34;* ]]; then nohup &#34;$@&#34; &amp; fi 查找某项目所有文件包含的头文件并排序去重 1 2 grep --color=auto -rain &#34;#include&#34; ./ | tr &#39;:&#39; &#39; &#39; | awk &#39;{print $4}&#39; | sort | uniq ;; 如果要查看有多少个结果，可以在上面命令的最后以管道的形式加上 wc -l linux如何只复制目录结构而不复制数据 1 find ./ -type d | xargs tar -cvf anna.tar --no-recursion 将目录结构压缩到指定目录，然后手动解压即可得到目录结构\n&#34;–no-recursion&#34;表示不递归\nfind + grep 查找关键词 这个命令是在当前目录及其子目录中查找所有扩展名为 .h 或 .cpp 的文件，并在找到的文件中搜索包含 &#34;sigToTh&#34; 的内容\n1 find ./ -name &#34;*.cpp&#34; -o -name &#34;*.h&#34; | xargs grep --color=auto -rwin &#34;keyword&#34; 查看Zynq各工程版本的命令 1 find ./ -maxdepth 2 -name &#34;*.xpr&#34; | xargs head -5 linux命令将&#34;./&#34;替换为空格 1 find ./ -maxdepth 1 -type f | sed -e &#39;s/\\.\\//\\ /g&#39; linux命令将&#34;./&#34;删除 在sed命令中，替换操作的分隔符可以使用除了反斜杠 (\\)、换行符以及所选字符之一以外的任何字符。在上面的命令中，我们使用了竖线 (|) 作为分隔符，因为这个字符不太可能出现在文件路径中，以避免干扰正则表达式的匹配。\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_f509edb42ecc0ebd.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">ynhugo</a></h1>
            <h2 class="site-description">ynhugo.github.io</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://x.com'
                        target="_blank"
                        title="x"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/book/' >
                
                
                
                    <svg fill="#000000" height="24" width="24" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
    <path d="m443.6,11h-321c-35.4,0-64.6,26.1-64.6,59.4v371.1c0,33.4 26.1,59.4 59.4,59.4h326.2c6.3,0 10.4-4.2 10.4-11.5v-468c0-6.2-4.2-10.4-10.4-10.4zm-321,20.9h310.5v350.3h-315.7c-14.9,0-28.3,5.2-38.6,13.9v-325.7c-1.42109e-14-21.9 19.8-38.5 43.8-38.5zm310.6,449.3h-315.8c-21.9,0-38.6-16.7-38.6-38.6 0-21.9 17.7-38.6 38.6-38.6l315.8,.1v77.1z"/>
</svg>
                
                <span>Book</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://ynhugo.github.io/en/" >English</option>
                                
                                    <option value="https://ynhugo.github.io/" selected>中文</option>
                                
                                    <option value="https://ynhugo.github.io/ar/" >عربي</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">在shell环境提取书签文件中某一链接的技巧</a>
</li>
<li><a href="#headline-2">使某命令在后台运行的方法，但是我没有感受到效果</a>
</li>
<li><a href="#headline-3">查找某项目所有文件包含的头文件并排序去重</a>
</li>
<li><a href="#headline-4">linux如何只复制目录结构而不复制数据</a>
</li>
<li><a href="#headline-5">find + grep 查找关键词</a>
</li>
<li><a href="#headline-6">查看Zynq各工程版本的命令</a>
</li>
<li><a href="#headline-7">linux命令将&#34;./&#34;替换为空格</a>
</li>
<li><a href="#headline-8">linux命令将&#34;./&#34;删除</a>
</li>
<li><a href="#headline-9">查找文件并高亮显示</a>
</li>
<li><a href="#headline-10">linux查看cpu核数</a>
</li>
<li><a href="#headline-11">通过find查找文件和通过grep查找关键词并排除进制文件</a>
</li>
<li><a href="#headline-12">通过find查找最近一天的文件，通过grep命令匹配当天的文件</a>
</li>
<li><a href="#headline-13">在Shell脚本中，单个等号 `=` 和双等号 `==` 在条件判断时有一些区别</a>
</li>
<li><a href="#headline-14">处理 URL 中获取的变量的乱码 </a>
</li>
<li><a href="#headline-15">shell位运算，左移，右移，与运算，进制转换</a>
<ul>
<li><a href="#headline-16">进行移位运算</a>
</li>
<li><a href="#headline-17">进行与运算</a>
</li>
<li><a href="#headline-18">进行或运算</a>
</li>
<li><a href="#headline-19">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-20">如何用shell脚本实现回车继续</a>
</li>
<li><a href="#headline-21">shell 如何只刷新当前行</a>
<ul>
<li><a href="#headline-22">shell 通过只刷新当前行显示时间</a>
</li>
</ul>
</li>
<li><a href="#headline-23">显示 grep 匹配关键词之前或之后指定行数</a>
<ul>
<li><a href="#headline-24">显示 grep 匹配关键词之前指定行数</a>
</li>
<li><a href="#headline-25">显示 grep 匹配关键词之后指定行数</a>
</li>
</ul>
</li>
<li><a href="#headline-26">Ubuntu 匹配 IP 地址</a>
</li>
<li><a href="#headline-27">shell脚本如何创建数组或列表</a>
<ul>
<li><a href="#headline-28">如何自动获取数组个数</a>
</li>
</ul>
</li>
<li><a href="#headline-29">如何找到文件安装位置</a>
</li>
<li><a href="#headline-30">如何将多行数据存储到数组中</a>
<ul>
<li><a href="#headline-31">在终端执行示例-1</a>
</li>
<li><a href="#headline-32">在终端执行示例-2</a>
</li>
</ul>
</li>
<li><a href="#headline-33">查看文件创建时间，并把创建时间组成使用hugo命令创建博客时生成的时间戳：</a>
</li>
<li><a href="#headline-34">在 awk 中，可以使用字符串连接符来连接多个关键词或字段</a>
</li>
<li><a href="#headline-35">要使用 AWK 输出指定行</a>
</li>
<li><a href="#headline-36">hugo 批量插入文件的 Linux 脚本参考</a>
</li>
<li><a href="#headline-37">批量创建文件并添加指定内容到文件中</a>
</li>
<li><a href="#headline-38">如果您想要使用 grep 命令从文件中的指定范围检索内容，可以结合使用 head 和 tail 命令来实现。下面是一个示例：</a>
</li>
<li><a href="#headline-39">想办法将文件存入数组</a>
</li>
<li><a href="#headline-40">sftp 批量执行命令教程</a>
<ul>
<li><a href="#headline-41">sftp 批量执行命令教程-示例</a>
</li>
<li><a href="#headline-42">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-43">expect</a>
<ul>
<li><a href="#headline-44">1.用expect实现与shell交互，用ssh连接termxu实例：</a>
</li>
<li><a href="#headline-45">2.用 expect 登录 termux 并执行脚本实例：</a>
</li>
<li><a href="#headline-46">3. expect eof 与 interact 的区别：</a>
</li>
<li><a href="#headline-47">4.注意事项：</a>
</li>
</ul>
</li>
<li><a href="#headline-48">如何使用wget下载整个网站</a>
<ul>
<li><a href="#headline-49">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-50">cat命令</a>
</li>
<li><a href="#headline-51">在SSH命令中，使用-D参数来创建动态端口转发时</a>
</li>
<li><a href="#headline-52">find命令查找并复制文件到指定路径</a>
</li>
<li><a href="#headline-53">ffmpeg-ffplay自动播放视频列表</a>
</li>
<li><a href="#headline-54">查找文件并进行排序</a>
</li>
<li><a href="#headline-55">shopt 使用技巧</a>
<ul>
<li><a href="#headline-56">Linux 环境启用 extglob 扩展 </a>
</li>
<li><a href="#headline-57">shopt -s extglob 与 shopt -u extglob 有区别吗</a>
</li>
<li><a href="#headline-58">Linux 下切换目录省略 cd 命令</a>
</li>
</ul>
</li>
<li><a href="#headline-59">shell脚本如何获取参数数量</a>
<ul>
<li><a href="#headline-60">如何获取最后一个参数</a>
</li>
<li><a href="#headline-61">如何获取多个参数的内容</a>
</li>
</ul>
</li>
<li><a href="#headline-62">Linux命令中短横线的作用</a>
</li>
<li><a href="#headline-63">Linux下如何查看当前用的是zsh还是bash</a>
</li>
<li><a href="#headline-64">通过lshw命令确定系统是否支持 ECC 内存</a>
</li>
<li><a href="#headline-65">linux如何查看内存大小</a>
<ul>
<li><a href="#headline-66">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-67">使用 dd 命令来测试硬盘的写入速度，并且采用一些优化参数来减少系统缓存的影响</a>
<ul>
<li><a href="#headline-68">示例</a>
</li>
</ul>
</li>
<li><a href="#headline-69">xxd使用技巧</a>
<ul>
<li><a href="#headline-70">将文本转换为ASCII对应的16进制输出</a>
<ul>
<li><a href="#headline-71">操作命令</a>
</li>
<li><a href="#headline-72">使用实例</a>
</li>
</ul>
</li>
<li><a href="#headline-73">将ASCII对应的16进制转换为ASCII输出</a>
<ul>
<li><a href="#headline-74">操作命令</a>
</li>
<li><a href="#headline-75">使用实例</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-76">linux环境如何合并两个文件夹，两个目录名相同，文件有相同的也有不相同的，遇到同名文件跳过</a>
</li>
<li><a href="#headline-77">Linux history 命令详解：如何查看、显示时间、清空、重复和控制历史记录</a>
</li>
<li><a href="#headline-78">Linux终端打印如何删除指定列或多列</a>
</li>
<li><a href="#headline-79">shell排序，强大的sort</a>
</li>
<li><a href="#headline-80">当前目录下多文件根据排序顺序一对一对的依次进行比较</a>
</li>
<li><a href="#headline-81">从当前目前进入到一个子目录过滤文件字符串并返回到当前目录</a>
<ul>
<li><a href="#headline-82">单次手动操作</a>
</li>
<li><a href="#headline-83">多次自动操作</a>
</li>
</ul>
</li>
<li><a href="#headline-84">Linux下gh批量下载github某仓库中Release所有版本文件</a>
<ul>
<li><a href="#headline-85">工具官网</a>
</li>
<li><a href="#headline-86">查看指定仓库中的所有版本</a>
</li>
<li><a href="#headline-87">下载所有版本的Release</a>
</li>
<li><a href="#headline-88">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-89">从文件列表中查找指定关键词脚本</a>
</li>
<li><a href="#headline-90">Linux 下计算圆周率</a>
</li>
<li><a href="#headline-91">查找文件关键词并替换</a>
</li>
<li><a href="#headline-92">输出累加数+时间戳，按回车继续</a>
</li>
<li><a href="#headline-93">要仅查找 driver 目录下的 Pciedma_DLL.h 文件，可以使用以下 find 命令：</a>
</li>
<li><a href="#headline-94">Linux tar命令解压时提示时间戳异常的处理办法</a>
<ul>
<li><a href="#headline-95">方法一</a>
</li>
<li><a href="#headline-96">方法二</a>
</li>
<li><a href="#headline-97">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-98">Linux终端批量造数</a>
<ul>
<li><a href="#headline-99">Linux终端批量造十进制数</a>
</li>
<li><a href="#headline-100">Linux终端批量造十六进制数</a>
<ul>
<li><a href="#headline-101">Linux终端批量造十六进制数-16位</a>
</li>
<li><a href="#headline-102">Linux终端批量造十六进制数-32位</a>
</li>
<li><a href="#headline-103">Linux终端批量造十六进制数-64位</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-104">在Windows的文件资源管理器的地址栏使用mintty命令或者当前文件夹路径</a>
</li>
<li><a href="#headline-105">查找文件并依次进行比较</a>
</li>
<li><a href="#headline-106">将连续的两个字节以一个字节单位倒序处理，并计算对应的10进制结果</a>
<ul>
<li><a href="#headline-107">命令拆解</a>
</li>
<li><a href="#headline-108">参考链接</a>
</li>
</ul>
</li>
<li><a href="#headline-109">删除文件指定字节二进制数据</a>
</li>
<li><a href="#headline-110">将二进制文件16进制输出的情况下每两个字符后添加一个0并输出到另一个文件</a>
</li>
<li><a href="#headline-111">查找指定类型文件中的内容返回结果，并且会自动去除第一列的空格</a>
</li>
<li><a href="#headline-112">显示文件最后修改时间</a>
<ul>
<li><a href="#headline-113">方式一</a>
</li>
<li><a href="#headline-114">方式二</a>
</li>
</ul>
</li>
<li><a href="#headline-115">visual studio的dll相关文件拷贝到Qt工程的driver目录技巧</a>
</li>
<li><a href="#headline-116">命令行的shell脚本练习：read与case组合</a>
</li>
<li><a href="#headline-117">shell脚本将case语句放在for循环中 - ChatGPT</a>
<ul>
<li><a href="#headline-118">示例：使用 case 语句和 for 循环</a>
</li>
<li><a href="#headline-119">说明：</a>
</li>
<li><a href="#headline-120">运行结果：</a>
</li>
<li><a href="#headline-121">关键点：</a>
</li>
</ul>
</li>
<li><a href="#headline-122">case语句+shift偏移参数</a>
<ul>
<li><a href="#headline-123">脚本代码</a>
<ul>
<li><a href="#headline-124">运行示例</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#headline-125">sed命令在包含指定关键词的行首与包含指定关键词的下一行的行首添加&#39;//&#39;</a>
<ul>
<li><a href="#headline-126">示例命令</a>
</li>
<li><a href="#headline-127">解释：</a>
</li>
</ul>
</li>
<li><a href="#headline-128">解决使用脚本创建Makefile内容不对齐问题</a>
</li>
<li><a href="#headline-129">scp使用技巧</a>
</li>
<li><a href="#headline-130">sed使用技巧</a>
</li>
<li><a href="#headline-131">Bash 命令行选项解析</a>
<ul>
<li><a href="#headline-132">1. while getopts &#34;hv&#34; opt; do</a>
</li>
<li><a href="#headline-133">2. case &#34;$opt&#34; in</a>
</li>
<li><a href="#headline-134">3. h)</a>
</li>
<li><a href="#headline-135">4. v)</a>
</li>
<li><a href="#headline-136">5. esac 和 done</a>
</li>
<li><a href="#headline-137">6. shift &#34;$((OPTIND - 1))&#34;</a>
</li>
<li><a href="#headline-138">示例用法：</a>
</li>
<li><a href="#headline-139">总结：</a>
</li>
<li><a href="#headline-140">参考链接</a>
</li>
</ul>
</li>
</ul>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/shell%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/">shell环境操作技巧</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 15, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 19 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
在shell环境提取书签文件中某一链接的技巧
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<div class="src src-emacs-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl">  <span class="nv">cat</span> <span class="nv">bookmarks_2023_7_12.html</span> <span class="nv">|</span> <span class="nv">grep</span> <span class="s">&#34;emacs&#34;</span> <span class="nv">|</span> <span class="nv">grep</span> <span class="s">&#34;https&#34;</span> <span class="nv">|</span> <span class="nv">awk</span> <span class="ss">&#39;{print</span> <span class="nv">$2}</span><span class="o">&#39;</span> <span class="nv">|</span> <span class="nv">tr</span> <span class="o">&#39;</span><span class="s">&#34;&#39; &#39; &#39; | awk &#39;{print $2}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
使某命令在后台运行的方法，但是我没有感受到效果
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<div class="src src-emacs-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl">  <span class="nb">if</span> <span class="p">[[</span> <span class="s">&#34;$@&#34;</span> <span class="nv">==</span> <span class="nf">*</span><span class="s">&#34;syncthing&#34;</span><span class="nf">*</span> <span class="p">]]</span><span class="c1">;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">then</span>
</span></span><span class="line"><span class="cl">  <span class="nv">nohup</span> <span class="s">&#34;$@&#34;</span> <span class="nv">&amp;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">fi</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
查找某项目所有文件包含的头文件并排序去重
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<div class="src src-emacs-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl">  <span class="nv">grep</span> <span class="nv">--color=auto</span> <span class="nv">-rain</span> <span class="s">&#34;#include&#34;</span> <span class="o">.</span><span class="nf">/</span> <span class="nv">|</span> <span class="nv">tr</span> <span class="o">&#39;:&#39;</span> <span class="o">&#39;</span> <span class="o">&#39;</span> <span class="nv">|</span> <span class="nv">awk</span> <span class="ss">&#39;{print</span> <span class="nv">$4}</span><span class="o">&#39;</span> <span class="nv">|</span> <span class="nf">sort</span> <span class="nv">|</span> <span class="nv">uniq</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; 如果要查看有多少个结果，可以在上面命令的最后以管道的形式加上 wc -l</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
linux如何只复制目录结构而不复制数据
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -type d <span class="p">|</span> xargs tar -cvf anna.tar --no-recursion</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
将目录结构压缩到指定目录，然后手动解压即可得到目录结构</p>
<p>
&#34;–no-recursion&#34;表示不递归</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
find + grep 查找关键词
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>
这个命令是在当前目录及其子目录中查找所有扩展名为 .h 或 .cpp 的文件，并在找到的文件中搜索包含 &#34;sigToTh&#34; 的内容</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -name <span class="s2">&#34;*.cpp&#34;</span> -o -name <span class="s2">&#34;*.h&#34;</span> <span class="p">|</span> xargs grep --color<span class="o">=</span>auto -rwin <span class="s2">&#34;keyword&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
查看Zynq各工程版本的命令
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -maxdepth <span class="m">2</span> -name <span class="s2">&#34;*.xpr&#34;</span> <span class="p">|</span> xargs head -5</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
linux命令将&#34;./&#34;替换为空格
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -maxdepth <span class="m">1</span> -type f <span class="p">|</span> sed -e <span class="s1">&#39;s/\.\//\ /g&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
linux命令将&#34;./&#34;删除
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>
在sed命令中，替换操作的分隔符可以使用除了反斜杠 (\)、换行符以及所选字符之一以外的任何字符。在上面的命令中，我们使用了竖线 (|) 作为分隔符，因为这个字符不太可能出现在文件路径中，以避免干扰正则表达式的匹配。</p>
<p>
在sed命令中，也可以使用斜杠 (/) 作为分隔符。但是，在本例中，文件路径中包含斜杠字符，会引起匹配错误。因此，我们选择使用竖线作为分隔符。</p>
<p>
在sed命令中，正则表达式和替换字符串之间用分隔符分隔开来。因为我们使用的是竖线作为分隔符，所以需要在每个竖线字符前后都加上一个竖线字符，即 &#34;s|pattern|replacement|&#34;。</p>
<p>
最终，两个竖线字符 (||) 表示空字符串，用于替换字符串为空。在这个命令中，我们使用sed命令将文件路径中开头的 &#34;./&#34; 删除，如下所示：</p>
<p>
其中，&#34;^\\./&#34;表示以 &#34;./&#34; 开头的字符串，&#34;|&#34; 是分隔符，&#34;&#34; 表示替换为空字符串。</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -maxdepth <span class="m">1</span> -type f <span class="p">|</span> sed -e <span class="s1">&#39;s|^\./||&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
查找文件并高亮显示
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -name <span class="s2">&#34;stm32*&#34;</span> <span class="p">|</span> grep --color <span class="s2">&#34;.&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
linux查看cpu核数
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  cat /proc/cpuinfo <span class="p">|</span> grep -w <span class="s2">&#34;cpu cores&#34;</span> <span class="p">|</span> head -1 <span class="p">|</span> awk <span class="s1">&#39;{print $4}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
通过find查找文件和通过grep查找关键词并排除进制文件
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>
排除二进制文件：–binary-files=without-match</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -type f <span class="p">|</span> xargs grep --color --binary-files<span class="o">=</span>without-match -n <span class="s2">&#34;sit0&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
通过find查找最近一天的文件，通过grep命令匹配当天的文件
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">work_dir</span><span class="o">=</span><span class="si">${</span><span class="nv">USER</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">  <span class="nb">alias</span> <span class="nv">cr</span><span class="o">=</span><span class="s1">&#39;clear &amp;&amp; clear &amp;&amp; find ${HOME}/${work_dir}/reports/*.txt -mtime -1 | xargs cat | grep -A 100 &#34;$(date -I | sed -e &#39;</span>s/-//g<span class="s1">&#39;)&#34;&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
在Shell脚本中，单个等号 `=` 和双等号 `==` 在条件判断时有一些区别
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<ol>
<li>
<p>单个等号 =</p>
<ul>
<li>在条件判断中，单个等号用于判断字符串是否相等。</li>
<li>用法示例：[ &#34;$var&#34; = &#34;value&#34; ]，表示变量 $var 的值是否等于字符串 &#34;value&#34;。</li>
</ul>
</li>
<li>
<p>双等号 ==</p>
<ul>
<li>在条件判断中，双等号也用于判断字符串是否相等，但是推荐在 Bash 中使用双等号进行字符串比较。</li>
<li>用法示例：<a href=" &#34;$var&#34; == &#34;value&#34; "> &#34;$var&#34; == &#34;value&#34; </a>，表示变量 $var 的值是否等于字符串 &#34;value&#34;。</li>
</ul>
</li>
</ol>
<p>主要区别在于：</p>
<ul>
<li>单个等号 = 可以在绝大多数的Shell中使用，而双等号 == 是Bash特有的语法。</li>
<li>双等号 == 支持更多高级的模式匹配功能，例如正则表达式匹配。</li>
</ul>
<p>总的来说，在Bash脚本中推荐使用双等号 == 来进行字符串比较，更加灵活且符合习惯。如果你不确定当前环境是否支持双等号 ==，可以使用单个等号 = 来进行字符串比较。</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
处理 URL 中获取的变量的乱码 
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>
例如变量 cfv 打印到终端上的是&#34;v2.2.5&#34;，但是在用 wget 下载的时候，链接中 cfv 的值就变成了&#34;v2.2.5%0D&#34;这是为什么呢</p>
<p>
在这样的情况下，出现链接中包含了 %0D 的原因可能是因为在获取 cfv 变量的过程中，字符串结尾包含了回车符（Carriage Return）。</p>
<p>
回车符通常用 \r 表示，在 URL 中，\r 会被转义成 %0D。这可能是由于在从网页内容中提取 cfv 变量时，结尾包含了回车符导致的。在处理字符串时，特别是从网页内容中提取的字符串，需要格外注意是否包含了不可见的控制字符，如回车符或换行符。</p>
<p>
为了解决这个问题，可以在提取 cfv 变量后，对其进行处理以去除结尾的回车符或其他不可见字符。在 Bash 脚本中，可以使用 sed 命令来去除结尾的回车符，例如：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">cfv</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$cfv</span> <span class="p">|</span> sed <span class="s1">&#39;s/\r//g&#39;</span><span class="k">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这样处理后，cfv 变量中就不会包含回车符，从而避免在 URL 中出现 %0D 的情况。</p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
shell位运算，左移，右移，与运算，进制转换
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
进行移位运算
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p>
左移29位，以十六进制输出</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">a</span><span class="o">=</span><span class="k">$((</span><span class="m">0</span>x1&lt;&lt;<span class="m">29</span><span class="k">))</span><span class="p">;</span> <span class="nb">printf</span> <span class="s2">&#34;0x%04X&#34;</span> <span class="nv">$a</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
进行与运算
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">a</span><span class="o">=</span><span class="k">$((</span><span class="m">0</span>x03<span class="o">&amp;</span><span class="m">0</span>x07<span class="k">))</span><span class="p">;</span> <span class="nb">printf</span> <span class="s2">&#34;0x%X&#34;</span> <span class="nv">$a</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
进行或运算
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">a</span><span class="o">=</span><span class="k">$((</span><span class="m">0</span>x03<span class="o">|</span><span class="m">0</span>x07<span class="k">))</span><span class="p">;</span> <span class="nb">printf</span> <span class="s2">&#34;0x%X&#34;</span> <span class="nv">$a</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
参考链接
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p>
<a href="https://blog.csdn.net/qq_45503700/article/details/100678500">第八篇 shell位运算，左移，右移，与运算，进制转换</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-20" class="outline-2">
<h2 id="headline-20">
如何用shell脚本实现回车继续
</h2>
<div id="outline-text-headline-20" class="outline-text-2">
<p>
在 Bash 脚本中，你可以使用 read 命令来等待用户按下回车键继续执行脚本。下面是一个简单的示例：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 显示提示信息</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;按下回车键继续...&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 读取用户输入（等待用户按下回车键）</span>
</span></span><span class="line"><span class="cl">  <span class="nb">read</span> -p <span class="s2">&#34;（按下回车键继续）&#34;</span> <span class="k">continue</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
在这个示例中，read -p &#34;（按下回车键继续）&#34; continue 会等待用户按下回车键，并且在用户按下回车键之后继续执行脚本。</p>
<p>
当脚本执行到这一行时，它会暂停等待用户输入。用户按下回车键之后，脚本会继续执行后面的命令。</p>
<p>
你也可以根据自己的需求修改提示信息和变量名。这样的代码片段可以用于需要用户确认或者暂停执行的情况。</p>
</div>
</div>
<div id="outline-container-headline-21" class="outline-2">
<h2 id="headline-21">
shell 如何只刷新当前行
</h2>
<div id="outline-text-headline-21" class="outline-text-2">
<p>
在 shell 中，要实现只刷新当前行而不换行，可以使用 ANSI 控制码 \r。这个控制码会将光标移动到当前行的开头，然后你可以输出新的内容，从而实现只刷新当前行而不换行。示例代码如下：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/usr/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> -n <span class="s2">&#34;Loading: 10%&#34;</span>
</span></span><span class="line"><span class="cl">  sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> -en <span class="s2">&#34;\rLoading: 20%&#34;</span>
</span></span><span class="line"><span class="cl">  sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> -en <span class="s2">&#34;\rLoading: 30%&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 以此类推</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
在这个例子中，-n 参数用于禁止echo命令自动换行，而\r用于将光标移动到行首，然后输出新的内容，实现了只刷新当前行的效果。</p>
<p>
在 Bash 中，-e 选项用于启用反斜杠转义（enable escape characters），它允许 echo 命令解释特定的转义序列。</p>
<p>
具体来说，当你在 echo 命令中使用 -e 选项时，可以在输出中使用以下特殊的转义序列：</p>
<ul>
<li>\n：换行</li>
<li>\t：制表符</li>
<li>\r：回车</li>
<li>\\：反斜杠</li>
</ul>
<p>举个例子，如果你想在输出中包含一个换行符，你可以这样使用 -e 选项：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> -e <span class="s2">&#34;Hello\nWorld&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这将会输出以下内容：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  Hello
</span></span><span class="line"><span class="cl">  World</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如果不使用 -e 选项，\n 将会被当作普通字符输出，而不会被解释为换行符。</p>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
shell 通过只刷新当前行显示时间
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  $ <span class="k">while</span> true<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> -en <span class="s2">&#34;\r\e[34m</span><span class="k">$(</span>date<span class="k">)</span><span class="s2">\e[0m&#34;</span><span class="p">;</span> sleep 1<span class="p">;</span> <span class="k">done</span>
</span></span><span class="line"><span class="cl">  2024年03月18日 11:10:40</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-23" class="outline-2">
<h2 id="headline-23">
显示 grep 匹配关键词之前或之后指定行数
</h2>
<div id="outline-text-headline-23" class="outline-text-2">
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
显示 grep 匹配关键词之前指定行数
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  grep <span class="s2">&#34;MODULE_LICENSE&#34;</span> -B <span class="m">27</span> /usr/src/linux-headers-<span class="sb">`</span>uname -r<span class="sb">`</span>/include/linux/module.h</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-25" class="outline-3">
<h3 id="headline-25">
显示 grep 匹配关键词之后指定行数
</h3>
<div id="outline-text-headline-25" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  grep <span class="s2">&#34;MODULE_LICENSE&#34;</span> -A <span class="m">27</span> /usr/src/linux-headers-<span class="sb">`</span>uname -r<span class="sb">`</span>/include/linux/module.h</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-26" class="outline-2">
<h2 id="headline-26">
Ubuntu 匹配 IP 地址
</h2>
<div id="outline-text-headline-26" class="outline-text-2">
<p>
只打印匹配到的内容，不打印多余的内容</p>
<p>
如果您需要提取出 IP 地址，可以使用正则表达式来匹配并提取 IP 地址。以下是一个示例命令，可以从文本中提取出 IP 地址：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  ifconfig <span class="p">|</span> grep -w -A <span class="m">1</span> <span class="s2">&#34;br0&#34;</span> <span class="p">|</span> grep -v <span class="s2">&#34;br0&#34;</span> <span class="p">|</span> awk <span class="s1">&#39;$1==&#34;inet&#34; {print $2}&#39;</span> <span class="p">|</span> grep -oE <span class="s2">&#34;\b([0-9]{1,3}\.){3}[0-9]{1,3}\b&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
在这个命令中，我们使用了 grep -oE 结合正则表达式 \b([0-9]{1,3}\.){3}[0-9]{1,3}\b 来提取文本中的 IP 地址。这个正则表达式可以匹配标准的 IPv4 地址格式。</p>
<p>
当处理 IP 地址时，常见的 IPv4 地址由四个小节组成，每个小节是 0 到 255 之间的数字。在正则表达式中，可以使用以下模式来匹配一个标准的 IPv4 地址：</p>
<ul>
<li>\b：表示单词边界，用于确保匹配的是完整的 IP 地址而不是部分匹配。</li>
<li>([0-9]{1,3}\.){3}：匹配三个由数字组成的小节，每个小节包含 1 到 3 个数字（{1,3} 表示重复 1 到 3 次），并且每个小节之间用点号分隔。</li>
<li>[0-9]{1,3}：匹配最后一个小节，同样包含 1 到 3 个数字。</li>
<li>\b：再次使用单词边界，以确保 IP 地址的结尾是一个单词边界。</li>
</ul>
<p>因此，这个正则表达式 \b([0-9]{1,3}\.){3}[0-9]{1,3}\b 可以准确地匹配一个标准的 IPv4 地址格式。</p>
<p>
在命令中使用 grep -oE 来执行正则表达式匹配操作，-o 选项表示只输出匹配到的部分，-E 表示使用扩展的正则表达式语法。</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-2">
<h2 id="headline-27">
shell脚本如何创建数组或列表
</h2>
<div id="outline-text-headline-27" class="outline-text-2">
<p>
在 shell 脚本中，您可以使用类似以下的语法来创建数组：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1"># 创建一个包含多个元素的数组</span>
</span></span><span class="line"><span class="cl">  <span class="nv">my_array</span><span class="o">=(</span>element1 element2 element3<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 或者逐个添加元素到数组中</span>
</span></span><span class="line"><span class="cl">  my_array<span class="o">[</span>0<span class="o">]=</span>element1
</span></span><span class="line"><span class="cl">  my_array<span class="o">[</span>1<span class="o">]=</span>element2
</span></span><span class="line"><span class="cl">  my_array<span class="o">[</span>2<span class="o">]=</span>element3</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
另外，您也可以使用 declare 命令来声明一个数组：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">declare</span> -a my_array
</span></span><span class="line"><span class="cl">  <span class="nv">my_array</span><span class="o">=(</span>element1 element2 element3<span class="o">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
要访问数组中的元素，可以使用下标来引用：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="si">${</span><span class="nv">my_array</span><span class="p">[0]</span><span class="si">}</span>  <span class="c1"># 输出第一个元素</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="si">${</span><span class="nv">my_array</span><span class="p">[1]</span><span class="si">}</span>  <span class="c1"># 输出第二个元素</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="si">${</span><span class="nv">my_array</span><span class="p">[2]</span><span class="si">}</span>  <span class="c1"># 输出第三个元素</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 输出整个数组</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="si">${</span><span class="nv">my_array</span><span class="p">[@]</span><span class="si">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
除了数组，您也可以使用空格分隔的列表，如下所示：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">my_list</span><span class="o">=</span><span class="s2">&#34;item1 item2 item3&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
然后，您可以使用变量来引用整个列表或者单独的元素：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="nv">$my_list</span>   <span class="c1"># 输出整个列表</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="nv">$my_list</span>   <span class="c1"># 输出第一个元素</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这是在 shell 脚本中创建数组和列表的简单方法。根据您的需求选择合适的数据结构来存储元素。</p>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
如何自动获取数组个数
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>
在 shell 脚本中，您可以使用 ${#array[@]} 来获取数组中元素的个数。以下是一个示例：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1"># 创建一个包含多个元素的数组</span>
</span></span><span class="line"><span class="cl">  <span class="nv">my_array</span><span class="o">=(</span>element1 element2 element3<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 获取数组中元素的个数</span>
</span></span><span class="line"><span class="cl">  <span class="nv">array_length</span><span class="o">=</span><span class="si">${#</span><span class="nv">my_array</span><span class="p">[@]</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 输出数组中元素的个数</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;数组中元素的个数为: </span><span class="nv">$array_length</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
通过 ${#my_array[@]}，您可以轻松地获取数组 my_array 中元素的个数，并将其存储在变量 array_length 中以供后续使用。</p>
<p>
如果您需要获取列表的元素个数，可以使用类似的方法：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1"># 创建一个空格分隔的列表</span>
</span></span><span class="line"><span class="cl">  <span class="nv">my_list</span><span class="o">=</span><span class="s2">&#34;item1 item2 item3&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 将列表转换为数组（以便使用相同的方式获取元素个数）</span>
</span></span><span class="line"><span class="cl">  <span class="nv">list_array</span><span class="o">=(</span><span class="nv">$my_list</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="nv">list_length</span><span class="o">=</span><span class="si">${#</span><span class="nv">list_array</span><span class="p">[@]</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 输出列表中元素的个数</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;列表中元素的个数为: </span><span class="nv">$list_length</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这样就可以自动获取数组和列表中元素的个数，方便您在脚本中进行后续处理。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-29" class="outline-2">
<h2 id="headline-29">
如何找到文件安装位置
</h2>
<div id="outline-text-headline-29" class="outline-text-2">
<p>
要找到软件包的安装位置，可以使用 dpkg 命令来查询已安装软件包的安装信息。以下是一些常用的命令和选项：</p>
<ol>
<li>列出所有已安装的软件包及其安装路径：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  dpkg -l</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这条命令会列出系统上所有已安装的软件包以及它们的版本号、描述等信息，其中包含了软件包的安装路径。</p>
<ol>
<li>查询特定软件包的安装路径：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  dpkg -L package_name</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
将 package_name 替换为你想要查询的软件包名称，这条命令会列出指定软件包的安装路径。</p>
<ol>
<li>查询文件属于哪个软件包：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  dpkg -S /path/to/file</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
将 /path/to/file 替换为你想要查询的文件路径，这条命令会告诉你该文件属于哪个软件包。</p>
<ol>
<li>要获取软件包的精确安装路径，可以使用以下命令来查询软件包的安装位置：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  dpkg-query -L package_name</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
将 package_name 替换为你想要查询的软件包名称。这条命令会列出指定软件包的安装路径，包括所有安装文件和目录的详细路径信息。</p>
</div>
</div>
<div id="outline-container-headline-30" class="outline-2">
<h2 id="headline-30">
如何将多行数据存储到数组中
</h2>
<div id="outline-text-headline-30" class="outline-text-2">
<p>
你可以使用循环来逐行读取并存储到数组中。在Bash中，可以按照以下方式操作：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1"># 初始化一个空数组</span>
</span></span><span class="line"><span class="cl">  <span class="nv">myArray</span><span class="o">=()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 使用循环逐行读取数据并存储到数组中</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> -r line<span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">	<span class="nv">myArray</span><span class="o">+=(</span><span class="s2">&#34;</span><span class="nv">$line</span><span class="s2">&#34;</span><span class="o">)</span>  <span class="c1"># 将每行数据添加到数组中</span>
</span></span><span class="line"><span class="cl">  <span class="k">done</span> &lt; &lt;<span class="o">(</span>find ./ -name <span class="s1">&#39;*.org&#39;</span> -exec head -n <span class="m">5</span> <span class="o">{}</span> <span class="se">\;</span> <span class="p">|</span> grep -w <span class="s2">&#34;^date:&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 打印整个数组</span>
</span></span><span class="line"><span class="cl">  <span class="nb">printf</span> <span class="s1">&#39;%s\n&#39;</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">myArray</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这段代码会从find命令和grep命令中获取多行数据，并逐行存储到名为myArray的数组中。最后，通过 printf 将整个数组打印出来。</p>
<p>
在 Bash 中，IFS（Internal Field Separator）是一个特殊的环境变量，用于指定字段的分隔符，默认情况下包含空格、制表符和换行符。当对 IFS 进行设置时，会影响到后续命令中对字段的解析方式，例如 read 命令。</p>
<p>
在 Bash 的 read 命令中，-r 和 -a 都是选项（或称为标志），用于对输入进行处理和赋值。它们的作用如下：</p>
<ol>
<li>
<p>-r 选项：</p>
<ul>
<li>当使用 -r 选项时，read 命令会禁用反斜杠转义。这意味着如果输入中包含反斜杠字符 \，它不会被特殊对待，而是按照原样赋值给变量。通常情况下，建议在使用 read 命令时始终加上 -r 选项，以避免意外的反斜杠转义。</li>
</ul>
</li>
<li>
<p>-a 选项：</p>
<ul>
<li>当使用 -a 选项时，read 命令会将读取的输入赋值给指定的数组变量，而不是普通的字符串变量。这样可以方便地将输入按照特定的分隔符（如空格）分割成多个部分，并存储到数组中的各个元素中。</li>
</ul>
</li>
</ol>
<p>因此，-r 选项用于禁用反斜杠转义，而 -a 选项用于将输入赋值给数组变量。</p>
<div id="outline-container-headline-31" class="outline-3">
<h3 id="headline-31">
在终端执行示例-1
</h3>
<div id="outline-text-headline-31" class="outline-text-3">
<p>
查找&#34;*.org&#34;文件并存入数组，然后打印数组第一个元素到终端验证效果</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t file_array &lt; &lt;<span class="o">(</span>find ./ -name <span class="s2">&#34;*.org&#34;</span> -type f -exec readlink -f <span class="o">{}</span> +<span class="o">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="si">${</span><span class="nv">file_array</span><span class="p">[0]</span><span class="si">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-32" class="outline-3">
<h3 id="headline-32">
在终端执行示例-2
</h3>
<div id="outline-text-headline-32" class="outline-text-3">
<p>
该示例在vivado工程包含sdk应用程序的条件下，查找sdk工程中的.mss文件，然后去搜索zynq芯片ps端的配置是否存在，从而确认ps端的配置情况</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t file_array &lt; &lt;<span class="o">(</span>find ./ -name <span class="s2">&#34;*.mss&#34;</span> -type f<span class="o">)</span><span class="p">;</span> <span class="k">for</span> i in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">file_array</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> -e <span class="s2">&#34;\n&#34;</span><span class="p">;</span> grep --color<span class="o">=</span>always -Hn <span class="s2">&#34;psu_uart&#34;</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-33" class="outline-2">
<h2 id="headline-33">
查看文件创建时间，并把创建时间组成使用hugo命令创建博客时生成的时间戳：
</h2>
<div id="outline-text-headline-33" class="outline-text-2">
<p>
以 ssh配置.org 为例，查看该文件的创建时间，然后组成时间戳</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">target</span><span class="o">=</span><span class="s2">&#34;ssh配置.org&#34;</span><span class="p">;</span> <span class="nv">fileCreateTime</span><span class="o">=</span><span class="s2">&#34;date: </span><span class="k">$(</span>stat <span class="si">${</span><span class="nv">target</span><span class="si">}</span> <span class="p">|</span> tail -n <span class="m">1</span> <span class="p">|</span> grep -Eo <span class="s2">&#34;\b[0-9]{4}-[0-9]{2}-[0-9]{2}\b&#34;</span><span class="k">)</span><span class="s2">T</span><span class="k">$(</span>stat <span class="si">${</span><span class="nv">target</span><span class="si">}</span> <span class="p">|</span> tail -n <span class="m">1</span> <span class="p">|</span> grep -Eo <span class="s2">&#34;\b[0-9]{2}:[0-9]{2}:[0-9]{2}\b&#34;</span><span class="k">)</span><span class="s2">+08:00&#34;</span><span class="p">;</span> <span class="nb">echo</span> <span class="si">${</span><span class="nv">fileCreateTime</span><span class="si">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
运行后，打印如下时间戳</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  date: 2024-03-26T00:24:29+08:00</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-34" class="outline-2">
<h2 id="headline-34">
在 awk 中，可以使用字符串连接符来连接多个关键词或字段
</h2>
<div id="outline-text-headline-34" class="outline-text-2">
<p>
你可以使用逗号 , 来连接多个字段或字符串，并通过空格或其他字符来分隔它们。下面是一个示例，演示了如何在 awk 中连接多个关键词：</p>
<p>
假设我们有一个名为 data.txt 的文本文件，内容如下：</p>
<div class="src src-txt">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Alice 25
</span></span><span class="line"><span class="cl">Bob 30
</span></span><span class="line"><span class="cl">Charlie 27
</span></span><span class="line"><span class="cl">David 22
</span></span><span class="line"><span class="cl">Eve 35</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
现在假设我们想要使用 awk 命令来输出年龄大于 25 的人的姓名和年龄，并在输出时添加一些额外的描述性文字。我们可以这样做：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  awk <span class="s1">&#39;$2 &gt; 25 {print &#34;Name: &#34; $1 &#34;, Age: &#34; $2}&#39;</span> data.txt</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这个命令的含义是，对于每一行数据，如果第二列（年龄）大于 25，则输出 &#34;Name: &#34;、姓名、&#34;, Age: &#34;、年龄。运行这个命令后，输出将会是：</p>
<div class="src src-txt">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Name: Bob, Age: 30
</span></span><span class="line"><span class="cl">Name: Charlie, Age: 27
</span></span><span class="line"><span class="cl">Name: Eve, Age: 35</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
在这个示例中，我们使用了字符串连接符 , 来连接固定的文字和字段，以便形成输出的完整描述。你可以根据自己的需求使用不同的连接方式和格式来构建输出。</p>
</div>
</div>
<div id="outline-container-headline-35" class="outline-2">
<h2 id="headline-35">
要使用 AWK 输出指定行
</h2>
<div id="outline-text-headline-35" class="outline-text-2">
<p>
你可以结合 AWK 的条件判断功能来实现。以下是一个简单的示例：</p>
<p>
假设有一个名为 example.txt 的文本文件，内容如下：</p>
<p>#+end_src
Line 1: This is the first line
Line 2: This is the second line
Line 3: This is the third line
Line 4: This is the fourth line
Line 5: This is the fifth line</p>
<p>#+end_src</p>
<p>
如果要输出第3行的内容，可以使用以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  awk <span class="s1">&#39;NR==3&#39;</span> example.txt</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这行命令中，NR==3 表示当前行号等于3时执行相应操作，example.txt 是输入文件。</p>
<p>
如果要输出多行（比如输出第2行到第4行的内容），可以使用类似的方式：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  awk <span class="s1">&#39;NR&gt;=2 &amp;&amp; NR&lt;=4&#39;</span> example.txt</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这样会输出第2行到第4行的内容。</p>
</div>
</div>
<div id="outline-container-headline-36" class="outline-2">
<h2 id="headline-36">
hugo 批量插入文件的 Linux 脚本参考
</h2>
<div id="outline-text-headline-36" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -type f <span class="p">|</span> xargs readlink -f<span class="p">|</span> awk -F <span class="s1">&#39;/&#39;</span> <span class="s1">&#39;{print &#34;[[/&#34;$8&#34;/&#34;$9&#34;/&#34;$10&#34;/&#34;$11&#34;/&#34;$12&#34;][&#34;$12&#34;]]&#34;}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-37" class="outline-2">
<h2 id="headline-37">
批量创建文件并添加指定内容到文件中
</h2>
<div id="outline-text-headline-37" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="k">for</span> i in <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do</span> touch <span class="nv">$i</span>.org<span class="p">;</span> <span class="nb">echo</span> -e <span class="s2">&#34;1\n2\n3\n4\n5\n&#34;</span> &gt;&gt; <span class="nv">$i</span>.org<span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-38" class="outline-2">
<h2 id="headline-38">
如果您想要使用 grep 命令从文件中的指定范围检索内容，可以结合使用 head 和 tail 命令来实现。下面是一个示例：
</h2>
<div id="outline-text-headline-38" class="outline-text-2">
<p>
假设您想在文件 example.txt 的第 10 行到第 20 行之间检索包含特定内容的行，可以按照以下步骤进行：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  head -n <span class="m">20</span> example.txt <span class="p">|</span> tail -n +10 <span class="p">|</span> grep <span class="s2">&#34;要查找的内容&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这个命令的含义是先使用 head 命令获取文件前 20 行，然后再通过 tail 命令取其中的第 10 行到最后一行，最后使用 grep 命令在这个范围内查找包含特定内容的行。</p>
<p>
请将上述命令中的 &#34;要查找的内容&#34; 替换为您需要查找的实际内容。</p>
</div>
</div>
<div id="outline-container-headline-39" class="outline-2">
<h2 id="headline-39">
想办法将文件存入数组
</h2>
<div id="outline-text-headline-39" class="outline-text-2">
<p>
将文件存入数组，然后查看数组成员个数，再将数组的第四个成员值打印出来</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t file_array &lt; &lt;<span class="o">(</span>find ./ -name <span class="s2">&#34;*.org&#34;</span> -type f -exec readlink -f <span class="o">{}</span> +<span class="o">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${#</span><span class="nv">file_array</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">file_array</span><span class="p">[3]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
mapfile 是一个 Bash 内置命令，用于将输入按行分割并存储到数组中。</p>
<p>
具体来说，mapfile 命令会从标准输入中读取数据，并将每一行作为数组的一个元素存储起来。这在处理文本文件、命令输出或其他需要按行进行处理的情况下非常有用。</p>
<p>
Here 文档（&lt;&lt;）是用来输入多行字符串的，而不是用来处理命令替换的。</p>
<p>
以下是 mapfile 命令的一般语法：</p>
<p>
bash
mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] array</p>
<ul>
<li>-n count：指定要读取的行数。</li>
<li>-O origin：从数组的哪个索引位置开始存储数据。</li>
<li>-s count：跳过输入的前几行。</li>
<li>-t：去掉每个元素末尾的换行符。</li>
<li>-u fd：从指定文件描述符读取输入。</li>
<li>-C callback：对每个读取的行调用一个回调函数进行处理。</li>
</ul>
<p>使用 mapfile 命令可以简化将文本文件内容读入数组的过程，同时避免了使用循环逐行读取的繁琐操作。</p>
<p>
总之，mapfile 命令的作用是将输入按行分割并存储到数组中，为处理大量文本数据提供了便利的方法。</p>
</div>
</div>
<div id="outline-container-headline-40" class="outline-2">
<h2 id="headline-40">
sftp 批量执行命令教程
</h2>
<div id="outline-text-headline-40" class="outline-text-2">
<p>
通过以下方式批量执行命令</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sftp ssh <span class="s">&lt;&lt; __EOF__
</span></span></span><span class="line"><span class="cl"><span class="s">  cd /
</span></span></span><span class="line"><span class="cl"><span class="s">  ls
</span></span></span><span class="line"><span class="cl"><span class="s">  __EOF__</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-41" class="outline-3">
<h3 id="headline-41">
sftp 批量执行命令教程-示例
</h3>
<div id="outline-text-headline-41" class="outline-text-3">
<p>
将运行命令粘贴到终端并回车直接运行，也可以以脚本的形式运行</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  $ sftp sdf <span class="s">&lt;&lt; __EOF__
</span></span></span><span class="line"><span class="cl"><span class="s">  cd /
</span></span></span><span class="line"><span class="cl"><span class="s">  ls
</span></span></span><span class="line"><span class="cl"><span class="s">  __EOF__</span>
</span></span><span class="line"><span class="cl">  Connected to sdf.
</span></span><span class="line"><span class="cl">  sftp&gt; <span class="nb">cd</span> /
</span></span><span class="line"><span class="cl">  sftp&gt; ls
</span></span><span class="line"><span class="cl">  arpa         bin          boot         boot.cfg     com          dev
</span></span><span class="line"><span class="cl">  etc          ftp          lib          libdata      libexec      lost+found
</span></span><span class="line"><span class="cl">  mail         mnt          netbsd       proc         sbin         sdf
</span></span><span class="line"><span class="cl">  stand        sys          tmp          udd          usr          var
</span></span><span class="line"><span class="cl">  www</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-42" class="outline-3">
<h3 id="headline-42">
参考链接
</h3>
<div id="outline-text-headline-42" class="outline-text-3">
<p>
<a href="https://blog.csdn.net/sunny_day_day/article/details/106746799">shell ssh sftp 远程自动部署程序、上传文件，sftp文件上传下载shell脚本</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-43" class="outline-2">
<h2 id="headline-43">
expect
</h2>
<div id="outline-text-headline-43" class="outline-text-2">
<div id="outline-container-headline-44" class="outline-3">
<h3 id="headline-44">
1.用expect实现与shell交互，用ssh连接termxu实例：
</h3>
<div id="outline-text-headline-44" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/usr/bin/expect       #这一句为声明，声明的方式为`#` + `!` + `expect路径`果不知道expectr的路径，可以执行`which expect`来查看</span>
</span></span><span class="line"><span class="cl">  <span class="nb">set</span> host <span class="s2">&#34;192.168.0.0&#34;</span>  <span class="c1">#非本人ip，随便编的ip地址</span>
</span></span><span class="line"><span class="cl">  <span class="nb">set</span> password <span class="s2">&#34;123456&#34;</span>
</span></span><span class="line"><span class="cl">  spawn ssh -p <span class="m">8022</span> <span class="nv">$host</span>
</span></span><span class="line"><span class="cl">  expect 
</span></span><span class="line"><span class="cl">  <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s2">&#34;*yes/no*\r&#34;</span>    <span class="c1">#如果检测到包含部分字符串，输出内容与shell交互</span>
</span></span><span class="line"><span class="cl">	<span class="o">{</span>
</span></span><span class="line"><span class="cl">	  send <span class="s2">&#34;yes\r&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s2">&#34;*assword:&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">{</span>
</span></span><span class="line"><span class="cl">	  send <span class="s2">&#34;</span><span class="nv">$password</span><span class="s2">\r&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  interact       <span class="c1">#连接后保持连接状态</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-45" class="outline-3">
<h3 id="headline-45">
2.用 expect 登录 termux 并执行脚本实例：
</h3>
<div id="outline-text-headline-45" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/usr/bin/expect</span>
</span></span><span class="line"><span class="cl">  <span class="nb">set</span> host <span class="s2">&#34;192.168.0.0&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">set</span> password <span class="s2">&#34;..Qq1ssh..&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">set</span> script <span class="s2">&#34;touch 54545455454545454544545545445455545454454454.sh&#34;</span> <span class="c1">#假设脚本内容只是创建一个文件</span>
</span></span><span class="line"><span class="cl">  spawn ssh -p <span class="m">8022</span> <span class="nv">$host</span>
</span></span><span class="line"><span class="cl">  expect <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="s2">&#34;*yes/no*\r&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">{</span>
</span></span><span class="line"><span class="cl">	  send <span class="s2">&#34;yes\r&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="s2">&#34;*assword:&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">{</span>
</span></span><span class="line"><span class="cl">	  send <span class="s2">&#34;</span><span class="nv">$password</span><span class="s2">\r&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>expect &#34;*&#34;              #匹配到任意字符</li>
<li>send &#34;$script\r&#34;        #执行脚本</li>
<li>expect &#34;*&#34;              #匹配到任意内容</li>
<li>send &#34;exit\r&#34;           #退出</li>
<li>send &#34;\r&#34;               #换行</li>
<li>expect eof              #执行完后退出</li>
</ul>
</div>
</div>
<div id="outline-container-headline-46" class="outline-3">
<h3 id="headline-46">
3. expect eof 与 interact 的区别：
</h3>
<div id="outline-text-headline-46" class="outline-text-3">
<p>
这两个命令作为结束语句用的，如果只是执行一次任务就退出，那么可以用expect eof，如果连接后想要保持连接状态，那么就用interact</p>
</div>
</div>
<div id="outline-container-headline-47" class="outline-3">
<h3 id="headline-47">
4.注意事项：
</h3>
<div id="outline-text-headline-47" class="outline-text-3">
<p>
有一点需要注意，执行脚本的方式有很多种，但是执行expect脚本的时候只能用 expect ./ 的方式执行，目前我知道的两种方式，不然会执行失败。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-48" class="outline-2">
<h2 id="headline-48">
如何使用wget下载整个网站
</h2>
<div id="outline-text-headline-48" class="outline-text-2">
<p>
wget 是用于从网站下载资源的 linux 命令，基本用法是 wget url:</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  wget http://www.w3schools.com/</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
一般来说，网站的页面会有很多链接，点击之后可以链接到其他页面，其他页面也可能有链接，就这样一级一级链接下去，如果要把这些所有关联的页面都下载下来，用法是：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  wget -r http://www.w3schools.com/</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
但是大部分网站不允许你下载所有网站的内容，如果网站检测不到浏览器标识，会拒绝你的下载连接或者给你发送回一个空白网页。这个时候在 wget 后面加上 user-agent 就可以：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  wget -r -p -U Mozilla http://www.w3schools.com/</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
为了避免被网站加入黑名单，我们可以限制下载的速度以及两次下载之间的等待时间：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  wget --wait<span class="o">=</span><span class="m">20</span> --limit-rate<span class="o">=</span>20K -r -p -U Mozilla http://www.w3schools.com/</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如何只是想下载特定文件夹下的网页，使用 –no-parent 只下载 /js 下的所有页面</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  wget --wait<span class="o">=</span><span class="m">20</span> --limit-rate<span class="o">=</span>20K --no-parent -r -p -U Mozilla http://www.w3schools.com/js/default.asp</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-49" class="outline-3">
<h3 id="headline-49">
参考链接
</h3>
<div id="outline-text-headline-49" class="outline-text-3">
<p>
<a href="https://blog.csdn.net/github_37483541/article/details/54955425">Linux 如何使用 wget 下载整个网站</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-50" class="outline-2">
<h2 id="headline-50">
cat命令
</h2>
<div id="outline-text-headline-50" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  cat a &gt; b <span class="c1">#将a中文件覆盖到文件b中</span>
</span></span><span class="line"><span class="cl">  cat a &gt;&gt; b <span class="c1">#将a中文件追加到文件b中</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-51" class="outline-2">
<h2 id="headline-51">
在SSH命令中，使用-D参数来创建动态端口转发时
</h2>
<div id="outline-text-headline-51" class="outline-text-2">
<p>
不需要指定本地地址。正确的用法是只指定端口号，例如：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  ssh -D <span class="m">1080</span> root@segfault.net</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这将在本地主机上创建一个SOCKS代理，监听在端口1080上，并将流量通过SSH通道转发到远程主机segfault.net。在这个命令中，root是远程主机的用户名，segfault.net是远程主机的地址。</p>
</div>
</div>
<div id="outline-container-headline-52" class="outline-2">
<h2 id="headline-52">
find命令查找并复制文件到指定路径
</h2>
<div id="outline-text-headline-52" class="outline-text-2">
<p>
提取视频到“视频提取”这个目录中</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -name <span class="s2">&#34;*.mp4&#34;</span> -type f -exec cp <span class="s1">&#39;{}&#39;</span> 视频提取 <span class="se">\;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-53" class="outline-2">
<h2 id="headline-53">
ffmpeg-ffplay自动播放视频列表
</h2>
<div id="outline-text-headline-53" class="outline-text-2">
<p>
将当前中路径下的视频文件名称保存到数组中，然后通过for循环和ffplay依次播放数组中的文件</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t file_array &lt; &lt;<span class="o">(</span>ls <span class="p">|</span> sort<span class="o">)</span><span class="p">;</span> <span class="k">for</span> i in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">file_array</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span> ffplay -autoexit <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-54" class="outline-2">
<h2 id="headline-54">
查找文件并进行排序
</h2>
<div id="outline-text-headline-54" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find ./ -type f -exec ls -l --time-style<span class="o">=</span>+%s <span class="o">{}</span> <span class="se">\;</span> <span class="p">|</span> sort -k6n <span class="p">|</span> awk <span class="s1">&#39;{print $1, $2, $3, $4, $5, strftime(&#34;%Y-%m-%d %H:%M:%S&#34;, $6), $7, $8, $9, $10}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这个命令是一个复杂的管道命令，它主要用于列出当前目录及其子目录中所有文件的详细信息，并按文件修改时间进行排序。让我们一步步拆解这个命令：</p>
<ol>
<li>
<p>find ./ -type f -exec ls -l –time-style=+%s {} \;：</p>
<ul>
<li>find ./ -type f：使用 find 命令查找当前目录 (./) 及其子目录中的所有文件 (-type f)。</li>
<li>-exec ls -l –time-style=+%s {} \;：对于找到的每一个文件，执行 ls -l 命令来显示详细信息，并使用 –time-style=+%s 选项以秒数的形式显示修改时间。</li>
</ul>
</li>
<li>
<p>sort -k6n：</p>
<ul>
<li>sort 命令用于排序输入的行。</li>
<li>-k6n：指定排序的关键字为第6列（修改时间），并使用数字方式进行排序。</li>
</ul>
</li>
<li>
<p>awk &#39;{print $1, $2, $3, $4, $5, strftime(&#34;%Y-%m-%d %H:%M:%S&#34;, $6), $7}&#39;：</p>
<ul>
<li>awk 是一种文本处理工具，用于对文本进行逐行处理。</li>
<li>&#39;{print $1, $2, $3, $4, $5, strftime(&#34;%Y-%m-%d %H:%M:%S&#34;, $6), $7}&#39;：对输入的每一行进行处理，打印出第1到第7列的内容，并将第6列的时间戳转换为指定格式的日期时间字符串。</li>
</ul>
</li>
</ol>
<p>综合起来，这个命令的作用是列出当前目录及其子目录中所有文件的详细信息，并按文件修改时间进行排序，最后以指定的格式输出。</p>
<p>
在这个命令中，find 和 ls 是结合使用的，但它们的工作方式是分开的。find 命令是用来查找文件的，它会递归地遍历指定目录及其子目录，找到符合条件的文件。而 -exec ls -l –time-style=+%s {} \; 这部分则是在找到每一个文件后都会执行一次 ls -l 命令来获取文件的详细信息。</p>
<p>
换句话说，find 命令是逐个找到文件，然后立即通过 -exec 选项将每个找到的文件传递给 ls -l 命令进行处理。这意味着，不是等到所有文件都找到后再一次性地通过 ls -l 命令处理，而是边找到文件边处理。</p>
<p>
这样做的好处是可以实时获取每个文件的详细信息，并且可以在处理每个文件时进行额外的操作，例如这里的 –time-style=+%s 选项用来显示文件的修改时间戳。</p>
</div>
</div>
<div id="outline-container-headline-55" class="outline-2">
<h2 id="headline-55">
shopt 使用技巧
</h2>
<div id="outline-text-headline-55" class="outline-text-2">
<div id="outline-container-headline-56" class="outline-3">
<h3 id="headline-56">
Linux 环境启用 extglob 扩展 
</h3>
<div id="outline-text-headline-56" class="outline-text-3">
<p>
例如在 bash shell 中，rm -rf !(file) 无效，因为 !(pattern) 是 extglob 扩展，需要打开扩展模式才能使用。要配置 shopt 来启用 extglob 扩展，可以按照以下步骤进行：</p>
<ol>
<li>打开终端。</li>
<li>运行 shopt -s extglob 命令来启用 extglob 扩展。</li>
<li>现在你应该可以使用 !(pattern) 这样的模式来排除某些文件，例如 rm -rf !(file)。</li>
</ol>
<p>请注意，在使用 extglob 扩展时要格外小心，确保不会意外删除重要文件。</p>
</div>
</div>
<div id="outline-container-headline-57" class="outline-3">
<h3 id="headline-57">
shopt -s extglob 与 shopt -u extglob 有区别吗
</h3>
<div id="outline-text-headline-57" class="outline-text-3">
<p>
shopt -s extglob 和 shopt -u extglob 是 bash shell 中的两个不同命令，它们分别用于启用和禁用 extglob 扩展。这两个命令的作用如下：</p>
<ul>
<li>shopt -s extglob：这个命令用于启用 extglob 扩展，允许在 bash shell 中使用扩展模式，比如 !(pattern)、*(pattern)、+(pattern)、?(pattern) 和 @(pattern)。</li>
<li>shopt -u extglob：这个命令用于禁用 extglob 扩展，即关闭扩展模式，使得在 bash shell 中不能再使用上述提到的扩展模式。</li>
</ul>
<p>因此，这两个命令的区别在于一个用于启用扩展模式，另一个用于禁用扩展模式。</p>
</div>
</div>
<div id="outline-container-headline-58" class="outline-3">
<h3 id="headline-58">
Linux 下切换目录省略 cd 命令
</h3>
<div id="outline-text-headline-58" class="outline-text-3">
<p>
shopt -s autocd：启用 Bash 的 autocd 选项，使得在输入目录路径时可以省略 cd 命令，直接切换到该目录。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-59" class="outline-2">
<h2 id="headline-59">
shell脚本如何获取参数数量
</h2>
<div id="outline-text-headline-59" class="outline-text-2">
<p>
在Shell脚本中，你可以使用内置变量 $# 来获取传递给脚本或函数的参数数量。这个变量表示传递给脚本或函数的参数数量。</p>
<p>
例如，假设你有一个名为 script.sh 的Shell脚本，可以通过 $# 来获取传递给该脚本的参数数量，如下所示：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;Number of arguments: </span><span class="nv">$#</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当你执行 ./script.sh arg1 arg2 arg3 时，它将输出：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  Number of arguments: <span class="m">3</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这表明传递给脚本的参数数量为3。</p>
<div id="outline-container-headline-60" class="outline-3">
<h3 id="headline-60">
如何获取最后一个参数
</h3>
<div id="outline-text-headline-60" class="outline-text-3">
<p>
要获取最后一个参数，你可以使用特殊变量 $ 后跟参数的索引。在 Bash 中，$# 表示参数的总数，而 ${!#} 表示最后一个参数。</p>
</div>
</div>
<div id="outline-container-headline-61" class="outline-3">
<h3 id="headline-61">
如何获取多个参数的内容
</h3>
<div id="outline-text-headline-61" class="outline-text-3">
<p>
要获取多个参数的内容，你可以使用 $1, $2, $3 等等来访问每个参数的值。如果你不确定要获取多少个参数，可以使用循环来处理它们。</p>
<p>
以下是一个示例脚本，演示如何获取并打印所有参数的内容：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/usr/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nv">args</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$#</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;Total arguments: </span><span class="nv">$args</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 1<span class="p">;</span> i &lt;<span class="o">=</span> args<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">	<span class="nb">echo</span> <span class="s2">&#34;Argument </span><span class="nv">$i</span><span class="s2">: </span><span class="si">${</span><span class="p">!i</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当你执行 ./script.sh arg1 arg2 arg3 时，它将输出：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  Total arguments: <span class="m">3</span>
</span></span><span class="line"><span class="cl">  Argument 1: arg1
</span></span><span class="line"><span class="cl">  Argument 2: arg2
</span></span><span class="line"><span class="cl">  Argument 3: arg3</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这表明脚本正确地获取并打印了所有参数的内容。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-62" class="outline-2">
<h2 id="headline-62">
Linux命令中短横线的作用
</h2>
<div id="outline-text-headline-62" class="outline-text-2">
<p>
用以下命令举例</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  tar -cpzf - ./ <span class="p">|</span> tar -xpzf - -C dir</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这个命令可以分解为两个部分：</p>
<ol>
<li>tar -cpzf - ./：这部分将当前目录中的所有文件和子目录打包成一个tar文件，并通过标准输出（stdout）输出。 -c 表示创建归档文件，-p 保留文件权限和属性，-z 使用gzip进行压缩，-f - 将归档文件输出到标准输出。</li>
<li>tar -xpzf - -C dir：这部分将从标准输入（stdin）读取tar文件，并将其解压缩到指定的目录。-x 表示提取文件，-p 保留文件权限和属性，-z 使用gzip进行解压缩，-f - 从标准输入读取归档文件，-C dir表示将文件提取到指定的目录。</li>
</ol>
<p>综合起来，整个命令的作用是将当前目录中的所有文件和子目录打包成一个tar文件，并通过管道传输给另一个命令，该命令将tar文件解压缩到指定的目录（dir）。这样就实现了将当前目录中的文件和子目录传输到指定目录并进行解压缩的操作。</p>
</div>
</div>
<div id="outline-container-headline-63" class="outline-2">
<h2 id="headline-63">
Linux下如何查看当前用的是zsh还是bash
</h2>
<div id="outline-text-headline-63" class="outline-text-2">
<p>
要查看当前正在使用的是 zsh 还是 bash，可以使用以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="nv">$SHELL</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这个命令会输出当前 shell 的路径。通常情况下，如果你的 shell 是 bash，它会输出 /bin/bash；如果是 zsh，它会输出 /bin/zsh。</p>
</div>
</div>
<div id="outline-container-headline-64" class="outline-2">
<h2 id="headline-64">
通过lshw命令确定系统是否支持 ECC 内存
</h2>
<div id="outline-text-headline-64" class="outline-text-2">
<p>
使用 lshw 命令： lshw 是一个用于列出系统硬件信息的工具，可以使用它来查看系统的内存信息，包括 ECC 支持情况。运行以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sudo lshw -class memory <span class="p">|</span> grep -i ecc</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-65" class="outline-2">
<h2 id="headline-65">
linux如何查看内存大小
</h2>
<div id="outline-text-headline-65" class="outline-text-2">
<p>
在Linux系统中，有多种方式可以查看系统内存大小。以下是几种常用的方法：</p>
<ol>
<li>使用free命令</li>
</ol>
<p>free命令可以查看系统内存的总量、使用量和空闲量等信息。在终端中输入以下命令即可查看：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  free -h</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
该命令会以人类可读的方式显示内存信息，例如：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  total        used        free      shared  buff/cache   available
</span></span><span class="line"><span class="cl">  Mem:           7.7G        2.4G        1.1G        1.1G        4.2G        4.3G
</span></span><span class="line"><span class="cl">  Swap:          2.0G          0B        2.0G</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
其中，total表示内存总量，used表示已使用的内存量，free表示空闲的内存量。</p>
<ol>
<li>使用cat命令</li>
</ol>
<p>/proc/meminfo文件包含了系统内存的详细信息。您可以使用cat命令查看该文件的内容，如下所示：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  cat /proc/meminfo</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
该命令会输出系统内存的详细信息，例如</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  MemTotal:        <span class="m">8051920</span> kB
</span></span><span class="line"><span class="cl">  MemFree:         <span class="m">1172128</span> kB
</span></span><span class="line"><span class="cl">  MemAvailable:    <span class="m">4458368</span> kB
</span></span><span class="line"><span class="cl">  Buffers:          <span class="m">125528</span> kB
</span></span><span class="line"><span class="cl">  Cached:          <span class="m">4023852</span> kB
</span></span><span class="line"><span class="cl">  SwapCached:            <span class="m">0</span> kB
</span></span><span class="line"><span class="cl">  Active:          <span class="m">2927372</span> kB
</span></span><span class="line"><span class="cl">  Inactive:        <span class="m">2965436</span> kB</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
其中，MemTotal表示内存总量，以千字节为单位。</p>
<ol>
<li>使用dmidecode命令</li>
</ol>
<p>dmidecode命令可以显示系统硬件信息，包括内存信息。在终端中输入以下命令即可查看：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sudo dmidecode -t memory</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
该命令会输出系统中所有内存模块的详细信息，例如：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1"># dmidecode 3.2</span>
</span></span><span class="line"><span class="cl">  Getting SMBIOS data from sysfs.
</span></span><span class="line"><span class="cl">  SMBIOS 2.7 present.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Handle 0x1000, DMI <span class="nb">type</span> 16, <span class="m">23</span> bytes
</span></span><span class="line"><span class="cl">  Physical Memory Array
</span></span><span class="line"><span class="cl">  Location: System Board Or Motherboard
</span></span><span class="line"><span class="cl">  Use: System Memory
</span></span><span class="line"><span class="cl">  Error Correction Type: None
</span></span><span class="line"><span class="cl">  Maximum Capacity: <span class="m">32</span> GB
</span></span><span class="line"><span class="cl">  Error Information Handle: Not Provided
</span></span><span class="line"><span class="cl">  Number Of Devices: <span class="m">4</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Handle 0x1100, DMI <span class="nb">type</span> 17, <span class="m">34</span> bytes
</span></span><span class="line"><span class="cl">  Memory Device
</span></span><span class="line"><span class="cl">  Array Handle: 0x1000
</span></span><span class="line"><span class="cl">  Error Information Handle: Not Provided
</span></span><span class="line"><span class="cl">  Total Width: <span class="m">64</span> bits
</span></span><span class="line"><span class="cl">  Data Width: <span class="m">64</span> bits
</span></span><span class="line"><span class="cl">  Size: <span class="m">8192</span> MB
</span></span><span class="line"><span class="cl">  Form Factor: DIMM
</span></span><span class="line"><span class="cl">  Set: None
</span></span><span class="line"><span class="cl">  Locator: ChannelA-DIMM0
</span></span><span class="line"><span class="cl">  Bank Locator: BANK <span class="m">0</span>
</span></span><span class="line"><span class="cl">  Type: DDR3
</span></span><span class="line"><span class="cl">  Type Detail: Synchronous
</span></span><span class="line"><span class="cl">  Speed: <span class="m">1600</span> MT/s
</span></span><span class="line"><span class="cl">  Manufacturer: Kingston
</span></span><span class="line"><span class="cl">  Serial Number: <span class="m">123456789</span>
</span></span><span class="line"><span class="cl">  Asset Tag: Not Specified
</span></span><span class="line"><span class="cl">  Part Number: KHX1600C9D3K2/8GX
</span></span><span class="line"><span class="cl">  Rank: <span class="m">2</span>
</span></span><span class="line"><span class="cl">  Configured Clock Speed: <span class="m">1600</span> MT/s
</span></span><span class="line"><span class="cl">  Minimum Voltage: 1.5 V
</span></span><span class="line"><span class="cl">  Maximum Voltage: 1.5 V
</span></span><span class="line"><span class="cl">  Configured Voltage: 1.5 V</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
其中，Maximum Capacity表示内存总量，以GB为单位。</p>
<div id="outline-container-headline-66" class="outline-5">
<h5 id="headline-66">
参考链接
</h5>
<div id="outline-text-headline-66" class="outline-text-5">
<p>
<a href="https://blog.csdn.net/bulucc/article/details/130204908">linux如何查看内存大小</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-67" class="outline-2">
<h2 id="headline-67">
使用 dd 命令来测试硬盘的写入速度，并且采用一些优化参数来减少系统缓存的影响
</h2>
<div id="outline-text-headline-67" class="outline-text-2">
<div id="outline-container-headline-68" class="outline-3">
<h3 id="headline-68">
示例
</h3>
<div id="outline-text-headline-68" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  $ <span class="nb">time</span> dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/testw.dbf <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span><span class="m">1000</span> <span class="nv">oflag</span><span class="o">=</span>direct
</span></span><span class="line"><span class="cl">  记录了1000+0 的读入
</span></span><span class="line"><span class="cl">  记录了1000+0 的写出
</span></span><span class="line"><span class="cl">  1048576000字节（1.0 GB，1000 MiB）已复制，6.8299 s，154 MB/s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  real    0m6.876s
</span></span><span class="line"><span class="cl">  user    0m0.046s
</span></span><span class="line"><span class="cl">  sys     0m0.108s</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ol>
<li>
<p>time dd if=/dev/zero of=/testw.dbf bs=1M count=1000 oflag=direct：</p>
<ul>
<li>time：用于测量命令执行的时间。</li>
<li>dd：数据传输命令。</li>
<li>if=/dev/zero：输入文件指定为 /dev/zero，该文件会产生无限的零字节流。</li>
<li>of=/testw.dbf：输出文件指定为 /testw.dbf，这是测试中要写入的文件。</li>
<li>bs=1M：块大小设置为 1 MB，表示每次读取或写入的数据块大小为 1 MB。</li>
<li>count=1000：指定了写入的块数为 1000，因此总共要写入 1000 × 1 MB = 1000 MB 的数据。</li>
<li>oflag=direct：该参数指示 dd 命令在执行时绕过系统缓存，直接与硬盘进行数据交换。</li>
</ul>
</li>
<li>记录了1000+0 的读入：表示成功读取了 1000 个数据块。</li>
<li>记录了1000+0 的写出：表示成功写入了 1000 个数据块。</li>
<li>
<p>1048576000字节（1.0 GB，1000 MiB）已复制，6.8299 s，154 MB/s：</p>
<ul>
<li>表示总共复制了 1,048,576,000 字节，即 1.0 GB 的数据。</li>
<li>6.8299 s 是命令执行的实际时间。</li>
<li>154 MB/s 是写入速度，即每秒写入 154 MB 的数据量。</li>
</ul>
</li>
<li>real    0m6.876s：实际时间，即命令的总执行时间。</li>
<li>user    0m0.046s：用户 CPU 时间，即命令在用户态消耗的 CPU 时间。</li>
<li>sys     0m0.108s：系统 CPU 时间，即命令在内核态消耗的 CPU 时间。</li>
</ol>
<p>综合来看，该命令测试了硬盘的写入速度，并显示了每秒写入的数据量为 154 MB，这是在绕过系统缓存的情况下测得的结果。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-69" class="outline-2">
<h2 id="headline-69">
xxd使用技巧
</h2>
<div id="outline-text-headline-69" class="outline-text-2">
<div id="outline-container-headline-70" class="outline-3">
<h3 id="headline-70">
将文本转换为ASCII对应的16进制输出
</h3>
<div id="outline-text-headline-70" class="outline-text-3">
<div id="outline-container-headline-71" class="outline-4">
<h4 id="headline-71">
操作命令
</h4>
<div id="outline-text-headline-71" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s1">&#39;0&#39;</span> <span class="p">|</span> xxd -p</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-72" class="outline-4">
<h4 id="headline-72">
使用实例
</h4>
<div id="outline-text-headline-72" class="outline-text-4">
<p>
结果用ASCII表示，30表示字符0，0a表示换行符</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  $ <span class="nb">echo</span> <span class="s1">&#39;0&#39;</span> <span class="p">|</span> xxd -p
</span></span><span class="line"><span class="cl">  300a</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-73" class="outline-3">
<h3 id="headline-73">
将ASCII对应的16进制转换为ASCII输出
</h3>
<div id="outline-text-headline-73" class="outline-text-3">
<div id="outline-container-headline-74" class="outline-4">
<h4 id="headline-74">
操作命令
</h4>
<div id="outline-text-headline-74" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s1">&#39;300a&#39;</span> <span class="p">|</span> xxd -r -p</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-75" class="outline-4">
<h4 id="headline-75">
使用实例
</h4>
<div id="outline-text-headline-75" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  $ <span class="nb">echo</span> <span class="s1">&#39;300a&#39;</span> <span class="p">|</span> xxd -r -p
</span></span><span class="line"><span class="cl">  <span class="m">0</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-76" class="outline-2">
<h2 id="headline-76">
linux环境如何合并两个文件夹，两个目录名相同，文件有相同的也有不相同的，遇到同名文件跳过
</h2>
<div id="outline-text-headline-76" class="outline-text-2">
<p>
在 Linux 环境中，你可以使用 rsync 命令来合并两个文件夹，并在遇到同名文件时跳过。rsync 是一个强大的文件同步工具，可以用于在本地或远程系统之间同步文件和目录。</p>
<p>
以下是使用 rsync 命令合并两个目录的基本语法：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  rsync -av --ignore-existing 源目录/ 目标目录/</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这里的参数含义如下：</p>
<ul>
<li>-a, –archive：以归档模式进行同步，包括递归地复制子目录、保持文件权限、保持文件修改时间等。</li>
<li>-v, –verbose：显示详细的输出信息，让你知道正在发生什么。</li>
<li>–ignore-existing：忽略已经存在于目标目录中的文件，不进行覆盖，这样就能实现遇到同名文件时跳过的效果。</li>
<li>源目录/：指定源目录的路径。</li>
<li>目标目录/：指定目标目录的路径。</li>
</ul>
<p>例如，假设你有两个目录 folder1 和 folder2，你想将它们合并到一个目录 merged_folder 中，可以使用以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  rsync -av --ignore-existing folder1/ merged_folder/
</span></span><span class="line"><span class="cl">  rsync -av --ignore-existing folder2/ merged_folder/</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这样就会将 folder1 和 folder2 中的文件合并到 merged_folder 中，并在遇到同名文件时跳过。</p>
</div>
</div>
<div id="outline-container-headline-77" class="outline-2">
<h2 id="headline-77">
Linux history 命令详解：如何查看、显示时间、清空、重复和控制历史记录
</h2>
<div id="outline-text-headline-77" class="outline-text-2">
<p>
当然，让我们详细解释 history 命令的各个方面：</p>
<p>
### 1. 查看历史记录</p>
<p>
使用 history 命令可以查看 Bash shell 中执行过的命令历史记录。这将显示按照执行顺序排列的历史记录列表，每个命令前面带有一个数字。</p>
<p>
### 2. 显示时间戳</p>
<p>
默认情况下，history 命令不会显示每个命令执行的时间戳。但是，你可以通过设置 HISTTIMEFORMAT 环境变量来显示时间戳。例如：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">export</span> <span class="nv">HISTTIMEFORMAT</span><span class="o">=</span><span class="s2">&#34;%F %T &#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这将在历史记录中显示日期和时间。</p>
<p>
### 3. 清空历史记录</p>
<p>
要清空 Bash shell 中的命令历史记录，可以使用 history -c 命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">history</span> -c</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这将删除当前会话中的所有历史记录。要永久删除历史记录，可以编辑或者删除历史记录文件，通常是 ~/.bash_history。</p>
<p>
### 4. 重复执行历史命令</p>
<p>
要重复执行历史记录中的命令，可以使用 ! 后跟命令的历史编号。例如，要重新执行历史记录中编号为 123 的命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  !123</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
你还可以使用 !! 来重复执行上一条命令。</p>
<p>
### 5. 控制历史记录</p>
<p>
你可以使用 HISTSIZE 和 HISTFILESIZE 环境变量来控制历史记录的大小。HISTSIZE 定义了保存在内存中的历史记录数目，HISTFILESIZE 定义了保存在历史记录文件中的历史记录数目。如果 HISTFILESIZE 比 HISTSIZE 小，那么当 shell 退出时，会将 HISTSIZE 指定的数量的命令写入历史记录文件中。</p>
</div>
</div>
<div id="outline-container-headline-78" class="outline-2">
<h2 id="headline-78">
Linux终端打印如何删除指定列或多列
</h2>
<div id="outline-text-headline-78" class="outline-text-2">
<p>
要删除Linux终端中的指定列或多列，你可以使用一些命令和技巧。以下是几种方法：</p>
<ol>
<li>
<p><strong><strong>使用awk命令删除指定列：</strong></strong>
如果你知道要删除的列的位置，你可以使用awk命令来实现。例如，如果要删除第3列，你可以使用以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">awk <span class="s1">&#39;{$3=&#34;&#34;; print}&#39;</span> input_file</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>这将从input_file中删除第3列并输出结果。你还可以使用逗号分隔多个列的位置，例如：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">awk <span class="s1">&#39;{$2=&#34;&#34;; $4=&#34;&#34;; print}&#39;</span> input_file</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>这将删除第2列和第4列，并输出结果。</p>
</li>
<li>
<p><strong><strong>使用cut命令删除指定列：</strong></strong>
如果你知道要删除的列的位置，你也可以使用cut命令。例如，如果要删除第3列，你可以使用以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cut -d<span class="s1">&#39; &#39;</span> -f1,2,4- input_file</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>这将从input_file中删除第3列并输出结果。你可以通过指定列的位置来删除多列。</p>
</li>
</ol>
<p>这个命令是用来在Linux终端中删除指定列的。让我们一步步解析：</p>
<ul>
<li>cut：这是用于剪切文本的命令。</li>
<li>-d&#39; &#39;：这个选项指定了字段的分隔符。在这里，-d 后跟着一个空格 (&#39; &#39;) 表示字段是以空格作为分隔符的。</li>
<li>-f1,2,4-：这个选项指定了要保留的字段。在这里，-f 表示字段，后面跟着的 1,2,4- 表示要保留第1、第2列以及第4列及之后的所有列。</li>
<li>input_file：这是要进行操作的输入文件的名称。</li>
</ul>
<p>因此，整个命令的含义是从input_file中剪切出第1、第2、第4列及之后的所有列，并将结果输出到终端。</p>
<ol>
<li>
<p><strong><strong>使用sed命令删除指定列：</strong></strong>
sed命令可以用来对文本进行替换和删除操作。例如，如果要删除第3列，你可以使用以下命令：</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sed <span class="s1">&#39;s/\([^ ]* *\)\{2\}[^ ]* *//&#39;</span> input_file</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>这将从input_file中删除第3列并输出结果。你可以通过调整正则表达式来删除多列。</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-79" class="outline-2">
<h2 id="headline-79">
shell排序，强大的sort
</h2>
<div id="outline-text-headline-79" class="outline-text-2">
<p>
在Shell中，sort命令是一个强大的工具，用于对文本文件进行排序。它可以按照字母顺序或数字顺序对文件的行进行排序，并且可以根据需要进行自定义配置。</p>
<p>
以下是一些常见用法：</p>
<ol>
<li>按字母顺序排序：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sort filename</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ol>
<li>按数字顺序排序：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sort -n filename</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ol>
<li>逆序排序：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sort -r filename</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ol>
<li>按照指定列排序：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sort -k &lt;column_number&gt; filename</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ol>
<li>去重并排序：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sort -u filename</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<ol>
<li>将结果输出到新文件：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sort input_filename &gt; output_filename</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这些只是 sort 命令的一些基本用法示例。根据你的需求，你可以结合使用不同的选项来实现各种排序操作。</p>
</div>
</div>
<div id="outline-container-headline-80" class="outline-2">
<h2 id="headline-80">
当前目录下多文件根据排序顺序一对一对的依次进行比较
</h2>
<div id="outline-text-headline-80" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t files &lt; &lt;<span class="o">(</span>ls<span class="o">)</span><span class="p">;</span> <span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;7<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> diff <span class="s2">&#34;</span><span class="si">${</span><span class="nv">files</span><span class="p">[i]</span><span class="si">}</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">files</span><span class="p">[i+1]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-81" class="outline-2">
<h2 id="headline-81">
从当前目前进入到一个子目录过滤文件字符串并返回到当前目录
</h2>
<div id="outline-text-headline-81" class="outline-text-2">
<div id="outline-container-headline-82" class="outline-3">
<h3 id="headline-82">
单次手动操作
</h3>
<div id="outline-text-headline-82" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">cd</span> <span class="k">$(</span>ls <span class="p">|</span> awk <span class="s1">&#39;NR==15&#39;</span><span class="k">)</span><span class="p">;</span> find ./ -name <span class="s2">&#34;*.c&#34;</span> -o -name <span class="s2">&#34;*.h&#34;</span> <span class="p">|</span> xargs grep --color<span class="o">=</span>always -n <span class="s2">&#34;keyword&#34;</span><span class="p">;</span> <span class="nb">cd</span> ../</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-83" class="outline-3">
<h3 id="headline-83">
多次自动操作
</h3>
<div id="outline-text-headline-83" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>15<span class="p">;</span> i&lt;21<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">cd</span> <span class="k">$(</span>ls <span class="p">|</span> awk <span class="s2">&#34;NR==</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="k">)</span><span class="p">;</span> find ./ -name <span class="s2">&#34;*.c&#34;</span> -o -name <span class="s2">&#34;*.h&#34;</span> <span class="p">|</span> xargs grep --color<span class="o">=</span>always -n <span class="s2">&#34;keyword&#34;</span><span class="p">;</span> <span class="nb">cd</span> ../<span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-84" class="outline-2">
<h2 id="headline-84">
Linux下gh批量下载github某仓库中Release所有版本文件
</h2>
<div id="outline-text-headline-84" class="outline-text-2">
<div id="outline-container-headline-85" class="outline-3">
<h3 id="headline-85">
工具官网
</h3>
<div id="outline-text-headline-85" class="outline-text-3">
<p>
https://github.com/cli/cli</p>
</div>
</div>
<div id="outline-container-headline-86" class="outline-3">
<h3 id="headline-86">
查看指定仓库中的所有版本
</h3>
<div id="outline-text-headline-86" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t file_version &lt; &lt;<span class="o">(</span>gh release list -R 201853910/VMwareWorkstation <span class="p">|</span> awk <span class="s1">&#39;{$NF=&#34;&#34;; print}&#39;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/Latest//g&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $NF}&#39;</span><span class="o">)</span><span class="p">;</span> <span class="k">for</span> i in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">file_version</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> sleep 1<span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-87" class="outline-3">
<h3 id="headline-87">
下载所有版本的Release
</h3>
<div id="outline-text-headline-87" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t file_version &lt; &lt;<span class="o">(</span>gh release list -R 201853910/VMwareWorkstation <span class="p">|</span> awk <span class="s1">&#39;{$NF=&#34;&#34;; print}&#39;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/Latest//g&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $NF}&#39;</span><span class="o">)</span><span class="p">;</span> <span class="k">for</span> i in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">file_version</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span> gh release download <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span> -D Vmwares/ -R 201853910/VMwareWorkstation<span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-88" class="outline-3">
<h3 id="headline-88">
参考链接
</h3>
<div id="outline-text-headline-88" class="outline-text-3">
<p>
<a href="https://zhuanlan.zhihu.com/p/667880441">使用cli批量下载GitHub仓库中所有的release</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-89" class="outline-2">
<h2 id="headline-89">
从文件列表中查找指定关键词脚本
</h2>
<div id="outline-text-headline-89" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  clear <span class="o">&amp;&amp;</span> mapfile -t dts &lt; &lt;<span class="o">(</span>cat temp.txt<span class="o">)</span><span class="p">;</span> <span class="k">for</span> i in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dts</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">:&#34;</span><span class="p">;</span> grep --color<span class="o">=</span>always -ain <span class="s2">&#34;hdmi&#34;</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="nb">echo</span> -e <span class="s2">&#34;\e[32m==========================================================================================\e[0m&#34;</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-90" class="outline-2">
<h2 id="headline-90">
Linux 下计算圆周率
</h2>
<div id="outline-text-headline-90" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">time</span> <span class="nb">echo</span> <span class="s2">&#34;scale=5000; 4*a(1)&#34;</span> <span class="p">|</span> bc -l -q</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
time命令：指令执行时所消耗的时间</p>
<p>
bc -l：设置标准数学库</p>
<p>
bc -q：显示正常的GNU bc环境信息</p>
</div>
</div>
<div id="outline-container-headline-91" class="outline-2">
<h2 id="headline-91">
查找文件关键词并替换
</h2>
<div id="outline-text-headline-91" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1">#!/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 将var2变量值替换掉var1变量值</span>
</span></span><span class="line"><span class="cl">  <span class="nv">var1</span><span class="o">=</span><span class="s2">&#34;10.8.98.80&#34;</span>				<span class="c1"># 待被替换的关键词</span>
</span></span><span class="line"><span class="cl">  <span class="nv">var2</span><span class="o">=</span><span class="s2">&#34;192.168.0.64&#34;</span>				<span class="c1"># 作为替换的关键词</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  mapfile -t files &lt; &lt;<span class="o">(</span>find ./ -name <span class="s2">&#34;*.cpp&#34;</span> <span class="p">|</span> xargs readlink -f <span class="p">|</span> xargs grep -l <span class="s2">&#34;</span><span class="si">${</span><span class="nv">var1</span><span class="si">}</span><span class="s2">&#34;</span><span class="o">)</span> <span class="c1"># 查找包含var1变量值的文件存入数组</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nv">fileNum</span><span class="o">=</span><span class="si">${#</span><span class="nv">files</span><span class="p">[@]</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; fileNum<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">	sed -i <span class="s2">&#34;s/</span><span class="si">${</span><span class="nv">var1</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">var2</span><span class="si">}</span><span class="s2">/g&#34;</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">files</span><span class="p">[i]</span><span class="si">}</span><span class="s2">&#34;</span> <span class="c1"># 将var1替换为var2</span>
</span></span><span class="line"><span class="cl">  <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-92" class="outline-2">
<h2 id="headline-92">
输出累加数+时间戳，按回车继续
</h2>
<div id="outline-text-headline-92" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">count</span><span class="o">=</span>0<span class="p">;</span> <span class="k">while</span> true<span class="p">;</span> <span class="k">do</span> <span class="o">((</span>count++<span class="o">))</span><span class="p">;</span> <span class="nb">echo</span> -en <span class="s2">&#34;\r\n</span><span class="k">$(</span>date<span class="k">)</span><span class="s2">-----\e[31m</span><span class="si">${</span><span class="nv">count</span><span class="si">}</span><span class="s2">\e[0m&#34;</span><span class="p">;</span> <span class="nb">read</span> -p <span class="s2">&#34;&#34;</span> <span class="k">continue</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-93" class="outline-2">
<h2 id="headline-93">
要仅查找 driver 目录下的 Pciedma_DLL.h 文件，可以使用以下 find 命令：
</h2>
<div id="outline-text-headline-93" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  find *SGDMA* -type d -name <span class="s2">&#34;driver&#34;</span> -exec find <span class="o">{}</span> -name <span class="s2">&#34;Pciedma_DLL.h&#34;</span> <span class="se">\;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这个命令首先在包含 SGDMA 的目录下找到所有名为 driver 的目录，然后在这些目录中查找 Pciedma_DLL.h 文件。</p>
</div>
</div>
<div id="outline-container-headline-94" class="outline-2">
<h2 id="headline-94">
Linux tar命令解压时提示时间戳异常的处理办法
</h2>
<div id="outline-text-headline-94" class="outline-text-2">
<div id="outline-container-headline-95" class="outline-3">
<h3 id="headline-95">
方法一
</h3>
<div id="outline-text-headline-95" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  ta --touch -zxvf test.tar.gz</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-96" class="outline-3">
<h3 id="headline-96">
方法二
</h3>
<div id="outline-text-headline-96" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  tar -m -zxvf test.tar.gz</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
-m或–modification-time 还原文件时，不变更文件的更改时间。</p>
</div>
</div>
<div id="outline-container-headline-97" class="outline-3">
<h3 id="headline-97">
参考链接
</h3>
<div id="outline-text-headline-97" class="outline-text-3">
<p>
<a href="https://www.cnblogs.com/chenjinxi/p/7468824.html">Linux tar命令解压时提示时间戳异常的处理办法</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-98" class="outline-2">
<h2 id="headline-98">
Linux终端批量造数
</h2>
<div id="outline-text-headline-98" class="outline-text-2">
<div id="outline-container-headline-99" class="outline-3">
<h3 id="headline-99">
Linux终端批量造十进制数
</h3>
<div id="outline-text-headline-99" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  clear <span class="o">&amp;&amp;</span> clear <span class="o">&amp;&amp;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; 65536<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> -en <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2"> &#34;</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-100" class="outline-3">
<h3 id="headline-100">
Linux终端批量造十六进制数
</h3>
<div id="outline-text-headline-100" class="outline-text-3">
<p>
%x：小写</p>
<p>
%X：大写</p>
<p>
0x%04X：十六位大写，4*4=16</p>
<p>
0x%08X：三十二位大写，8*4=32</p>
<p>
0x%016X：六十四位大写，16*4=64，依次类推</p>
<div id="outline-container-headline-101" class="outline-4">
<h4 id="headline-101">
Linux终端批量造十六进制数-16位
</h4>
<div id="outline-text-headline-101" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  clear <span class="o">&amp;&amp;</span> clear <span class="o">&amp;&amp;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; 65536<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">printf</span> <span class="s2">&#34;0x%04X &#34;</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-102" class="outline-4">
<h4 id="headline-102">
Linux终端批量造十六进制数-32位
</h4>
<div id="outline-text-headline-102" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  clear <span class="o">&amp;&amp;</span> clear <span class="o">&amp;&amp;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; 65536<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">printf</span> <span class="s2">&#34;0x%08X &#34;</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-103" class="outline-4">
<h4 id="headline-103">
Linux终端批量造十六进制数-64位
</h4>
<div id="outline-text-headline-103" class="outline-text-4">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  clear <span class="o">&amp;&amp;</span> clear <span class="o">&amp;&amp;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; 65536<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">printf</span> <span class="s2">&#34;0x%016X &#34;</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-104" class="outline-2">
<h2 id="headline-104">
在Windows的文件资源管理器的地址栏使用mintty命令或者当前文件夹路径
</h2>
<div id="outline-text-headline-104" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mintty -e /bin/bash -c <span class="s2">&#34;pwd | clip&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
或者</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  D:<span class="se">\c</span>ygwin<span class="se">\b</span>in<span class="se">\m</span>intty.exe -e /bin/bash -c <span class="s2">&#34;pwd | clip&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-105" class="outline-2">
<h2 id="headline-105">
查找文件并依次进行比较
</h2>
<div id="outline-text-headline-105" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t files &lt; &lt;<span class="o">(</span>find ./ -name <span class="s2">&#34;M6678_SRIO.h&#34;</span><span class="o">)</span><span class="p">;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; <span class="si">${#</span><span class="nv">files</span><span class="p">[@]</span><span class="si">}</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> diff <span class="s2">&#34;</span><span class="si">${</span><span class="nv">files</span><span class="p">[i]</span><span class="si">}</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">files</span><span class="p">[i+1]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-106" class="outline-2">
<h2 id="headline-106">
将连续的两个字节以一个字节单位倒序处理，并计算对应的10进制结果
</h2>
<div id="outline-text-headline-106" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">input</span><span class="o">=</span><span class="k">$(</span>xxd -l <span class="m">4</span> output_0001.bmp <span class="p">|</span> awk <span class="s1">&#39;{print $3}&#39;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/../&amp;\ /g&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $2$1}&#39;</span> <span class="p">|</span> tr <span class="s1">&#39;[a-z]&#39;</span> <span class="s1">&#39;[A-Z]&#39;</span><span class="k">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;obase=10; ibase=16; </span><span class="si">${</span><span class="nv">input</span><span class="si">}</span><span class="s2">&#34;</span> <span class="p">|</span> bc</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-107" class="outline-3">
<h3 id="headline-107">
命令拆解
</h3>
<div id="outline-text-headline-107" class="outline-text-3">
<p>
这个命令的作用是从 output_0001.bmp 文件中提取前 4 字节的数据，将其转换为十进制数。让我们逐步拆解它：</p>
<ol>
<li>提取数据：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  xxd -l <span class="m">4</span> output_0001.bmp</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>xxd 工具将 output_0001.bmp 文件的前 4 字节以十六进制格式输出。每行输出包括地址、十六进制数据和 ASCII 表示。</p>
<ol>
<li>提取十六进制数据：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  awk <span class="s1">&#39;{print $3}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>awk 从 xxd 的输出中提取第三列，这一列包含了十六进制数据。</p>
<ol>
<li>格式化数据：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sed -e <span class="s1">&#39;s/../&amp;\ /g&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>sed 用于在每两个字符之间插入一个空格，使其变成以空格分隔的十六进制对。</p>
<ol>
<li>重排数据：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  awk <span class="s1">&#39;{print $2$1}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>awk 将第一列和第二列的十六进制对连接起来，通常这一步用来调整字节顺序。</p>
<ol>
<li>转换为大写：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  tr <span class="s1">&#39;[a-z]&#39;</span> <span class="s1">&#39;[A-Z]&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>tr 将十六进制数中的小写字母转换为大写字母。</p>
<ol>
<li>计算十进制值：</li>
</ol>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;obase=10; ibase=16; </span><span class="si">${</span><span class="nv">input</span><span class="si">}</span><span class="s2">&#34;</span> <span class="p">|</span> bc</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>bc 用于将处理后的十六进制字符串转换为十进制值。obase=10 设置输出为十进制，ibase=16 设置输入为十六进制。</p>
<p>
总结：
这个命令将 BMP 文件的前 4 字节提取、格式化并转化为十进制数。</p>
</div>
</div>
<div id="outline-container-headline-108" class="outline-3">
<h3 id="headline-108">
参考链接
</h3>
<div id="outline-text-headline-108" class="outline-text-3">
<p>
<a href="https://www.cnblogs.com/oboth-zl/p/10314071.html">Linux终端中的字符串使用总结（截取，切片，查找替换，转换，变量赋值等）</a></p>
<p>
<a href="https://jingyan.baidu.com/article/08b6a59191815f14a80922b0.html">shell分隔字符串插入空格</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-109" class="outline-2">
<h2 id="headline-109">
删除文件指定字节二进制数据
</h2>
<div id="outline-text-headline-109" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nv">output</span><span class="o">=</span><span class="k">$(</span><span class="nv">input</span><span class="o">=</span><span class="k">$(</span>xxd -l <span class="m">4</span> output_0001.bmp <span class="p">|</span> awk <span class="s1">&#39;{print $3}&#39;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/../&amp;\ /g&#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $2$1}&#39;</span> <span class="p">|</span> tr <span class="s1">&#39;[a-z]&#39;</span> <span class="s1">&#39;[A-Z]&#39;</span><span class="k">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;obase=10; ibase=16; </span><span class="si">${</span><span class="nv">input</span><span class="si">}</span><span class="s2">&#34;</span> <span class="p">|</span> bc<span class="k">)</span><span class="p">;</span> dd <span class="k">if</span><span class="o">=</span>output_0001.bmp <span class="nv">of</span><span class="o">=</span>newBmp.bmp <span class="nv">skip</span><span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">output</span><span class="si">}</span><span class="s2">&#34;</span> <span class="nv">bs</span><span class="o">=</span><span class="m">1024</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-110" class="outline-2">
<h2 id="headline-110">
将二进制文件16进制输出的情况下每两个字符后添加一个0并输出到另一个文件
</h2>
<div id="outline-text-headline-110" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  xxd -p output_0001.bmp <span class="p">|</span> sed <span class="s1">&#39;s/../&amp;0/g&#39;</span> &gt; output.bmp</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-111" class="outline-2">
<h2 id="headline-111">
查找指定类型文件中的内容返回结果，并且会自动去除第一列的空格
</h2>
<div id="outline-text-headline-111" class="outline-text-2">
<p>
由于结果并不是在第一列显示，因此让第一列为空，再把空格去掉</p>
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;使用示例：</span><span class="k">$(</span>find ./ -name <span class="s2">&#34;*.cpp&#34;</span> <span class="p">|</span> xargs grep --color<span class="o">=</span>always <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">&#34;</span> <span class="p">|</span> awk <span class="s1">&#39;{$1=&#34;&#34;; print $0}&#39;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/^[ ]*//g&#39;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/[ ]*$//g&#39;</span><span class="k">)</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-112" class="outline-2">
<h2 id="headline-112">
显示文件最后修改时间
</h2>
<div id="outline-text-headline-112" class="outline-text-2">
<div id="outline-container-headline-113" class="outline-3">
<h3 id="headline-113">
方式一
</h3>
<div id="outline-text-headline-113" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  stat ts1.c</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-114" class="outline-3">
<h3 id="headline-114">
方式二
</h3>
<div id="outline-text-headline-114" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  date -Ins -r ts1.c <span class="p">|</span> tr <span class="s1">&#39;,&#39;</span> <span class="s1">&#39;.&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-115" class="outline-2">
<h2 id="headline-115">
visual studio的dll相关文件拷贝到Qt工程的driver目录技巧
</h2>
<div id="outline-text-headline-115" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  mapfile -t files &lt; &lt;<span class="o">(</span>find ./ -name <span class="s2">&#34;*DLL.h&#34;</span> -o -name <span class="s2">&#34;*.x64.dll&#34;</span> -o -name <span class="s2">&#34;*.x64.lib&#34;</span><span class="o">)</span><span class="p">;</span> <span class="k">for</span> i in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">files</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span> cp -vf <span class="s2">&#34;</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">&#34;</span> ../03_Demo/PCIE_SGDMA-4CH_HTFD/driver/<span class="p">;</span> <span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-116" class="outline-2">
<h2 id="headline-116">
命令行的shell脚本练习：read与case组合
</h2>
<div id="outline-text-headline-116" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="nb">read</span> key<span class="p">;</span> <span class="k">case</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">key</span><span class="si">}</span><span class="s2">&#34;</span> in *<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">key</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;;</span><span class="k">esac</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
执行结果：</p>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ read key; case &#34;${key}&#34; in *) echo &#34;${key}&#34;;;esac
</span></span><span class="line"><span class="cl">test
</span></span><span class="line"><span class="cl">test</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>运行后输入test并回车，然后将输入结果打印出来。</p>
</div>
</div>
<div id="outline-container-headline-117" class="outline-2">
<h2 id="headline-117">
shell脚本将case语句放在for循环中 - ChatGPT
</h2>
<div id="outline-text-headline-117" class="outline-text-2">
<p>
在 Shell 脚本中，可以将 case 语句放入 for 循环中，以便对每个循环的项进行不同的处理。case 语句用于匹配某个条件，并根据条件执行相应的操作，结合 for 循环可以对多个元素做类似的处理。</p>
<p>
以下是一个基本的例子，展示如何在 for 循环中使用 case 语句：</p>
<div id="outline-container-headline-118" class="outline-3">
<h3 id="headline-118">
示例：使用 case 语句和 for 循环
</h3>
<div id="outline-text-headline-118" class="outline-text-3">
<p>
假设你有一组文件名，你想根据文件扩展名进行不同的处理，可以在 for 循环中使用 case 语句来分类：</p>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 假设有一组文件名
</span></span><span class="line"><span class="cl">files=(&#34;file1.txt&#34; &#34;file2.jpg&#34; &#34;file3.png&#34; &#34;file4.txt&#34; &#34;file5.doc&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 遍历文件名列表
</span></span><span class="line"><span class="cl">for file in &#34;${files[@]}&#34;; do
</span></span><span class="line"><span class="cl">  # 提取文件的扩展名
</span></span><span class="line"><span class="cl">  extension=&#34;${file##*.}&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  # 使用 case 语句处理不同的扩展名
</span></span><span class="line"><span class="cl">  case &#34;$extension&#34; in
</span></span><span class="line"><span class="cl">    txt)
</span></span><span class="line"><span class="cl">      echo &#34;$file 是一个文本文件&#34;
</span></span><span class="line"><span class="cl">      ;;
</span></span><span class="line"><span class="cl">    jpg|png)
</span></span><span class="line"><span class="cl">      echo &#34;$file 是一个图片文件&#34;
</span></span><span class="line"><span class="cl">      ;;
</span></span><span class="line"><span class="cl">    doc)
</span></span><span class="line"><span class="cl">      echo &#34;$file 是一个文档文件&#34;
</span></span><span class="line"><span class="cl">      ;;
</span></span><span class="line"><span class="cl">    *)
</span></span><span class="line"><span class="cl">      echo &#34;$file 是其他类型的文件&#34;
</span></span><span class="line"><span class="cl">      ;;
</span></span><span class="line"><span class="cl">  esac
</span></span><span class="line"><span class="cl">done</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-119" class="outline-3">
<h3 id="headline-119">
说明：
</h3>
<div id="outline-text-headline-119" class="outline-text-3">
<ul>
<li>files=(&#34;file1.txt&#34; &#34;file2.jpg&#34; &#34;file3.png&#34; &#34;file4.txt&#34; &#34;file5.doc&#34;)：这是一个包含文件名的数组。</li>
<li>for file in &#34;${files[@]}&#34;：遍历数组中的每个文件名。</li>
<li>extension=&#34;${file##*.}&#34;：通过 Shell 参数扩展提取文件的扩展名（即最后一个点 . 后面的部分）。</li>
<li>case &#34;$extension&#34; in … esac：根据文件扩展名做不同的处理。| 用于在 case 语句中匹配多个选项（例如 jpg|png）。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-120" class="outline-3">
<h3 id="headline-120">
运行结果：
</h3>
<div id="outline-text-headline-120" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">file1.txt 是一个文本文件
</span></span><span class="line"><span class="cl">file2.jpg 是一个图片文件
</span></span><span class="line"><span class="cl">file3.png 是一个图片文件
</span></span><span class="line"><span class="cl">file4.txt 是一个文本文件
</span></span><span class="line"><span class="cl">file5.doc 是一个文档文件</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-121" class="outline-3">
<h3 id="headline-121">
关键点：
</h3>
<div id="outline-text-headline-121" class="outline-text-3">
<ol>
<li>for 循环遍历一个列表或数组，并且对每个元素执行循环体中的操作。</li>
<li>case 语句用于根据不同条件执行不同的代码块。在这个例子中，判断的是文件的扩展名。</li>
<li>
<ul>
<li>是 case 语句中的默认匹配模式，表示所有未匹配的情况。</li>
</ul>
</li>
</ol>
<p>这个示例展示了如何结合 for 循环和 case 语句来处理一系列数据，并根据不同的条件执行相应的操作。在 Shell 脚本中，这种结构非常常见且有效，尤其适用于分类处理和不同条件下的动作。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-122" class="outline-2">
<h2 id="headline-122">
case语句+shift偏移参数
</h2>
<div id="outline-text-headline-122" class="outline-text-2">
<div id="outline-container-headline-123" class="outline-3">
<h3 id="headline-123">
脚本代码
</h3>
<div id="outline-text-headline-123" class="outline-text-3">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">case $1 in
</span></span><span class="line"><span class="cl">    param1)
</span></span><span class="line"><span class="cl">	shift  # 移除第一个参数，$1 变成了原来的 $2
</span></span><span class="line"><span class="cl">        for i in &#34;$@&#34;; do  # 循环处理剩余参数
</span></span><span class="line"><span class="cl">            case $i in
</span></span><span class="line"><span class="cl">                2)
</span></span><span class="line"><span class="cl">                    echo &#34;2&#34;
</span></span><span class="line"><span class="cl">                    ;;	
</span></span><span class="line"><span class="cl">                3)
</span></span><span class="line"><span class="cl">                    echo &#34;3&#34;
</span></span><span class="line"><span class="cl">                    ;;
</span></span><span class="line"><span class="cl">                *)  # 默认处理未匹配的情况
</span></span><span class="line"><span class="cl">                    echo &#34;Unrecognized input: $i&#34;
</span></span><span class="line"><span class="cl">                    ;;
</span></span><span class="line"><span class="cl">            esac
</span></span><span class="line"><span class="cl">        done    
</span></span><span class="line"><span class="cl">        ;;
</span></span><span class="line"><span class="cl">    param2)
</span></span><span class="line"><span class="cl">	shift  # 移除第一个参数，$1 变成了原来的 $2
</span></span><span class="line"><span class="cl">        for i in &#34;$@&#34;; do  # 循环处理剩余参数
</span></span><span class="line"><span class="cl">            case $i in
</span></span><span class="line"><span class="cl">                2)
</span></span><span class="line"><span class="cl">                    echo &#34;3&#34;
</span></span><span class="line"><span class="cl">                    ;;	
</span></span><span class="line"><span class="cl">                3)
</span></span><span class="line"><span class="cl">                    echo &#34;4&#34;
</span></span><span class="line"><span class="cl">                    ;;
</span></span><span class="line"><span class="cl">                *)  # 默认处理未匹配的情况
</span></span><span class="line"><span class="cl">                    echo &#34;Unrecognized input: $i&#34;
</span></span><span class="line"><span class="cl">                    ;;
</span></span><span class="line"><span class="cl">            esac
</span></span><span class="line"><span class="cl">        done    
</span></span><span class="line"><span class="cl">        ;;
</span></span><span class="line"><span class="cl">    *)  # 处理未匹配的主参数
</span></span><span class="line"><span class="cl">        echo &#34;Invalid command: $1&#34;
</span></span><span class="line"><span class="cl">        ;;
</span></span><span class="line"><span class="cl">esac</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-124" class="outline-4">
<h4 id="headline-124">
运行示例
</h4>
<div id="outline-text-headline-124" class="outline-text-4">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ ./ts2.sh param1 2 3
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">3</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ ./ts2.sh param2 2 3
</span></span><span class="line"><span class="cl">3
</span></span><span class="line"><span class="cl">4</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-125" class="outline-2">
<h2 id="headline-125">
sed命令在包含指定关键词的行首与包含指定关键词的下一行的行首添加&#39;//&#39;
</h2>
<div id="outline-text-headline-125" class="outline-text-2">
<div id="outline-container-headline-126" class="outline-3">
<h3 id="headline-126">
示例命令
</h3>
<div id="outline-text-headline-126" class="outline-text-3">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  sed <span class="s1">&#39;/KEYWORD/{s/^/\/\//;n;s/^/\/\//}&#39;</span> input.txt</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-127" class="outline-3">
<h3 id="headline-127">
解释：
</h3>
<div id="outline-text-headline-127" class="outline-text-3">
<ul>
<li>/KEYWORD/：查找包含 KEYWORD 的行。</li>
<li>{…}：表示一个代码块，包含多个操作。</li>
<li>s/^/\/\//：在匹配的行行首添加 //。这里的 ^ 是行首的符号。</li>
<li>n：n 命令让 sed 跳到下一行进行处理（并打印出该行）。</li>
<li>再次执行 s/^/\/\//：在下一行的行首也添加 //。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-128" class="outline-2">
<h2 id="headline-128">
解决使用脚本创建Makefile内容不对齐问题
</h2>
<div id="outline-text-headline-128" class="outline-text-2">
<p>
使用echo命令，要加入-e选项开启转义，然后在需要加入制表符的地方插入\t，示例如下：</p>
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">echo -e &#39;DRIVER_NAME = xilinx-axidma&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;$(DRIVER_NAME)-objs = axi_dma.o axidma_chrdev.o axidma_dma.o axidma_of.o&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;obj-m := $(DRIVER_NAME).o&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;SRC := $(shell pwd)&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;all:&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;\t$(MAKE) -C $(KERNEL_SRC) M=$(SRC)&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;modules_install:&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;\t$(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;clean:&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;\trm -f *.o *~ core .depend .*.cmd *.ko *.mod.c&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;\trm -f Module.markers Module.symvers modules.order&#39;
</span></span><span class="line"><span class="cl">echo -e &#39;\trm -rf .tmp_versions Modules.symvers&#39;
</span></span><span class="line"><span class="cl">} &gt; ./project-spec/meta-user/recipes-modules/xilinx-axidma/files/Makefile</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-129" class="outline-2">
<h2 id="headline-129">
scp使用技巧
</h2>
<div id="outline-text-headline-129" class="outline-text-2">
<div class="src src-text">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"># 删除指定IP连接记录并上传本地公钥到远端 
</span></span><span class="line"><span class="cl">sed -i &#39;/192.168.1.10/d&#39; ~/.ssh/known_hosts; ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.10
</span></span><span class="line"><span class="cl"># 上传应用程序
</span></span><span class="line"><span class="cl">scp test_axi_dma_v1/Debug/test_axi_dma_v1.elf root@192.168.1.10:/run/media/mmcblk0p1</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
<a href="https://blog.csdn.net/weixin_43760266/article/details/123520322">使用Petalinux实现ZYNQ的linux程序开发（实现简单的socket通信程序）</a></p>
</div>
</div>
<div id="outline-container-headline-130" class="outline-2">
<h2 id="headline-130">
sed使用技巧
</h2>
<div id="outline-text-headline-130" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="c1"># 查看有多少个pcie控制器</span>
</span></span><span class="line"><span class="cl">  sed -i <span class="s1">&#39;/^[[:space:]]*\/\*/d&#39;</span> product/hi1910B-pcie-rc-M150-B50.dtsi
</span></span><span class="line"><span class="cl">  sed -i <span class="s1">&#39;/^[[:space:]]*\*\//d&#39;</span> product/hi1910B-pcie-rc-M150-B50.dtsi
</span></span><span class="line"><span class="cl">  mapfile -t array1 &lt; &lt;<span class="o">(</span>grep -oE <span class="s2">&#34;pcie@.*{&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi<span class="o">)</span><span class="p">;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; <span class="si">${#</span><span class="nv">array1</span><span class="p">[@]</span><span class="si">}</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">array1</span><span class="p">[i]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span>  
</span></span><span class="line"><span class="cl">  <span class="c1"># 添加 ^[[:space:]]* 只匹配行首的注释  </span>
</span></span><span class="line"><span class="cl">  <span class="nv">str1</span><span class="o">=</span><span class="s2">&#34;/*&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">str2</span><span class="o">=</span><span class="s2">&#34;*/&#34;</span>
</span></span><span class="line"><span class="cl">  sed -i <span class="s2">&#34;/</span><span class="si">${</span><span class="nv">array1</span><span class="p">[2]</span><span class="si">}</span><span class="s2">/i\\</span><span class="si">${</span><span class="nv">str1</span><span class="si">}</span><span class="s2">&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi
</span></span><span class="line"><span class="cl">  mapfile -t array2 &lt; &lt;<span class="o">(</span>grep -noE <span class="s2">&#34;};&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi <span class="p">|</span> awk -F <span class="s1">&#39;:&#39;</span> <span class="s1">&#39;{print $1}&#39;</span><span class="o">)</span><span class="p">;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; <span class="si">${#</span><span class="nv">array2</span><span class="p">[@]</span><span class="si">}</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">array2</span><span class="p">[i]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span>
</span></span><span class="line"><span class="cl">  sed -i <span class="s2">&#34;</span><span class="si">${</span><span class="nv">array2</span><span class="p">[2]</span><span class="si">}</span><span class="s2"> a </span><span class="si">${</span><span class="nv">str2</span><span class="si">}</span><span class="s2">&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  sed -i <span class="s2">&#34;/</span><span class="si">${</span><span class="nv">array1</span><span class="p">[3]</span><span class="si">}</span><span class="s2">/i\\</span><span class="si">${</span><span class="nv">str1</span><span class="si">}</span><span class="s2">&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi
</span></span><span class="line"><span class="cl">  mapfile -t array2 &lt; &lt;<span class="o">(</span>grep -noE <span class="s2">&#34;};&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi <span class="p">|</span> awk -F <span class="s1">&#39;:&#39;</span> <span class="s1">&#39;{print $1}&#39;</span><span class="o">)</span><span class="p">;</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 0<span class="p">;</span> i &lt; <span class="si">${#</span><span class="nv">array2</span><span class="p">[@]</span><span class="si">}</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">array2</span><span class="p">[i]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span>
</span></span><span class="line"><span class="cl">  sed -i <span class="s2">&#34;</span><span class="si">${</span><span class="nv">array2</span><span class="p">[3]</span><span class="si">}</span><span class="s2"> a </span><span class="si">${</span><span class="nv">str2</span><span class="si">}</span><span class="s2">&#34;</span> product/hi1910B-pcie-rc-M150-B50.dtsi</span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>这段脚本的主要功能是修改设备树文件(hi1910B-pcie-rc-M150-B50.dtsi)，具体操作包括删除现有注释、查找PCIe控制器定义、并在特定PCIe控制器前后添加注释标记</p>
</div>
</div>
<div id="outline-container-headline-131" class="outline-2">
<h2 id="headline-131">
Bash 命令行选项解析
</h2>
<div id="outline-text-headline-131" class="outline-text-2">
<div class="src src-bash">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="k">while</span> <span class="nb">getopts</span> <span class="s2">&#34;hv&#34;</span> opt<span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="s2">&#34;</span><span class="nv">$opt</span><span class="s2">&#34;</span> in
</span></span><span class="line"><span class="cl">	  h<span class="o">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">echo</span> <span class="s2">&#34;h&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="p">;;</span>
</span></span><span class="line"><span class="cl">	  v<span class="o">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">echo</span> <span class="s2">&#34;v&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="p">;;</span>	  
</span></span><span class="line"><span class="cl">	<span class="k">esac</span>
</span></span><span class="line"><span class="cl">  <span class="k">done</span>  
</span></span><span class="line"><span class="cl">  <span class="nb">shift</span> <span class="s2">&#34;</span><span class="k">$((</span>OPTIND <span class="o">-</span> <span class="m">1</span><span class="k">))</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
解析：Deepseek
这个脚本是一个典型的 Bash shell 脚本片段，用于处理命令行参数。下面我来逐行解析它的功能：</p>
<div id="outline-container-headline-132" class="outline-3">
<h3 id="headline-132">
1. while getopts &#34;hv&#34; opt; do
</h3>
<div id="outline-text-headline-132" class="outline-text-3">
<ul>
<li>getopts 是 Bash 内置的命令行选项解析器</li>
<li>
<p>&#34;hv&#34; 定义了脚本接受的选项：</p>
<ul>
<li>-h 是一个选项</li>
<li>-v 是另一个选项</li>
</ul>
</li>
<li>opt 是变量，用于存储当前处理的选项字符</li>
<li>这个 while 循环会遍历所有提供的命令行选项</li>
</ul>
</div>
</div>
<div id="outline-container-headline-133" class="outline-3">
<h3 id="headline-133">
2. case &#34;$opt&#34; in
</h3>
<div id="outline-text-headline-133" class="outline-text-3">
<ul>
<li>开始一个 case 语句，根据当前选项 $opt 的值执行不同的操作</li>
</ul>
</div>
</div>
<div id="outline-container-headline-134" class="outline-3">
<h3 id="headline-134">
3. h)
</h3>
<div id="outline-text-headline-134" class="outline-text-3">
<ul>
<li>当选项是 -h 时的处理分支</li>
<li>echo &#34;h&#34;：简单地输出字母 &#34;h&#34;</li>
<li>;; 表示这个 case 分支的结束</li>
</ul>
</div>
</div>
<div id="outline-container-headline-135" class="outline-3">
<h3 id="headline-135">
4. v)
</h3>
<div id="outline-text-headline-135" class="outline-text-3">
<ul>
<li>当选项是 -v 时的处理分支</li>
<li>echo &#34;v&#34;：简单地输出字母 &#34;v&#34;</li>
<li>;; 表示这个 case 分支的结束</li>
</ul>
</div>
</div>
<div id="outline-container-headline-136" class="outline-3">
<h3 id="headline-136">
5. esac 和 done
</h3>
<div id="outline-text-headline-136" class="outline-text-3">
<ul>
<li>esac 结束 case 语句</li>
<li>done 结束 while 循环</li>
</ul>
</div>
</div>
<div id="outline-container-headline-137" class="outline-3">
<h3 id="headline-137">
6. shift &#34;$((OPTIND - 1))&#34;
</h3>
<div id="outline-text-headline-137" class="outline-text-3">
<ul>
<li>OPTIND 是 getopts 维护的变量，表示下一个要处理的参数的索引</li>
<li>$((OPTIND - 1)) 计算需要移除的已处理选项数量</li>
<li>shift 命令将位置参数向左移动，移除已经处理过的选项</li>
<li>这样处理之后，$1 将指向第一个非选项参数</li>
</ul>
</div>
</div>
<div id="outline-container-headline-138" class="outline-3">
<h3 id="headline-138">
示例用法：
</h3>
<div id="outline-text-headline-138" class="outline-text-3">
<ol>
<li>
<p>如果运行脚本时输入 script.sh -h -v：</p>
<ul>
<li>会输出：

h
v</li>
</ul>
</li>
<li>
<p>如果运行 script.sh -h file.txt：</p>
<ul>
<li>会输出 h</li>
<li>然后 file.txt 会成为第一个位置参数（$1）</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-139" class="outline-3">
<h3 id="headline-139">
总结：
</h3>
<div id="outline-text-headline-139" class="outline-text-3">
<p>这个脚本处理两个选项：</p>
<ul>
<li>-h：输出 &#34;h&#34;</li>
<li>-v：输出 &#34;v&#34;</li>
</ul>
<p>然后使用 shift 调整位置参数，使得后续代码可以方便地处理非选项参数。</p>
<p>
这是一个基础的命令行选项处理框架，实际应用中通常会在各个 case 分支中执行更复杂的操作，而不仅仅是 echo。</p>
</div>
</div>
<div id="outline-container-headline-140" class="outline-3">
<h3 id="headline-140">
参考链接
</h3>
<div id="outline-text-headline-140" class="outline-text-3">
<p>
<a href="https://gitee.com/HUAWEI-ASCEND/ascend-devkit/blob/master/src/image-builder/src/minimal/base.sh">ascend-devkit/src/image-builder/src/minimal/base.sh</a></p>
</div>
</div>
</div>
</div>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/shell/">Shell</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
